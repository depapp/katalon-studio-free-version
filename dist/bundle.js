'use strict';

var require$$0$8 = require('fs');
var require$$1$4 = require('path');
var require$$0$3 = require('net');
var require$$0$2 = require('url');
var require$$1$2 = require('util');
var require$$0$5 = require('crypto');
var require$$0$4 = require('buffer');
var require$$2$1 = require('http');
var require$$4$1 = require('https');
var require$$0$6 = require('stream');
var require$$5$1 = require('zlib');
var require$$1$3 = require('querystring');
var require$$0$7 = require('assert');
var require$$3$4 = require('tls');
var require$$4$2 = require('events');
var require$$0$9 = require('tty');
var require$$1$5 = require('os');
var require$$0$a = require('constants');
var require$$0$b = require('child_process');
var require$$6$1 = require('string_decoder');
var fs$2 = require('node:fs');
var fsPromises = require('node:fs/promises');
var os = require('node:os');
var path = require('node:path');

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var freeKatalonStudio = {};

var lodash$1 = {exports: {}};

/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var lodash = lodash$1.exports;

var hasRequiredLodash;

function requireLodash () {
	if (hasRequiredLodash) return lodash$1.exports;
	hasRequiredLodash = 1;
	(function (module, exports) {
(function() {

		  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
		  var undefined$1;

		  /** Used as the semantic version number. */
		  var VERSION = '4.17.21';

		  /** Used as the size to enable large array optimizations. */
		  var LARGE_ARRAY_SIZE = 200;

		  /** Error message constants. */
		  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
		      FUNC_ERROR_TEXT = 'Expected a function',
		      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

		  /** Used to stand-in for `undefined` hash values. */
		  var HASH_UNDEFINED = '__lodash_hash_undefined__';

		  /** Used as the maximum memoize cache size. */
		  var MAX_MEMOIZE_SIZE = 500;

		  /** Used as the internal argument placeholder. */
		  var PLACEHOLDER = '__lodash_placeholder__';

		  /** Used to compose bitmasks for cloning. */
		  var CLONE_DEEP_FLAG = 1,
		      CLONE_FLAT_FLAG = 2,
		      CLONE_SYMBOLS_FLAG = 4;

		  /** Used to compose bitmasks for value comparisons. */
		  var COMPARE_PARTIAL_FLAG = 1,
		      COMPARE_UNORDERED_FLAG = 2;

		  /** Used to compose bitmasks for function metadata. */
		  var WRAP_BIND_FLAG = 1,
		      WRAP_BIND_KEY_FLAG = 2,
		      WRAP_CURRY_BOUND_FLAG = 4,
		      WRAP_CURRY_FLAG = 8,
		      WRAP_CURRY_RIGHT_FLAG = 16,
		      WRAP_PARTIAL_FLAG = 32,
		      WRAP_PARTIAL_RIGHT_FLAG = 64,
		      WRAP_ARY_FLAG = 128,
		      WRAP_REARG_FLAG = 256,
		      WRAP_FLIP_FLAG = 512;

		  /** Used as default options for `_.truncate`. */
		  var DEFAULT_TRUNC_LENGTH = 30,
		      DEFAULT_TRUNC_OMISSION = '...';

		  /** Used to detect hot functions by number of calls within a span of milliseconds. */
		  var HOT_COUNT = 800,
		      HOT_SPAN = 16;

		  /** Used to indicate the type of lazy iteratees. */
		  var LAZY_FILTER_FLAG = 1,
		      LAZY_MAP_FLAG = 2,
		      LAZY_WHILE_FLAG = 3;

		  /** Used as references for various `Number` constants. */
		  var INFINITY = 1 / 0,
		      MAX_SAFE_INTEGER = 9007199254740991,
		      MAX_INTEGER = 1.7976931348623157e+308,
		      NAN = 0 / 0;

		  /** Used as references for the maximum length and index of an array. */
		  var MAX_ARRAY_LENGTH = 4294967295,
		      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
		      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

		  /** Used to associate wrap methods with their bit flags. */
		  var wrapFlags = [
		    ['ary', WRAP_ARY_FLAG],
		    ['bind', WRAP_BIND_FLAG],
		    ['bindKey', WRAP_BIND_KEY_FLAG],
		    ['curry', WRAP_CURRY_FLAG],
		    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
		    ['flip', WRAP_FLIP_FLAG],
		    ['partial', WRAP_PARTIAL_FLAG],
		    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
		    ['rearg', WRAP_REARG_FLAG]
		  ];

		  /** `Object#toString` result references. */
		  var argsTag = '[object Arguments]',
		      arrayTag = '[object Array]',
		      asyncTag = '[object AsyncFunction]',
		      boolTag = '[object Boolean]',
		      dateTag = '[object Date]',
		      domExcTag = '[object DOMException]',
		      errorTag = '[object Error]',
		      funcTag = '[object Function]',
		      genTag = '[object GeneratorFunction]',
		      mapTag = '[object Map]',
		      numberTag = '[object Number]',
		      nullTag = '[object Null]',
		      objectTag = '[object Object]',
		      promiseTag = '[object Promise]',
		      proxyTag = '[object Proxy]',
		      regexpTag = '[object RegExp]',
		      setTag = '[object Set]',
		      stringTag = '[object String]',
		      symbolTag = '[object Symbol]',
		      undefinedTag = '[object Undefined]',
		      weakMapTag = '[object WeakMap]',
		      weakSetTag = '[object WeakSet]';

		  var arrayBufferTag = '[object ArrayBuffer]',
		      dataViewTag = '[object DataView]',
		      float32Tag = '[object Float32Array]',
		      float64Tag = '[object Float64Array]',
		      int8Tag = '[object Int8Array]',
		      int16Tag = '[object Int16Array]',
		      int32Tag = '[object Int32Array]',
		      uint8Tag = '[object Uint8Array]',
		      uint8ClampedTag = '[object Uint8ClampedArray]',
		      uint16Tag = '[object Uint16Array]',
		      uint32Tag = '[object Uint32Array]';

		  /** Used to match empty string literals in compiled template source. */
		  var reEmptyStringLeading = /\b__p \+= '';/g,
		      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
		      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

		  /** Used to match HTML entities and HTML characters. */
		  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
		      reUnescapedHtml = /[&<>"']/g,
		      reHasEscapedHtml = RegExp(reEscapedHtml.source),
		      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

		  /** Used to match template delimiters. */
		  var reEscape = /<%-([\s\S]+?)%>/g,
		      reEvaluate = /<%([\s\S]+?)%>/g,
		      reInterpolate = /<%=([\s\S]+?)%>/g;

		  /** Used to match property names within property paths. */
		  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
		      reIsPlainProp = /^\w*$/,
		      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

		  /**
		   * Used to match `RegExp`
		   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
		   */
		  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
		      reHasRegExpChar = RegExp(reRegExpChar.source);

		  /** Used to match leading whitespace. */
		  var reTrimStart = /^\s+/;

		  /** Used to match a single whitespace character. */
		  var reWhitespace = /\s/;

		  /** Used to match wrap detail comments. */
		  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
		      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
		      reSplitDetails = /,? & /;

		  /** Used to match words composed of alphanumeric characters. */
		  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

		  /**
		   * Used to validate the `validate` option in `_.template` variable.
		   *
		   * Forbids characters which could potentially change the meaning of the function argument definition:
		   * - "()," (modification of function parameters)
		   * - "=" (default value)
		   * - "[]{}" (destructuring of function parameters)
		   * - "/" (beginning of a comment)
		   * - whitespace
		   */
		  var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

		  /** Used to match backslashes in property paths. */
		  var reEscapeChar = /\\(\\)?/g;

		  /**
		   * Used to match
		   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
		   */
		  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

		  /** Used to match `RegExp` flags from their coerced string values. */
		  var reFlags = /\w*$/;

		  /** Used to detect bad signed hexadecimal string values. */
		  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

		  /** Used to detect binary string values. */
		  var reIsBinary = /^0b[01]+$/i;

		  /** Used to detect host constructors (Safari). */
		  var reIsHostCtor = /^\[object .+?Constructor\]$/;

		  /** Used to detect octal string values. */
		  var reIsOctal = /^0o[0-7]+$/i;

		  /** Used to detect unsigned integer values. */
		  var reIsUint = /^(?:0|[1-9]\d*)$/;

		  /** Used to match Latin Unicode letters (excluding mathematical operators). */
		  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

		  /** Used to ensure capturing order of template delimiters. */
		  var reNoMatch = /($^)/;

		  /** Used to match unescaped characters in compiled string literals. */
		  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

		  /** Used to compose unicode character classes. */
		  var rsAstralRange = '\\ud800-\\udfff',
		      rsComboMarksRange = '\\u0300-\\u036f',
		      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
		      rsComboSymbolsRange = '\\u20d0-\\u20ff',
		      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
		      rsDingbatRange = '\\u2700-\\u27bf',
		      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
		      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
		      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
		      rsPunctuationRange = '\\u2000-\\u206f',
		      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
		      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
		      rsVarRange = '\\ufe0e\\ufe0f',
		      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

		  /** Used to compose unicode capture groups. */
		  var rsApos = "['\u2019]",
		      rsAstral = '[' + rsAstralRange + ']',
		      rsBreak = '[' + rsBreakRange + ']',
		      rsCombo = '[' + rsComboRange + ']',
		      rsDigits = '\\d+',
		      rsDingbat = '[' + rsDingbatRange + ']',
		      rsLower = '[' + rsLowerRange + ']',
		      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
		      rsFitz = '\\ud83c[\\udffb-\\udfff]',
		      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
		      rsNonAstral = '[^' + rsAstralRange + ']',
		      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
		      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
		      rsUpper = '[' + rsUpperRange + ']',
		      rsZWJ = '\\u200d';

		  /** Used to compose unicode regexes. */
		  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
		      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
		      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
		      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
		      reOptMod = rsModifier + '?',
		      rsOptVar = '[' + rsVarRange + ']?',
		      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
		      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
		      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
		      rsSeq = rsOptVar + reOptMod + rsOptJoin,
		      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
		      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

		  /** Used to match apostrophes. */
		  var reApos = RegExp(rsApos, 'g');

		  /**
		   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
		   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
		   */
		  var reComboMark = RegExp(rsCombo, 'g');

		  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
		  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

		  /** Used to match complex or compound words. */
		  var reUnicodeWord = RegExp([
		    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
		    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
		    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
		    rsUpper + '+' + rsOptContrUpper,
		    rsOrdUpper,
		    rsOrdLower,
		    rsDigits,
		    rsEmoji
		  ].join('|'), 'g');

		  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
		  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

		  /** Used to detect strings that need a more robust regexp to match words. */
		  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

		  /** Used to assign default `context` object properties. */
		  var contextProps = [
		    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
		    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
		    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
		    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
		    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
		  ];

		  /** Used to make template sourceURLs easier to identify. */
		  var templateCounter = -1;

		  /** Used to identify `toStringTag` values of typed arrays. */
		  var typedArrayTags = {};
		  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
		  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
		  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
		  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
		  typedArrayTags[uint32Tag] = true;
		  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
		  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
		  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
		  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
		  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
		  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
		  typedArrayTags[setTag] = typedArrayTags[stringTag] =
		  typedArrayTags[weakMapTag] = false;

		  /** Used to identify `toStringTag` values supported by `_.clone`. */
		  var cloneableTags = {};
		  cloneableTags[argsTag] = cloneableTags[arrayTag] =
		  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
		  cloneableTags[boolTag] = cloneableTags[dateTag] =
		  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
		  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
		  cloneableTags[int32Tag] = cloneableTags[mapTag] =
		  cloneableTags[numberTag] = cloneableTags[objectTag] =
		  cloneableTags[regexpTag] = cloneableTags[setTag] =
		  cloneableTags[stringTag] = cloneableTags[symbolTag] =
		  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
		  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
		  cloneableTags[errorTag] = cloneableTags[funcTag] =
		  cloneableTags[weakMapTag] = false;

		  /** Used to map Latin Unicode letters to basic Latin letters. */
		  var deburredLetters = {
		    // Latin-1 Supplement block.
		    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
		    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
		    '\xc7': 'C',  '\xe7': 'c',
		    '\xd0': 'D',  '\xf0': 'd',
		    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
		    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
		    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
		    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
		    '\xd1': 'N',  '\xf1': 'n',
		    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
		    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
		    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
		    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
		    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
		    '\xc6': 'Ae', '\xe6': 'ae',
		    '\xde': 'Th', '\xfe': 'th',
		    '\xdf': 'ss',
		    // Latin Extended-A block.
		    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
		    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
		    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
		    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
		    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
		    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
		    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
		    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
		    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
		    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
		    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
		    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
		    '\u0134': 'J',  '\u0135': 'j',
		    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
		    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
		    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
		    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
		    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
		    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
		    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
		    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
		    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
		    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
		    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
		    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
		    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
		    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
		    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
		    '\u0174': 'W',  '\u0175': 'w',
		    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
		    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
		    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
		    '\u0132': 'IJ', '\u0133': 'ij',
		    '\u0152': 'Oe', '\u0153': 'oe',
		    '\u0149': "'n", '\u017f': 's'
		  };

		  /** Used to map characters to HTML entities. */
		  var htmlEscapes = {
		    '&': '&amp;',
		    '<': '&lt;',
		    '>': '&gt;',
		    '"': '&quot;',
		    "'": '&#39;'
		  };

		  /** Used to map HTML entities to characters. */
		  var htmlUnescapes = {
		    '&amp;': '&',
		    '&lt;': '<',
		    '&gt;': '>',
		    '&quot;': '"',
		    '&#39;': "'"
		  };

		  /** Used to escape characters for inclusion in compiled string literals. */
		  var stringEscapes = {
		    '\\': '\\',
		    "'": "'",
		    '\n': 'n',
		    '\r': 'r',
		    '\u2028': 'u2028',
		    '\u2029': 'u2029'
		  };

		  /** Built-in method references without a dependency on `root`. */
		  var freeParseFloat = parseFloat,
		      freeParseInt = parseInt;

		  /** Detect free variable `global` from Node.js. */
		  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

		  /** Detect free variable `self`. */
		  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

		  /** Used as a reference to the global object. */
		  var root = freeGlobal || freeSelf || Function('return this')();

		  /** Detect free variable `exports`. */
		  var freeExports = exports && !exports.nodeType && exports;

		  /** Detect free variable `module`. */
		  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		  /** Detect the popular CommonJS extension `module.exports`. */
		  var moduleExports = freeModule && freeModule.exports === freeExports;

		  /** Detect free variable `process` from Node.js. */
		  var freeProcess = moduleExports && freeGlobal.process;

		  /** Used to access faster Node.js helpers. */
		  var nodeUtil = (function() {
		    try {
		      // Use `util.types` for Node.js 10+.
		      var types = freeModule && freeModule.require && freeModule.require('util').types;

		      if (types) {
		        return types;
		      }

		      // Legacy `process.binding('util')` for Node.js < 10.
		      return freeProcess && freeProcess.binding && freeProcess.binding('util');
		    } catch (e) {}
		  }());

		  /* Node.js helper references. */
		  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
		      nodeIsDate = nodeUtil && nodeUtil.isDate,
		      nodeIsMap = nodeUtil && nodeUtil.isMap,
		      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
		      nodeIsSet = nodeUtil && nodeUtil.isSet,
		      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

		  /*--------------------------------------------------------------------------*/

		  /**
		   * A faster alternative to `Function#apply`, this function invokes `func`
		   * with the `this` binding of `thisArg` and the arguments of `args`.
		   *
		   * @private
		   * @param {Function} func The function to invoke.
		   * @param {*} thisArg The `this` binding of `func`.
		   * @param {Array} args The arguments to invoke `func` with.
		   * @returns {*} Returns the result of `func`.
		   */
		  function apply(func, thisArg, args) {
		    switch (args.length) {
		      case 0: return func.call(thisArg);
		      case 1: return func.call(thisArg, args[0]);
		      case 2: return func.call(thisArg, args[0], args[1]);
		      case 3: return func.call(thisArg, args[0], args[1], args[2]);
		    }
		    return func.apply(thisArg, args);
		  }

		  /**
		   * A specialized version of `baseAggregator` for arrays.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} setter The function to set `accumulator` values.
		   * @param {Function} iteratee The iteratee to transform keys.
		   * @param {Object} accumulator The initial aggregated object.
		   * @returns {Function} Returns `accumulator`.
		   */
		  function arrayAggregator(array, setter, iteratee, accumulator) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      var value = array[index];
		      setter(accumulator, value, iteratee(value), array);
		    }
		    return accumulator;
		  }

		  /**
		   * A specialized version of `_.forEach` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns `array`.
		   */
		  function arrayEach(array, iteratee) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      if (iteratee(array[index], index, array) === false) {
		        break;
		      }
		    }
		    return array;
		  }

		  /**
		   * A specialized version of `_.forEachRight` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns `array`.
		   */
		  function arrayEachRight(array, iteratee) {
		    var length = array == null ? 0 : array.length;

		    while (length--) {
		      if (iteratee(array[length], length, array) === false) {
		        break;
		      }
		    }
		    return array;
		  }

		  /**
		   * A specialized version of `_.every` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} predicate The function invoked per iteration.
		   * @returns {boolean} Returns `true` if all elements pass the predicate check,
		   *  else `false`.
		   */
		  function arrayEvery(array, predicate) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      if (!predicate(array[index], index, array)) {
		        return false;
		      }
		    }
		    return true;
		  }

		  /**
		   * A specialized version of `_.filter` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} predicate The function invoked per iteration.
		   * @returns {Array} Returns the new filtered array.
		   */
		  function arrayFilter(array, predicate) {
		    var index = -1,
		        length = array == null ? 0 : array.length,
		        resIndex = 0,
		        result = [];

		    while (++index < length) {
		      var value = array[index];
		      if (predicate(value, index, array)) {
		        result[resIndex++] = value;
		      }
		    }
		    return result;
		  }

		  /**
		   * A specialized version of `_.includes` for arrays without support for
		   * specifying an index to search from.
		   *
		   * @private
		   * @param {Array} [array] The array to inspect.
		   * @param {*} target The value to search for.
		   * @returns {boolean} Returns `true` if `target` is found, else `false`.
		   */
		  function arrayIncludes(array, value) {
		    var length = array == null ? 0 : array.length;
		    return !!length && baseIndexOf(array, value, 0) > -1;
		  }

		  /**
		   * This function is like `arrayIncludes` except that it accepts a comparator.
		   *
		   * @private
		   * @param {Array} [array] The array to inspect.
		   * @param {*} target The value to search for.
		   * @param {Function} comparator The comparator invoked per element.
		   * @returns {boolean} Returns `true` if `target` is found, else `false`.
		   */
		  function arrayIncludesWith(array, value, comparator) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      if (comparator(value, array[index])) {
		        return true;
		      }
		    }
		    return false;
		  }

		  /**
		   * A specialized version of `_.map` for arrays without support for iteratee
		   * shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns the new mapped array.
		   */
		  function arrayMap(array, iteratee) {
		    var index = -1,
		        length = array == null ? 0 : array.length,
		        result = Array(length);

		    while (++index < length) {
		      result[index] = iteratee(array[index], index, array);
		    }
		    return result;
		  }

		  /**
		   * Appends the elements of `values` to `array`.
		   *
		   * @private
		   * @param {Array} array The array to modify.
		   * @param {Array} values The values to append.
		   * @returns {Array} Returns `array`.
		   */
		  function arrayPush(array, values) {
		    var index = -1,
		        length = values.length,
		        offset = array.length;

		    while (++index < length) {
		      array[offset + index] = values[index];
		    }
		    return array;
		  }

		  /**
		   * A specialized version of `_.reduce` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @param {*} [accumulator] The initial value.
		   * @param {boolean} [initAccum] Specify using the first element of `array` as
		   *  the initial value.
		   * @returns {*} Returns the accumulated value.
		   */
		  function arrayReduce(array, iteratee, accumulator, initAccum) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    if (initAccum && length) {
		      accumulator = array[++index];
		    }
		    while (++index < length) {
		      accumulator = iteratee(accumulator, array[index], index, array);
		    }
		    return accumulator;
		  }

		  /**
		   * A specialized version of `_.reduceRight` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @param {*} [accumulator] The initial value.
		   * @param {boolean} [initAccum] Specify using the last element of `array` as
		   *  the initial value.
		   * @returns {*} Returns the accumulated value.
		   */
		  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
		    var length = array == null ? 0 : array.length;
		    if (initAccum && length) {
		      accumulator = array[--length];
		    }
		    while (length--) {
		      accumulator = iteratee(accumulator, array[length], length, array);
		    }
		    return accumulator;
		  }

		  /**
		   * A specialized version of `_.some` for arrays without support for iteratee
		   * shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} predicate The function invoked per iteration.
		   * @returns {boolean} Returns `true` if any element passes the predicate check,
		   *  else `false`.
		   */
		  function arraySome(array, predicate) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      if (predicate(array[index], index, array)) {
		        return true;
		      }
		    }
		    return false;
		  }

		  /**
		   * Gets the size of an ASCII `string`.
		   *
		   * @private
		   * @param {string} string The string inspect.
		   * @returns {number} Returns the string size.
		   */
		  var asciiSize = baseProperty('length');

		  /**
		   * Converts an ASCII `string` to an array.
		   *
		   * @private
		   * @param {string} string The string to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function asciiToArray(string) {
		    return string.split('');
		  }

		  /**
		   * Splits an ASCII `string` into an array of its words.
		   *
		   * @private
		   * @param {string} The string to inspect.
		   * @returns {Array} Returns the words of `string`.
		   */
		  function asciiWords(string) {
		    return string.match(reAsciiWord) || [];
		  }

		  /**
		   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
		   * without support for iteratee shorthands, which iterates over `collection`
		   * using `eachFunc`.
		   *
		   * @private
		   * @param {Array|Object} collection The collection to inspect.
		   * @param {Function} predicate The function invoked per iteration.
		   * @param {Function} eachFunc The function to iterate over `collection`.
		   * @returns {*} Returns the found element or its key, else `undefined`.
		   */
		  function baseFindKey(collection, predicate, eachFunc) {
		    var result;
		    eachFunc(collection, function(value, key, collection) {
		      if (predicate(value, key, collection)) {
		        result = key;
		        return false;
		      }
		    });
		    return result;
		  }

		  /**
		   * The base implementation of `_.findIndex` and `_.findLastIndex` without
		   * support for iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {Function} predicate The function invoked per iteration.
		   * @param {number} fromIndex The index to search from.
		   * @param {boolean} [fromRight] Specify iterating from right to left.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function baseFindIndex(array, predicate, fromIndex, fromRight) {
		    var length = array.length,
		        index = fromIndex + (fromRight ? 1 : -1);

		    while ((fromRight ? index-- : ++index < length)) {
		      if (predicate(array[index], index, array)) {
		        return index;
		      }
		    }
		    return -1;
		  }

		  /**
		   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} value The value to search for.
		   * @param {number} fromIndex The index to search from.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function baseIndexOf(array, value, fromIndex) {
		    return value === value
		      ? strictIndexOf(array, value, fromIndex)
		      : baseFindIndex(array, baseIsNaN, fromIndex);
		  }

		  /**
		   * This function is like `baseIndexOf` except that it accepts a comparator.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} value The value to search for.
		   * @param {number} fromIndex The index to search from.
		   * @param {Function} comparator The comparator invoked per element.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function baseIndexOfWith(array, value, fromIndex, comparator) {
		    var index = fromIndex - 1,
		        length = array.length;

		    while (++index < length) {
		      if (comparator(array[index], value)) {
		        return index;
		      }
		    }
		    return -1;
		  }

		  /**
		   * The base implementation of `_.isNaN` without support for number objects.
		   *
		   * @private
		   * @param {*} value The value to check.
		   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
		   */
		  function baseIsNaN(value) {
		    return value !== value;
		  }

		  /**
		   * The base implementation of `_.mean` and `_.meanBy` without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {number} Returns the mean.
		   */
		  function baseMean(array, iteratee) {
		    var length = array == null ? 0 : array.length;
		    return length ? (baseSum(array, iteratee) / length) : NAN;
		  }

		  /**
		   * The base implementation of `_.property` without support for deep paths.
		   *
		   * @private
		   * @param {string} key The key of the property to get.
		   * @returns {Function} Returns the new accessor function.
		   */
		  function baseProperty(key) {
		    return function(object) {
		      return object == null ? undefined$1 : object[key];
		    };
		  }

		  /**
		   * The base implementation of `_.propertyOf` without support for deep paths.
		   *
		   * @private
		   * @param {Object} object The object to query.
		   * @returns {Function} Returns the new accessor function.
		   */
		  function basePropertyOf(object) {
		    return function(key) {
		      return object == null ? undefined$1 : object[key];
		    };
		  }

		  /**
		   * The base implementation of `_.reduce` and `_.reduceRight`, without support
		   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
		   *
		   * @private
		   * @param {Array|Object} collection The collection to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @param {*} accumulator The initial value.
		   * @param {boolean} initAccum Specify using the first or last element of
		   *  `collection` as the initial value.
		   * @param {Function} eachFunc The function to iterate over `collection`.
		   * @returns {*} Returns the accumulated value.
		   */
		  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
		    eachFunc(collection, function(value, index, collection) {
		      accumulator = initAccum
		        ? (initAccum = false, value)
		        : iteratee(accumulator, value, index, collection);
		    });
		    return accumulator;
		  }

		  /**
		   * The base implementation of `_.sortBy` which uses `comparer` to define the
		   * sort order of `array` and replaces criteria objects with their corresponding
		   * values.
		   *
		   * @private
		   * @param {Array} array The array to sort.
		   * @param {Function} comparer The function to define sort order.
		   * @returns {Array} Returns `array`.
		   */
		  function baseSortBy(array, comparer) {
		    var length = array.length;

		    array.sort(comparer);
		    while (length--) {
		      array[length] = array[length].value;
		    }
		    return array;
		  }

		  /**
		   * The base implementation of `_.sum` and `_.sumBy` without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {number} Returns the sum.
		   */
		  function baseSum(array, iteratee) {
		    var result,
		        index = -1,
		        length = array.length;

		    while (++index < length) {
		      var current = iteratee(array[index]);
		      if (current !== undefined$1) {
		        result = result === undefined$1 ? current : (result + current);
		      }
		    }
		    return result;
		  }

		  /**
		   * The base implementation of `_.times` without support for iteratee shorthands
		   * or max array length checks.
		   *
		   * @private
		   * @param {number} n The number of times to invoke `iteratee`.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns the array of results.
		   */
		  function baseTimes(n, iteratee) {
		    var index = -1,
		        result = Array(n);

		    while (++index < n) {
		      result[index] = iteratee(index);
		    }
		    return result;
		  }

		  /**
		   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
		   * of key-value pairs for `object` corresponding to the property names of `props`.
		   *
		   * @private
		   * @param {Object} object The object to query.
		   * @param {Array} props The property names to get values for.
		   * @returns {Object} Returns the key-value pairs.
		   */
		  function baseToPairs(object, props) {
		    return arrayMap(props, function(key) {
		      return [key, object[key]];
		    });
		  }

		  /**
		   * The base implementation of `_.trim`.
		   *
		   * @private
		   * @param {string} string The string to trim.
		   * @returns {string} Returns the trimmed string.
		   */
		  function baseTrim(string) {
		    return string
		      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
		      : string;
		  }

		  /**
		   * The base implementation of `_.unary` without support for storing metadata.
		   *
		   * @private
		   * @param {Function} func The function to cap arguments for.
		   * @returns {Function} Returns the new capped function.
		   */
		  function baseUnary(func) {
		    return function(value) {
		      return func(value);
		    };
		  }

		  /**
		   * The base implementation of `_.values` and `_.valuesIn` which creates an
		   * array of `object` property values corresponding to the property names
		   * of `props`.
		   *
		   * @private
		   * @param {Object} object The object to query.
		   * @param {Array} props The property names to get values for.
		   * @returns {Object} Returns the array of property values.
		   */
		  function baseValues(object, props) {
		    return arrayMap(props, function(key) {
		      return object[key];
		    });
		  }

		  /**
		   * Checks if a `cache` value for `key` exists.
		   *
		   * @private
		   * @param {Object} cache The cache to query.
		   * @param {string} key The key of the entry to check.
		   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		   */
		  function cacheHas(cache, key) {
		    return cache.has(key);
		  }

		  /**
		   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
		   * that is not found in the character symbols.
		   *
		   * @private
		   * @param {Array} strSymbols The string symbols to inspect.
		   * @param {Array} chrSymbols The character symbols to find.
		   * @returns {number} Returns the index of the first unmatched string symbol.
		   */
		  function charsStartIndex(strSymbols, chrSymbols) {
		    var index = -1,
		        length = strSymbols.length;

		    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
		    return index;
		  }

		  /**
		   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
		   * that is not found in the character symbols.
		   *
		   * @private
		   * @param {Array} strSymbols The string symbols to inspect.
		   * @param {Array} chrSymbols The character symbols to find.
		   * @returns {number} Returns the index of the last unmatched string symbol.
		   */
		  function charsEndIndex(strSymbols, chrSymbols) {
		    var index = strSymbols.length;

		    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
		    return index;
		  }

		  /**
		   * Gets the number of `placeholder` occurrences in `array`.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} placeholder The placeholder to search for.
		   * @returns {number} Returns the placeholder count.
		   */
		  function countHolders(array, placeholder) {
		    var length = array.length,
		        result = 0;

		    while (length--) {
		      if (array[length] === placeholder) {
		        ++result;
		      }
		    }
		    return result;
		  }

		  /**
		   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
		   * letters to basic Latin letters.
		   *
		   * @private
		   * @param {string} letter The matched letter to deburr.
		   * @returns {string} Returns the deburred letter.
		   */
		  var deburrLetter = basePropertyOf(deburredLetters);

		  /**
		   * Used by `_.escape` to convert characters to HTML entities.
		   *
		   * @private
		   * @param {string} chr The matched character to escape.
		   * @returns {string} Returns the escaped character.
		   */
		  var escapeHtmlChar = basePropertyOf(htmlEscapes);

		  /**
		   * Used by `_.template` to escape characters for inclusion in compiled string literals.
		   *
		   * @private
		   * @param {string} chr The matched character to escape.
		   * @returns {string} Returns the escaped character.
		   */
		  function escapeStringChar(chr) {
		    return '\\' + stringEscapes[chr];
		  }

		  /**
		   * Gets the value at `key` of `object`.
		   *
		   * @private
		   * @param {Object} [object] The object to query.
		   * @param {string} key The key of the property to get.
		   * @returns {*} Returns the property value.
		   */
		  function getValue(object, key) {
		    return object == null ? undefined$1 : object[key];
		  }

		  /**
		   * Checks if `string` contains Unicode symbols.
		   *
		   * @private
		   * @param {string} string The string to inspect.
		   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
		   */
		  function hasUnicode(string) {
		    return reHasUnicode.test(string);
		  }

		  /**
		   * Checks if `string` contains a word composed of Unicode symbols.
		   *
		   * @private
		   * @param {string} string The string to inspect.
		   * @returns {boolean} Returns `true` if a word is found, else `false`.
		   */
		  function hasUnicodeWord(string) {
		    return reHasUnicodeWord.test(string);
		  }

		  /**
		   * Converts `iterator` to an array.
		   *
		   * @private
		   * @param {Object} iterator The iterator to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function iteratorToArray(iterator) {
		    var data,
		        result = [];

		    while (!(data = iterator.next()).done) {
		      result.push(data.value);
		    }
		    return result;
		  }

		  /**
		   * Converts `map` to its key-value pairs.
		   *
		   * @private
		   * @param {Object} map The map to convert.
		   * @returns {Array} Returns the key-value pairs.
		   */
		  function mapToArray(map) {
		    var index = -1,
		        result = Array(map.size);

		    map.forEach(function(value, key) {
		      result[++index] = [key, value];
		    });
		    return result;
		  }

		  /**
		   * Creates a unary function that invokes `func` with its argument transformed.
		   *
		   * @private
		   * @param {Function} func The function to wrap.
		   * @param {Function} transform The argument transform.
		   * @returns {Function} Returns the new function.
		   */
		  function overArg(func, transform) {
		    return function(arg) {
		      return func(transform(arg));
		    };
		  }

		  /**
		   * Replaces all `placeholder` elements in `array` with an internal placeholder
		   * and returns an array of their indexes.
		   *
		   * @private
		   * @param {Array} array The array to modify.
		   * @param {*} placeholder The placeholder to replace.
		   * @returns {Array} Returns the new array of placeholder indexes.
		   */
		  function replaceHolders(array, placeholder) {
		    var index = -1,
		        length = array.length,
		        resIndex = 0,
		        result = [];

		    while (++index < length) {
		      var value = array[index];
		      if (value === placeholder || value === PLACEHOLDER) {
		        array[index] = PLACEHOLDER;
		        result[resIndex++] = index;
		      }
		    }
		    return result;
		  }

		  /**
		   * Converts `set` to an array of its values.
		   *
		   * @private
		   * @param {Object} set The set to convert.
		   * @returns {Array} Returns the values.
		   */
		  function setToArray(set) {
		    var index = -1,
		        result = Array(set.size);

		    set.forEach(function(value) {
		      result[++index] = value;
		    });
		    return result;
		  }

		  /**
		   * Converts `set` to its value-value pairs.
		   *
		   * @private
		   * @param {Object} set The set to convert.
		   * @returns {Array} Returns the value-value pairs.
		   */
		  function setToPairs(set) {
		    var index = -1,
		        result = Array(set.size);

		    set.forEach(function(value) {
		      result[++index] = [value, value];
		    });
		    return result;
		  }

		  /**
		   * A specialized version of `_.indexOf` which performs strict equality
		   * comparisons of values, i.e. `===`.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} value The value to search for.
		   * @param {number} fromIndex The index to search from.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function strictIndexOf(array, value, fromIndex) {
		    var index = fromIndex - 1,
		        length = array.length;

		    while (++index < length) {
		      if (array[index] === value) {
		        return index;
		      }
		    }
		    return -1;
		  }

		  /**
		   * A specialized version of `_.lastIndexOf` which performs strict equality
		   * comparisons of values, i.e. `===`.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} value The value to search for.
		   * @param {number} fromIndex The index to search from.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function strictLastIndexOf(array, value, fromIndex) {
		    var index = fromIndex + 1;
		    while (index--) {
		      if (array[index] === value) {
		        return index;
		      }
		    }
		    return index;
		  }

		  /**
		   * Gets the number of symbols in `string`.
		   *
		   * @private
		   * @param {string} string The string to inspect.
		   * @returns {number} Returns the string size.
		   */
		  function stringSize(string) {
		    return hasUnicode(string)
		      ? unicodeSize(string)
		      : asciiSize(string);
		  }

		  /**
		   * Converts `string` to an array.
		   *
		   * @private
		   * @param {string} string The string to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function stringToArray(string) {
		    return hasUnicode(string)
		      ? unicodeToArray(string)
		      : asciiToArray(string);
		  }

		  /**
		   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
		   * character of `string`.
		   *
		   * @private
		   * @param {string} string The string to inspect.
		   * @returns {number} Returns the index of the last non-whitespace character.
		   */
		  function trimmedEndIndex(string) {
		    var index = string.length;

		    while (index-- && reWhitespace.test(string.charAt(index))) {}
		    return index;
		  }

		  /**
		   * Used by `_.unescape` to convert HTML entities to characters.
		   *
		   * @private
		   * @param {string} chr The matched character to unescape.
		   * @returns {string} Returns the unescaped character.
		   */
		  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

		  /**
		   * Gets the size of a Unicode `string`.
		   *
		   * @private
		   * @param {string} string The string inspect.
		   * @returns {number} Returns the string size.
		   */
		  function unicodeSize(string) {
		    var result = reUnicode.lastIndex = 0;
		    while (reUnicode.test(string)) {
		      ++result;
		    }
		    return result;
		  }

		  /**
		   * Converts a Unicode `string` to an array.
		   *
		   * @private
		   * @param {string} string The string to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function unicodeToArray(string) {
		    return string.match(reUnicode) || [];
		  }

		  /**
		   * Splits a Unicode `string` into an array of its words.
		   *
		   * @private
		   * @param {string} The string to inspect.
		   * @returns {Array} Returns the words of `string`.
		   */
		  function unicodeWords(string) {
		    return string.match(reUnicodeWord) || [];
		  }

		  /*--------------------------------------------------------------------------*/

		  /**
		   * Create a new pristine `lodash` function using the `context` object.
		   *
		   * @static
		   * @memberOf _
		   * @since 1.1.0
		   * @category Util
		   * @param {Object} [context=root] The context object.
		   * @returns {Function} Returns a new `lodash` function.
		   * @example
		   *
		   * _.mixin({ 'foo': _.constant('foo') });
		   *
		   * var lodash = _.runInContext();
		   * lodash.mixin({ 'bar': lodash.constant('bar') });
		   *
		   * _.isFunction(_.foo);
		   * // => true
		   * _.isFunction(_.bar);
		   * // => false
		   *
		   * lodash.isFunction(lodash.foo);
		   * // => false
		   * lodash.isFunction(lodash.bar);
		   * // => true
		   *
		   * // Create a suped-up `defer` in Node.js.
		   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
		   */
		  var runInContext = (function runInContext(context) {
		    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

		    /** Built-in constructor references. */
		    var Array = context.Array,
		        Date = context.Date,
		        Error = context.Error,
		        Function = context.Function,
		        Math = context.Math,
		        Object = context.Object,
		        RegExp = context.RegExp,
		        String = context.String,
		        TypeError = context.TypeError;

		    /** Used for built-in method references. */
		    var arrayProto = Array.prototype,
		        funcProto = Function.prototype,
		        objectProto = Object.prototype;

		    /** Used to detect overreaching core-js shims. */
		    var coreJsData = context['__core-js_shared__'];

		    /** Used to resolve the decompiled source of functions. */
		    var funcToString = funcProto.toString;

		    /** Used to check objects for own properties. */
		    var hasOwnProperty = objectProto.hasOwnProperty;

		    /** Used to generate unique IDs. */
		    var idCounter = 0;

		    /** Used to detect methods masquerading as native. */
		    var maskSrcKey = (function() {
		      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
		      return uid ? ('Symbol(src)_1.' + uid) : '';
		    }());

		    /**
		     * Used to resolve the
		     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
		     * of values.
		     */
		    var nativeObjectToString = objectProto.toString;

		    /** Used to infer the `Object` constructor. */
		    var objectCtorString = funcToString.call(Object);

		    /** Used to restore the original `_` reference in `_.noConflict`. */
		    var oldDash = root._;

		    /** Used to detect if a method is native. */
		    var reIsNative = RegExp('^' +
		      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
		      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
		    );

		    /** Built-in value references. */
		    var Buffer = moduleExports ? context.Buffer : undefined$1,
		        Symbol = context.Symbol,
		        Uint8Array = context.Uint8Array,
		        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1,
		        getPrototype = overArg(Object.getPrototypeOf, Object),
		        objectCreate = Object.create,
		        propertyIsEnumerable = objectProto.propertyIsEnumerable,
		        splice = arrayProto.splice,
		        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined$1,
		        symIterator = Symbol ? Symbol.iterator : undefined$1,
		        symToStringTag = Symbol ? Symbol.toStringTag : undefined$1;

		    var defineProperty = (function() {
		      try {
		        var func = getNative(Object, 'defineProperty');
		        func({}, '', {});
		        return func;
		      } catch (e) {}
		    }());

		    /** Mocked built-ins. */
		    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
		        ctxNow = Date && Date.now !== root.Date.now && Date.now,
		        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

		    /* Built-in method references for those with the same name as other `lodash` methods. */
		    var nativeCeil = Math.ceil,
		        nativeFloor = Math.floor,
		        nativeGetSymbols = Object.getOwnPropertySymbols,
		        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1,
		        nativeIsFinite = context.isFinite,
		        nativeJoin = arrayProto.join,
		        nativeKeys = overArg(Object.keys, Object),
		        nativeMax = Math.max,
		        nativeMin = Math.min,
		        nativeNow = Date.now,
		        nativeParseInt = context.parseInt,
		        nativeRandom = Math.random,
		        nativeReverse = arrayProto.reverse;

		    /* Built-in method references that are verified to be native. */
		    var DataView = getNative(context, 'DataView'),
		        Map = getNative(context, 'Map'),
		        Promise = getNative(context, 'Promise'),
		        Set = getNative(context, 'Set'),
		        WeakMap = getNative(context, 'WeakMap'),
		        nativeCreate = getNative(Object, 'create');

		    /** Used to store function metadata. */
		    var metaMap = WeakMap && new WeakMap;

		    /** Used to lookup unminified function names. */
		    var realNames = {};

		    /** Used to detect maps, sets, and weakmaps. */
		    var dataViewCtorString = toSource(DataView),
		        mapCtorString = toSource(Map),
		        promiseCtorString = toSource(Promise),
		        setCtorString = toSource(Set),
		        weakMapCtorString = toSource(WeakMap);

		    /** Used to convert symbols to primitives and strings. */
		    var symbolProto = Symbol ? Symbol.prototype : undefined$1,
		        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1,
		        symbolToString = symbolProto ? symbolProto.toString : undefined$1;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a `lodash` object which wraps `value` to enable implicit method
		     * chain sequences. Methods that operate on and return arrays, collections,
		     * and functions can be chained together. Methods that retrieve a single value
		     * or may return a primitive value will automatically end the chain sequence
		     * and return the unwrapped value. Otherwise, the value must be unwrapped
		     * with `_#value`.
		     *
		     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
		     * enabled using `_.chain`.
		     *
		     * The execution of chained methods is lazy, that is, it's deferred until
		     * `_#value` is implicitly or explicitly called.
		     *
		     * Lazy evaluation allows several methods to support shortcut fusion.
		     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
		     * the creation of intermediate arrays and can greatly reduce the number of
		     * iteratee executions. Sections of a chain sequence qualify for shortcut
		     * fusion if the section is applied to an array and iteratees accept only
		     * one argument. The heuristic for whether a section qualifies for shortcut
		     * fusion is subject to change.
		     *
		     * Chaining is supported in custom builds as long as the `_#value` method is
		     * directly or indirectly included in the build.
		     *
		     * In addition to lodash methods, wrappers have `Array` and `String` methods.
		     *
		     * The wrapper `Array` methods are:
		     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
		     *
		     * The wrapper `String` methods are:
		     * `replace` and `split`
		     *
		     * The wrapper methods that support shortcut fusion are:
		     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
		     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
		     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
		     *
		     * The chainable wrapper methods are:
		     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
		     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
		     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
		     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
		     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
		     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
		     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
		     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
		     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
		     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
		     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
		     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
		     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
		     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
		     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
		     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
		     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
		     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
		     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
		     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
		     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
		     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
		     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
		     * `zipObject`, `zipObjectDeep`, and `zipWith`
		     *
		     * The wrapper methods that are **not** chainable by default are:
		     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
		     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
		     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
		     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
		     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
		     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
		     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
		     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
		     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
		     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
		     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
		     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
		     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
		     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
		     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
		     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
		     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
		     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
		     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
		     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
		     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
		     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
		     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
		     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
		     * `upperFirst`, `value`, and `words`
		     *
		     * @name _
		     * @constructor
		     * @category Seq
		     * @param {*} value The value to wrap in a `lodash` instance.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var wrapped = _([1, 2, 3]);
		     *
		     * // Returns an unwrapped value.
		     * wrapped.reduce(_.add);
		     * // => 6
		     *
		     * // Returns a wrapped value.
		     * var squares = wrapped.map(square);
		     *
		     * _.isArray(squares);
		     * // => false
		     *
		     * _.isArray(squares.value());
		     * // => true
		     */
		    function lodash(value) {
		      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
		        if (value instanceof LodashWrapper) {
		          return value;
		        }
		        if (hasOwnProperty.call(value, '__wrapped__')) {
		          return wrapperClone(value);
		        }
		      }
		      return new LodashWrapper(value);
		    }

		    /**
		     * The base implementation of `_.create` without support for assigning
		     * properties to the created object.
		     *
		     * @private
		     * @param {Object} proto The object to inherit from.
		     * @returns {Object} Returns the new object.
		     */
		    var baseCreate = (function() {
		      function object() {}
		      return function(proto) {
		        if (!isObject(proto)) {
		          return {};
		        }
		        if (objectCreate) {
		          return objectCreate(proto);
		        }
		        object.prototype = proto;
		        var result = new object;
		        object.prototype = undefined$1;
		        return result;
		      };
		    }());

		    /**
		     * The function whose prototype chain sequence wrappers inherit from.
		     *
		     * @private
		     */
		    function baseLodash() {
		      // No operation performed.
		    }

		    /**
		     * The base constructor for creating `lodash` wrapper objects.
		     *
		     * @private
		     * @param {*} value The value to wrap.
		     * @param {boolean} [chainAll] Enable explicit method chain sequences.
		     */
		    function LodashWrapper(value, chainAll) {
		      this.__wrapped__ = value;
		      this.__actions__ = [];
		      this.__chain__ = !!chainAll;
		      this.__index__ = 0;
		      this.__values__ = undefined$1;
		    }

		    /**
		     * By default, the template delimiters used by lodash are like those in
		     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
		     * following template settings to use alternative delimiters.
		     *
		     * @static
		     * @memberOf _
		     * @type {Object}
		     */
		    lodash.templateSettings = {

		      /**
		       * Used to detect `data` property values to be HTML-escaped.
		       *
		       * @memberOf _.templateSettings
		       * @type {RegExp}
		       */
		      'escape': reEscape,

		      /**
		       * Used to detect code to be evaluated.
		       *
		       * @memberOf _.templateSettings
		       * @type {RegExp}
		       */
		      'evaluate': reEvaluate,

		      /**
		       * Used to detect `data` property values to inject.
		       *
		       * @memberOf _.templateSettings
		       * @type {RegExp}
		       */
		      'interpolate': reInterpolate,

		      /**
		       * Used to reference the data object in the template text.
		       *
		       * @memberOf _.templateSettings
		       * @type {string}
		       */
		      'variable': '',

		      /**
		       * Used to import variables into the compiled template.
		       *
		       * @memberOf _.templateSettings
		       * @type {Object}
		       */
		      'imports': {

		        /**
		         * A reference to the `lodash` function.
		         *
		         * @memberOf _.templateSettings.imports
		         * @type {Function}
		         */
		        '_': lodash
		      }
		    };

		    // Ensure wrappers are instances of `baseLodash`.
		    lodash.prototype = baseLodash.prototype;
		    lodash.prototype.constructor = lodash;

		    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
		    LodashWrapper.prototype.constructor = LodashWrapper;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
		     *
		     * @private
		     * @constructor
		     * @param {*} value The value to wrap.
		     */
		    function LazyWrapper(value) {
		      this.__wrapped__ = value;
		      this.__actions__ = [];
		      this.__dir__ = 1;
		      this.__filtered__ = false;
		      this.__iteratees__ = [];
		      this.__takeCount__ = MAX_ARRAY_LENGTH;
		      this.__views__ = [];
		    }

		    /**
		     * Creates a clone of the lazy wrapper object.
		     *
		     * @private
		     * @name clone
		     * @memberOf LazyWrapper
		     * @returns {Object} Returns the cloned `LazyWrapper` object.
		     */
		    function lazyClone() {
		      var result = new LazyWrapper(this.__wrapped__);
		      result.__actions__ = copyArray(this.__actions__);
		      result.__dir__ = this.__dir__;
		      result.__filtered__ = this.__filtered__;
		      result.__iteratees__ = copyArray(this.__iteratees__);
		      result.__takeCount__ = this.__takeCount__;
		      result.__views__ = copyArray(this.__views__);
		      return result;
		    }

		    /**
		     * Reverses the direction of lazy iteration.
		     *
		     * @private
		     * @name reverse
		     * @memberOf LazyWrapper
		     * @returns {Object} Returns the new reversed `LazyWrapper` object.
		     */
		    function lazyReverse() {
		      if (this.__filtered__) {
		        var result = new LazyWrapper(this);
		        result.__dir__ = -1;
		        result.__filtered__ = true;
		      } else {
		        result = this.clone();
		        result.__dir__ *= -1;
		      }
		      return result;
		    }

		    /**
		     * Extracts the unwrapped value from its lazy wrapper.
		     *
		     * @private
		     * @name value
		     * @memberOf LazyWrapper
		     * @returns {*} Returns the unwrapped value.
		     */
		    function lazyValue() {
		      var array = this.__wrapped__.value(),
		          dir = this.__dir__,
		          isArr = isArray(array),
		          isRight = dir < 0,
		          arrLength = isArr ? array.length : 0,
		          view = getView(0, arrLength, this.__views__),
		          start = view.start,
		          end = view.end,
		          length = end - start,
		          index = isRight ? end : (start - 1),
		          iteratees = this.__iteratees__,
		          iterLength = iteratees.length,
		          resIndex = 0,
		          takeCount = nativeMin(length, this.__takeCount__);

		      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
		        return baseWrapperValue(array, this.__actions__);
		      }
		      var result = [];

		      outer:
		      while (length-- && resIndex < takeCount) {
		        index += dir;

		        var iterIndex = -1,
		            value = array[index];

		        while (++iterIndex < iterLength) {
		          var data = iteratees[iterIndex],
		              iteratee = data.iteratee,
		              type = data.type,
		              computed = iteratee(value);

		          if (type == LAZY_MAP_FLAG) {
		            value = computed;
		          } else if (!computed) {
		            if (type == LAZY_FILTER_FLAG) {
		              continue outer;
		            } else {
		              break outer;
		            }
		          }
		        }
		        result[resIndex++] = value;
		      }
		      return result;
		    }

		    // Ensure `LazyWrapper` is an instance of `baseLodash`.
		    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
		    LazyWrapper.prototype.constructor = LazyWrapper;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a hash object.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [entries] The key-value pairs to cache.
		     */
		    function Hash(entries) {
		      var index = -1,
		          length = entries == null ? 0 : entries.length;

		      this.clear();
		      while (++index < length) {
		        var entry = entries[index];
		        this.set(entry[0], entry[1]);
		      }
		    }

		    /**
		     * Removes all key-value entries from the hash.
		     *
		     * @private
		     * @name clear
		     * @memberOf Hash
		     */
		    function hashClear() {
		      this.__data__ = nativeCreate ? nativeCreate(null) : {};
		      this.size = 0;
		    }

		    /**
		     * Removes `key` and its value from the hash.
		     *
		     * @private
		     * @name delete
		     * @memberOf Hash
		     * @param {Object} hash The hash to modify.
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function hashDelete(key) {
		      var result = this.has(key) && delete this.__data__[key];
		      this.size -= result ? 1 : 0;
		      return result;
		    }

		    /**
		     * Gets the hash value for `key`.
		     *
		     * @private
		     * @name get
		     * @memberOf Hash
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function hashGet(key) {
		      var data = this.__data__;
		      if (nativeCreate) {
		        var result = data[key];
		        return result === HASH_UNDEFINED ? undefined$1 : result;
		      }
		      return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
		    }

		    /**
		     * Checks if a hash value for `key` exists.
		     *
		     * @private
		     * @name has
		     * @memberOf Hash
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function hashHas(key) {
		      var data = this.__data__;
		      return nativeCreate ? (data[key] !== undefined$1) : hasOwnProperty.call(data, key);
		    }

		    /**
		     * Sets the hash `key` to `value`.
		     *
		     * @private
		     * @name set
		     * @memberOf Hash
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns the hash instance.
		     */
		    function hashSet(key, value) {
		      var data = this.__data__;
		      this.size += this.has(key) ? 0 : 1;
		      data[key] = (nativeCreate && value === undefined$1) ? HASH_UNDEFINED : value;
		      return this;
		    }

		    // Add methods to `Hash`.
		    Hash.prototype.clear = hashClear;
		    Hash.prototype['delete'] = hashDelete;
		    Hash.prototype.get = hashGet;
		    Hash.prototype.has = hashHas;
		    Hash.prototype.set = hashSet;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates an list cache object.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [entries] The key-value pairs to cache.
		     */
		    function ListCache(entries) {
		      var index = -1,
		          length = entries == null ? 0 : entries.length;

		      this.clear();
		      while (++index < length) {
		        var entry = entries[index];
		        this.set(entry[0], entry[1]);
		      }
		    }

		    /**
		     * Removes all key-value entries from the list cache.
		     *
		     * @private
		     * @name clear
		     * @memberOf ListCache
		     */
		    function listCacheClear() {
		      this.__data__ = [];
		      this.size = 0;
		    }

		    /**
		     * Removes `key` and its value from the list cache.
		     *
		     * @private
		     * @name delete
		     * @memberOf ListCache
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function listCacheDelete(key) {
		      var data = this.__data__,
		          index = assocIndexOf(data, key);

		      if (index < 0) {
		        return false;
		      }
		      var lastIndex = data.length - 1;
		      if (index == lastIndex) {
		        data.pop();
		      } else {
		        splice.call(data, index, 1);
		      }
		      --this.size;
		      return true;
		    }

		    /**
		     * Gets the list cache value for `key`.
		     *
		     * @private
		     * @name get
		     * @memberOf ListCache
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function listCacheGet(key) {
		      var data = this.__data__,
		          index = assocIndexOf(data, key);

		      return index < 0 ? undefined$1 : data[index][1];
		    }

		    /**
		     * Checks if a list cache value for `key` exists.
		     *
		     * @private
		     * @name has
		     * @memberOf ListCache
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function listCacheHas(key) {
		      return assocIndexOf(this.__data__, key) > -1;
		    }

		    /**
		     * Sets the list cache `key` to `value`.
		     *
		     * @private
		     * @name set
		     * @memberOf ListCache
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns the list cache instance.
		     */
		    function listCacheSet(key, value) {
		      var data = this.__data__,
		          index = assocIndexOf(data, key);

		      if (index < 0) {
		        ++this.size;
		        data.push([key, value]);
		      } else {
		        data[index][1] = value;
		      }
		      return this;
		    }

		    // Add methods to `ListCache`.
		    ListCache.prototype.clear = listCacheClear;
		    ListCache.prototype['delete'] = listCacheDelete;
		    ListCache.prototype.get = listCacheGet;
		    ListCache.prototype.has = listCacheHas;
		    ListCache.prototype.set = listCacheSet;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a map cache object to store key-value pairs.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [entries] The key-value pairs to cache.
		     */
		    function MapCache(entries) {
		      var index = -1,
		          length = entries == null ? 0 : entries.length;

		      this.clear();
		      while (++index < length) {
		        var entry = entries[index];
		        this.set(entry[0], entry[1]);
		      }
		    }

		    /**
		     * Removes all key-value entries from the map.
		     *
		     * @private
		     * @name clear
		     * @memberOf MapCache
		     */
		    function mapCacheClear() {
		      this.size = 0;
		      this.__data__ = {
		        'hash': new Hash,
		        'map': new (Map || ListCache),
		        'string': new Hash
		      };
		    }

		    /**
		     * Removes `key` and its value from the map.
		     *
		     * @private
		     * @name delete
		     * @memberOf MapCache
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function mapCacheDelete(key) {
		      var result = getMapData(this, key)['delete'](key);
		      this.size -= result ? 1 : 0;
		      return result;
		    }

		    /**
		     * Gets the map value for `key`.
		     *
		     * @private
		     * @name get
		     * @memberOf MapCache
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function mapCacheGet(key) {
		      return getMapData(this, key).get(key);
		    }

		    /**
		     * Checks if a map value for `key` exists.
		     *
		     * @private
		     * @name has
		     * @memberOf MapCache
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function mapCacheHas(key) {
		      return getMapData(this, key).has(key);
		    }

		    /**
		     * Sets the map `key` to `value`.
		     *
		     * @private
		     * @name set
		     * @memberOf MapCache
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns the map cache instance.
		     */
		    function mapCacheSet(key, value) {
		      var data = getMapData(this, key),
		          size = data.size;

		      data.set(key, value);
		      this.size += data.size == size ? 0 : 1;
		      return this;
		    }

		    // Add methods to `MapCache`.
		    MapCache.prototype.clear = mapCacheClear;
		    MapCache.prototype['delete'] = mapCacheDelete;
		    MapCache.prototype.get = mapCacheGet;
		    MapCache.prototype.has = mapCacheHas;
		    MapCache.prototype.set = mapCacheSet;

		    /*------------------------------------------------------------------------*/

		    /**
		     *
		     * Creates an array cache object to store unique values.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [values] The values to cache.
		     */
		    function SetCache(values) {
		      var index = -1,
		          length = values == null ? 0 : values.length;

		      this.__data__ = new MapCache;
		      while (++index < length) {
		        this.add(values[index]);
		      }
		    }

		    /**
		     * Adds `value` to the array cache.
		     *
		     * @private
		     * @name add
		     * @memberOf SetCache
		     * @alias push
		     * @param {*} value The value to cache.
		     * @returns {Object} Returns the cache instance.
		     */
		    function setCacheAdd(value) {
		      this.__data__.set(value, HASH_UNDEFINED);
		      return this;
		    }

		    /**
		     * Checks if `value` is in the array cache.
		     *
		     * @private
		     * @name has
		     * @memberOf SetCache
		     * @param {*} value The value to search for.
		     * @returns {number} Returns `true` if `value` is found, else `false`.
		     */
		    function setCacheHas(value) {
		      return this.__data__.has(value);
		    }

		    // Add methods to `SetCache`.
		    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
		    SetCache.prototype.has = setCacheHas;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a stack cache object to store key-value pairs.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [entries] The key-value pairs to cache.
		     */
		    function Stack(entries) {
		      var data = this.__data__ = new ListCache(entries);
		      this.size = data.size;
		    }

		    /**
		     * Removes all key-value entries from the stack.
		     *
		     * @private
		     * @name clear
		     * @memberOf Stack
		     */
		    function stackClear() {
		      this.__data__ = new ListCache;
		      this.size = 0;
		    }

		    /**
		     * Removes `key` and its value from the stack.
		     *
		     * @private
		     * @name delete
		     * @memberOf Stack
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function stackDelete(key) {
		      var data = this.__data__,
		          result = data['delete'](key);

		      this.size = data.size;
		      return result;
		    }

		    /**
		     * Gets the stack value for `key`.
		     *
		     * @private
		     * @name get
		     * @memberOf Stack
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function stackGet(key) {
		      return this.__data__.get(key);
		    }

		    /**
		     * Checks if a stack value for `key` exists.
		     *
		     * @private
		     * @name has
		     * @memberOf Stack
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function stackHas(key) {
		      return this.__data__.has(key);
		    }

		    /**
		     * Sets the stack `key` to `value`.
		     *
		     * @private
		     * @name set
		     * @memberOf Stack
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns the stack cache instance.
		     */
		    function stackSet(key, value) {
		      var data = this.__data__;
		      if (data instanceof ListCache) {
		        var pairs = data.__data__;
		        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
		          pairs.push([key, value]);
		          this.size = ++data.size;
		          return this;
		        }
		        data = this.__data__ = new MapCache(pairs);
		      }
		      data.set(key, value);
		      this.size = data.size;
		      return this;
		    }

		    // Add methods to `Stack`.
		    Stack.prototype.clear = stackClear;
		    Stack.prototype['delete'] = stackDelete;
		    Stack.prototype.get = stackGet;
		    Stack.prototype.has = stackHas;
		    Stack.prototype.set = stackSet;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates an array of the enumerable property names of the array-like `value`.
		     *
		     * @private
		     * @param {*} value The value to query.
		     * @param {boolean} inherited Specify returning inherited property names.
		     * @returns {Array} Returns the array of property names.
		     */
		    function arrayLikeKeys(value, inherited) {
		      var isArr = isArray(value),
		          isArg = !isArr && isArguments(value),
		          isBuff = !isArr && !isArg && isBuffer(value),
		          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
		          skipIndexes = isArr || isArg || isBuff || isType,
		          result = skipIndexes ? baseTimes(value.length, String) : [],
		          length = result.length;

		      for (var key in value) {
		        if ((inherited || hasOwnProperty.call(value, key)) &&
		            !(skipIndexes && (
		               // Safari 9 has enumerable `arguments.length` in strict mode.
		               key == 'length' ||
		               // Node.js 0.10 has enumerable non-index properties on buffers.
		               (isBuff && (key == 'offset' || key == 'parent')) ||
		               // PhantomJS 2 has enumerable non-index properties on typed arrays.
		               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
		               // Skip index properties.
		               isIndex(key, length)
		            ))) {
		          result.push(key);
		        }
		      }
		      return result;
		    }

		    /**
		     * A specialized version of `_.sample` for arrays.
		     *
		     * @private
		     * @param {Array} array The array to sample.
		     * @returns {*} Returns the random element.
		     */
		    function arraySample(array) {
		      var length = array.length;
		      return length ? array[baseRandom(0, length - 1)] : undefined$1;
		    }

		    /**
		     * A specialized version of `_.sampleSize` for arrays.
		     *
		     * @private
		     * @param {Array} array The array to sample.
		     * @param {number} n The number of elements to sample.
		     * @returns {Array} Returns the random elements.
		     */
		    function arraySampleSize(array, n) {
		      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
		    }

		    /**
		     * A specialized version of `_.shuffle` for arrays.
		     *
		     * @private
		     * @param {Array} array The array to shuffle.
		     * @returns {Array} Returns the new shuffled array.
		     */
		    function arrayShuffle(array) {
		      return shuffleSelf(copyArray(array));
		    }

		    /**
		     * This function is like `assignValue` except that it doesn't assign
		     * `undefined` values.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {string} key The key of the property to assign.
		     * @param {*} value The value to assign.
		     */
		    function assignMergeValue(object, key, value) {
		      if ((value !== undefined$1 && !eq(object[key], value)) ||
		          (value === undefined$1 && !(key in object))) {
		        baseAssignValue(object, key, value);
		      }
		    }

		    /**
		     * Assigns `value` to `key` of `object` if the existing value is not equivalent
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {string} key The key of the property to assign.
		     * @param {*} value The value to assign.
		     */
		    function assignValue(object, key, value) {
		      var objValue = object[key];
		      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
		          (value === undefined$1 && !(key in object))) {
		        baseAssignValue(object, key, value);
		      }
		    }

		    /**
		     * Gets the index at which the `key` is found in `array` of key-value pairs.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {*} key The key to search for.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     */
		    function assocIndexOf(array, key) {
		      var length = array.length;
		      while (length--) {
		        if (eq(array[length][0], key)) {
		          return length;
		        }
		      }
		      return -1;
		    }

		    /**
		     * Aggregates elements of `collection` on `accumulator` with keys transformed
		     * by `iteratee` and values set by `setter`.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} setter The function to set `accumulator` values.
		     * @param {Function} iteratee The iteratee to transform keys.
		     * @param {Object} accumulator The initial aggregated object.
		     * @returns {Function} Returns `accumulator`.
		     */
		    function baseAggregator(collection, setter, iteratee, accumulator) {
		      baseEach(collection, function(value, key, collection) {
		        setter(accumulator, value, iteratee(value), collection);
		      });
		      return accumulator;
		    }

		    /**
		     * The base implementation of `_.assign` without support for multiple sources
		     * or `customizer` functions.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @returns {Object} Returns `object`.
		     */
		    function baseAssign(object, source) {
		      return object && copyObject(source, keys(source), object);
		    }

		    /**
		     * The base implementation of `_.assignIn` without support for multiple sources
		     * or `customizer` functions.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @returns {Object} Returns `object`.
		     */
		    function baseAssignIn(object, source) {
		      return object && copyObject(source, keysIn(source), object);
		    }

		    /**
		     * The base implementation of `assignValue` and `assignMergeValue` without
		     * value checks.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {string} key The key of the property to assign.
		     * @param {*} value The value to assign.
		     */
		    function baseAssignValue(object, key, value) {
		      if (key == '__proto__' && defineProperty) {
		        defineProperty(object, key, {
		          'configurable': true,
		          'enumerable': true,
		          'value': value,
		          'writable': true
		        });
		      } else {
		        object[key] = value;
		      }
		    }

		    /**
		     * The base implementation of `_.at` without support for individual paths.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {string[]} paths The property paths to pick.
		     * @returns {Array} Returns the picked elements.
		     */
		    function baseAt(object, paths) {
		      var index = -1,
		          length = paths.length,
		          result = Array(length),
		          skip = object == null;

		      while (++index < length) {
		        result[index] = skip ? undefined$1 : get(object, paths[index]);
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.clamp` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {number} number The number to clamp.
		     * @param {number} [lower] The lower bound.
		     * @param {number} upper The upper bound.
		     * @returns {number} Returns the clamped number.
		     */
		    function baseClamp(number, lower, upper) {
		      if (number === number) {
		        if (upper !== undefined$1) {
		          number = number <= upper ? number : upper;
		        }
		        if (lower !== undefined$1) {
		          number = number >= lower ? number : lower;
		        }
		      }
		      return number;
		    }

		    /**
		     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
		     * traversed objects.
		     *
		     * @private
		     * @param {*} value The value to clone.
		     * @param {boolean} bitmask The bitmask flags.
		     *  1 - Deep clone
		     *  2 - Flatten inherited properties
		     *  4 - Clone symbols
		     * @param {Function} [customizer] The function to customize cloning.
		     * @param {string} [key] The key of `value`.
		     * @param {Object} [object] The parent object of `value`.
		     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
		     * @returns {*} Returns the cloned value.
		     */
		    function baseClone(value, bitmask, customizer, key, object, stack) {
		      var result,
		          isDeep = bitmask & CLONE_DEEP_FLAG,
		          isFlat = bitmask & CLONE_FLAT_FLAG,
		          isFull = bitmask & CLONE_SYMBOLS_FLAG;

		      if (customizer) {
		        result = object ? customizer(value, key, object, stack) : customizer(value);
		      }
		      if (result !== undefined$1) {
		        return result;
		      }
		      if (!isObject(value)) {
		        return value;
		      }
		      var isArr = isArray(value);
		      if (isArr) {
		        result = initCloneArray(value);
		        if (!isDeep) {
		          return copyArray(value, result);
		        }
		      } else {
		        var tag = getTag(value),
		            isFunc = tag == funcTag || tag == genTag;

		        if (isBuffer(value)) {
		          return cloneBuffer(value, isDeep);
		        }
		        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
		          result = (isFlat || isFunc) ? {} : initCloneObject(value);
		          if (!isDeep) {
		            return isFlat
		              ? copySymbolsIn(value, baseAssignIn(result, value))
		              : copySymbols(value, baseAssign(result, value));
		          }
		        } else {
		          if (!cloneableTags[tag]) {
		            return object ? value : {};
		          }
		          result = initCloneByTag(value, tag, isDeep);
		        }
		      }
		      // Check for circular references and return its corresponding clone.
		      stack || (stack = new Stack);
		      var stacked = stack.get(value);
		      if (stacked) {
		        return stacked;
		      }
		      stack.set(value, result);

		      if (isSet(value)) {
		        value.forEach(function(subValue) {
		          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
		        });
		      } else if (isMap(value)) {
		        value.forEach(function(subValue, key) {
		          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
		        });
		      }

		      var keysFunc = isFull
		        ? (isFlat ? getAllKeysIn : getAllKeys)
		        : (isFlat ? keysIn : keys);

		      var props = isArr ? undefined$1 : keysFunc(value);
		      arrayEach(props || value, function(subValue, key) {
		        if (props) {
		          key = subValue;
		          subValue = value[key];
		        }
		        // Recursively populate clone (susceptible to call stack limits).
		        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
		      });
		      return result;
		    }

		    /**
		     * The base implementation of `_.conforms` which doesn't clone `source`.
		     *
		     * @private
		     * @param {Object} source The object of property predicates to conform to.
		     * @returns {Function} Returns the new spec function.
		     */
		    function baseConforms(source) {
		      var props = keys(source);
		      return function(object) {
		        return baseConformsTo(object, source, props);
		      };
		    }

		    /**
		     * The base implementation of `_.conformsTo` which accepts `props` to check.
		     *
		     * @private
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property predicates to conform to.
		     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
		     */
		    function baseConformsTo(object, source, props) {
		      var length = props.length;
		      if (object == null) {
		        return !length;
		      }
		      object = Object(object);
		      while (length--) {
		        var key = props[length],
		            predicate = source[key],
		            value = object[key];

		        if ((value === undefined$1 && !(key in object)) || !predicate(value)) {
		          return false;
		        }
		      }
		      return true;
		    }

		    /**
		     * The base implementation of `_.delay` and `_.defer` which accepts `args`
		     * to provide to `func`.
		     *
		     * @private
		     * @param {Function} func The function to delay.
		     * @param {number} wait The number of milliseconds to delay invocation.
		     * @param {Array} args The arguments to provide to `func`.
		     * @returns {number|Object} Returns the timer id or timeout object.
		     */
		    function baseDelay(func, wait, args) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      return setTimeout(function() { func.apply(undefined$1, args); }, wait);
		    }

		    /**
		     * The base implementation of methods like `_.difference` without support
		     * for excluding multiple arrays or iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {Array} values The values to exclude.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     */
		    function baseDifference(array, values, iteratee, comparator) {
		      var index = -1,
		          includes = arrayIncludes,
		          isCommon = true,
		          length = array.length,
		          result = [],
		          valuesLength = values.length;

		      if (!length) {
		        return result;
		      }
		      if (iteratee) {
		        values = arrayMap(values, baseUnary(iteratee));
		      }
		      if (comparator) {
		        includes = arrayIncludesWith;
		        isCommon = false;
		      }
		      else if (values.length >= LARGE_ARRAY_SIZE) {
		        includes = cacheHas;
		        isCommon = false;
		        values = new SetCache(values);
		      }
		      outer:
		      while (++index < length) {
		        var value = array[index],
		            computed = iteratee == null ? value : iteratee(value);

		        value = (comparator || value !== 0) ? value : 0;
		        if (isCommon && computed === computed) {
		          var valuesIndex = valuesLength;
		          while (valuesIndex--) {
		            if (values[valuesIndex] === computed) {
		              continue outer;
		            }
		          }
		          result.push(value);
		        }
		        else if (!includes(values, computed, comparator)) {
		          result.push(value);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.forEach` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     */
		    var baseEach = createBaseEach(baseForOwn);

		    /**
		     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     */
		    var baseEachRight = createBaseEach(baseForOwnRight, true);

		    /**
		     * The base implementation of `_.every` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} predicate The function invoked per iteration.
		     * @returns {boolean} Returns `true` if all elements pass the predicate check,
		     *  else `false`
		     */
		    function baseEvery(collection, predicate) {
		      var result = true;
		      baseEach(collection, function(value, index, collection) {
		        result = !!predicate(value, index, collection);
		        return result;
		      });
		      return result;
		    }

		    /**
		     * The base implementation of methods like `_.max` and `_.min` which accepts a
		     * `comparator` to determine the extremum value.
		     *
		     * @private
		     * @param {Array} array The array to iterate over.
		     * @param {Function} iteratee The iteratee invoked per iteration.
		     * @param {Function} comparator The comparator used to compare values.
		     * @returns {*} Returns the extremum value.
		     */
		    function baseExtremum(array, iteratee, comparator) {
		      var index = -1,
		          length = array.length;

		      while (++index < length) {
		        var value = array[index],
		            current = iteratee(value);

		        if (current != null && (computed === undefined$1
		              ? (current === current && !isSymbol(current))
		              : comparator(current, computed)
		            )) {
		          var computed = current,
		              result = value;
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.fill` without an iteratee call guard.
		     *
		     * @private
		     * @param {Array} array The array to fill.
		     * @param {*} value The value to fill `array` with.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns `array`.
		     */
		    function baseFill(array, value, start, end) {
		      var length = array.length;

		      start = toInteger(start);
		      if (start < 0) {
		        start = -start > length ? 0 : (length + start);
		      }
		      end = (end === undefined$1 || end > length) ? length : toInteger(end);
		      if (end < 0) {
		        end += length;
		      }
		      end = start > end ? 0 : toLength(end);
		      while (start < end) {
		        array[start++] = value;
		      }
		      return array;
		    }

		    /**
		     * The base implementation of `_.filter` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} predicate The function invoked per iteration.
		     * @returns {Array} Returns the new filtered array.
		     */
		    function baseFilter(collection, predicate) {
		      var result = [];
		      baseEach(collection, function(value, index, collection) {
		        if (predicate(value, index, collection)) {
		          result.push(value);
		        }
		      });
		      return result;
		    }

		    /**
		     * The base implementation of `_.flatten` with support for restricting flattening.
		     *
		     * @private
		     * @param {Array} array The array to flatten.
		     * @param {number} depth The maximum recursion depth.
		     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
		     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
		     * @param {Array} [result=[]] The initial result value.
		     * @returns {Array} Returns the new flattened array.
		     */
		    function baseFlatten(array, depth, predicate, isStrict, result) {
		      var index = -1,
		          length = array.length;

		      predicate || (predicate = isFlattenable);
		      result || (result = []);

		      while (++index < length) {
		        var value = array[index];
		        if (depth > 0 && predicate(value)) {
		          if (depth > 1) {
		            // Recursively flatten arrays (susceptible to call stack limits).
		            baseFlatten(value, depth - 1, predicate, isStrict, result);
		          } else {
		            arrayPush(result, value);
		          }
		        } else if (!isStrict) {
		          result[result.length] = value;
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `baseForOwn` which iterates over `object`
		     * properties returned by `keysFunc` and invokes `iteratee` for each property.
		     * Iteratee functions may exit iteration early by explicitly returning `false`.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @param {Function} keysFunc The function to get the keys of `object`.
		     * @returns {Object} Returns `object`.
		     */
		    var baseFor = createBaseFor();

		    /**
		     * This function is like `baseFor` except that it iterates over properties
		     * in the opposite order.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @param {Function} keysFunc The function to get the keys of `object`.
		     * @returns {Object} Returns `object`.
		     */
		    var baseForRight = createBaseFor(true);

		    /**
		     * The base implementation of `_.forOwn` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     */
		    function baseForOwn(object, iteratee) {
		      return object && baseFor(object, iteratee, keys);
		    }

		    /**
		     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     */
		    function baseForOwnRight(object, iteratee) {
		      return object && baseForRight(object, iteratee, keys);
		    }

		    /**
		     * The base implementation of `_.functions` which creates an array of
		     * `object` function property names filtered from `props`.
		     *
		     * @private
		     * @param {Object} object The object to inspect.
		     * @param {Array} props The property names to filter.
		     * @returns {Array} Returns the function names.
		     */
		    function baseFunctions(object, props) {
		      return arrayFilter(props, function(key) {
		        return isFunction(object[key]);
		      });
		    }

		    /**
		     * The base implementation of `_.get` without support for default values.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the property to get.
		     * @returns {*} Returns the resolved value.
		     */
		    function baseGet(object, path) {
		      path = castPath(path, object);

		      var index = 0,
		          length = path.length;

		      while (object != null && index < length) {
		        object = object[toKey(path[index++])];
		      }
		      return (index && index == length) ? object : undefined$1;
		    }

		    /**
		     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
		     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
		     * symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Function} keysFunc The function to get the keys of `object`.
		     * @param {Function} symbolsFunc The function to get the symbols of `object`.
		     * @returns {Array} Returns the array of property names and symbols.
		     */
		    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
		      var result = keysFunc(object);
		      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
		    }

		    /**
		     * The base implementation of `getTag` without fallbacks for buggy environments.
		     *
		     * @private
		     * @param {*} value The value to query.
		     * @returns {string} Returns the `toStringTag`.
		     */
		    function baseGetTag(value) {
		      if (value == null) {
		        return value === undefined$1 ? undefinedTag : nullTag;
		      }
		      return (symToStringTag && symToStringTag in Object(value))
		        ? getRawTag(value)
		        : objectToString(value);
		    }

		    /**
		     * The base implementation of `_.gt` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is greater than `other`,
		     *  else `false`.
		     */
		    function baseGt(value, other) {
		      return value > other;
		    }

		    /**
		     * The base implementation of `_.has` without support for deep paths.
		     *
		     * @private
		     * @param {Object} [object] The object to query.
		     * @param {Array|string} key The key to check.
		     * @returns {boolean} Returns `true` if `key` exists, else `false`.
		     */
		    function baseHas(object, key) {
		      return object != null && hasOwnProperty.call(object, key);
		    }

		    /**
		     * The base implementation of `_.hasIn` without support for deep paths.
		     *
		     * @private
		     * @param {Object} [object] The object to query.
		     * @param {Array|string} key The key to check.
		     * @returns {boolean} Returns `true` if `key` exists, else `false`.
		     */
		    function baseHasIn(object, key) {
		      return object != null && key in Object(object);
		    }

		    /**
		     * The base implementation of `_.inRange` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {number} number The number to check.
		     * @param {number} start The start of the range.
		     * @param {number} end The end of the range.
		     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
		     */
		    function baseInRange(number, start, end) {
		      return number >= nativeMin(start, end) && number < nativeMax(start, end);
		    }

		    /**
		     * The base implementation of methods like `_.intersection`, without support
		     * for iteratee shorthands, that accepts an array of arrays to inspect.
		     *
		     * @private
		     * @param {Array} arrays The arrays to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of shared values.
		     */
		    function baseIntersection(arrays, iteratee, comparator) {
		      var includes = comparator ? arrayIncludesWith : arrayIncludes,
		          length = arrays[0].length,
		          othLength = arrays.length,
		          othIndex = othLength,
		          caches = Array(othLength),
		          maxLength = Infinity,
		          result = [];

		      while (othIndex--) {
		        var array = arrays[othIndex];
		        if (othIndex && iteratee) {
		          array = arrayMap(array, baseUnary(iteratee));
		        }
		        maxLength = nativeMin(array.length, maxLength);
		        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
		          ? new SetCache(othIndex && array)
		          : undefined$1;
		      }
		      array = arrays[0];

		      var index = -1,
		          seen = caches[0];

		      outer:
		      while (++index < length && result.length < maxLength) {
		        var value = array[index],
		            computed = iteratee ? iteratee(value) : value;

		        value = (comparator || value !== 0) ? value : 0;
		        if (!(seen
		              ? cacheHas(seen, computed)
		              : includes(result, computed, comparator)
		            )) {
		          othIndex = othLength;
		          while (--othIndex) {
		            var cache = caches[othIndex];
		            if (!(cache
		                  ? cacheHas(cache, computed)
		                  : includes(arrays[othIndex], computed, comparator))
		                ) {
		              continue outer;
		            }
		          }
		          if (seen) {
		            seen.push(computed);
		          }
		          result.push(value);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.invert` and `_.invertBy` which inverts
		     * `object` with values transformed by `iteratee` and set by `setter`.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} setter The function to set `accumulator` values.
		     * @param {Function} iteratee The iteratee to transform values.
		     * @param {Object} accumulator The initial inverted object.
		     * @returns {Function} Returns `accumulator`.
		     */
		    function baseInverter(object, setter, iteratee, accumulator) {
		      baseForOwn(object, function(value, key, object) {
		        setter(accumulator, iteratee(value), key, object);
		      });
		      return accumulator;
		    }

		    /**
		     * The base implementation of `_.invoke` without support for individual
		     * method arguments.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the method to invoke.
		     * @param {Array} args The arguments to invoke the method with.
		     * @returns {*} Returns the result of the invoked method.
		     */
		    function baseInvoke(object, path, args) {
		      path = castPath(path, object);
		      object = parent(object, path);
		      var func = object == null ? object : object[toKey(last(path))];
		      return func == null ? undefined$1 : apply(func, object, args);
		    }

		    /**
		     * The base implementation of `_.isArguments`.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
		     */
		    function baseIsArguments(value) {
		      return isObjectLike(value) && baseGetTag(value) == argsTag;
		    }

		    /**
		     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
		     */
		    function baseIsArrayBuffer(value) {
		      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
		    }

		    /**
		     * The base implementation of `_.isDate` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
		     */
		    function baseIsDate(value) {
		      return isObjectLike(value) && baseGetTag(value) == dateTag;
		    }

		    /**
		     * The base implementation of `_.isEqual` which supports partial comparisons
		     * and tracks traversed objects.
		     *
		     * @private
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @param {boolean} bitmask The bitmask flags.
		     *  1 - Unordered comparison
		     *  2 - Partial comparison
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     */
		    function baseIsEqual(value, other, bitmask, customizer, stack) {
		      if (value === other) {
		        return true;
		      }
		      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
		        return value !== value && other !== other;
		      }
		      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
		    }

		    /**
		     * A specialized version of `baseIsEqual` for arrays and objects which performs
		     * deep comparisons and tracks traversed objects enabling objects with circular
		     * references to be compared.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
		     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
		     */
		    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
		      var objIsArr = isArray(object),
		          othIsArr = isArray(other),
		          objTag = objIsArr ? arrayTag : getTag(object),
		          othTag = othIsArr ? arrayTag : getTag(other);

		      objTag = objTag == argsTag ? objectTag : objTag;
		      othTag = othTag == argsTag ? objectTag : othTag;

		      var objIsObj = objTag == objectTag,
		          othIsObj = othTag == objectTag,
		          isSameTag = objTag == othTag;

		      if (isSameTag && isBuffer(object)) {
		        if (!isBuffer(other)) {
		          return false;
		        }
		        objIsArr = true;
		        objIsObj = false;
		      }
		      if (isSameTag && !objIsObj) {
		        stack || (stack = new Stack);
		        return (objIsArr || isTypedArray(object))
		          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
		          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
		      }
		      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
		        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
		            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

		        if (objIsWrapped || othIsWrapped) {
		          var objUnwrapped = objIsWrapped ? object.value() : object,
		              othUnwrapped = othIsWrapped ? other.value() : other;

		          stack || (stack = new Stack);
		          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
		        }
		      }
		      if (!isSameTag) {
		        return false;
		      }
		      stack || (stack = new Stack);
		      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
		    }

		    /**
		     * The base implementation of `_.isMap` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
		     */
		    function baseIsMap(value) {
		      return isObjectLike(value) && getTag(value) == mapTag;
		    }

		    /**
		     * The base implementation of `_.isMatch` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property values to match.
		     * @param {Array} matchData The property names, values, and compare flags to match.
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
		     */
		    function baseIsMatch(object, source, matchData, customizer) {
		      var index = matchData.length,
		          length = index,
		          noCustomizer = !customizer;

		      if (object == null) {
		        return !length;
		      }
		      object = Object(object);
		      while (index--) {
		        var data = matchData[index];
		        if ((noCustomizer && data[2])
		              ? data[1] !== object[data[0]]
		              : !(data[0] in object)
		            ) {
		          return false;
		        }
		      }
		      while (++index < length) {
		        data = matchData[index];
		        var key = data[0],
		            objValue = object[key],
		            srcValue = data[1];

		        if (noCustomizer && data[2]) {
		          if (objValue === undefined$1 && !(key in object)) {
		            return false;
		          }
		        } else {
		          var stack = new Stack;
		          if (customizer) {
		            var result = customizer(objValue, srcValue, key, object, source, stack);
		          }
		          if (!(result === undefined$1
		                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
		                : result
		              )) {
		            return false;
		          }
		        }
		      }
		      return true;
		    }

		    /**
		     * The base implementation of `_.isNative` without bad shim checks.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a native function,
		     *  else `false`.
		     */
		    function baseIsNative(value) {
		      if (!isObject(value) || isMasked(value)) {
		        return false;
		      }
		      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
		      return pattern.test(toSource(value));
		    }

		    /**
		     * The base implementation of `_.isRegExp` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
		     */
		    function baseIsRegExp(value) {
		      return isObjectLike(value) && baseGetTag(value) == regexpTag;
		    }

		    /**
		     * The base implementation of `_.isSet` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
		     */
		    function baseIsSet(value) {
		      return isObjectLike(value) && getTag(value) == setTag;
		    }

		    /**
		     * The base implementation of `_.isTypedArray` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
		     */
		    function baseIsTypedArray(value) {
		      return isObjectLike(value) &&
		        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
		    }

		    /**
		     * The base implementation of `_.iteratee`.
		     *
		     * @private
		     * @param {*} [value=_.identity] The value to convert to an iteratee.
		     * @returns {Function} Returns the iteratee.
		     */
		    function baseIteratee(value) {
		      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
		      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
		      if (typeof value == 'function') {
		        return value;
		      }
		      if (value == null) {
		        return identity;
		      }
		      if (typeof value == 'object') {
		        return isArray(value)
		          ? baseMatchesProperty(value[0], value[1])
		          : baseMatches(value);
		      }
		      return property(value);
		    }

		    /**
		     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     */
		    function baseKeys(object) {
		      if (!isPrototype(object)) {
		        return nativeKeys(object);
		      }
		      var result = [];
		      for (var key in Object(object)) {
		        if (hasOwnProperty.call(object, key) && key != 'constructor') {
		          result.push(key);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     */
		    function baseKeysIn(object) {
		      if (!isObject(object)) {
		        return nativeKeysIn(object);
		      }
		      var isProto = isPrototype(object),
		          result = [];

		      for (var key in object) {
		        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
		          result.push(key);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.lt` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is less than `other`,
		     *  else `false`.
		     */
		    function baseLt(value, other) {
		      return value < other;
		    }

		    /**
		     * The base implementation of `_.map` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Array} Returns the new mapped array.
		     */
		    function baseMap(collection, iteratee) {
		      var index = -1,
		          result = isArrayLike(collection) ? Array(collection.length) : [];

		      baseEach(collection, function(value, key, collection) {
		        result[++index] = iteratee(value, key, collection);
		      });
		      return result;
		    }

		    /**
		     * The base implementation of `_.matches` which doesn't clone `source`.
		     *
		     * @private
		     * @param {Object} source The object of property values to match.
		     * @returns {Function} Returns the new spec function.
		     */
		    function baseMatches(source) {
		      var matchData = getMatchData(source);
		      if (matchData.length == 1 && matchData[0][2]) {
		        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
		      }
		      return function(object) {
		        return object === source || baseIsMatch(object, source, matchData);
		      };
		    }

		    /**
		     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
		     *
		     * @private
		     * @param {string} path The path of the property to get.
		     * @param {*} srcValue The value to match.
		     * @returns {Function} Returns the new spec function.
		     */
		    function baseMatchesProperty(path, srcValue) {
		      if (isKey(path) && isStrictComparable(srcValue)) {
		        return matchesStrictComparable(toKey(path), srcValue);
		      }
		      return function(object) {
		        var objValue = get(object, path);
		        return (objValue === undefined$1 && objValue === srcValue)
		          ? hasIn(object, path)
		          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
		      };
		    }

		    /**
		     * The base implementation of `_.merge` without support for multiple sources.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @param {number} srcIndex The index of `source`.
		     * @param {Function} [customizer] The function to customize merged values.
		     * @param {Object} [stack] Tracks traversed source values and their merged
		     *  counterparts.
		     */
		    function baseMerge(object, source, srcIndex, customizer, stack) {
		      if (object === source) {
		        return;
		      }
		      baseFor(source, function(srcValue, key) {
		        stack || (stack = new Stack);
		        if (isObject(srcValue)) {
		          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
		        }
		        else {
		          var newValue = customizer
		            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
		            : undefined$1;

		          if (newValue === undefined$1) {
		            newValue = srcValue;
		          }
		          assignMergeValue(object, key, newValue);
		        }
		      }, keysIn);
		    }

		    /**
		     * A specialized version of `baseMerge` for arrays and objects which performs
		     * deep merges and tracks traversed objects enabling objects with circular
		     * references to be merged.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @param {string} key The key of the value to merge.
		     * @param {number} srcIndex The index of `source`.
		     * @param {Function} mergeFunc The function to merge values.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @param {Object} [stack] Tracks traversed source values and their merged
		     *  counterparts.
		     */
		    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
		      var objValue = safeGet(object, key),
		          srcValue = safeGet(source, key),
		          stacked = stack.get(srcValue);

		      if (stacked) {
		        assignMergeValue(object, key, stacked);
		        return;
		      }
		      var newValue = customizer
		        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
		        : undefined$1;

		      var isCommon = newValue === undefined$1;

		      if (isCommon) {
		        var isArr = isArray(srcValue),
		            isBuff = !isArr && isBuffer(srcValue),
		            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

		        newValue = srcValue;
		        if (isArr || isBuff || isTyped) {
		          if (isArray(objValue)) {
		            newValue = objValue;
		          }
		          else if (isArrayLikeObject(objValue)) {
		            newValue = copyArray(objValue);
		          }
		          else if (isBuff) {
		            isCommon = false;
		            newValue = cloneBuffer(srcValue, true);
		          }
		          else if (isTyped) {
		            isCommon = false;
		            newValue = cloneTypedArray(srcValue, true);
		          }
		          else {
		            newValue = [];
		          }
		        }
		        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
		          newValue = objValue;
		          if (isArguments(objValue)) {
		            newValue = toPlainObject(objValue);
		          }
		          else if (!isObject(objValue) || isFunction(objValue)) {
		            newValue = initCloneObject(srcValue);
		          }
		        }
		        else {
		          isCommon = false;
		        }
		      }
		      if (isCommon) {
		        // Recursively merge objects and arrays (susceptible to call stack limits).
		        stack.set(srcValue, newValue);
		        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
		        stack['delete'](srcValue);
		      }
		      assignMergeValue(object, key, newValue);
		    }

		    /**
		     * The base implementation of `_.nth` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {Array} array The array to query.
		     * @param {number} n The index of the element to return.
		     * @returns {*} Returns the nth element of `array`.
		     */
		    function baseNth(array, n) {
		      var length = array.length;
		      if (!length) {
		        return;
		      }
		      n += n < 0 ? length : 0;
		      return isIndex(n, length) ? array[n] : undefined$1;
		    }

		    /**
		     * The base implementation of `_.orderBy` without param guards.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
		     * @param {string[]} orders The sort orders of `iteratees`.
		     * @returns {Array} Returns the new sorted array.
		     */
		    function baseOrderBy(collection, iteratees, orders) {
		      if (iteratees.length) {
		        iteratees = arrayMap(iteratees, function(iteratee) {
		          if (isArray(iteratee)) {
		            return function(value) {
		              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
		            }
		          }
		          return iteratee;
		        });
		      } else {
		        iteratees = [identity];
		      }

		      var index = -1;
		      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

		      var result = baseMap(collection, function(value, key, collection) {
		        var criteria = arrayMap(iteratees, function(iteratee) {
		          return iteratee(value);
		        });
		        return { 'criteria': criteria, 'index': ++index, 'value': value };
		      });

		      return baseSortBy(result, function(object, other) {
		        return compareMultiple(object, other, orders);
		      });
		    }

		    /**
		     * The base implementation of `_.pick` without support for individual
		     * property identifiers.
		     *
		     * @private
		     * @param {Object} object The source object.
		     * @param {string[]} paths The property paths to pick.
		     * @returns {Object} Returns the new object.
		     */
		    function basePick(object, paths) {
		      return basePickBy(object, paths, function(value, path) {
		        return hasIn(object, path);
		      });
		    }

		    /**
		     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The source object.
		     * @param {string[]} paths The property paths to pick.
		     * @param {Function} predicate The function invoked per property.
		     * @returns {Object} Returns the new object.
		     */
		    function basePickBy(object, paths, predicate) {
		      var index = -1,
		          length = paths.length,
		          result = {};

		      while (++index < length) {
		        var path = paths[index],
		            value = baseGet(object, path);

		        if (predicate(value, path)) {
		          baseSet(result, castPath(path, object), value);
		        }
		      }
		      return result;
		    }

		    /**
		     * A specialized version of `baseProperty` which supports deep paths.
		     *
		     * @private
		     * @param {Array|string} path The path of the property to get.
		     * @returns {Function} Returns the new accessor function.
		     */
		    function basePropertyDeep(path) {
		      return function(object) {
		        return baseGet(object, path);
		      };
		    }

		    /**
		     * The base implementation of `_.pullAllBy` without support for iteratee
		     * shorthands.
		     *
		     * @private
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns `array`.
		     */
		    function basePullAll(array, values, iteratee, comparator) {
		      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
		          index = -1,
		          length = values.length,
		          seen = array;

		      if (array === values) {
		        values = copyArray(values);
		      }
		      if (iteratee) {
		        seen = arrayMap(array, baseUnary(iteratee));
		      }
		      while (++index < length) {
		        var fromIndex = 0,
		            value = values[index],
		            computed = iteratee ? iteratee(value) : value;

		        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
		          if (seen !== array) {
		            splice.call(seen, fromIndex, 1);
		          }
		          splice.call(array, fromIndex, 1);
		        }
		      }
		      return array;
		    }

		    /**
		     * The base implementation of `_.pullAt` without support for individual
		     * indexes or capturing the removed elements.
		     *
		     * @private
		     * @param {Array} array The array to modify.
		     * @param {number[]} indexes The indexes of elements to remove.
		     * @returns {Array} Returns `array`.
		     */
		    function basePullAt(array, indexes) {
		      var length = array ? indexes.length : 0,
		          lastIndex = length - 1;

		      while (length--) {
		        var index = indexes[length];
		        if (length == lastIndex || index !== previous) {
		          var previous = index;
		          if (isIndex(index)) {
		            splice.call(array, index, 1);
		          } else {
		            baseUnset(array, index);
		          }
		        }
		      }
		      return array;
		    }

		    /**
		     * The base implementation of `_.random` without support for returning
		     * floating-point numbers.
		     *
		     * @private
		     * @param {number} lower The lower bound.
		     * @param {number} upper The upper bound.
		     * @returns {number} Returns the random number.
		     */
		    function baseRandom(lower, upper) {
		      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
		    }

		    /**
		     * The base implementation of `_.range` and `_.rangeRight` which doesn't
		     * coerce arguments.
		     *
		     * @private
		     * @param {number} start The start of the range.
		     * @param {number} end The end of the range.
		     * @param {number} step The value to increment or decrement by.
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Array} Returns the range of numbers.
		     */
		    function baseRange(start, end, step, fromRight) {
		      var index = -1,
		          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
		          result = Array(length);

		      while (length--) {
		        result[fromRight ? length : ++index] = start;
		        start += step;
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.repeat` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {string} string The string to repeat.
		     * @param {number} n The number of times to repeat the string.
		     * @returns {string} Returns the repeated string.
		     */
		    function baseRepeat(string, n) {
		      var result = '';
		      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
		        return result;
		      }
		      // Leverage the exponentiation by squaring algorithm for a faster repeat.
		      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
		      do {
		        if (n % 2) {
		          result += string;
		        }
		        n = nativeFloor(n / 2);
		        if (n) {
		          string += string;
		        }
		      } while (n);

		      return result;
		    }

		    /**
		     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
		     *
		     * @private
		     * @param {Function} func The function to apply a rest parameter to.
		     * @param {number} [start=func.length-1] The start position of the rest parameter.
		     * @returns {Function} Returns the new function.
		     */
		    function baseRest(func, start) {
		      return setToString(overRest(func, start, identity), func + '');
		    }

		    /**
		     * The base implementation of `_.sample`.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to sample.
		     * @returns {*} Returns the random element.
		     */
		    function baseSample(collection) {
		      return arraySample(values(collection));
		    }

		    /**
		     * The base implementation of `_.sampleSize` without param guards.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to sample.
		     * @param {number} n The number of elements to sample.
		     * @returns {Array} Returns the random elements.
		     */
		    function baseSampleSize(collection, n) {
		      var array = values(collection);
		      return shuffleSelf(array, baseClamp(n, 0, array.length));
		    }

		    /**
		     * The base implementation of `_.set`.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {*} value The value to set.
		     * @param {Function} [customizer] The function to customize path creation.
		     * @returns {Object} Returns `object`.
		     */
		    function baseSet(object, path, value, customizer) {
		      if (!isObject(object)) {
		        return object;
		      }
		      path = castPath(path, object);

		      var index = -1,
		          length = path.length,
		          lastIndex = length - 1,
		          nested = object;

		      while (nested != null && ++index < length) {
		        var key = toKey(path[index]),
		            newValue = value;

		        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
		          return object;
		        }

		        if (index != lastIndex) {
		          var objValue = nested[key];
		          newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
		          if (newValue === undefined$1) {
		            newValue = isObject(objValue)
		              ? objValue
		              : (isIndex(path[index + 1]) ? [] : {});
		          }
		        }
		        assignValue(nested, key, newValue);
		        nested = nested[key];
		      }
		      return object;
		    }

		    /**
		     * The base implementation of `setData` without support for hot loop shorting.
		     *
		     * @private
		     * @param {Function} func The function to associate metadata with.
		     * @param {*} data The metadata.
		     * @returns {Function} Returns `func`.
		     */
		    var baseSetData = !metaMap ? identity : function(func, data) {
		      metaMap.set(func, data);
		      return func;
		    };

		    /**
		     * The base implementation of `setToString` without support for hot loop shorting.
		     *
		     * @private
		     * @param {Function} func The function to modify.
		     * @param {Function} string The `toString` result.
		     * @returns {Function} Returns `func`.
		     */
		    var baseSetToString = !defineProperty ? identity : function(func, string) {
		      return defineProperty(func, 'toString', {
		        'configurable': true,
		        'enumerable': false,
		        'value': constant(string),
		        'writable': true
		      });
		    };

		    /**
		     * The base implementation of `_.shuffle`.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to shuffle.
		     * @returns {Array} Returns the new shuffled array.
		     */
		    function baseShuffle(collection) {
		      return shuffleSelf(values(collection));
		    }

		    /**
		     * The base implementation of `_.slice` without an iteratee call guard.
		     *
		     * @private
		     * @param {Array} array The array to slice.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns the slice of `array`.
		     */
		    function baseSlice(array, start, end) {
		      var index = -1,
		          length = array.length;

		      if (start < 0) {
		        start = -start > length ? 0 : (length + start);
		      }
		      end = end > length ? length : end;
		      if (end < 0) {
		        end += length;
		      }
		      length = start > end ? 0 : ((end - start) >>> 0);
		      start >>>= 0;

		      var result = Array(length);
		      while (++index < length) {
		        result[index] = array[index + start];
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.some` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} predicate The function invoked per iteration.
		     * @returns {boolean} Returns `true` if any element passes the predicate check,
		     *  else `false`.
		     */
		    function baseSome(collection, predicate) {
		      var result;

		      baseEach(collection, function(value, index, collection) {
		        result = predicate(value, index, collection);
		        return !result;
		      });
		      return !!result;
		    }

		    /**
		     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
		     * performs a binary search of `array` to determine the index at which `value`
		     * should be inserted into `array` in order to maintain its sort order.
		     *
		     * @private
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {boolean} [retHighest] Specify returning the highest qualified index.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     */
		    function baseSortedIndex(array, value, retHighest) {
		      var low = 0,
		          high = array == null ? low : array.length;

		      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
		        while (low < high) {
		          var mid = (low + high) >>> 1,
		              computed = array[mid];

		          if (computed !== null && !isSymbol(computed) &&
		              (retHighest ? (computed <= value) : (computed < value))) {
		            low = mid + 1;
		          } else {
		            high = mid;
		          }
		        }
		        return high;
		      }
		      return baseSortedIndexBy(array, value, identity, retHighest);
		    }

		    /**
		     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
		     * which invokes `iteratee` for `value` and each element of `array` to compute
		     * their sort ranking. The iteratee is invoked with one argument; (value).
		     *
		     * @private
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {Function} iteratee The iteratee invoked per element.
		     * @param {boolean} [retHighest] Specify returning the highest qualified index.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     */
		    function baseSortedIndexBy(array, value, iteratee, retHighest) {
		      var low = 0,
		          high = array == null ? 0 : array.length;
		      if (high === 0) {
		        return 0;
		      }

		      value = iteratee(value);
		      var valIsNaN = value !== value,
		          valIsNull = value === null,
		          valIsSymbol = isSymbol(value),
		          valIsUndefined = value === undefined$1;

		      while (low < high) {
		        var mid = nativeFloor((low + high) / 2),
		            computed = iteratee(array[mid]),
		            othIsDefined = computed !== undefined$1,
		            othIsNull = computed === null,
		            othIsReflexive = computed === computed,
		            othIsSymbol = isSymbol(computed);

		        if (valIsNaN) {
		          var setLow = retHighest || othIsReflexive;
		        } else if (valIsUndefined) {
		          setLow = othIsReflexive && (retHighest || othIsDefined);
		        } else if (valIsNull) {
		          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
		        } else if (valIsSymbol) {
		          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
		        } else if (othIsNull || othIsSymbol) {
		          setLow = false;
		        } else {
		          setLow = retHighest ? (computed <= value) : (computed < value);
		        }
		        if (setLow) {
		          low = mid + 1;
		        } else {
		          high = mid;
		        }
		      }
		      return nativeMin(high, MAX_ARRAY_INDEX);
		    }

		    /**
		     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
		     * support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     */
		    function baseSortedUniq(array, iteratee) {
		      var index = -1,
		          length = array.length,
		          resIndex = 0,
		          result = [];

		      while (++index < length) {
		        var value = array[index],
		            computed = iteratee ? iteratee(value) : value;

		        if (!index || !eq(computed, seen)) {
		          var seen = computed;
		          result[resIndex++] = value === 0 ? 0 : value;
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.toNumber` which doesn't ensure correct
		     * conversions of binary, hexadecimal, or octal string values.
		     *
		     * @private
		     * @param {*} value The value to process.
		     * @returns {number} Returns the number.
		     */
		    function baseToNumber(value) {
		      if (typeof value == 'number') {
		        return value;
		      }
		      if (isSymbol(value)) {
		        return NAN;
		      }
		      return +value;
		    }

		    /**
		     * The base implementation of `_.toString` which doesn't convert nullish
		     * values to empty strings.
		     *
		     * @private
		     * @param {*} value The value to process.
		     * @returns {string} Returns the string.
		     */
		    function baseToString(value) {
		      // Exit early for strings to avoid a performance hit in some environments.
		      if (typeof value == 'string') {
		        return value;
		      }
		      if (isArray(value)) {
		        // Recursively convert values (susceptible to call stack limits).
		        return arrayMap(value, baseToString) + '';
		      }
		      if (isSymbol(value)) {
		        return symbolToString ? symbolToString.call(value) : '';
		      }
		      var result = (value + '');
		      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
		    }

		    /**
		     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     */
		    function baseUniq(array, iteratee, comparator) {
		      var index = -1,
		          includes = arrayIncludes,
		          length = array.length,
		          isCommon = true,
		          result = [],
		          seen = result;

		      if (comparator) {
		        isCommon = false;
		        includes = arrayIncludesWith;
		      }
		      else if (length >= LARGE_ARRAY_SIZE) {
		        var set = iteratee ? null : createSet(array);
		        if (set) {
		          return setToArray(set);
		        }
		        isCommon = false;
		        includes = cacheHas;
		        seen = new SetCache;
		      }
		      else {
		        seen = iteratee ? [] : result;
		      }
		      outer:
		      while (++index < length) {
		        var value = array[index],
		            computed = iteratee ? iteratee(value) : value;

		        value = (comparator || value !== 0) ? value : 0;
		        if (isCommon && computed === computed) {
		          var seenIndex = seen.length;
		          while (seenIndex--) {
		            if (seen[seenIndex] === computed) {
		              continue outer;
		            }
		          }
		          if (iteratee) {
		            seen.push(computed);
		          }
		          result.push(value);
		        }
		        else if (!includes(seen, computed, comparator)) {
		          if (seen !== result) {
		            seen.push(computed);
		          }
		          result.push(value);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.unset`.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The property path to unset.
		     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
		     */
		    function baseUnset(object, path) {
		      path = castPath(path, object);
		      object = parent(object, path);
		      return object == null || delete object[toKey(last(path))];
		    }

		    /**
		     * The base implementation of `_.update`.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to update.
		     * @param {Function} updater The function to produce the updated value.
		     * @param {Function} [customizer] The function to customize path creation.
		     * @returns {Object} Returns `object`.
		     */
		    function baseUpdate(object, path, updater, customizer) {
		      return baseSet(object, path, updater(baseGet(object, path)), customizer);
		    }

		    /**
		     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
		     * without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to query.
		     * @param {Function} predicate The function invoked per iteration.
		     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Array} Returns the slice of `array`.
		     */
		    function baseWhile(array, predicate, isDrop, fromRight) {
		      var length = array.length,
		          index = fromRight ? length : -1;

		      while ((fromRight ? index-- : ++index < length) &&
		        predicate(array[index], index, array)) {}

		      return isDrop
		        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
		        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
		    }

		    /**
		     * The base implementation of `wrapperValue` which returns the result of
		     * performing a sequence of actions on the unwrapped `value`, where each
		     * successive action is supplied the return value of the previous.
		     *
		     * @private
		     * @param {*} value The unwrapped value.
		     * @param {Array} actions Actions to perform to resolve the unwrapped value.
		     * @returns {*} Returns the resolved value.
		     */
		    function baseWrapperValue(value, actions) {
		      var result = value;
		      if (result instanceof LazyWrapper) {
		        result = result.value();
		      }
		      return arrayReduce(actions, function(result, action) {
		        return action.func.apply(action.thisArg, arrayPush([result], action.args));
		      }, result);
		    }

		    /**
		     * The base implementation of methods like `_.xor`, without support for
		     * iteratee shorthands, that accepts an array of arrays to inspect.
		     *
		     * @private
		     * @param {Array} arrays The arrays to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of values.
		     */
		    function baseXor(arrays, iteratee, comparator) {
		      var length = arrays.length;
		      if (length < 2) {
		        return length ? baseUniq(arrays[0]) : [];
		      }
		      var index = -1,
		          result = Array(length);

		      while (++index < length) {
		        var array = arrays[index],
		            othIndex = -1;

		        while (++othIndex < length) {
		          if (othIndex != index) {
		            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
		          }
		        }
		      }
		      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
		    }

		    /**
		     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
		     *
		     * @private
		     * @param {Array} props The property identifiers.
		     * @param {Array} values The property values.
		     * @param {Function} assignFunc The function to assign values.
		     * @returns {Object} Returns the new object.
		     */
		    function baseZipObject(props, values, assignFunc) {
		      var index = -1,
		          length = props.length,
		          valsLength = values.length,
		          result = {};

		      while (++index < length) {
		        var value = index < valsLength ? values[index] : undefined$1;
		        assignFunc(result, props[index], value);
		      }
		      return result;
		    }

		    /**
		     * Casts `value` to an empty array if it's not an array like object.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @returns {Array|Object} Returns the cast array-like object.
		     */
		    function castArrayLikeObject(value) {
		      return isArrayLikeObject(value) ? value : [];
		    }

		    /**
		     * Casts `value` to `identity` if it's not a function.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @returns {Function} Returns cast function.
		     */
		    function castFunction(value) {
		      return typeof value == 'function' ? value : identity;
		    }

		    /**
		     * Casts `value` to a path array if it's not one.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @param {Object} [object] The object to query keys on.
		     * @returns {Array} Returns the cast property path array.
		     */
		    function castPath(value, object) {
		      if (isArray(value)) {
		        return value;
		      }
		      return isKey(value, object) ? [value] : stringToPath(toString(value));
		    }

		    /**
		     * A `baseRest` alias which can be replaced with `identity` by module
		     * replacement plugins.
		     *
		     * @private
		     * @type {Function}
		     * @param {Function} func The function to apply a rest parameter to.
		     * @returns {Function} Returns the new function.
		     */
		    var castRest = baseRest;

		    /**
		     * Casts `array` to a slice if it's needed.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {number} start The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns the cast slice.
		     */
		    function castSlice(array, start, end) {
		      var length = array.length;
		      end = end === undefined$1 ? length : end;
		      return (!start && end >= length) ? array : baseSlice(array, start, end);
		    }

		    /**
		     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
		     *
		     * @private
		     * @param {number|Object} id The timer id or timeout object of the timer to clear.
		     */
		    var clearTimeout = ctxClearTimeout || function(id) {
		      return root.clearTimeout(id);
		    };

		    /**
		     * Creates a clone of  `buffer`.
		     *
		     * @private
		     * @param {Buffer} buffer The buffer to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Buffer} Returns the cloned buffer.
		     */
		    function cloneBuffer(buffer, isDeep) {
		      if (isDeep) {
		        return buffer.slice();
		      }
		      var length = buffer.length,
		          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

		      buffer.copy(result);
		      return result;
		    }

		    /**
		     * Creates a clone of `arrayBuffer`.
		     *
		     * @private
		     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
		     * @returns {ArrayBuffer} Returns the cloned array buffer.
		     */
		    function cloneArrayBuffer(arrayBuffer) {
		      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
		      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
		      return result;
		    }

		    /**
		     * Creates a clone of `dataView`.
		     *
		     * @private
		     * @param {Object} dataView The data view to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Object} Returns the cloned data view.
		     */
		    function cloneDataView(dataView, isDeep) {
		      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
		      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
		    }

		    /**
		     * Creates a clone of `regexp`.
		     *
		     * @private
		     * @param {Object} regexp The regexp to clone.
		     * @returns {Object} Returns the cloned regexp.
		     */
		    function cloneRegExp(regexp) {
		      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
		      result.lastIndex = regexp.lastIndex;
		      return result;
		    }

		    /**
		     * Creates a clone of the `symbol` object.
		     *
		     * @private
		     * @param {Object} symbol The symbol object to clone.
		     * @returns {Object} Returns the cloned symbol object.
		     */
		    function cloneSymbol(symbol) {
		      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
		    }

		    /**
		     * Creates a clone of `typedArray`.
		     *
		     * @private
		     * @param {Object} typedArray The typed array to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Object} Returns the cloned typed array.
		     */
		    function cloneTypedArray(typedArray, isDeep) {
		      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
		      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
		    }

		    /**
		     * Compares values to sort them in ascending order.
		     *
		     * @private
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {number} Returns the sort order indicator for `value`.
		     */
		    function compareAscending(value, other) {
		      if (value !== other) {
		        var valIsDefined = value !== undefined$1,
		            valIsNull = value === null,
		            valIsReflexive = value === value,
		            valIsSymbol = isSymbol(value);

		        var othIsDefined = other !== undefined$1,
		            othIsNull = other === null,
		            othIsReflexive = other === other,
		            othIsSymbol = isSymbol(other);

		        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
		            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
		            (valIsNull && othIsDefined && othIsReflexive) ||
		            (!valIsDefined && othIsReflexive) ||
		            !valIsReflexive) {
		          return 1;
		        }
		        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
		            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
		            (othIsNull && valIsDefined && valIsReflexive) ||
		            (!othIsDefined && valIsReflexive) ||
		            !othIsReflexive) {
		          return -1;
		        }
		      }
		      return 0;
		    }

		    /**
		     * Used by `_.orderBy` to compare multiple properties of a value to another
		     * and stable sort them.
		     *
		     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
		     * specify an order of "desc" for descending or "asc" for ascending sort order
		     * of corresponding values.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {boolean[]|string[]} orders The order to sort by for each property.
		     * @returns {number} Returns the sort order indicator for `object`.
		     */
		    function compareMultiple(object, other, orders) {
		      var index = -1,
		          objCriteria = object.criteria,
		          othCriteria = other.criteria,
		          length = objCriteria.length,
		          ordersLength = orders.length;

		      while (++index < length) {
		        var result = compareAscending(objCriteria[index], othCriteria[index]);
		        if (result) {
		          if (index >= ordersLength) {
		            return result;
		          }
		          var order = orders[index];
		          return result * (order == 'desc' ? -1 : 1);
		        }
		      }
		      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
		      // that causes it, under certain circumstances, to provide the same value for
		      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
		      // for more details.
		      //
		      // This also ensures a stable sort in V8 and other engines.
		      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
		      return object.index - other.index;
		    }

		    /**
		     * Creates an array that is the composition of partially applied arguments,
		     * placeholders, and provided arguments into a single array of arguments.
		     *
		     * @private
		     * @param {Array} args The provided arguments.
		     * @param {Array} partials The arguments to prepend to those provided.
		     * @param {Array} holders The `partials` placeholder indexes.
		     * @params {boolean} [isCurried] Specify composing for a curried function.
		     * @returns {Array} Returns the new array of composed arguments.
		     */
		    function composeArgs(args, partials, holders, isCurried) {
		      var argsIndex = -1,
		          argsLength = args.length,
		          holdersLength = holders.length,
		          leftIndex = -1,
		          leftLength = partials.length,
		          rangeLength = nativeMax(argsLength - holdersLength, 0),
		          result = Array(leftLength + rangeLength),
		          isUncurried = !isCurried;

		      while (++leftIndex < leftLength) {
		        result[leftIndex] = partials[leftIndex];
		      }
		      while (++argsIndex < holdersLength) {
		        if (isUncurried || argsIndex < argsLength) {
		          result[holders[argsIndex]] = args[argsIndex];
		        }
		      }
		      while (rangeLength--) {
		        result[leftIndex++] = args[argsIndex++];
		      }
		      return result;
		    }

		    /**
		     * This function is like `composeArgs` except that the arguments composition
		     * is tailored for `_.partialRight`.
		     *
		     * @private
		     * @param {Array} args The provided arguments.
		     * @param {Array} partials The arguments to append to those provided.
		     * @param {Array} holders The `partials` placeholder indexes.
		     * @params {boolean} [isCurried] Specify composing for a curried function.
		     * @returns {Array} Returns the new array of composed arguments.
		     */
		    function composeArgsRight(args, partials, holders, isCurried) {
		      var argsIndex = -1,
		          argsLength = args.length,
		          holdersIndex = -1,
		          holdersLength = holders.length,
		          rightIndex = -1,
		          rightLength = partials.length,
		          rangeLength = nativeMax(argsLength - holdersLength, 0),
		          result = Array(rangeLength + rightLength),
		          isUncurried = !isCurried;

		      while (++argsIndex < rangeLength) {
		        result[argsIndex] = args[argsIndex];
		      }
		      var offset = argsIndex;
		      while (++rightIndex < rightLength) {
		        result[offset + rightIndex] = partials[rightIndex];
		      }
		      while (++holdersIndex < holdersLength) {
		        if (isUncurried || argsIndex < argsLength) {
		          result[offset + holders[holdersIndex]] = args[argsIndex++];
		        }
		      }
		      return result;
		    }

		    /**
		     * Copies the values of `source` to `array`.
		     *
		     * @private
		     * @param {Array} source The array to copy values from.
		     * @param {Array} [array=[]] The array to copy values to.
		     * @returns {Array} Returns `array`.
		     */
		    function copyArray(source, array) {
		      var index = -1,
		          length = source.length;

		      array || (array = Array(length));
		      while (++index < length) {
		        array[index] = source[index];
		      }
		      return array;
		    }

		    /**
		     * Copies properties of `source` to `object`.
		     *
		     * @private
		     * @param {Object} source The object to copy properties from.
		     * @param {Array} props The property identifiers to copy.
		     * @param {Object} [object={}] The object to copy properties to.
		     * @param {Function} [customizer] The function to customize copied values.
		     * @returns {Object} Returns `object`.
		     */
		    function copyObject(source, props, object, customizer) {
		      var isNew = !object;
		      object || (object = {});

		      var index = -1,
		          length = props.length;

		      while (++index < length) {
		        var key = props[index];

		        var newValue = customizer
		          ? customizer(object[key], source[key], key, object, source)
		          : undefined$1;

		        if (newValue === undefined$1) {
		          newValue = source[key];
		        }
		        if (isNew) {
		          baseAssignValue(object, key, newValue);
		        } else {
		          assignValue(object, key, newValue);
		        }
		      }
		      return object;
		    }

		    /**
		     * Copies own symbols of `source` to `object`.
		     *
		     * @private
		     * @param {Object} source The object to copy symbols from.
		     * @param {Object} [object={}] The object to copy symbols to.
		     * @returns {Object} Returns `object`.
		     */
		    function copySymbols(source, object) {
		      return copyObject(source, getSymbols(source), object);
		    }

		    /**
		     * Copies own and inherited symbols of `source` to `object`.
		     *
		     * @private
		     * @param {Object} source The object to copy symbols from.
		     * @param {Object} [object={}] The object to copy symbols to.
		     * @returns {Object} Returns `object`.
		     */
		    function copySymbolsIn(source, object) {
		      return copyObject(source, getSymbolsIn(source), object);
		    }

		    /**
		     * Creates a function like `_.groupBy`.
		     *
		     * @private
		     * @param {Function} setter The function to set accumulator values.
		     * @param {Function} [initializer] The accumulator object initializer.
		     * @returns {Function} Returns the new aggregator function.
		     */
		    function createAggregator(setter, initializer) {
		      return function(collection, iteratee) {
		        var func = isArray(collection) ? arrayAggregator : baseAggregator,
		            accumulator = initializer ? initializer() : {};

		        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
		      };
		    }

		    /**
		     * Creates a function like `_.assign`.
		     *
		     * @private
		     * @param {Function} assigner The function to assign values.
		     * @returns {Function} Returns the new assigner function.
		     */
		    function createAssigner(assigner) {
		      return baseRest(function(object, sources) {
		        var index = -1,
		            length = sources.length,
		            customizer = length > 1 ? sources[length - 1] : undefined$1,
		            guard = length > 2 ? sources[2] : undefined$1;

		        customizer = (assigner.length > 3 && typeof customizer == 'function')
		          ? (length--, customizer)
		          : undefined$1;

		        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
		          customizer = length < 3 ? undefined$1 : customizer;
		          length = 1;
		        }
		        object = Object(object);
		        while (++index < length) {
		          var source = sources[index];
		          if (source) {
		            assigner(object, source, index, customizer);
		          }
		        }
		        return object;
		      });
		    }

		    /**
		     * Creates a `baseEach` or `baseEachRight` function.
		     *
		     * @private
		     * @param {Function} eachFunc The function to iterate over a collection.
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new base function.
		     */
		    function createBaseEach(eachFunc, fromRight) {
		      return function(collection, iteratee) {
		        if (collection == null) {
		          return collection;
		        }
		        if (!isArrayLike(collection)) {
		          return eachFunc(collection, iteratee);
		        }
		        var length = collection.length,
		            index = fromRight ? length : -1,
		            iterable = Object(collection);

		        while ((fromRight ? index-- : ++index < length)) {
		          if (iteratee(iterable[index], index, iterable) === false) {
		            break;
		          }
		        }
		        return collection;
		      };
		    }

		    /**
		     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
		     *
		     * @private
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new base function.
		     */
		    function createBaseFor(fromRight) {
		      return function(object, iteratee, keysFunc) {
		        var index = -1,
		            iterable = Object(object),
		            props = keysFunc(object),
		            length = props.length;

		        while (length--) {
		          var key = props[fromRight ? length : ++index];
		          if (iteratee(iterable[key], key, iterable) === false) {
		            break;
		          }
		        }
		        return object;
		      };
		    }

		    /**
		     * Creates a function that wraps `func` to invoke it with the optional `this`
		     * binding of `thisArg`.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createBind(func, bitmask, thisArg) {
		      var isBind = bitmask & WRAP_BIND_FLAG,
		          Ctor = createCtor(func);

		      function wrapper() {
		        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
		        return fn.apply(isBind ? thisArg : this, arguments);
		      }
		      return wrapper;
		    }

		    /**
		     * Creates a function like `_.lowerFirst`.
		     *
		     * @private
		     * @param {string} methodName The name of the `String` case method to use.
		     * @returns {Function} Returns the new case function.
		     */
		    function createCaseFirst(methodName) {
		      return function(string) {
		        string = toString(string);

		        var strSymbols = hasUnicode(string)
		          ? stringToArray(string)
		          : undefined$1;

		        var chr = strSymbols
		          ? strSymbols[0]
		          : string.charAt(0);

		        var trailing = strSymbols
		          ? castSlice(strSymbols, 1).join('')
		          : string.slice(1);

		        return chr[methodName]() + trailing;
		      };
		    }

		    /**
		     * Creates a function like `_.camelCase`.
		     *
		     * @private
		     * @param {Function} callback The function to combine each word.
		     * @returns {Function} Returns the new compounder function.
		     */
		    function createCompounder(callback) {
		      return function(string) {
		        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
		      };
		    }

		    /**
		     * Creates a function that produces an instance of `Ctor` regardless of
		     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
		     *
		     * @private
		     * @param {Function} Ctor The constructor to wrap.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createCtor(Ctor) {
		      return function() {
		        // Use a `switch` statement to work with class constructors. See
		        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
		        // for more details.
		        var args = arguments;
		        switch (args.length) {
		          case 0: return new Ctor;
		          case 1: return new Ctor(args[0]);
		          case 2: return new Ctor(args[0], args[1]);
		          case 3: return new Ctor(args[0], args[1], args[2]);
		          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
		          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
		          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
		          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
		        }
		        var thisBinding = baseCreate(Ctor.prototype),
		            result = Ctor.apply(thisBinding, args);

		        // Mimic the constructor's `return` behavior.
		        // See https://es5.github.io/#x13.2.2 for more details.
		        return isObject(result) ? result : thisBinding;
		      };
		    }

		    /**
		     * Creates a function that wraps `func` to enable currying.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {number} arity The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createCurry(func, bitmask, arity) {
		      var Ctor = createCtor(func);

		      function wrapper() {
		        var length = arguments.length,
		            args = Array(length),
		            index = length,
		            placeholder = getHolder(wrapper);

		        while (index--) {
		          args[index] = arguments[index];
		        }
		        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
		          ? []
		          : replaceHolders(args, placeholder);

		        length -= holders.length;
		        if (length < arity) {
		          return createRecurry(
		            func, bitmask, createHybrid, wrapper.placeholder, undefined$1,
		            args, holders, undefined$1, undefined$1, arity - length);
		        }
		        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
		        return apply(fn, this, args);
		      }
		      return wrapper;
		    }

		    /**
		     * Creates a `_.find` or `_.findLast` function.
		     *
		     * @private
		     * @param {Function} findIndexFunc The function to find the collection index.
		     * @returns {Function} Returns the new find function.
		     */
		    function createFind(findIndexFunc) {
		      return function(collection, predicate, fromIndex) {
		        var iterable = Object(collection);
		        if (!isArrayLike(collection)) {
		          var iteratee = getIteratee(predicate, 3);
		          collection = keys(collection);
		          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
		        }
		        var index = findIndexFunc(collection, predicate, fromIndex);
		        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined$1;
		      };
		    }

		    /**
		     * Creates a `_.flow` or `_.flowRight` function.
		     *
		     * @private
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new flow function.
		     */
		    function createFlow(fromRight) {
		      return flatRest(function(funcs) {
		        var length = funcs.length,
		            index = length,
		            prereq = LodashWrapper.prototype.thru;

		        if (fromRight) {
		          funcs.reverse();
		        }
		        while (index--) {
		          var func = funcs[index];
		          if (typeof func != 'function') {
		            throw new TypeError(FUNC_ERROR_TEXT);
		          }
		          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
		            var wrapper = new LodashWrapper([], true);
		          }
		        }
		        index = wrapper ? index : length;
		        while (++index < length) {
		          func = funcs[index];

		          var funcName = getFuncName(func),
		              data = funcName == 'wrapper' ? getData(func) : undefined$1;

		          if (data && isLaziable(data[0]) &&
		                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
		                !data[4].length && data[9] == 1
		              ) {
		            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
		          } else {
		            wrapper = (func.length == 1 && isLaziable(func))
		              ? wrapper[funcName]()
		              : wrapper.thru(func);
		          }
		        }
		        return function() {
		          var args = arguments,
		              value = args[0];

		          if (wrapper && args.length == 1 && isArray(value)) {
		            return wrapper.plant(value).value();
		          }
		          var index = 0,
		              result = length ? funcs[index].apply(this, args) : value;

		          while (++index < length) {
		            result = funcs[index].call(this, result);
		          }
		          return result;
		        };
		      });
		    }

		    /**
		     * Creates a function that wraps `func` to invoke it with optional `this`
		     * binding of `thisArg`, partial application, and currying.
		     *
		     * @private
		     * @param {Function|string} func The function or method name to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @param {Array} [partials] The arguments to prepend to those provided to
		     *  the new function.
		     * @param {Array} [holders] The `partials` placeholder indexes.
		     * @param {Array} [partialsRight] The arguments to append to those provided
		     *  to the new function.
		     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
		     * @param {Array} [argPos] The argument positions of the new function.
		     * @param {number} [ary] The arity cap of `func`.
		     * @param {number} [arity] The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
		      var isAry = bitmask & WRAP_ARY_FLAG,
		          isBind = bitmask & WRAP_BIND_FLAG,
		          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
		          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
		          isFlip = bitmask & WRAP_FLIP_FLAG,
		          Ctor = isBindKey ? undefined$1 : createCtor(func);

		      function wrapper() {
		        var length = arguments.length,
		            args = Array(length),
		            index = length;

		        while (index--) {
		          args[index] = arguments[index];
		        }
		        if (isCurried) {
		          var placeholder = getHolder(wrapper),
		              holdersCount = countHolders(args, placeholder);
		        }
		        if (partials) {
		          args = composeArgs(args, partials, holders, isCurried);
		        }
		        if (partialsRight) {
		          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
		        }
		        length -= holdersCount;
		        if (isCurried && length < arity) {
		          var newHolders = replaceHolders(args, placeholder);
		          return createRecurry(
		            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
		            args, newHolders, argPos, ary, arity - length
		          );
		        }
		        var thisBinding = isBind ? thisArg : this,
		            fn = isBindKey ? thisBinding[func] : func;

		        length = args.length;
		        if (argPos) {
		          args = reorder(args, argPos);
		        } else if (isFlip && length > 1) {
		          args.reverse();
		        }
		        if (isAry && ary < length) {
		          args.length = ary;
		        }
		        if (this && this !== root && this instanceof wrapper) {
		          fn = Ctor || createCtor(fn);
		        }
		        return fn.apply(thisBinding, args);
		      }
		      return wrapper;
		    }

		    /**
		     * Creates a function like `_.invertBy`.
		     *
		     * @private
		     * @param {Function} setter The function to set accumulator values.
		     * @param {Function} toIteratee The function to resolve iteratees.
		     * @returns {Function} Returns the new inverter function.
		     */
		    function createInverter(setter, toIteratee) {
		      return function(object, iteratee) {
		        return baseInverter(object, setter, toIteratee(iteratee), {});
		      };
		    }

		    /**
		     * Creates a function that performs a mathematical operation on two values.
		     *
		     * @private
		     * @param {Function} operator The function to perform the operation.
		     * @param {number} [defaultValue] The value used for `undefined` arguments.
		     * @returns {Function} Returns the new mathematical operation function.
		     */
		    function createMathOperation(operator, defaultValue) {
		      return function(value, other) {
		        var result;
		        if (value === undefined$1 && other === undefined$1) {
		          return defaultValue;
		        }
		        if (value !== undefined$1) {
		          result = value;
		        }
		        if (other !== undefined$1) {
		          if (result === undefined$1) {
		            return other;
		          }
		          if (typeof value == 'string' || typeof other == 'string') {
		            value = baseToString(value);
		            other = baseToString(other);
		          } else {
		            value = baseToNumber(value);
		            other = baseToNumber(other);
		          }
		          result = operator(value, other);
		        }
		        return result;
		      };
		    }

		    /**
		     * Creates a function like `_.over`.
		     *
		     * @private
		     * @param {Function} arrayFunc The function to iterate over iteratees.
		     * @returns {Function} Returns the new over function.
		     */
		    function createOver(arrayFunc) {
		      return flatRest(function(iteratees) {
		        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
		        return baseRest(function(args) {
		          var thisArg = this;
		          return arrayFunc(iteratees, function(iteratee) {
		            return apply(iteratee, thisArg, args);
		          });
		        });
		      });
		    }

		    /**
		     * Creates the padding for `string` based on `length`. The `chars` string
		     * is truncated if the number of characters exceeds `length`.
		     *
		     * @private
		     * @param {number} length The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padding for `string`.
		     */
		    function createPadding(length, chars) {
		      chars = chars === undefined$1 ? ' ' : baseToString(chars);

		      var charsLength = chars.length;
		      if (charsLength < 2) {
		        return charsLength ? baseRepeat(chars, length) : chars;
		      }
		      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
		      return hasUnicode(chars)
		        ? castSlice(stringToArray(result), 0, length).join('')
		        : result.slice(0, length);
		    }

		    /**
		     * Creates a function that wraps `func` to invoke it with the `this` binding
		     * of `thisArg` and `partials` prepended to the arguments it receives.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {*} thisArg The `this` binding of `func`.
		     * @param {Array} partials The arguments to prepend to those provided to
		     *  the new function.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createPartial(func, bitmask, thisArg, partials) {
		      var isBind = bitmask & WRAP_BIND_FLAG,
		          Ctor = createCtor(func);

		      function wrapper() {
		        var argsIndex = -1,
		            argsLength = arguments.length,
		            leftIndex = -1,
		            leftLength = partials.length,
		            args = Array(leftLength + argsLength),
		            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

		        while (++leftIndex < leftLength) {
		          args[leftIndex] = partials[leftIndex];
		        }
		        while (argsLength--) {
		          args[leftIndex++] = arguments[++argsIndex];
		        }
		        return apply(fn, isBind ? thisArg : this, args);
		      }
		      return wrapper;
		    }

		    /**
		     * Creates a `_.range` or `_.rangeRight` function.
		     *
		     * @private
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new range function.
		     */
		    function createRange(fromRight) {
		      return function(start, end, step) {
		        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
		          end = step = undefined$1;
		        }
		        // Ensure the sign of `-0` is preserved.
		        start = toFinite(start);
		        if (end === undefined$1) {
		          end = start;
		          start = 0;
		        } else {
		          end = toFinite(end);
		        }
		        step = step === undefined$1 ? (start < end ? 1 : -1) : toFinite(step);
		        return baseRange(start, end, step, fromRight);
		      };
		    }

		    /**
		     * Creates a function that performs a relational operation on two values.
		     *
		     * @private
		     * @param {Function} operator The function to perform the operation.
		     * @returns {Function} Returns the new relational operation function.
		     */
		    function createRelationalOperation(operator) {
		      return function(value, other) {
		        if (!(typeof value == 'string' && typeof other == 'string')) {
		          value = toNumber(value);
		          other = toNumber(other);
		        }
		        return operator(value, other);
		      };
		    }

		    /**
		     * Creates a function that wraps `func` to continue currying.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {Function} wrapFunc The function to create the `func` wrapper.
		     * @param {*} placeholder The placeholder value.
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @param {Array} [partials] The arguments to prepend to those provided to
		     *  the new function.
		     * @param {Array} [holders] The `partials` placeholder indexes.
		     * @param {Array} [argPos] The argument positions of the new function.
		     * @param {number} [ary] The arity cap of `func`.
		     * @param {number} [arity] The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
		      var isCurry = bitmask & WRAP_CURRY_FLAG,
		          newHolders = isCurry ? holders : undefined$1,
		          newHoldersRight = isCurry ? undefined$1 : holders,
		          newPartials = isCurry ? partials : undefined$1,
		          newPartialsRight = isCurry ? undefined$1 : partials;

		      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
		      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

		      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
		        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
		      }
		      var newData = [
		        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
		        newHoldersRight, argPos, ary, arity
		      ];

		      var result = wrapFunc.apply(undefined$1, newData);
		      if (isLaziable(func)) {
		        setData(result, newData);
		      }
		      result.placeholder = placeholder;
		      return setWrapToString(result, func, bitmask);
		    }

		    /**
		     * Creates a function like `_.round`.
		     *
		     * @private
		     * @param {string} methodName The name of the `Math` method to use when rounding.
		     * @returns {Function} Returns the new round function.
		     */
		    function createRound(methodName) {
		      var func = Math[methodName];
		      return function(number, precision) {
		        number = toNumber(number);
		        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
		        if (precision && nativeIsFinite(number)) {
		          // Shift with exponential notation to avoid floating-point issues.
		          // See [MDN](https://mdn.io/round#Examples) for more details.
		          var pair = (toString(number) + 'e').split('e'),
		              value = func(pair[0] + 'e' + (+pair[1] + precision));

		          pair = (toString(value) + 'e').split('e');
		          return +(pair[0] + 'e' + (+pair[1] - precision));
		        }
		        return func(number);
		      };
		    }

		    /**
		     * Creates a set object of `values`.
		     *
		     * @private
		     * @param {Array} values The values to add to the set.
		     * @returns {Object} Returns the new set.
		     */
		    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
		      return new Set(values);
		    };

		    /**
		     * Creates a `_.toPairs` or `_.toPairsIn` function.
		     *
		     * @private
		     * @param {Function} keysFunc The function to get the keys of a given object.
		     * @returns {Function} Returns the new pairs function.
		     */
		    function createToPairs(keysFunc) {
		      return function(object) {
		        var tag = getTag(object);
		        if (tag == mapTag) {
		          return mapToArray(object);
		        }
		        if (tag == setTag) {
		          return setToPairs(object);
		        }
		        return baseToPairs(object, keysFunc(object));
		      };
		    }

		    /**
		     * Creates a function that either curries or invokes `func` with optional
		     * `this` binding and partially applied arguments.
		     *
		     * @private
		     * @param {Function|string} func The function or method name to wrap.
		     * @param {number} bitmask The bitmask flags.
		     *    1 - `_.bind`
		     *    2 - `_.bindKey`
		     *    4 - `_.curry` or `_.curryRight` of a bound function
		     *    8 - `_.curry`
		     *   16 - `_.curryRight`
		     *   32 - `_.partial`
		     *   64 - `_.partialRight`
		     *  128 - `_.rearg`
		     *  256 - `_.ary`
		     *  512 - `_.flip`
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @param {Array} [partials] The arguments to be partially applied.
		     * @param {Array} [holders] The `partials` placeholder indexes.
		     * @param {Array} [argPos] The argument positions of the new function.
		     * @param {number} [ary] The arity cap of `func`.
		     * @param {number} [arity] The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
		      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
		      if (!isBindKey && typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      var length = partials ? partials.length : 0;
		      if (!length) {
		        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
		        partials = holders = undefined$1;
		      }
		      ary = ary === undefined$1 ? ary : nativeMax(toInteger(ary), 0);
		      arity = arity === undefined$1 ? arity : toInteger(arity);
		      length -= holders ? holders.length : 0;

		      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
		        var partialsRight = partials,
		            holdersRight = holders;

		        partials = holders = undefined$1;
		      }
		      var data = isBindKey ? undefined$1 : getData(func);

		      var newData = [
		        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
		        argPos, ary, arity
		      ];

		      if (data) {
		        mergeData(newData, data);
		      }
		      func = newData[0];
		      bitmask = newData[1];
		      thisArg = newData[2];
		      partials = newData[3];
		      holders = newData[4];
		      arity = newData[9] = newData[9] === undefined$1
		        ? (isBindKey ? 0 : func.length)
		        : nativeMax(newData[9] - length, 0);

		      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
		        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
		      }
		      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
		        var result = createBind(func, bitmask, thisArg);
		      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
		        result = createCurry(func, bitmask, arity);
		      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
		        result = createPartial(func, bitmask, thisArg, partials);
		      } else {
		        result = createHybrid.apply(undefined$1, newData);
		      }
		      var setter = data ? baseSetData : setData;
		      return setWrapToString(setter(result, newData), func, bitmask);
		    }

		    /**
		     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
		     * of source objects to the destination object for all destination properties
		     * that resolve to `undefined`.
		     *
		     * @private
		     * @param {*} objValue The destination value.
		     * @param {*} srcValue The source value.
		     * @param {string} key The key of the property to assign.
		     * @param {Object} object The parent object of `objValue`.
		     * @returns {*} Returns the value to assign.
		     */
		    function customDefaultsAssignIn(objValue, srcValue, key, object) {
		      if (objValue === undefined$1 ||
		          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
		        return srcValue;
		      }
		      return objValue;
		    }

		    /**
		     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
		     * objects into destination objects that are passed thru.
		     *
		     * @private
		     * @param {*} objValue The destination value.
		     * @param {*} srcValue The source value.
		     * @param {string} key The key of the property to merge.
		     * @param {Object} object The parent object of `objValue`.
		     * @param {Object} source The parent object of `srcValue`.
		     * @param {Object} [stack] Tracks traversed source values and their merged
		     *  counterparts.
		     * @returns {*} Returns the value to assign.
		     */
		    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
		      if (isObject(objValue) && isObject(srcValue)) {
		        // Recursively merge objects and arrays (susceptible to call stack limits).
		        stack.set(srcValue, objValue);
		        baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
		        stack['delete'](srcValue);
		      }
		      return objValue;
		    }

		    /**
		     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
		     * objects.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @param {string} key The key of the property to inspect.
		     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
		     */
		    function customOmitClone(value) {
		      return isPlainObject(value) ? undefined$1 : value;
		    }

		    /**
		     * A specialized version of `baseIsEqualDeep` for arrays with support for
		     * partial deep comparisons.
		     *
		     * @private
		     * @param {Array} array The array to compare.
		     * @param {Array} other The other array to compare.
		     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Object} stack Tracks traversed `array` and `other` objects.
		     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
		     */
		    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
		      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
		          arrLength = array.length,
		          othLength = other.length;

		      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
		        return false;
		      }
		      // Check that cyclic values are equal.
		      var arrStacked = stack.get(array);
		      var othStacked = stack.get(other);
		      if (arrStacked && othStacked) {
		        return arrStacked == other && othStacked == array;
		      }
		      var index = -1,
		          result = true,
		          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined$1;

		      stack.set(array, other);
		      stack.set(other, array);

		      // Ignore non-index properties.
		      while (++index < arrLength) {
		        var arrValue = array[index],
		            othValue = other[index];

		        if (customizer) {
		          var compared = isPartial
		            ? customizer(othValue, arrValue, index, other, array, stack)
		            : customizer(arrValue, othValue, index, array, other, stack);
		        }
		        if (compared !== undefined$1) {
		          if (compared) {
		            continue;
		          }
		          result = false;
		          break;
		        }
		        // Recursively compare arrays (susceptible to call stack limits).
		        if (seen) {
		          if (!arraySome(other, function(othValue, othIndex) {
		                if (!cacheHas(seen, othIndex) &&
		                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
		                  return seen.push(othIndex);
		                }
		              })) {
		            result = false;
		            break;
		          }
		        } else if (!(
		              arrValue === othValue ||
		                equalFunc(arrValue, othValue, bitmask, customizer, stack)
		            )) {
		          result = false;
		          break;
		        }
		      }
		      stack['delete'](array);
		      stack['delete'](other);
		      return result;
		    }

		    /**
		     * A specialized version of `baseIsEqualDeep` for comparing objects of
		     * the same `toStringTag`.
		     *
		     * **Note:** This function only supports comparing values with tags of
		     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {string} tag The `toStringTag` of the objects to compare.
		     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Object} stack Tracks traversed `object` and `other` objects.
		     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
		     */
		    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
		      switch (tag) {
		        case dataViewTag:
		          if ((object.byteLength != other.byteLength) ||
		              (object.byteOffset != other.byteOffset)) {
		            return false;
		          }
		          object = object.buffer;
		          other = other.buffer;

		        case arrayBufferTag:
		          if ((object.byteLength != other.byteLength) ||
		              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
		            return false;
		          }
		          return true;

		        case boolTag:
		        case dateTag:
		        case numberTag:
		          // Coerce booleans to `1` or `0` and dates to milliseconds.
		          // Invalid dates are coerced to `NaN`.
		          return eq(+object, +other);

		        case errorTag:
		          return object.name == other.name && object.message == other.message;

		        case regexpTag:
		        case stringTag:
		          // Coerce regexes to strings and treat strings, primitives and objects,
		          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
		          // for more details.
		          return object == (other + '');

		        case mapTag:
		          var convert = mapToArray;

		        case setTag:
		          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
		          convert || (convert = setToArray);

		          if (object.size != other.size && !isPartial) {
		            return false;
		          }
		          // Assume cyclic values are equal.
		          var stacked = stack.get(object);
		          if (stacked) {
		            return stacked == other;
		          }
		          bitmask |= COMPARE_UNORDERED_FLAG;

		          // Recursively compare objects (susceptible to call stack limits).
		          stack.set(object, other);
		          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
		          stack['delete'](object);
		          return result;

		        case symbolTag:
		          if (symbolValueOf) {
		            return symbolValueOf.call(object) == symbolValueOf.call(other);
		          }
		      }
		      return false;
		    }

		    /**
		     * A specialized version of `baseIsEqualDeep` for objects with support for
		     * partial deep comparisons.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Object} stack Tracks traversed `object` and `other` objects.
		     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
		     */
		    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
		      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
		          objProps = getAllKeys(object),
		          objLength = objProps.length,
		          othProps = getAllKeys(other),
		          othLength = othProps.length;

		      if (objLength != othLength && !isPartial) {
		        return false;
		      }
		      var index = objLength;
		      while (index--) {
		        var key = objProps[index];
		        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
		          return false;
		        }
		      }
		      // Check that cyclic values are equal.
		      var objStacked = stack.get(object);
		      var othStacked = stack.get(other);
		      if (objStacked && othStacked) {
		        return objStacked == other && othStacked == object;
		      }
		      var result = true;
		      stack.set(object, other);
		      stack.set(other, object);

		      var skipCtor = isPartial;
		      while (++index < objLength) {
		        key = objProps[index];
		        var objValue = object[key],
		            othValue = other[key];

		        if (customizer) {
		          var compared = isPartial
		            ? customizer(othValue, objValue, key, other, object, stack)
		            : customizer(objValue, othValue, key, object, other, stack);
		        }
		        // Recursively compare objects (susceptible to call stack limits).
		        if (!(compared === undefined$1
		              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
		              : compared
		            )) {
		          result = false;
		          break;
		        }
		        skipCtor || (skipCtor = key == 'constructor');
		      }
		      if (result && !skipCtor) {
		        var objCtor = object.constructor,
		            othCtor = other.constructor;

		        // Non `Object` object instances with different constructors are not equal.
		        if (objCtor != othCtor &&
		            ('constructor' in object && 'constructor' in other) &&
		            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
		              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
		          result = false;
		        }
		      }
		      stack['delete'](object);
		      stack['delete'](other);
		      return result;
		    }

		    /**
		     * A specialized version of `baseRest` which flattens the rest array.
		     *
		     * @private
		     * @param {Function} func The function to apply a rest parameter to.
		     * @returns {Function} Returns the new function.
		     */
		    function flatRest(func) {
		      return setToString(overRest(func, undefined$1, flatten), func + '');
		    }

		    /**
		     * Creates an array of own enumerable property names and symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names and symbols.
		     */
		    function getAllKeys(object) {
		      return baseGetAllKeys(object, keys, getSymbols);
		    }

		    /**
		     * Creates an array of own and inherited enumerable property names and
		     * symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names and symbols.
		     */
		    function getAllKeysIn(object) {
		      return baseGetAllKeys(object, keysIn, getSymbolsIn);
		    }

		    /**
		     * Gets metadata for `func`.
		     *
		     * @private
		     * @param {Function} func The function to query.
		     * @returns {*} Returns the metadata for `func`.
		     */
		    var getData = !metaMap ? noop : function(func) {
		      return metaMap.get(func);
		    };

		    /**
		     * Gets the name of `func`.
		     *
		     * @private
		     * @param {Function} func The function to query.
		     * @returns {string} Returns the function name.
		     */
		    function getFuncName(func) {
		      var result = (func.name + ''),
		          array = realNames[result],
		          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

		      while (length--) {
		        var data = array[length],
		            otherFunc = data.func;
		        if (otherFunc == null || otherFunc == func) {
		          return data.name;
		        }
		      }
		      return result;
		    }

		    /**
		     * Gets the argument placeholder value for `func`.
		     *
		     * @private
		     * @param {Function} func The function to inspect.
		     * @returns {*} Returns the placeholder value.
		     */
		    function getHolder(func) {
		      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
		      return object.placeholder;
		    }

		    /**
		     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
		     * this function returns the custom method, otherwise it returns `baseIteratee`.
		     * If arguments are provided, the chosen function is invoked with them and
		     * its result is returned.
		     *
		     * @private
		     * @param {*} [value] The value to convert to an iteratee.
		     * @param {number} [arity] The arity of the created iteratee.
		     * @returns {Function} Returns the chosen function or its result.
		     */
		    function getIteratee() {
		      var result = lodash.iteratee || iteratee;
		      result = result === iteratee ? baseIteratee : result;
		      return arguments.length ? result(arguments[0], arguments[1]) : result;
		    }

		    /**
		     * Gets the data for `map`.
		     *
		     * @private
		     * @param {Object} map The map to query.
		     * @param {string} key The reference key.
		     * @returns {*} Returns the map data.
		     */
		    function getMapData(map, key) {
		      var data = map.__data__;
		      return isKeyable(key)
		        ? data[typeof key == 'string' ? 'string' : 'hash']
		        : data.map;
		    }

		    /**
		     * Gets the property names, values, and compare flags of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the match data of `object`.
		     */
		    function getMatchData(object) {
		      var result = keys(object),
		          length = result.length;

		      while (length--) {
		        var key = result[length],
		            value = object[key];

		        result[length] = [key, value, isStrictComparable(value)];
		      }
		      return result;
		    }

		    /**
		     * Gets the native function at `key` of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {string} key The key of the method to get.
		     * @returns {*} Returns the function if it's native, else `undefined`.
		     */
		    function getNative(object, key) {
		      var value = getValue(object, key);
		      return baseIsNative(value) ? value : undefined$1;
		    }

		    /**
		     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
		     *
		     * @private
		     * @param {*} value The value to query.
		     * @returns {string} Returns the raw `toStringTag`.
		     */
		    function getRawTag(value) {
		      var isOwn = hasOwnProperty.call(value, symToStringTag),
		          tag = value[symToStringTag];

		      try {
		        value[symToStringTag] = undefined$1;
		        var unmasked = true;
		      } catch (e) {}

		      var result = nativeObjectToString.call(value);
		      if (unmasked) {
		        if (isOwn) {
		          value[symToStringTag] = tag;
		        } else {
		          delete value[symToStringTag];
		        }
		      }
		      return result;
		    }

		    /**
		     * Creates an array of the own enumerable symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of symbols.
		     */
		    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
		      if (object == null) {
		        return [];
		      }
		      object = Object(object);
		      return arrayFilter(nativeGetSymbols(object), function(symbol) {
		        return propertyIsEnumerable.call(object, symbol);
		      });
		    };

		    /**
		     * Creates an array of the own and inherited enumerable symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of symbols.
		     */
		    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
		      var result = [];
		      while (object) {
		        arrayPush(result, getSymbols(object));
		        object = getPrototype(object);
		      }
		      return result;
		    };

		    /**
		     * Gets the `toStringTag` of `value`.
		     *
		     * @private
		     * @param {*} value The value to query.
		     * @returns {string} Returns the `toStringTag`.
		     */
		    var getTag = baseGetTag;

		    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
		    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
		        (Map && getTag(new Map) != mapTag) ||
		        (Promise && getTag(Promise.resolve()) != promiseTag) ||
		        (Set && getTag(new Set) != setTag) ||
		        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
		      getTag = function(value) {
		        var result = baseGetTag(value),
		            Ctor = result == objectTag ? value.constructor : undefined$1,
		            ctorString = Ctor ? toSource(Ctor) : '';

		        if (ctorString) {
		          switch (ctorString) {
		            case dataViewCtorString: return dataViewTag;
		            case mapCtorString: return mapTag;
		            case promiseCtorString: return promiseTag;
		            case setCtorString: return setTag;
		            case weakMapCtorString: return weakMapTag;
		          }
		        }
		        return result;
		      };
		    }

		    /**
		     * Gets the view, applying any `transforms` to the `start` and `end` positions.
		     *
		     * @private
		     * @param {number} start The start of the view.
		     * @param {number} end The end of the view.
		     * @param {Array} transforms The transformations to apply to the view.
		     * @returns {Object} Returns an object containing the `start` and `end`
		     *  positions of the view.
		     */
		    function getView(start, end, transforms) {
		      var index = -1,
		          length = transforms.length;

		      while (++index < length) {
		        var data = transforms[index],
		            size = data.size;

		        switch (data.type) {
		          case 'drop':      start += size; break;
		          case 'dropRight': end -= size; break;
		          case 'take':      end = nativeMin(end, start + size); break;
		          case 'takeRight': start = nativeMax(start, end - size); break;
		        }
		      }
		      return { 'start': start, 'end': end };
		    }

		    /**
		     * Extracts wrapper details from the `source` body comment.
		     *
		     * @private
		     * @param {string} source The source to inspect.
		     * @returns {Array} Returns the wrapper details.
		     */
		    function getWrapDetails(source) {
		      var match = source.match(reWrapDetails);
		      return match ? match[1].split(reSplitDetails) : [];
		    }

		    /**
		     * Checks if `path` exists on `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path to check.
		     * @param {Function} hasFunc The function to check properties.
		     * @returns {boolean} Returns `true` if `path` exists, else `false`.
		     */
		    function hasPath(object, path, hasFunc) {
		      path = castPath(path, object);

		      var index = -1,
		          length = path.length,
		          result = false;

		      while (++index < length) {
		        var key = toKey(path[index]);
		        if (!(result = object != null && hasFunc(object, key))) {
		          break;
		        }
		        object = object[key];
		      }
		      if (result || ++index != length) {
		        return result;
		      }
		      length = object == null ? 0 : object.length;
		      return !!length && isLength(length) && isIndex(key, length) &&
		        (isArray(object) || isArguments(object));
		    }

		    /**
		     * Initializes an array clone.
		     *
		     * @private
		     * @param {Array} array The array to clone.
		     * @returns {Array} Returns the initialized clone.
		     */
		    function initCloneArray(array) {
		      var length = array.length,
		          result = new array.constructor(length);

		      // Add properties assigned by `RegExp#exec`.
		      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
		        result.index = array.index;
		        result.input = array.input;
		      }
		      return result;
		    }

		    /**
		     * Initializes an object clone.
		     *
		     * @private
		     * @param {Object} object The object to clone.
		     * @returns {Object} Returns the initialized clone.
		     */
		    function initCloneObject(object) {
		      return (typeof object.constructor == 'function' && !isPrototype(object))
		        ? baseCreate(getPrototype(object))
		        : {};
		    }

		    /**
		     * Initializes an object clone based on its `toStringTag`.
		     *
		     * **Note:** This function only supports cloning values with tags of
		     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
		     *
		     * @private
		     * @param {Object} object The object to clone.
		     * @param {string} tag The `toStringTag` of the object to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Object} Returns the initialized clone.
		     */
		    function initCloneByTag(object, tag, isDeep) {
		      var Ctor = object.constructor;
		      switch (tag) {
		        case arrayBufferTag:
		          return cloneArrayBuffer(object);

		        case boolTag:
		        case dateTag:
		          return new Ctor(+object);

		        case dataViewTag:
		          return cloneDataView(object, isDeep);

		        case float32Tag: case float64Tag:
		        case int8Tag: case int16Tag: case int32Tag:
		        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
		          return cloneTypedArray(object, isDeep);

		        case mapTag:
		          return new Ctor;

		        case numberTag:
		        case stringTag:
		          return new Ctor(object);

		        case regexpTag:
		          return cloneRegExp(object);

		        case setTag:
		          return new Ctor;

		        case symbolTag:
		          return cloneSymbol(object);
		      }
		    }

		    /**
		     * Inserts wrapper `details` in a comment at the top of the `source` body.
		     *
		     * @private
		     * @param {string} source The source to modify.
		     * @returns {Array} details The details to insert.
		     * @returns {string} Returns the modified source.
		     */
		    function insertWrapDetails(source, details) {
		      var length = details.length;
		      if (!length) {
		        return source;
		      }
		      var lastIndex = length - 1;
		      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
		      details = details.join(length > 2 ? ', ' : ' ');
		      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
		    }

		    /**
		     * Checks if `value` is a flattenable `arguments` object or array.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
		     */
		    function isFlattenable(value) {
		      return isArray(value) || isArguments(value) ||
		        !!(spreadableSymbol && value && value[spreadableSymbol]);
		    }

		    /**
		     * Checks if `value` is a valid array-like index.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
		     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
		     */
		    function isIndex(value, length) {
		      var type = typeof value;
		      length = length == null ? MAX_SAFE_INTEGER : length;

		      return !!length &&
		        (type == 'number' ||
		          (type != 'symbol' && reIsUint.test(value))) &&
		            (value > -1 && value % 1 == 0 && value < length);
		    }

		    /**
		     * Checks if the given arguments are from an iteratee call.
		     *
		     * @private
		     * @param {*} value The potential iteratee value argument.
		     * @param {*} index The potential iteratee index or key argument.
		     * @param {*} object The potential iteratee object argument.
		     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
		     *  else `false`.
		     */
		    function isIterateeCall(value, index, object) {
		      if (!isObject(object)) {
		        return false;
		      }
		      var type = typeof index;
		      if (type == 'number'
		            ? (isArrayLike(object) && isIndex(index, object.length))
		            : (type == 'string' && index in object)
		          ) {
		        return eq(object[index], value);
		      }
		      return false;
		    }

		    /**
		     * Checks if `value` is a property name and not a property path.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @param {Object} [object] The object to query keys on.
		     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
		     */
		    function isKey(value, object) {
		      if (isArray(value)) {
		        return false;
		      }
		      var type = typeof value;
		      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
		          value == null || isSymbol(value)) {
		        return true;
		      }
		      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
		        (object != null && value in Object(object));
		    }

		    /**
		     * Checks if `value` is suitable for use as unique object key.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
		     */
		    function isKeyable(value) {
		      var type = typeof value;
		      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
		        ? (value !== '__proto__')
		        : (value === null);
		    }

		    /**
		     * Checks if `func` has a lazy counterpart.
		     *
		     * @private
		     * @param {Function} func The function to check.
		     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
		     *  else `false`.
		     */
		    function isLaziable(func) {
		      var funcName = getFuncName(func),
		          other = lodash[funcName];

		      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
		        return false;
		      }
		      if (func === other) {
		        return true;
		      }
		      var data = getData(other);
		      return !!data && func === data[0];
		    }

		    /**
		     * Checks if `func` has its source masked.
		     *
		     * @private
		     * @param {Function} func The function to check.
		     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
		     */
		    function isMasked(func) {
		      return !!maskSrcKey && (maskSrcKey in func);
		    }

		    /**
		     * Checks if `func` is capable of being masked.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
		     */
		    var isMaskable = coreJsData ? isFunction : stubFalse;

		    /**
		     * Checks if `value` is likely a prototype object.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
		     */
		    function isPrototype(value) {
		      var Ctor = value && value.constructor,
		          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

		      return value === proto;
		    }

		    /**
		     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` if suitable for strict
		     *  equality comparisons, else `false`.
		     */
		    function isStrictComparable(value) {
		      return value === value && !isObject(value);
		    }

		    /**
		     * A specialized version of `matchesProperty` for source values suitable
		     * for strict equality comparisons, i.e. `===`.
		     *
		     * @private
		     * @param {string} key The key of the property to get.
		     * @param {*} srcValue The value to match.
		     * @returns {Function} Returns the new spec function.
		     */
		    function matchesStrictComparable(key, srcValue) {
		      return function(object) {
		        if (object == null) {
		          return false;
		        }
		        return object[key] === srcValue &&
		          (srcValue !== undefined$1 || (key in Object(object)));
		      };
		    }

		    /**
		     * A specialized version of `_.memoize` which clears the memoized function's
		     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
		     *
		     * @private
		     * @param {Function} func The function to have its output memoized.
		     * @returns {Function} Returns the new memoized function.
		     */
		    function memoizeCapped(func) {
		      var result = memoize(func, function(key) {
		        if (cache.size === MAX_MEMOIZE_SIZE) {
		          cache.clear();
		        }
		        return key;
		      });

		      var cache = result.cache;
		      return result;
		    }

		    /**
		     * Merges the function metadata of `source` into `data`.
		     *
		     * Merging metadata reduces the number of wrappers used to invoke a function.
		     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
		     * may be applied regardless of execution order. Methods like `_.ary` and
		     * `_.rearg` modify function arguments, making the order in which they are
		     * executed important, preventing the merging of metadata. However, we make
		     * an exception for a safe combined case where curried functions have `_.ary`
		     * and or `_.rearg` applied.
		     *
		     * @private
		     * @param {Array} data The destination metadata.
		     * @param {Array} source The source metadata.
		     * @returns {Array} Returns `data`.
		     */
		    function mergeData(data, source) {
		      var bitmask = data[1],
		          srcBitmask = source[1],
		          newBitmask = bitmask | srcBitmask,
		          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

		      var isCombo =
		        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
		        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
		        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

		      // Exit early if metadata can't be merged.
		      if (!(isCommon || isCombo)) {
		        return data;
		      }
		      // Use source `thisArg` if available.
		      if (srcBitmask & WRAP_BIND_FLAG) {
		        data[2] = source[2];
		        // Set when currying a bound function.
		        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
		      }
		      // Compose partial arguments.
		      var value = source[3];
		      if (value) {
		        var partials = data[3];
		        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
		        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
		      }
		      // Compose partial right arguments.
		      value = source[5];
		      if (value) {
		        partials = data[5];
		        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
		        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
		      }
		      // Use source `argPos` if available.
		      value = source[7];
		      if (value) {
		        data[7] = value;
		      }
		      // Use source `ary` if it's smaller.
		      if (srcBitmask & WRAP_ARY_FLAG) {
		        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
		      }
		      // Use source `arity` if one is not provided.
		      if (data[9] == null) {
		        data[9] = source[9];
		      }
		      // Use source `func` and merge bitmasks.
		      data[0] = source[0];
		      data[1] = newBitmask;

		      return data;
		    }

		    /**
		     * This function is like
		     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
		     * except that it includes inherited enumerable properties.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     */
		    function nativeKeysIn(object) {
		      var result = [];
		      if (object != null) {
		        for (var key in Object(object)) {
		          result.push(key);
		        }
		      }
		      return result;
		    }

		    /**
		     * Converts `value` to a string using `Object.prototype.toString`.
		     *
		     * @private
		     * @param {*} value The value to convert.
		     * @returns {string} Returns the converted string.
		     */
		    function objectToString(value) {
		      return nativeObjectToString.call(value);
		    }

		    /**
		     * A specialized version of `baseRest` which transforms the rest array.
		     *
		     * @private
		     * @param {Function} func The function to apply a rest parameter to.
		     * @param {number} [start=func.length-1] The start position of the rest parameter.
		     * @param {Function} transform The rest array transform.
		     * @returns {Function} Returns the new function.
		     */
		    function overRest(func, start, transform) {
		      start = nativeMax(start === undefined$1 ? (func.length - 1) : start, 0);
		      return function() {
		        var args = arguments,
		            index = -1,
		            length = nativeMax(args.length - start, 0),
		            array = Array(length);

		        while (++index < length) {
		          array[index] = args[start + index];
		        }
		        index = -1;
		        var otherArgs = Array(start + 1);
		        while (++index < start) {
		          otherArgs[index] = args[index];
		        }
		        otherArgs[start] = transform(array);
		        return apply(func, this, otherArgs);
		      };
		    }

		    /**
		     * Gets the parent value at `path` of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array} path The path to get the parent value of.
		     * @returns {*} Returns the parent value.
		     */
		    function parent(object, path) {
		      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
		    }

		    /**
		     * Reorder `array` according to the specified indexes where the element at
		     * the first index is assigned as the first element, the element at
		     * the second index is assigned as the second element, and so on.
		     *
		     * @private
		     * @param {Array} array The array to reorder.
		     * @param {Array} indexes The arranged array indexes.
		     * @returns {Array} Returns `array`.
		     */
		    function reorder(array, indexes) {
		      var arrLength = array.length,
		          length = nativeMin(indexes.length, arrLength),
		          oldArray = copyArray(array);

		      while (length--) {
		        var index = indexes[length];
		        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
		      }
		      return array;
		    }

		    /**
		     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {string} key The key of the property to get.
		     * @returns {*} Returns the property value.
		     */
		    function safeGet(object, key) {
		      if (key === 'constructor' && typeof object[key] === 'function') {
		        return;
		      }

		      if (key == '__proto__') {
		        return;
		      }

		      return object[key];
		    }

		    /**
		     * Sets metadata for `func`.
		     *
		     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
		     * period of time, it will trip its breaker and transition to an identity
		     * function to avoid garbage collection pauses in V8. See
		     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
		     * for more details.
		     *
		     * @private
		     * @param {Function} func The function to associate metadata with.
		     * @param {*} data The metadata.
		     * @returns {Function} Returns `func`.
		     */
		    var setData = shortOut(baseSetData);

		    /**
		     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
		     *
		     * @private
		     * @param {Function} func The function to delay.
		     * @param {number} wait The number of milliseconds to delay invocation.
		     * @returns {number|Object} Returns the timer id or timeout object.
		     */
		    var setTimeout = ctxSetTimeout || function(func, wait) {
		      return root.setTimeout(func, wait);
		    };

		    /**
		     * Sets the `toString` method of `func` to return `string`.
		     *
		     * @private
		     * @param {Function} func The function to modify.
		     * @param {Function} string The `toString` result.
		     * @returns {Function} Returns `func`.
		     */
		    var setToString = shortOut(baseSetToString);

		    /**
		     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
		     * with wrapper details in a comment at the top of the source body.
		     *
		     * @private
		     * @param {Function} wrapper The function to modify.
		     * @param {Function} reference The reference function.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @returns {Function} Returns `wrapper`.
		     */
		    function setWrapToString(wrapper, reference, bitmask) {
		      var source = (reference + '');
		      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
		    }

		    /**
		     * Creates a function that'll short out and invoke `identity` instead
		     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
		     * milliseconds.
		     *
		     * @private
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new shortable function.
		     */
		    function shortOut(func) {
		      var count = 0,
		          lastCalled = 0;

		      return function() {
		        var stamp = nativeNow(),
		            remaining = HOT_SPAN - (stamp - lastCalled);

		        lastCalled = stamp;
		        if (remaining > 0) {
		          if (++count >= HOT_COUNT) {
		            return arguments[0];
		          }
		        } else {
		          count = 0;
		        }
		        return func.apply(undefined$1, arguments);
		      };
		    }

		    /**
		     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
		     *
		     * @private
		     * @param {Array} array The array to shuffle.
		     * @param {number} [size=array.length] The size of `array`.
		     * @returns {Array} Returns `array`.
		     */
		    function shuffleSelf(array, size) {
		      var index = -1,
		          length = array.length,
		          lastIndex = length - 1;

		      size = size === undefined$1 ? length : size;
		      while (++index < size) {
		        var rand = baseRandom(index, lastIndex),
		            value = array[rand];

		        array[rand] = array[index];
		        array[index] = value;
		      }
		      array.length = size;
		      return array;
		    }

		    /**
		     * Converts `string` to a property path array.
		     *
		     * @private
		     * @param {string} string The string to convert.
		     * @returns {Array} Returns the property path array.
		     */
		    var stringToPath = memoizeCapped(function(string) {
		      var result = [];
		      if (string.charCodeAt(0) === 46 /* . */) {
		        result.push('');
		      }
		      string.replace(rePropName, function(match, number, quote, subString) {
		        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
		      });
		      return result;
		    });

		    /**
		     * Converts `value` to a string key if it's not a string or symbol.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @returns {string|symbol} Returns the key.
		     */
		    function toKey(value) {
		      if (typeof value == 'string' || isSymbol(value)) {
		        return value;
		      }
		      var result = (value + '');
		      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
		    }

		    /**
		     * Converts `func` to its source code.
		     *
		     * @private
		     * @param {Function} func The function to convert.
		     * @returns {string} Returns the source code.
		     */
		    function toSource(func) {
		      if (func != null) {
		        try {
		          return funcToString.call(func);
		        } catch (e) {}
		        try {
		          return (func + '');
		        } catch (e) {}
		      }
		      return '';
		    }

		    /**
		     * Updates wrapper `details` based on `bitmask` flags.
		     *
		     * @private
		     * @returns {Array} details The details to modify.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @returns {Array} Returns `details`.
		     */
		    function updateWrapDetails(details, bitmask) {
		      arrayEach(wrapFlags, function(pair) {
		        var value = '_.' + pair[0];
		        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
		          details.push(value);
		        }
		      });
		      return details.sort();
		    }

		    /**
		     * Creates a clone of `wrapper`.
		     *
		     * @private
		     * @param {Object} wrapper The wrapper to clone.
		     * @returns {Object} Returns the cloned wrapper.
		     */
		    function wrapperClone(wrapper) {
		      if (wrapper instanceof LazyWrapper) {
		        return wrapper.clone();
		      }
		      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
		      result.__actions__ = copyArray(wrapper.__actions__);
		      result.__index__  = wrapper.__index__;
		      result.__values__ = wrapper.__values__;
		      return result;
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates an array of elements split into groups the length of `size`.
		     * If `array` can't be split evenly, the final chunk will be the remaining
		     * elements.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to process.
		     * @param {number} [size=1] The length of each chunk
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the new array of chunks.
		     * @example
		     *
		     * _.chunk(['a', 'b', 'c', 'd'], 2);
		     * // => [['a', 'b'], ['c', 'd']]
		     *
		     * _.chunk(['a', 'b', 'c', 'd'], 3);
		     * // => [['a', 'b', 'c'], ['d']]
		     */
		    function chunk(array, size, guard) {
		      if ((guard ? isIterateeCall(array, size, guard) : size === undefined$1)) {
		        size = 1;
		      } else {
		        size = nativeMax(toInteger(size), 0);
		      }
		      var length = array == null ? 0 : array.length;
		      if (!length || size < 1) {
		        return [];
		      }
		      var index = 0,
		          resIndex = 0,
		          result = Array(nativeCeil(length / size));

		      while (index < length) {
		        result[resIndex++] = baseSlice(array, index, (index += size));
		      }
		      return result;
		    }

		    /**
		     * Creates an array with all falsey values removed. The values `false`, `null`,
		     * `0`, `""`, `undefined`, and `NaN` are falsey.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to compact.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * _.compact([0, 1, false, 2, '', 3]);
		     * // => [1, 2, 3]
		     */
		    function compact(array) {
		      var index = -1,
		          length = array == null ? 0 : array.length,
		          resIndex = 0,
		          result = [];

		      while (++index < length) {
		        var value = array[index];
		        if (value) {
		          result[resIndex++] = value;
		        }
		      }
		      return result;
		    }

		    /**
		     * Creates a new array concatenating `array` with any additional arrays
		     * and/or values.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to concatenate.
		     * @param {...*} [values] The values to concatenate.
		     * @returns {Array} Returns the new concatenated array.
		     * @example
		     *
		     * var array = [1];
		     * var other = _.concat(array, 2, [3], [[4]]);
		     *
		     * console.log(other);
		     * // => [1, 2, 3, [4]]
		     *
		     * console.log(array);
		     * // => [1]
		     */
		    function concat() {
		      var length = arguments.length;
		      if (!length) {
		        return [];
		      }
		      var args = Array(length - 1),
		          array = arguments[0],
		          index = length;

		      while (index--) {
		        args[index - 1] = arguments[index];
		      }
		      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
		    }

		    /**
		     * Creates an array of `array` values not included in the other given arrays
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons. The order and references of result values are
		     * determined by the first array.
		     *
		     * **Note:** Unlike `_.pullAll`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...Array} [values] The values to exclude.
		     * @returns {Array} Returns the new array of filtered values.
		     * @see _.without, _.xor
		     * @example
		     *
		     * _.difference([2, 1], [2, 3]);
		     * // => [1]
		     */
		    var difference = baseRest(function(array, values) {
		      return isArrayLikeObject(array)
		        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
		        : [];
		    });

		    /**
		     * This method is like `_.difference` except that it accepts `iteratee` which
		     * is invoked for each element of `array` and `values` to generate the criterion
		     * by which they're compared. The order and references of result values are
		     * determined by the first array. The iteratee is invoked with one argument:
		     * (value).
		     *
		     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...Array} [values] The values to exclude.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
		     * // => [1.2]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
		     * // => [{ 'x': 2 }]
		     */
		    var differenceBy = baseRest(function(array, values) {
		      var iteratee = last(values);
		      if (isArrayLikeObject(iteratee)) {
		        iteratee = undefined$1;
		      }
		      return isArrayLikeObject(array)
		        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
		        : [];
		    });

		    /**
		     * This method is like `_.difference` except that it accepts `comparator`
		     * which is invoked to compare elements of `array` to `values`. The order and
		     * references of result values are determined by the first array. The comparator
		     * is invoked with two arguments: (arrVal, othVal).
		     *
		     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...Array} [values] The values to exclude.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     *
		     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
		     * // => [{ 'x': 2, 'y': 1 }]
		     */
		    var differenceWith = baseRest(function(array, values) {
		      var comparator = last(values);
		      if (isArrayLikeObject(comparator)) {
		        comparator = undefined$1;
		      }
		      return isArrayLikeObject(array)
		        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined$1, comparator)
		        : [];
		    });

		    /**
		     * Creates a slice of `array` with `n` elements dropped from the beginning.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.5.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to drop.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.drop([1, 2, 3]);
		     * // => [2, 3]
		     *
		     * _.drop([1, 2, 3], 2);
		     * // => [3]
		     *
		     * _.drop([1, 2, 3], 5);
		     * // => []
		     *
		     * _.drop([1, 2, 3], 0);
		     * // => [1, 2, 3]
		     */
		    function drop(array, n, guard) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      n = (guard || n === undefined$1) ? 1 : toInteger(n);
		      return baseSlice(array, n < 0 ? 0 : n, length);
		    }

		    /**
		     * Creates a slice of `array` with `n` elements dropped from the end.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to drop.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.dropRight([1, 2, 3]);
		     * // => [1, 2]
		     *
		     * _.dropRight([1, 2, 3], 2);
		     * // => [1]
		     *
		     * _.dropRight([1, 2, 3], 5);
		     * // => []
		     *
		     * _.dropRight([1, 2, 3], 0);
		     * // => [1, 2, 3]
		     */
		    function dropRight(array, n, guard) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      n = (guard || n === undefined$1) ? 1 : toInteger(n);
		      n = length - n;
		      return baseSlice(array, 0, n < 0 ? 0 : n);
		    }

		    /**
		     * Creates a slice of `array` excluding elements dropped from the end.
		     * Elements are dropped until `predicate` returns falsey. The predicate is
		     * invoked with three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': true },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': false }
		     * ];
		     *
		     * _.dropRightWhile(users, function(o) { return !o.active; });
		     * // => objects for ['barney']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
		     * // => objects for ['barney', 'fred']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.dropRightWhile(users, ['active', false]);
		     * // => objects for ['barney']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.dropRightWhile(users, 'active');
		     * // => objects for ['barney', 'fred', 'pebbles']
		     */
		    function dropRightWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3), true, true)
		        : [];
		    }

		    /**
		     * Creates a slice of `array` excluding elements dropped from the beginning.
		     * Elements are dropped until `predicate` returns falsey. The predicate is
		     * invoked with three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': false },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': true }
		     * ];
		     *
		     * _.dropWhile(users, function(o) { return !o.active; });
		     * // => objects for ['pebbles']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.dropWhile(users, { 'user': 'barney', 'active': false });
		     * // => objects for ['fred', 'pebbles']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.dropWhile(users, ['active', false]);
		     * // => objects for ['pebbles']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.dropWhile(users, 'active');
		     * // => objects for ['barney', 'fred', 'pebbles']
		     */
		    function dropWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3), true)
		        : [];
		    }

		    /**
		     * Fills elements of `array` with `value` from `start` up to, but not
		     * including, `end`.
		     *
		     * **Note:** This method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.2.0
		     * @category Array
		     * @param {Array} array The array to fill.
		     * @param {*} value The value to fill `array` with.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [1, 2, 3];
		     *
		     * _.fill(array, 'a');
		     * console.log(array);
		     * // => ['a', 'a', 'a']
		     *
		     * _.fill(Array(3), 2);
		     * // => [2, 2, 2]
		     *
		     * _.fill([4, 6, 8, 10], '*', 1, 3);
		     * // => [4, '*', '*', 10]
		     */
		    function fill(array, value, start, end) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
		        start = 0;
		        end = length;
		      }
		      return baseFill(array, value, start, end);
		    }

		    /**
		     * This method is like `_.find` except that it returns the index of the first
		     * element `predicate` returns truthy for instead of the element itself.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @returns {number} Returns the index of the found element, else `-1`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': false },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': true }
		     * ];
		     *
		     * _.findIndex(users, function(o) { return o.user == 'barney'; });
		     * // => 0
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findIndex(users, { 'user': 'fred', 'active': false });
		     * // => 1
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findIndex(users, ['active', false]);
		     * // => 0
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findIndex(users, 'active');
		     * // => 2
		     */
		    function findIndex(array, predicate, fromIndex) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return -1;
		      }
		      var index = fromIndex == null ? 0 : toInteger(fromIndex);
		      if (index < 0) {
		        index = nativeMax(length + index, 0);
		      }
		      return baseFindIndex(array, getIteratee(predicate, 3), index);
		    }

		    /**
		     * This method is like `_.findIndex` except that it iterates over elements
		     * of `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param {number} [fromIndex=array.length-1] The index to search from.
		     * @returns {number} Returns the index of the found element, else `-1`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': true },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': false }
		     * ];
		     *
		     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
		     * // => 2
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
		     * // => 0
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findLastIndex(users, ['active', false]);
		     * // => 2
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findLastIndex(users, 'active');
		     * // => 0
		     */
		    function findLastIndex(array, predicate, fromIndex) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return -1;
		      }
		      var index = length - 1;
		      if (fromIndex !== undefined$1) {
		        index = toInteger(fromIndex);
		        index = fromIndex < 0
		          ? nativeMax(length + index, 0)
		          : nativeMin(index, length - 1);
		      }
		      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
		    }

		    /**
		     * Flattens `array` a single level deep.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to flatten.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * _.flatten([1, [2, [3, [4]], 5]]);
		     * // => [1, 2, [3, [4]], 5]
		     */
		    function flatten(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? baseFlatten(array, 1) : [];
		    }

		    /**
		     * Recursively flattens `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to flatten.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * _.flattenDeep([1, [2, [3, [4]], 5]]);
		     * // => [1, 2, 3, 4, 5]
		     */
		    function flattenDeep(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? baseFlatten(array, INFINITY) : [];
		    }

		    /**
		     * Recursively flatten `array` up to `depth` times.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.4.0
		     * @category Array
		     * @param {Array} array The array to flatten.
		     * @param {number} [depth=1] The maximum recursion depth.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * var array = [1, [2, [3, [4]], 5]];
		     *
		     * _.flattenDepth(array, 1);
		     * // => [1, 2, [3, [4]], 5]
		     *
		     * _.flattenDepth(array, 2);
		     * // => [1, 2, 3, [4], 5]
		     */
		    function flattenDepth(array, depth) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      depth = depth === undefined$1 ? 1 : toInteger(depth);
		      return baseFlatten(array, depth);
		    }

		    /**
		     * The inverse of `_.toPairs`; this method returns an object composed
		     * from key-value `pairs`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} pairs The key-value pairs.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * _.fromPairs([['a', 1], ['b', 2]]);
		     * // => { 'a': 1, 'b': 2 }
		     */
		    function fromPairs(pairs) {
		      var index = -1,
		          length = pairs == null ? 0 : pairs.length,
		          result = {};

		      while (++index < length) {
		        var pair = pairs[index];
		        result[pair[0]] = pair[1];
		      }
		      return result;
		    }

		    /**
		     * Gets the first element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @alias first
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {*} Returns the first element of `array`.
		     * @example
		     *
		     * _.head([1, 2, 3]);
		     * // => 1
		     *
		     * _.head([]);
		     * // => undefined
		     */
		    function head(array) {
		      return (array && array.length) ? array[0] : undefined$1;
		    }

		    /**
		     * Gets the index at which the first occurrence of `value` is found in `array`
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons. If `fromIndex` is negative, it's used as the
		     * offset from the end of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {*} value The value to search for.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.indexOf([1, 2, 1, 2], 2);
		     * // => 1
		     *
		     * // Search from the `fromIndex`.
		     * _.indexOf([1, 2, 1, 2], 2, 2);
		     * // => 3
		     */
		    function indexOf(array, value, fromIndex) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return -1;
		      }
		      var index = fromIndex == null ? 0 : toInteger(fromIndex);
		      if (index < 0) {
		        index = nativeMax(length + index, 0);
		      }
		      return baseIndexOf(array, value, index);
		    }

		    /**
		     * Gets all but the last element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.initial([1, 2, 3]);
		     * // => [1, 2]
		     */
		    function initial(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? baseSlice(array, 0, -1) : [];
		    }

		    /**
		     * Creates an array of unique values that are included in all given arrays
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons. The order and references of result values are
		     * determined by the first array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @returns {Array} Returns the new array of intersecting values.
		     * @example
		     *
		     * _.intersection([2, 1], [2, 3]);
		     * // => [2]
		     */
		    var intersection = baseRest(function(arrays) {
		      var mapped = arrayMap(arrays, castArrayLikeObject);
		      return (mapped.length && mapped[0] === arrays[0])
		        ? baseIntersection(mapped)
		        : [];
		    });

		    /**
		     * This method is like `_.intersection` except that it accepts `iteratee`
		     * which is invoked for each element of each `arrays` to generate the criterion
		     * by which they're compared. The order and references of result values are
		     * determined by the first array. The iteratee is invoked with one argument:
		     * (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new array of intersecting values.
		     * @example
		     *
		     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
		     * // => [2.1]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 1 }]
		     */
		    var intersectionBy = baseRest(function(arrays) {
		      var iteratee = last(arrays),
		          mapped = arrayMap(arrays, castArrayLikeObject);

		      if (iteratee === last(mapped)) {
		        iteratee = undefined$1;
		      } else {
		        mapped.pop();
		      }
		      return (mapped.length && mapped[0] === arrays[0])
		        ? baseIntersection(mapped, getIteratee(iteratee, 2))
		        : [];
		    });

		    /**
		     * This method is like `_.intersection` except that it accepts `comparator`
		     * which is invoked to compare elements of `arrays`. The order and references
		     * of result values are determined by the first array. The comparator is
		     * invoked with two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of intersecting values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.intersectionWith(objects, others, _.isEqual);
		     * // => [{ 'x': 1, 'y': 2 }]
		     */
		    var intersectionWith = baseRest(function(arrays) {
		      var comparator = last(arrays),
		          mapped = arrayMap(arrays, castArrayLikeObject);

		      comparator = typeof comparator == 'function' ? comparator : undefined$1;
		      if (comparator) {
		        mapped.pop();
		      }
		      return (mapped.length && mapped[0] === arrays[0])
		        ? baseIntersection(mapped, undefined$1, comparator)
		        : [];
		    });

		    /**
		     * Converts all elements in `array` into a string separated by `separator`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to convert.
		     * @param {string} [separator=','] The element separator.
		     * @returns {string} Returns the joined string.
		     * @example
		     *
		     * _.join(['a', 'b', 'c'], '~');
		     * // => 'a~b~c'
		     */
		    function join(array, separator) {
		      return array == null ? '' : nativeJoin.call(array, separator);
		    }

		    /**
		     * Gets the last element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {*} Returns the last element of `array`.
		     * @example
		     *
		     * _.last([1, 2, 3]);
		     * // => 3
		     */
		    function last(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? array[length - 1] : undefined$1;
		    }

		    /**
		     * This method is like `_.indexOf` except that it iterates over elements of
		     * `array` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {*} value The value to search for.
		     * @param {number} [fromIndex=array.length-1] The index to search from.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.lastIndexOf([1, 2, 1, 2], 2);
		     * // => 3
		     *
		     * // Search from the `fromIndex`.
		     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
		     * // => 1
		     */
		    function lastIndexOf(array, value, fromIndex) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return -1;
		      }
		      var index = length;
		      if (fromIndex !== undefined$1) {
		        index = toInteger(fromIndex);
		        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
		      }
		      return value === value
		        ? strictLastIndexOf(array, value, index)
		        : baseFindIndex(array, baseIsNaN, index, true);
		    }

		    /**
		     * Gets the element at index `n` of `array`. If `n` is negative, the nth
		     * element from the end is returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.11.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=0] The index of the element to return.
		     * @returns {*} Returns the nth element of `array`.
		     * @example
		     *
		     * var array = ['a', 'b', 'c', 'd'];
		     *
		     * _.nth(array, 1);
		     * // => 'b'
		     *
		     * _.nth(array, -2);
		     * // => 'c';
		     */
		    function nth(array, n) {
		      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined$1;
		    }

		    /**
		     * Removes all given values from `array` using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
		     * to remove elements from an array by predicate.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {...*} [values] The values to remove.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
		     *
		     * _.pull(array, 'a', 'c');
		     * console.log(array);
		     * // => ['b', 'b']
		     */
		    var pull = baseRest(pullAll);

		    /**
		     * This method is like `_.pull` except that it accepts an array of values to remove.
		     *
		     * **Note:** Unlike `_.difference`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
		     *
		     * _.pullAll(array, ['a', 'c']);
		     * console.log(array);
		     * // => ['b', 'b']
		     */
		    function pullAll(array, values) {
		      return (array && array.length && values && values.length)
		        ? basePullAll(array, values)
		        : array;
		    }

		    /**
		     * This method is like `_.pullAll` except that it accepts `iteratee` which is
		     * invoked for each element of `array` and `values` to generate the criterion
		     * by which they're compared. The iteratee is invoked with one argument: (value).
		     *
		     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
		     *
		     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
		     * console.log(array);
		     * // => [{ 'x': 2 }]
		     */
		    function pullAllBy(array, values, iteratee) {
		      return (array && array.length && values && values.length)
		        ? basePullAll(array, values, getIteratee(iteratee, 2))
		        : array;
		    }

		    /**
		     * This method is like `_.pullAll` except that it accepts `comparator` which
		     * is invoked to compare elements of `array` to `values`. The comparator is
		     * invoked with two arguments: (arrVal, othVal).
		     *
		     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.6.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
		     *
		     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
		     * console.log(array);
		     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
		     */
		    function pullAllWith(array, values, comparator) {
		      return (array && array.length && values && values.length)
		        ? basePullAll(array, values, undefined$1, comparator)
		        : array;
		    }

		    /**
		     * Removes elements from `array` corresponding to `indexes` and returns an
		     * array of removed elements.
		     *
		     * **Note:** Unlike `_.at`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
		     * @returns {Array} Returns the new array of removed elements.
		     * @example
		     *
		     * var array = ['a', 'b', 'c', 'd'];
		     * var pulled = _.pullAt(array, [1, 3]);
		     *
		     * console.log(array);
		     * // => ['a', 'c']
		     *
		     * console.log(pulled);
		     * // => ['b', 'd']
		     */
		    var pullAt = flatRest(function(array, indexes) {
		      var length = array == null ? 0 : array.length,
		          result = baseAt(array, indexes);

		      basePullAt(array, arrayMap(indexes, function(index) {
		        return isIndex(index, length) ? +index : index;
		      }).sort(compareAscending));

		      return result;
		    });

		    /**
		     * Removes all elements from `array` that `predicate` returns truthy for
		     * and returns an array of the removed elements. The predicate is invoked
		     * with three arguments: (value, index, array).
		     *
		     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
		     * to pull elements from an array by value.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new array of removed elements.
		     * @example
		     *
		     * var array = [1, 2, 3, 4];
		     * var evens = _.remove(array, function(n) {
		     *   return n % 2 == 0;
		     * });
		     *
		     * console.log(array);
		     * // => [1, 3]
		     *
		     * console.log(evens);
		     * // => [2, 4]
		     */
		    function remove(array, predicate) {
		      var result = [];
		      if (!(array && array.length)) {
		        return result;
		      }
		      var index = -1,
		          indexes = [],
		          length = array.length;

		      predicate = getIteratee(predicate, 3);
		      while (++index < length) {
		        var value = array[index];
		        if (predicate(value, index, array)) {
		          result.push(value);
		          indexes.push(index);
		        }
		      }
		      basePullAt(array, indexes);
		      return result;
		    }

		    /**
		     * Reverses `array` so that the first element becomes the last, the second
		     * element becomes the second to last, and so on.
		     *
		     * **Note:** This method mutates `array` and is based on
		     * [`Array#reverse`](https://mdn.io/Array/reverse).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [1, 2, 3];
		     *
		     * _.reverse(array);
		     * // => [3, 2, 1]
		     *
		     * console.log(array);
		     * // => [3, 2, 1]
		     */
		    function reverse(array) {
		      return array == null ? array : nativeReverse.call(array);
		    }

		    /**
		     * Creates a slice of `array` from `start` up to, but not including, `end`.
		     *
		     * **Note:** This method is used instead of
		     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
		     * returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to slice.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns the slice of `array`.
		     */
		    function slice(array, start, end) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
		        start = 0;
		        end = length;
		      }
		      else {
		        start = start == null ? 0 : toInteger(start);
		        end = end === undefined$1 ? length : toInteger(end);
		      }
		      return baseSlice(array, start, end);
		    }

		    /**
		     * Uses a binary search to determine the lowest index at which `value`
		     * should be inserted into `array` in order to maintain its sort order.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * _.sortedIndex([30, 50], 40);
		     * // => 1
		     */
		    function sortedIndex(array, value) {
		      return baseSortedIndex(array, value);
		    }

		    /**
		     * This method is like `_.sortedIndex` except that it accepts `iteratee`
		     * which is invoked for `value` and each element of `array` to compute their
		     * sort ranking. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * var objects = [{ 'x': 4 }, { 'x': 5 }];
		     *
		     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
		     * // => 0
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
		     * // => 0
		     */
		    function sortedIndexBy(array, value, iteratee) {
		      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
		    }

		    /**
		     * This method is like `_.indexOf` except that it performs a binary
		     * search on a sorted `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {*} value The value to search for.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
		     * // => 1
		     */
		    function sortedIndexOf(array, value) {
		      var length = array == null ? 0 : array.length;
		      if (length) {
		        var index = baseSortedIndex(array, value);
		        if (index < length && eq(array[index], value)) {
		          return index;
		        }
		      }
		      return -1;
		    }

		    /**
		     * This method is like `_.sortedIndex` except that it returns the highest
		     * index at which `value` should be inserted into `array` in order to
		     * maintain its sort order.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
		     * // => 4
		     */
		    function sortedLastIndex(array, value) {
		      return baseSortedIndex(array, value, true);
		    }

		    /**
		     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
		     * which is invoked for `value` and each element of `array` to compute their
		     * sort ranking. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * var objects = [{ 'x': 4 }, { 'x': 5 }];
		     *
		     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
		     * // => 1
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
		     * // => 1
		     */
		    function sortedLastIndexBy(array, value, iteratee) {
		      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
		    }

		    /**
		     * This method is like `_.lastIndexOf` except that it performs a binary
		     * search on a sorted `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {*} value The value to search for.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
		     * // => 3
		     */
		    function sortedLastIndexOf(array, value) {
		      var length = array == null ? 0 : array.length;
		      if (length) {
		        var index = baseSortedIndex(array, value, true) - 1;
		        if (eq(array[index], value)) {
		          return index;
		        }
		      }
		      return -1;
		    }

		    /**
		     * This method is like `_.uniq` except that it's designed and optimized
		     * for sorted arrays.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.sortedUniq([1, 1, 2]);
		     * // => [1, 2]
		     */
		    function sortedUniq(array) {
		      return (array && array.length)
		        ? baseSortedUniq(array)
		        : [];
		    }

		    /**
		     * This method is like `_.uniqBy` except that it's designed and optimized
		     * for sorted arrays.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
		     * // => [1.1, 2.3]
		     */
		    function sortedUniqBy(array, iteratee) {
		      return (array && array.length)
		        ? baseSortedUniq(array, getIteratee(iteratee, 2))
		        : [];
		    }

		    /**
		     * Gets all but the first element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.tail([1, 2, 3]);
		     * // => [2, 3]
		     */
		    function tail(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? baseSlice(array, 1, length) : [];
		    }

		    /**
		     * Creates a slice of `array` with `n` elements taken from the beginning.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to take.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.take([1, 2, 3]);
		     * // => [1]
		     *
		     * _.take([1, 2, 3], 2);
		     * // => [1, 2]
		     *
		     * _.take([1, 2, 3], 5);
		     * // => [1, 2, 3]
		     *
		     * _.take([1, 2, 3], 0);
		     * // => []
		     */
		    function take(array, n, guard) {
		      if (!(array && array.length)) {
		        return [];
		      }
		      n = (guard || n === undefined$1) ? 1 : toInteger(n);
		      return baseSlice(array, 0, n < 0 ? 0 : n);
		    }

		    /**
		     * Creates a slice of `array` with `n` elements taken from the end.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to take.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.takeRight([1, 2, 3]);
		     * // => [3]
		     *
		     * _.takeRight([1, 2, 3], 2);
		     * // => [2, 3]
		     *
		     * _.takeRight([1, 2, 3], 5);
		     * // => [1, 2, 3]
		     *
		     * _.takeRight([1, 2, 3], 0);
		     * // => []
		     */
		    function takeRight(array, n, guard) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      n = (guard || n === undefined$1) ? 1 : toInteger(n);
		      n = length - n;
		      return baseSlice(array, n < 0 ? 0 : n, length);
		    }

		    /**
		     * Creates a slice of `array` with elements taken from the end. Elements are
		     * taken until `predicate` returns falsey. The predicate is invoked with
		     * three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': true },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': false }
		     * ];
		     *
		     * _.takeRightWhile(users, function(o) { return !o.active; });
		     * // => objects for ['fred', 'pebbles']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
		     * // => objects for ['pebbles']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.takeRightWhile(users, ['active', false]);
		     * // => objects for ['fred', 'pebbles']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.takeRightWhile(users, 'active');
		     * // => []
		     */
		    function takeRightWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3), false, true)
		        : [];
		    }

		    /**
		     * Creates a slice of `array` with elements taken from the beginning. Elements
		     * are taken until `predicate` returns falsey. The predicate is invoked with
		     * three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': false },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': true }
		     * ];
		     *
		     * _.takeWhile(users, function(o) { return !o.active; });
		     * // => objects for ['barney', 'fred']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.takeWhile(users, { 'user': 'barney', 'active': false });
		     * // => objects for ['barney']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.takeWhile(users, ['active', false]);
		     * // => objects for ['barney', 'fred']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.takeWhile(users, 'active');
		     * // => []
		     */
		    function takeWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3))
		        : [];
		    }

		    /**
		     * Creates an array of unique values, in order, from all given arrays using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @returns {Array} Returns the new array of combined values.
		     * @example
		     *
		     * _.union([2], [1, 2]);
		     * // => [2, 1]
		     */
		    var union = baseRest(function(arrays) {
		      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
		    });

		    /**
		     * This method is like `_.union` except that it accepts `iteratee` which is
		     * invoked for each element of each `arrays` to generate the criterion by
		     * which uniqueness is computed. Result values are chosen from the first
		     * array in which the value occurs. The iteratee is invoked with one argument:
		     * (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new array of combined values.
		     * @example
		     *
		     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
		     * // => [2.1, 1.2]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 1 }, { 'x': 2 }]
		     */
		    var unionBy = baseRest(function(arrays) {
		      var iteratee = last(arrays);
		      if (isArrayLikeObject(iteratee)) {
		        iteratee = undefined$1;
		      }
		      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
		    });

		    /**
		     * This method is like `_.union` except that it accepts `comparator` which
		     * is invoked to compare elements of `arrays`. Result values are chosen from
		     * the first array in which the value occurs. The comparator is invoked
		     * with two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of combined values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.unionWith(objects, others, _.isEqual);
		     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
		     */
		    var unionWith = baseRest(function(arrays) {
		      var comparator = last(arrays);
		      comparator = typeof comparator == 'function' ? comparator : undefined$1;
		      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
		    });

		    /**
		     * Creates a duplicate-free version of an array, using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons, in which only the first occurrence of each element
		     * is kept. The order of result values is determined by the order they occur
		     * in the array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.uniq([2, 1, 2]);
		     * // => [2, 1]
		     */
		    function uniq(array) {
		      return (array && array.length) ? baseUniq(array) : [];
		    }

		    /**
		     * This method is like `_.uniq` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the criterion by which
		     * uniqueness is computed. The order of result values is determined by the
		     * order they occur in the array. The iteratee is invoked with one argument:
		     * (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
		     * // => [2.1, 1.2]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 1 }, { 'x': 2 }]
		     */
		    function uniqBy(array, iteratee) {
		      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
		    }

		    /**
		     * This method is like `_.uniq` except that it accepts `comparator` which
		     * is invoked to compare elements of `array`. The order of result values is
		     * determined by the order they occur in the array.The comparator is invoked
		     * with two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.uniqWith(objects, _.isEqual);
		     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
		     */
		    function uniqWith(array, comparator) {
		      comparator = typeof comparator == 'function' ? comparator : undefined$1;
		      return (array && array.length) ? baseUniq(array, undefined$1, comparator) : [];
		    }

		    /**
		     * This method is like `_.zip` except that it accepts an array of grouped
		     * elements and creates an array regrouping the elements to their pre-zip
		     * configuration.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.2.0
		     * @category Array
		     * @param {Array} array The array of grouped elements to process.
		     * @returns {Array} Returns the new array of regrouped elements.
		     * @example
		     *
		     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
		     * // => [['a', 1, true], ['b', 2, false]]
		     *
		     * _.unzip(zipped);
		     * // => [['a', 'b'], [1, 2], [true, false]]
		     */
		    function unzip(array) {
		      if (!(array && array.length)) {
		        return [];
		      }
		      var length = 0;
		      array = arrayFilter(array, function(group) {
		        if (isArrayLikeObject(group)) {
		          length = nativeMax(group.length, length);
		          return true;
		        }
		      });
		      return baseTimes(length, function(index) {
		        return arrayMap(array, baseProperty(index));
		      });
		    }

		    /**
		     * This method is like `_.unzip` except that it accepts `iteratee` to specify
		     * how regrouped values should be combined. The iteratee is invoked with the
		     * elements of each group: (...group).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.8.0
		     * @category Array
		     * @param {Array} array The array of grouped elements to process.
		     * @param {Function} [iteratee=_.identity] The function to combine
		     *  regrouped values.
		     * @returns {Array} Returns the new array of regrouped elements.
		     * @example
		     *
		     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
		     * // => [[1, 10, 100], [2, 20, 200]]
		     *
		     * _.unzipWith(zipped, _.add);
		     * // => [3, 30, 300]
		     */
		    function unzipWith(array, iteratee) {
		      if (!(array && array.length)) {
		        return [];
		      }
		      var result = unzip(array);
		      if (iteratee == null) {
		        return result;
		      }
		      return arrayMap(result, function(group) {
		        return apply(iteratee, undefined$1, group);
		      });
		    }

		    /**
		     * Creates an array excluding all given values using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * **Note:** Unlike `_.pull`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...*} [values] The values to exclude.
		     * @returns {Array} Returns the new array of filtered values.
		     * @see _.difference, _.xor
		     * @example
		     *
		     * _.without([2, 1, 2, 3], 1, 2);
		     * // => [3]
		     */
		    var without = baseRest(function(array, values) {
		      return isArrayLikeObject(array)
		        ? baseDifference(array, values)
		        : [];
		    });

		    /**
		     * Creates an array of unique values that is the
		     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
		     * of the given arrays. The order of result values is determined by the order
		     * they occur in the arrays.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @returns {Array} Returns the new array of filtered values.
		     * @see _.difference, _.without
		     * @example
		     *
		     * _.xor([2, 1], [2, 3]);
		     * // => [1, 3]
		     */
		    var xor = baseRest(function(arrays) {
		      return baseXor(arrayFilter(arrays, isArrayLikeObject));
		    });

		    /**
		     * This method is like `_.xor` except that it accepts `iteratee` which is
		     * invoked for each element of each `arrays` to generate the criterion by
		     * which by which they're compared. The order of result values is determined
		     * by the order they occur in the arrays. The iteratee is invoked with one
		     * argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
		     * // => [1.2, 3.4]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 2 }]
		     */
		    var xorBy = baseRest(function(arrays) {
		      var iteratee = last(arrays);
		      if (isArrayLikeObject(iteratee)) {
		        iteratee = undefined$1;
		      }
		      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
		    });

		    /**
		     * This method is like `_.xor` except that it accepts `comparator` which is
		     * invoked to compare elements of `arrays`. The order of result values is
		     * determined by the order they occur in the arrays. The comparator is invoked
		     * with two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.xorWith(objects, others, _.isEqual);
		     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
		     */
		    var xorWith = baseRest(function(arrays) {
		      var comparator = last(arrays);
		      comparator = typeof comparator == 'function' ? comparator : undefined$1;
		      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
		    });

		    /**
		     * Creates an array of grouped elements, the first of which contains the
		     * first elements of the given arrays, the second of which contains the
		     * second elements of the given arrays, and so on.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to process.
		     * @returns {Array} Returns the new array of grouped elements.
		     * @example
		     *
		     * _.zip(['a', 'b'], [1, 2], [true, false]);
		     * // => [['a', 1, true], ['b', 2, false]]
		     */
		    var zip = baseRest(unzip);

		    /**
		     * This method is like `_.fromPairs` except that it accepts two arrays,
		     * one of property identifiers and one of corresponding values.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.4.0
		     * @category Array
		     * @param {Array} [props=[]] The property identifiers.
		     * @param {Array} [values=[]] The property values.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * _.zipObject(['a', 'b'], [1, 2]);
		     * // => { 'a': 1, 'b': 2 }
		     */
		    function zipObject(props, values) {
		      return baseZipObject(props || [], values || [], assignValue);
		    }

		    /**
		     * This method is like `_.zipObject` except that it supports property paths.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.1.0
		     * @category Array
		     * @param {Array} [props=[]] The property identifiers.
		     * @param {Array} [values=[]] The property values.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
		     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
		     */
		    function zipObjectDeep(props, values) {
		      return baseZipObject(props || [], values || [], baseSet);
		    }

		    /**
		     * This method is like `_.zip` except that it accepts `iteratee` to specify
		     * how grouped values should be combined. The iteratee is invoked with the
		     * elements of each group: (...group).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.8.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to process.
		     * @param {Function} [iteratee=_.identity] The function to combine
		     *  grouped values.
		     * @returns {Array} Returns the new array of grouped elements.
		     * @example
		     *
		     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
		     *   return a + b + c;
		     * });
		     * // => [111, 222]
		     */
		    var zipWith = baseRest(function(arrays) {
		      var length = arrays.length,
		          iteratee = length > 1 ? arrays[length - 1] : undefined$1;

		      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined$1;
		      return unzipWith(arrays, iteratee);
		    });

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
		     * chain sequences enabled. The result of such sequences must be unwrapped
		     * with `_#value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.3.0
		     * @category Seq
		     * @param {*} value The value to wrap.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'age': 36 },
		     *   { 'user': 'fred',    'age': 40 },
		     *   { 'user': 'pebbles', 'age': 1 }
		     * ];
		     *
		     * var youngest = _
		     *   .chain(users)
		     *   .sortBy('age')
		     *   .map(function(o) {
		     *     return o.user + ' is ' + o.age;
		     *   })
		     *   .head()
		     *   .value();
		     * // => 'pebbles is 1'
		     */
		    function chain(value) {
		      var result = lodash(value);
		      result.__chain__ = true;
		      return result;
		    }

		    /**
		     * This method invokes `interceptor` and returns `value`. The interceptor
		     * is invoked with one argument; (value). The purpose of this method is to
		     * "tap into" a method chain sequence in order to modify intermediate results.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Seq
		     * @param {*} value The value to provide to `interceptor`.
		     * @param {Function} interceptor The function to invoke.
		     * @returns {*} Returns `value`.
		     * @example
		     *
		     * _([1, 2, 3])
		     *  .tap(function(array) {
		     *    // Mutate input array.
		     *    array.pop();
		     *  })
		     *  .reverse()
		     *  .value();
		     * // => [2, 1]
		     */
		    function tap(value, interceptor) {
		      interceptor(value);
		      return value;
		    }

		    /**
		     * This method is like `_.tap` except that it returns the result of `interceptor`.
		     * The purpose of this method is to "pass thru" values replacing intermediate
		     * results in a method chain sequence.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Seq
		     * @param {*} value The value to provide to `interceptor`.
		     * @param {Function} interceptor The function to invoke.
		     * @returns {*} Returns the result of `interceptor`.
		     * @example
		     *
		     * _('  abc  ')
		     *  .chain()
		     *  .trim()
		     *  .thru(function(value) {
		     *    return [value];
		     *  })
		     *  .value();
		     * // => ['abc']
		     */
		    function thru(value, interceptor) {
		      return interceptor(value);
		    }

		    /**
		     * This method is the wrapper version of `_.at`.
		     *
		     * @name at
		     * @memberOf _
		     * @since 1.0.0
		     * @category Seq
		     * @param {...(string|string[])} [paths] The property paths to pick.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
		     *
		     * _(object).at(['a[0].b.c', 'a[1]']).value();
		     * // => [3, 4]
		     */
		    var wrapperAt = flatRest(function(paths) {
		      var length = paths.length,
		          start = length ? paths[0] : 0,
		          value = this.__wrapped__,
		          interceptor = function(object) { return baseAt(object, paths); };

		      if (length > 1 || this.__actions__.length ||
		          !(value instanceof LazyWrapper) || !isIndex(start)) {
		        return this.thru(interceptor);
		      }
		      value = value.slice(start, +start + (length ? 1 : 0));
		      value.__actions__.push({
		        'func': thru,
		        'args': [interceptor],
		        'thisArg': undefined$1
		      });
		      return new LodashWrapper(value, this.__chain__).thru(function(array) {
		        if (length && !array.length) {
		          array.push(undefined$1);
		        }
		        return array;
		      });
		    });

		    /**
		     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
		     *
		     * @name chain
		     * @memberOf _
		     * @since 0.1.0
		     * @category Seq
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36 },
		     *   { 'user': 'fred',   'age': 40 }
		     * ];
		     *
		     * // A sequence without explicit chaining.
		     * _(users).head();
		     * // => { 'user': 'barney', 'age': 36 }
		     *
		     * // A sequence with explicit chaining.
		     * _(users)
		     *   .chain()
		     *   .head()
		     *   .pick('user')
		     *   .value();
		     * // => { 'user': 'barney' }
		     */
		    function wrapperChain() {
		      return chain(this);
		    }

		    /**
		     * Executes the chain sequence and returns the wrapped result.
		     *
		     * @name commit
		     * @memberOf _
		     * @since 3.2.0
		     * @category Seq
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var array = [1, 2];
		     * var wrapped = _(array).push(3);
		     *
		     * console.log(array);
		     * // => [1, 2]
		     *
		     * wrapped = wrapped.commit();
		     * console.log(array);
		     * // => [1, 2, 3]
		     *
		     * wrapped.last();
		     * // => 3
		     *
		     * console.log(array);
		     * // => [1, 2, 3]
		     */
		    function wrapperCommit() {
		      return new LodashWrapper(this.value(), this.__chain__);
		    }

		    /**
		     * Gets the next value on a wrapped object following the
		     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
		     *
		     * @name next
		     * @memberOf _
		     * @since 4.0.0
		     * @category Seq
		     * @returns {Object} Returns the next iterator value.
		     * @example
		     *
		     * var wrapped = _([1, 2]);
		     *
		     * wrapped.next();
		     * // => { 'done': false, 'value': 1 }
		     *
		     * wrapped.next();
		     * // => { 'done': false, 'value': 2 }
		     *
		     * wrapped.next();
		     * // => { 'done': true, 'value': undefined }
		     */
		    function wrapperNext() {
		      if (this.__values__ === undefined$1) {
		        this.__values__ = toArray(this.value());
		      }
		      var done = this.__index__ >= this.__values__.length,
		          value = done ? undefined$1 : this.__values__[this.__index__++];

		      return { 'done': done, 'value': value };
		    }

		    /**
		     * Enables the wrapper to be iterable.
		     *
		     * @name Symbol.iterator
		     * @memberOf _
		     * @since 4.0.0
		     * @category Seq
		     * @returns {Object} Returns the wrapper object.
		     * @example
		     *
		     * var wrapped = _([1, 2]);
		     *
		     * wrapped[Symbol.iterator]() === wrapped;
		     * // => true
		     *
		     * Array.from(wrapped);
		     * // => [1, 2]
		     */
		    function wrapperToIterator() {
		      return this;
		    }

		    /**
		     * Creates a clone of the chain sequence planting `value` as the wrapped value.
		     *
		     * @name plant
		     * @memberOf _
		     * @since 3.2.0
		     * @category Seq
		     * @param {*} value The value to plant.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var wrapped = _([1, 2]).map(square);
		     * var other = wrapped.plant([3, 4]);
		     *
		     * other.value();
		     * // => [9, 16]
		     *
		     * wrapped.value();
		     * // => [1, 4]
		     */
		    function wrapperPlant(value) {
		      var result,
		          parent = this;

		      while (parent instanceof baseLodash) {
		        var clone = wrapperClone(parent);
		        clone.__index__ = 0;
		        clone.__values__ = undefined$1;
		        if (result) {
		          previous.__wrapped__ = clone;
		        } else {
		          result = clone;
		        }
		        var previous = clone;
		        parent = parent.__wrapped__;
		      }
		      previous.__wrapped__ = value;
		      return result;
		    }

		    /**
		     * This method is the wrapper version of `_.reverse`.
		     *
		     * **Note:** This method mutates the wrapped array.
		     *
		     * @name reverse
		     * @memberOf _
		     * @since 0.1.0
		     * @category Seq
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var array = [1, 2, 3];
		     *
		     * _(array).reverse().value()
		     * // => [3, 2, 1]
		     *
		     * console.log(array);
		     * // => [3, 2, 1]
		     */
		    function wrapperReverse() {
		      var value = this.__wrapped__;
		      if (value instanceof LazyWrapper) {
		        var wrapped = value;
		        if (this.__actions__.length) {
		          wrapped = new LazyWrapper(this);
		        }
		        wrapped = wrapped.reverse();
		        wrapped.__actions__.push({
		          'func': thru,
		          'args': [reverse],
		          'thisArg': undefined$1
		        });
		        return new LodashWrapper(wrapped, this.__chain__);
		      }
		      return this.thru(reverse);
		    }

		    /**
		     * Executes the chain sequence to resolve the unwrapped value.
		     *
		     * @name value
		     * @memberOf _
		     * @since 0.1.0
		     * @alias toJSON, valueOf
		     * @category Seq
		     * @returns {*} Returns the resolved unwrapped value.
		     * @example
		     *
		     * _([1, 2, 3]).value();
		     * // => [1, 2, 3]
		     */
		    function wrapperValue() {
		      return baseWrapperValue(this.__wrapped__, this.__actions__);
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates an object composed of keys generated from the results of running
		     * each element of `collection` thru `iteratee`. The corresponding value of
		     * each key is the number of times the key was returned by `iteratee`. The
		     * iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.5.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
		     * @returns {Object} Returns the composed aggregate object.
		     * @example
		     *
		     * _.countBy([6.1, 4.2, 6.3], Math.floor);
		     * // => { '4': 1, '6': 2 }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.countBy(['one', 'two', 'three'], 'length');
		     * // => { '3': 2, '5': 1 }
		     */
		    var countBy = createAggregator(function(result, value, key) {
		      if (hasOwnProperty.call(result, key)) {
		        ++result[key];
		      } else {
		        baseAssignValue(result, key, 1);
		      }
		    });

		    /**
		     * Checks if `predicate` returns truthy for **all** elements of `collection`.
		     * Iteration is stopped once `predicate` returns falsey. The predicate is
		     * invoked with three arguments: (value, index|key, collection).
		     *
		     * **Note:** This method returns `true` for
		     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
		     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
		     * elements of empty collections.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {boolean} Returns `true` if all elements pass the predicate check,
		     *  else `false`.
		     * @example
		     *
		     * _.every([true, 1, null, 'yes'], Boolean);
		     * // => false
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': false },
		     *   { 'user': 'fred',   'age': 40, 'active': false }
		     * ];
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.every(users, { 'user': 'barney', 'active': false });
		     * // => false
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.every(users, ['active', false]);
		     * // => true
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.every(users, 'active');
		     * // => false
		     */
		    function every(collection, predicate, guard) {
		      var func = isArray(collection) ? arrayEvery : baseEvery;
		      if (guard && isIterateeCall(collection, predicate, guard)) {
		        predicate = undefined$1;
		      }
		      return func(collection, getIteratee(predicate, 3));
		    }

		    /**
		     * Iterates over elements of `collection`, returning an array of all elements
		     * `predicate` returns truthy for. The predicate is invoked with three
		     * arguments: (value, index|key, collection).
		     *
		     * **Note:** Unlike `_.remove`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new filtered array.
		     * @see _.reject
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': true },
		     *   { 'user': 'fred',   'age': 40, 'active': false }
		     * ];
		     *
		     * _.filter(users, function(o) { return !o.active; });
		     * // => objects for ['fred']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.filter(users, { 'age': 36, 'active': true });
		     * // => objects for ['barney']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.filter(users, ['active', false]);
		     * // => objects for ['fred']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.filter(users, 'active');
		     * // => objects for ['barney']
		     *
		     * // Combining several predicates using `_.overEvery` or `_.overSome`.
		     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
		     * // => objects for ['fred', 'barney']
		     */
		    function filter(collection, predicate) {
		      var func = isArray(collection) ? arrayFilter : baseFilter;
		      return func(collection, getIteratee(predicate, 3));
		    }

		    /**
		     * Iterates over elements of `collection`, returning the first element
		     * `predicate` returns truthy for. The predicate is invoked with three
		     * arguments: (value, index|key, collection).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @returns {*} Returns the matched element, else `undefined`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'age': 36, 'active': true },
		     *   { 'user': 'fred',    'age': 40, 'active': false },
		     *   { 'user': 'pebbles', 'age': 1,  'active': true }
		     * ];
		     *
		     * _.find(users, function(o) { return o.age < 40; });
		     * // => object for 'barney'
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.find(users, { 'age': 1, 'active': true });
		     * // => object for 'pebbles'
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.find(users, ['active', false]);
		     * // => object for 'fred'
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.find(users, 'active');
		     * // => object for 'barney'
		     */
		    var find = createFind(findIndex);

		    /**
		     * This method is like `_.find` except that it iterates over elements of
		     * `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param {number} [fromIndex=collection.length-1] The index to search from.
		     * @returns {*} Returns the matched element, else `undefined`.
		     * @example
		     *
		     * _.findLast([1, 2, 3, 4], function(n) {
		     *   return n % 2 == 1;
		     * });
		     * // => 3
		     */
		    var findLast = createFind(findLastIndex);

		    /**
		     * Creates a flattened array of values by running each element in `collection`
		     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
		     * with three arguments: (value, index|key, collection).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * function duplicate(n) {
		     *   return [n, n];
		     * }
		     *
		     * _.flatMap([1, 2], duplicate);
		     * // => [1, 1, 2, 2]
		     */
		    function flatMap(collection, iteratee) {
		      return baseFlatten(map(collection, iteratee), 1);
		    }

		    /**
		     * This method is like `_.flatMap` except that it recursively flattens the
		     * mapped results.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * function duplicate(n) {
		     *   return [[[n, n]]];
		     * }
		     *
		     * _.flatMapDeep([1, 2], duplicate);
		     * // => [1, 1, 2, 2]
		     */
		    function flatMapDeep(collection, iteratee) {
		      return baseFlatten(map(collection, iteratee), INFINITY);
		    }

		    /**
		     * This method is like `_.flatMap` except that it recursively flattens the
		     * mapped results up to `depth` times.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {number} [depth=1] The maximum recursion depth.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * function duplicate(n) {
		     *   return [[[n, n]]];
		     * }
		     *
		     * _.flatMapDepth([1, 2], duplicate, 2);
		     * // => [[1, 1], [2, 2]]
		     */
		    function flatMapDepth(collection, iteratee, depth) {
		      depth = depth === undefined$1 ? 1 : toInteger(depth);
		      return baseFlatten(map(collection, iteratee), depth);
		    }

		    /**
		     * Iterates over elements of `collection` and invokes `iteratee` for each element.
		     * The iteratee is invoked with three arguments: (value, index|key, collection).
		     * Iteratee functions may exit iteration early by explicitly returning `false`.
		     *
		     * **Note:** As with other "Collections" methods, objects with a "length"
		     * property are iterated like arrays. To avoid this behavior use `_.forIn`
		     * or `_.forOwn` for object iteration.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @alias each
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     * @see _.forEachRight
		     * @example
		     *
		     * _.forEach([1, 2], function(value) {
		     *   console.log(value);
		     * });
		     * // => Logs `1` then `2`.
		     *
		     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
		     */
		    function forEach(collection, iteratee) {
		      var func = isArray(collection) ? arrayEach : baseEach;
		      return func(collection, getIteratee(iteratee, 3));
		    }

		    /**
		     * This method is like `_.forEach` except that it iterates over elements of
		     * `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @alias eachRight
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     * @see _.forEach
		     * @example
		     *
		     * _.forEachRight([1, 2], function(value) {
		     *   console.log(value);
		     * });
		     * // => Logs `2` then `1`.
		     */
		    function forEachRight(collection, iteratee) {
		      var func = isArray(collection) ? arrayEachRight : baseEachRight;
		      return func(collection, getIteratee(iteratee, 3));
		    }

		    /**
		     * Creates an object composed of keys generated from the results of running
		     * each element of `collection` thru `iteratee`. The order of grouped values
		     * is determined by the order they occur in `collection`. The corresponding
		     * value of each key is an array of elements responsible for generating the
		     * key. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
		     * @returns {Object} Returns the composed aggregate object.
		     * @example
		     *
		     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
		     * // => { '4': [4.2], '6': [6.1, 6.3] }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.groupBy(['one', 'two', 'three'], 'length');
		     * // => { '3': ['one', 'two'], '5': ['three'] }
		     */
		    var groupBy = createAggregator(function(result, value, key) {
		      if (hasOwnProperty.call(result, key)) {
		        result[key].push(value);
		      } else {
		        baseAssignValue(result, key, [value]);
		      }
		    });

		    /**
		     * Checks if `value` is in `collection`. If `collection` is a string, it's
		     * checked for a substring of `value`, otherwise
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * is used for equality comparisons. If `fromIndex` is negative, it's used as
		     * the offset from the end of `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object|string} collection The collection to inspect.
		     * @param {*} value The value to search for.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
		     * @returns {boolean} Returns `true` if `value` is found, else `false`.
		     * @example
		     *
		     * _.includes([1, 2, 3], 1);
		     * // => true
		     *
		     * _.includes([1, 2, 3], 1, 2);
		     * // => false
		     *
		     * _.includes({ 'a': 1, 'b': 2 }, 1);
		     * // => true
		     *
		     * _.includes('abcd', 'bc');
		     * // => true
		     */
		    function includes(collection, value, fromIndex, guard) {
		      collection = isArrayLike(collection) ? collection : values(collection);
		      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

		      var length = collection.length;
		      if (fromIndex < 0) {
		        fromIndex = nativeMax(length + fromIndex, 0);
		      }
		      return isString(collection)
		        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
		        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
		    }

		    /**
		     * Invokes the method at `path` of each element in `collection`, returning
		     * an array of the results of each invoked method. Any additional arguments
		     * are provided to each invoked method. If `path` is a function, it's invoked
		     * for, and `this` bound to, each element in `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array|Function|string} path The path of the method to invoke or
		     *  the function invoked per iteration.
		     * @param {...*} [args] The arguments to invoke each method with.
		     * @returns {Array} Returns the array of results.
		     * @example
		     *
		     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
		     * // => [[1, 5, 7], [1, 2, 3]]
		     *
		     * _.invokeMap([123, 456], String.prototype.split, '');
		     * // => [['1', '2', '3'], ['4', '5', '6']]
		     */
		    var invokeMap = baseRest(function(collection, path, args) {
		      var index = -1,
		          isFunc = typeof path == 'function',
		          result = isArrayLike(collection) ? Array(collection.length) : [];

		      baseEach(collection, function(value) {
		        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
		      });
		      return result;
		    });

		    /**
		     * Creates an object composed of keys generated from the results of running
		     * each element of `collection` thru `iteratee`. The corresponding value of
		     * each key is the last element responsible for generating the key. The
		     * iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
		     * @returns {Object} Returns the composed aggregate object.
		     * @example
		     *
		     * var array = [
		     *   { 'dir': 'left', 'code': 97 },
		     *   { 'dir': 'right', 'code': 100 }
		     * ];
		     *
		     * _.keyBy(array, function(o) {
		     *   return String.fromCharCode(o.code);
		     * });
		     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
		     *
		     * _.keyBy(array, 'dir');
		     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
		     */
		    var keyBy = createAggregator(function(result, value, key) {
		      baseAssignValue(result, key, value);
		    });

		    /**
		     * Creates an array of values by running each element in `collection` thru
		     * `iteratee`. The iteratee is invoked with three arguments:
		     * (value, index|key, collection).
		     *
		     * Many lodash methods are guarded to work as iteratees for methods like
		     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
		     *
		     * The guarded methods are:
		     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
		     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
		     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
		     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new mapped array.
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * _.map([4, 8], square);
		     * // => [16, 64]
		     *
		     * _.map({ 'a': 4, 'b': 8 }, square);
		     * // => [16, 64] (iteration order is not guaranteed)
		     *
		     * var users = [
		     *   { 'user': 'barney' },
		     *   { 'user': 'fred' }
		     * ];
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.map(users, 'user');
		     * // => ['barney', 'fred']
		     */
		    function map(collection, iteratee) {
		      var func = isArray(collection) ? arrayMap : baseMap;
		      return func(collection, getIteratee(iteratee, 3));
		    }

		    /**
		     * This method is like `_.sortBy` except that it allows specifying the sort
		     * orders of the iteratees to sort by. If `orders` is unspecified, all values
		     * are sorted in ascending order. Otherwise, specify an order of "desc" for
		     * descending or "asc" for ascending sort order of corresponding values.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
		     *  The iteratees to sort by.
		     * @param {string[]} [orders] The sort orders of `iteratees`.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
		     * @returns {Array} Returns the new sorted array.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'fred',   'age': 48 },
		     *   { 'user': 'barney', 'age': 34 },
		     *   { 'user': 'fred',   'age': 40 },
		     *   { 'user': 'barney', 'age': 36 }
		     * ];
		     *
		     * // Sort by `user` in ascending order and by `age` in descending order.
		     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
		     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
		     */
		    function orderBy(collection, iteratees, orders, guard) {
		      if (collection == null) {
		        return [];
		      }
		      if (!isArray(iteratees)) {
		        iteratees = iteratees == null ? [] : [iteratees];
		      }
		      orders = guard ? undefined$1 : orders;
		      if (!isArray(orders)) {
		        orders = orders == null ? [] : [orders];
		      }
		      return baseOrderBy(collection, iteratees, orders);
		    }

		    /**
		     * Creates an array of elements split into two groups, the first of which
		     * contains elements `predicate` returns truthy for, the second of which
		     * contains elements `predicate` returns falsey for. The predicate is
		     * invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the array of grouped elements.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'age': 36, 'active': false },
		     *   { 'user': 'fred',    'age': 40, 'active': true },
		     *   { 'user': 'pebbles', 'age': 1,  'active': false }
		     * ];
		     *
		     * _.partition(users, function(o) { return o.active; });
		     * // => objects for [['fred'], ['barney', 'pebbles']]
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.partition(users, { 'age': 1, 'active': false });
		     * // => objects for [['pebbles'], ['barney', 'fred']]
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.partition(users, ['active', false]);
		     * // => objects for [['barney', 'pebbles'], ['fred']]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.partition(users, 'active');
		     * // => objects for [['fred'], ['barney', 'pebbles']]
		     */
		    var partition = createAggregator(function(result, value, key) {
		      result[key ? 0 : 1].push(value);
		    }, function() { return [[], []]; });

		    /**
		     * Reduces `collection` to a value which is the accumulated result of running
		     * each element in `collection` thru `iteratee`, where each successive
		     * invocation is supplied the return value of the previous. If `accumulator`
		     * is not given, the first element of `collection` is used as the initial
		     * value. The iteratee is invoked with four arguments:
		     * (accumulator, value, index|key, collection).
		     *
		     * Many lodash methods are guarded to work as iteratees for methods like
		     * `_.reduce`, `_.reduceRight`, and `_.transform`.
		     *
		     * The guarded methods are:
		     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
		     * and `sortBy`
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {*} [accumulator] The initial value.
		     * @returns {*} Returns the accumulated value.
		     * @see _.reduceRight
		     * @example
		     *
		     * _.reduce([1, 2], function(sum, n) {
		     *   return sum + n;
		     * }, 0);
		     * // => 3
		     *
		     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
		     *   (result[value] || (result[value] = [])).push(key);
		     *   return result;
		     * }, {});
		     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
		     */
		    function reduce(collection, iteratee, accumulator) {
		      var func = isArray(collection) ? arrayReduce : baseReduce,
		          initAccum = arguments.length < 3;

		      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
		    }

		    /**
		     * This method is like `_.reduce` except that it iterates over elements of
		     * `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {*} [accumulator] The initial value.
		     * @returns {*} Returns the accumulated value.
		     * @see _.reduce
		     * @example
		     *
		     * var array = [[0, 1], [2, 3], [4, 5]];
		     *
		     * _.reduceRight(array, function(flattened, other) {
		     *   return flattened.concat(other);
		     * }, []);
		     * // => [4, 5, 2, 3, 0, 1]
		     */
		    function reduceRight(collection, iteratee, accumulator) {
		      var func = isArray(collection) ? arrayReduceRight : baseReduce,
		          initAccum = arguments.length < 3;

		      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
		    }

		    /**
		     * The opposite of `_.filter`; this method returns the elements of `collection`
		     * that `predicate` does **not** return truthy for.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new filtered array.
		     * @see _.filter
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': false },
		     *   { 'user': 'fred',   'age': 40, 'active': true }
		     * ];
		     *
		     * _.reject(users, function(o) { return !o.active; });
		     * // => objects for ['fred']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.reject(users, { 'age': 40, 'active': true });
		     * // => objects for ['barney']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.reject(users, ['active', false]);
		     * // => objects for ['fred']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.reject(users, 'active');
		     * // => objects for ['barney']
		     */
		    function reject(collection, predicate) {
		      var func = isArray(collection) ? arrayFilter : baseFilter;
		      return func(collection, negate(getIteratee(predicate, 3)));
		    }

		    /**
		     * Gets a random element from `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to sample.
		     * @returns {*} Returns the random element.
		     * @example
		     *
		     * _.sample([1, 2, 3, 4]);
		     * // => 2
		     */
		    function sample(collection) {
		      var func = isArray(collection) ? arraySample : baseSample;
		      return func(collection);
		    }

		    /**
		     * Gets `n` random elements at unique keys from `collection` up to the
		     * size of `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to sample.
		     * @param {number} [n=1] The number of elements to sample.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the random elements.
		     * @example
		     *
		     * _.sampleSize([1, 2, 3], 2);
		     * // => [3, 1]
		     *
		     * _.sampleSize([1, 2, 3], 4);
		     * // => [2, 3, 1]
		     */
		    function sampleSize(collection, n, guard) {
		      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined$1)) {
		        n = 1;
		      } else {
		        n = toInteger(n);
		      }
		      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
		      return func(collection, n);
		    }

		    /**
		     * Creates an array of shuffled values, using a version of the
		     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to shuffle.
		     * @returns {Array} Returns the new shuffled array.
		     * @example
		     *
		     * _.shuffle([1, 2, 3, 4]);
		     * // => [4, 1, 3, 2]
		     */
		    function shuffle(collection) {
		      var func = isArray(collection) ? arrayShuffle : baseShuffle;
		      return func(collection);
		    }

		    /**
		     * Gets the size of `collection` by returning its length for array-like
		     * values or the number of own enumerable string keyed properties for objects.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object|string} collection The collection to inspect.
		     * @returns {number} Returns the collection size.
		     * @example
		     *
		     * _.size([1, 2, 3]);
		     * // => 3
		     *
		     * _.size({ 'a': 1, 'b': 2 });
		     * // => 2
		     *
		     * _.size('pebbles');
		     * // => 7
		     */
		    function size(collection) {
		      if (collection == null) {
		        return 0;
		      }
		      if (isArrayLike(collection)) {
		        return isString(collection) ? stringSize(collection) : collection.length;
		      }
		      var tag = getTag(collection);
		      if (tag == mapTag || tag == setTag) {
		        return collection.size;
		      }
		      return baseKeys(collection).length;
		    }

		    /**
		     * Checks if `predicate` returns truthy for **any** element of `collection`.
		     * Iteration is stopped once `predicate` returns truthy. The predicate is
		     * invoked with three arguments: (value, index|key, collection).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {boolean} Returns `true` if any element passes the predicate check,
		     *  else `false`.
		     * @example
		     *
		     * _.some([null, 0, 'yes', false], Boolean);
		     * // => true
		     *
		     * var users = [
		     *   { 'user': 'barney', 'active': true },
		     *   { 'user': 'fred',   'active': false }
		     * ];
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.some(users, { 'user': 'barney', 'active': false });
		     * // => false
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.some(users, ['active', false]);
		     * // => true
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.some(users, 'active');
		     * // => true
		     */
		    function some(collection, predicate, guard) {
		      var func = isArray(collection) ? arraySome : baseSome;
		      if (guard && isIterateeCall(collection, predicate, guard)) {
		        predicate = undefined$1;
		      }
		      return func(collection, getIteratee(predicate, 3));
		    }

		    /**
		     * Creates an array of elements, sorted in ascending order by the results of
		     * running each element in a collection thru each iteratee. This method
		     * performs a stable sort, that is, it preserves the original sort order of
		     * equal elements. The iteratees are invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {...(Function|Function[])} [iteratees=[_.identity]]
		     *  The iteratees to sort by.
		     * @returns {Array} Returns the new sorted array.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'fred',   'age': 48 },
		     *   { 'user': 'barney', 'age': 36 },
		     *   { 'user': 'fred',   'age': 30 },
		     *   { 'user': 'barney', 'age': 34 }
		     * ];
		     *
		     * _.sortBy(users, [function(o) { return o.user; }]);
		     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
		     *
		     * _.sortBy(users, ['user', 'age']);
		     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
		     */
		    var sortBy = baseRest(function(collection, iteratees) {
		      if (collection == null) {
		        return [];
		      }
		      var length = iteratees.length;
		      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
		        iteratees = [];
		      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
		        iteratees = [iteratees[0]];
		      }
		      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
		    });

		    /*------------------------------------------------------------------------*/

		    /**
		     * Gets the timestamp of the number of milliseconds that have elapsed since
		     * the Unix epoch (1 January 1970 00:00:00 UTC).
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Date
		     * @returns {number} Returns the timestamp.
		     * @example
		     *
		     * _.defer(function(stamp) {
		     *   console.log(_.now() - stamp);
		     * }, _.now());
		     * // => Logs the number of milliseconds it took for the deferred invocation.
		     */
		    var now = ctxNow || function() {
		      return root.Date.now();
		    };

		    /*------------------------------------------------------------------------*/

		    /**
		     * The opposite of `_.before`; this method creates a function that invokes
		     * `func` once it's called `n` or more times.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {number} n The number of calls before `func` is invoked.
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new restricted function.
		     * @example
		     *
		     * var saves = ['profile', 'settings'];
		     *
		     * var done = _.after(saves.length, function() {
		     *   console.log('done saving!');
		     * });
		     *
		     * _.forEach(saves, function(type) {
		     *   asyncSave({ 'type': type, 'complete': done });
		     * });
		     * // => Logs 'done saving!' after the two async saves have completed.
		     */
		    function after(n, func) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      n = toInteger(n);
		      return function() {
		        if (--n < 1) {
		          return func.apply(this, arguments);
		        }
		      };
		    }

		    /**
		     * Creates a function that invokes `func`, with up to `n` arguments,
		     * ignoring any additional arguments.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} func The function to cap arguments for.
		     * @param {number} [n=func.length] The arity cap.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the new capped function.
		     * @example
		     *
		     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
		     * // => [6, 8, 10]
		     */
		    function ary(func, n, guard) {
		      n = guard ? undefined$1 : n;
		      n = (func && n == null) ? func.length : n;
		      return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
		    }

		    /**
		     * Creates a function that invokes `func`, with the `this` binding and arguments
		     * of the created function, while it's called less than `n` times. Subsequent
		     * calls to the created function return the result of the last `func` invocation.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {number} n The number of calls at which `func` is no longer invoked.
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new restricted function.
		     * @example
		     *
		     * jQuery(element).on('click', _.before(5, addContactToList));
		     * // => Allows adding up to 4 contacts to the list.
		     */
		    function before(n, func) {
		      var result;
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      n = toInteger(n);
		      return function() {
		        if (--n > 0) {
		          result = func.apply(this, arguments);
		        }
		        if (n <= 1) {
		          func = undefined$1;
		        }
		        return result;
		      };
		    }

		    /**
		     * Creates a function that invokes `func` with the `this` binding of `thisArg`
		     * and `partials` prepended to the arguments it receives.
		     *
		     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
		     * may be used as a placeholder for partially applied arguments.
		     *
		     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
		     * property of bound functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to bind.
		     * @param {*} thisArg The `this` binding of `func`.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new bound function.
		     * @example
		     *
		     * function greet(greeting, punctuation) {
		     *   return greeting + ' ' + this.user + punctuation;
		     * }
		     *
		     * var object = { 'user': 'fred' };
		     *
		     * var bound = _.bind(greet, object, 'hi');
		     * bound('!');
		     * // => 'hi fred!'
		     *
		     * // Bound with placeholders.
		     * var bound = _.bind(greet, object, _, '!');
		     * bound('hi');
		     * // => 'hi fred!'
		     */
		    var bind = baseRest(function(func, thisArg, partials) {
		      var bitmask = WRAP_BIND_FLAG;
		      if (partials.length) {
		        var holders = replaceHolders(partials, getHolder(bind));
		        bitmask |= WRAP_PARTIAL_FLAG;
		      }
		      return createWrap(func, bitmask, thisArg, partials, holders);
		    });

		    /**
		     * Creates a function that invokes the method at `object[key]` with `partials`
		     * prepended to the arguments it receives.
		     *
		     * This method differs from `_.bind` by allowing bound functions to reference
		     * methods that may be redefined or don't yet exist. See
		     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
		     * for more details.
		     *
		     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for partially applied arguments.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.10.0
		     * @category Function
		     * @param {Object} object The object to invoke the method on.
		     * @param {string} key The key of the method.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new bound function.
		     * @example
		     *
		     * var object = {
		     *   'user': 'fred',
		     *   'greet': function(greeting, punctuation) {
		     *     return greeting + ' ' + this.user + punctuation;
		     *   }
		     * };
		     *
		     * var bound = _.bindKey(object, 'greet', 'hi');
		     * bound('!');
		     * // => 'hi fred!'
		     *
		     * object.greet = function(greeting, punctuation) {
		     *   return greeting + 'ya ' + this.user + punctuation;
		     * };
		     *
		     * bound('!');
		     * // => 'hiya fred!'
		     *
		     * // Bound with placeholders.
		     * var bound = _.bindKey(object, 'greet', _, '!');
		     * bound('hi');
		     * // => 'hiya fred!'
		     */
		    var bindKey = baseRest(function(object, key, partials) {
		      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
		      if (partials.length) {
		        var holders = replaceHolders(partials, getHolder(bindKey));
		        bitmask |= WRAP_PARTIAL_FLAG;
		      }
		      return createWrap(key, bitmask, object, partials, holders);
		    });

		    /**
		     * Creates a function that accepts arguments of `func` and either invokes
		     * `func` returning its result, if at least `arity` number of arguments have
		     * been provided, or returns a function that accepts the remaining `func`
		     * arguments, and so on. The arity of `func` may be specified if `func.length`
		     * is not sufficient.
		     *
		     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
		     * may be used as a placeholder for provided arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of curried functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Function
		     * @param {Function} func The function to curry.
		     * @param {number} [arity=func.length] The arity of `func`.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the new curried function.
		     * @example
		     *
		     * var abc = function(a, b, c) {
		     *   return [a, b, c];
		     * };
		     *
		     * var curried = _.curry(abc);
		     *
		     * curried(1)(2)(3);
		     * // => [1, 2, 3]
		     *
		     * curried(1, 2)(3);
		     * // => [1, 2, 3]
		     *
		     * curried(1, 2, 3);
		     * // => [1, 2, 3]
		     *
		     * // Curried with placeholders.
		     * curried(1)(_, 3)(2);
		     * // => [1, 2, 3]
		     */
		    function curry(func, arity, guard) {
		      arity = guard ? undefined$1 : arity;
		      var result = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
		      result.placeholder = curry.placeholder;
		      return result;
		    }

		    /**
		     * This method is like `_.curry` except that arguments are applied to `func`
		     * in the manner of `_.partialRight` instead of `_.partial`.
		     *
		     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for provided arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of curried functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} func The function to curry.
		     * @param {number} [arity=func.length] The arity of `func`.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the new curried function.
		     * @example
		     *
		     * var abc = function(a, b, c) {
		     *   return [a, b, c];
		     * };
		     *
		     * var curried = _.curryRight(abc);
		     *
		     * curried(3)(2)(1);
		     * // => [1, 2, 3]
		     *
		     * curried(2, 3)(1);
		     * // => [1, 2, 3]
		     *
		     * curried(1, 2, 3);
		     * // => [1, 2, 3]
		     *
		     * // Curried with placeholders.
		     * curried(3)(1, _)(2);
		     * // => [1, 2, 3]
		     */
		    function curryRight(func, arity, guard) {
		      arity = guard ? undefined$1 : arity;
		      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
		      result.placeholder = curryRight.placeholder;
		      return result;
		    }

		    /**
		     * Creates a debounced function that delays invoking `func` until after `wait`
		     * milliseconds have elapsed since the last time the debounced function was
		     * invoked. The debounced function comes with a `cancel` method to cancel
		     * delayed `func` invocations and a `flush` method to immediately invoke them.
		     * Provide `options` to indicate whether `func` should be invoked on the
		     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
		     * with the last arguments provided to the debounced function. Subsequent
		     * calls to the debounced function return the result of the last `func`
		     * invocation.
		     *
		     * **Note:** If `leading` and `trailing` options are `true`, `func` is
		     * invoked on the trailing edge of the timeout only if the debounced function
		     * is invoked more than once during the `wait` timeout.
		     *
		     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
		     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
		     *
		     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
		     * for details over the differences between `_.debounce` and `_.throttle`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to debounce.
		     * @param {number} [wait=0] The number of milliseconds to delay.
		     * @param {Object} [options={}] The options object.
		     * @param {boolean} [options.leading=false]
		     *  Specify invoking on the leading edge of the timeout.
		     * @param {number} [options.maxWait]
		     *  The maximum time `func` is allowed to be delayed before it's invoked.
		     * @param {boolean} [options.trailing=true]
		     *  Specify invoking on the trailing edge of the timeout.
		     * @returns {Function} Returns the new debounced function.
		     * @example
		     *
		     * // Avoid costly calculations while the window size is in flux.
		     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
		     *
		     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
		     * jQuery(element).on('click', _.debounce(sendMail, 300, {
		     *   'leading': true,
		     *   'trailing': false
		     * }));
		     *
		     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
		     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
		     * var source = new EventSource('/stream');
		     * jQuery(source).on('message', debounced);
		     *
		     * // Cancel the trailing debounced invocation.
		     * jQuery(window).on('popstate', debounced.cancel);
		     */
		    function debounce(func, wait, options) {
		      var lastArgs,
		          lastThis,
		          maxWait,
		          result,
		          timerId,
		          lastCallTime,
		          lastInvokeTime = 0,
		          leading = false,
		          maxing = false,
		          trailing = true;

		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      wait = toNumber(wait) || 0;
		      if (isObject(options)) {
		        leading = !!options.leading;
		        maxing = 'maxWait' in options;
		        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
		        trailing = 'trailing' in options ? !!options.trailing : trailing;
		      }

		      function invokeFunc(time) {
		        var args = lastArgs,
		            thisArg = lastThis;

		        lastArgs = lastThis = undefined$1;
		        lastInvokeTime = time;
		        result = func.apply(thisArg, args);
		        return result;
		      }

		      function leadingEdge(time) {
		        // Reset any `maxWait` timer.
		        lastInvokeTime = time;
		        // Start the timer for the trailing edge.
		        timerId = setTimeout(timerExpired, wait);
		        // Invoke the leading edge.
		        return leading ? invokeFunc(time) : result;
		      }

		      function remainingWait(time) {
		        var timeSinceLastCall = time - lastCallTime,
		            timeSinceLastInvoke = time - lastInvokeTime,
		            timeWaiting = wait - timeSinceLastCall;

		        return maxing
		          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
		          : timeWaiting;
		      }

		      function shouldInvoke(time) {
		        var timeSinceLastCall = time - lastCallTime,
		            timeSinceLastInvoke = time - lastInvokeTime;

		        // Either this is the first call, activity has stopped and we're at the
		        // trailing edge, the system time has gone backwards and we're treating
		        // it as the trailing edge, or we've hit the `maxWait` limit.
		        return (lastCallTime === undefined$1 || (timeSinceLastCall >= wait) ||
		          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
		      }

		      function timerExpired() {
		        var time = now();
		        if (shouldInvoke(time)) {
		          return trailingEdge(time);
		        }
		        // Restart the timer.
		        timerId = setTimeout(timerExpired, remainingWait(time));
		      }

		      function trailingEdge(time) {
		        timerId = undefined$1;

		        // Only invoke if we have `lastArgs` which means `func` has been
		        // debounced at least once.
		        if (trailing && lastArgs) {
		          return invokeFunc(time);
		        }
		        lastArgs = lastThis = undefined$1;
		        return result;
		      }

		      function cancel() {
		        if (timerId !== undefined$1) {
		          clearTimeout(timerId);
		        }
		        lastInvokeTime = 0;
		        lastArgs = lastCallTime = lastThis = timerId = undefined$1;
		      }

		      function flush() {
		        return timerId === undefined$1 ? result : trailingEdge(now());
		      }

		      function debounced() {
		        var time = now(),
		            isInvoking = shouldInvoke(time);

		        lastArgs = arguments;
		        lastThis = this;
		        lastCallTime = time;

		        if (isInvoking) {
		          if (timerId === undefined$1) {
		            return leadingEdge(lastCallTime);
		          }
		          if (maxing) {
		            // Handle invocations in a tight loop.
		            clearTimeout(timerId);
		            timerId = setTimeout(timerExpired, wait);
		            return invokeFunc(lastCallTime);
		          }
		        }
		        if (timerId === undefined$1) {
		          timerId = setTimeout(timerExpired, wait);
		        }
		        return result;
		      }
		      debounced.cancel = cancel;
		      debounced.flush = flush;
		      return debounced;
		    }

		    /**
		     * Defers invoking the `func` until the current call stack has cleared. Any
		     * additional arguments are provided to `func` when it's invoked.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to defer.
		     * @param {...*} [args] The arguments to invoke `func` with.
		     * @returns {number} Returns the timer id.
		     * @example
		     *
		     * _.defer(function(text) {
		     *   console.log(text);
		     * }, 'deferred');
		     * // => Logs 'deferred' after one millisecond.
		     */
		    var defer = baseRest(function(func, args) {
		      return baseDelay(func, 1, args);
		    });

		    /**
		     * Invokes `func` after `wait` milliseconds. Any additional arguments are
		     * provided to `func` when it's invoked.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to delay.
		     * @param {number} wait The number of milliseconds to delay invocation.
		     * @param {...*} [args] The arguments to invoke `func` with.
		     * @returns {number} Returns the timer id.
		     * @example
		     *
		     * _.delay(function(text) {
		     *   console.log(text);
		     * }, 1000, 'later');
		     * // => Logs 'later' after one second.
		     */
		    var delay = baseRest(function(func, wait, args) {
		      return baseDelay(func, toNumber(wait) || 0, args);
		    });

		    /**
		     * Creates a function that invokes `func` with arguments reversed.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Function
		     * @param {Function} func The function to flip arguments for.
		     * @returns {Function} Returns the new flipped function.
		     * @example
		     *
		     * var flipped = _.flip(function() {
		     *   return _.toArray(arguments);
		     * });
		     *
		     * flipped('a', 'b', 'c', 'd');
		     * // => ['d', 'c', 'b', 'a']
		     */
		    function flip(func) {
		      return createWrap(func, WRAP_FLIP_FLAG);
		    }

		    /**
		     * Creates a function that memoizes the result of `func`. If `resolver` is
		     * provided, it determines the cache key for storing the result based on the
		     * arguments provided to the memoized function. By default, the first argument
		     * provided to the memoized function is used as the map cache key. The `func`
		     * is invoked with the `this` binding of the memoized function.
		     *
		     * **Note:** The cache is exposed as the `cache` property on the memoized
		     * function. Its creation may be customized by replacing the `_.memoize.Cache`
		     * constructor with one whose instances implement the
		     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
		     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to have its output memoized.
		     * @param {Function} [resolver] The function to resolve the cache key.
		     * @returns {Function} Returns the new memoized function.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2 };
		     * var other = { 'c': 3, 'd': 4 };
		     *
		     * var values = _.memoize(_.values);
		     * values(object);
		     * // => [1, 2]
		     *
		     * values(other);
		     * // => [3, 4]
		     *
		     * object.a = 2;
		     * values(object);
		     * // => [1, 2]
		     *
		     * // Modify the result cache.
		     * values.cache.set(object, ['a', 'b']);
		     * values(object);
		     * // => ['a', 'b']
		     *
		     * // Replace `_.memoize.Cache`.
		     * _.memoize.Cache = WeakMap;
		     */
		    function memoize(func, resolver) {
		      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      var memoized = function() {
		        var args = arguments,
		            key = resolver ? resolver.apply(this, args) : args[0],
		            cache = memoized.cache;

		        if (cache.has(key)) {
		          return cache.get(key);
		        }
		        var result = func.apply(this, args);
		        memoized.cache = cache.set(key, result) || cache;
		        return result;
		      };
		      memoized.cache = new (memoize.Cache || MapCache);
		      return memoized;
		    }

		    // Expose `MapCache`.
		    memoize.Cache = MapCache;

		    /**
		     * Creates a function that negates the result of the predicate `func`. The
		     * `func` predicate is invoked with the `this` binding and arguments of the
		     * created function.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} predicate The predicate to negate.
		     * @returns {Function} Returns the new negated function.
		     * @example
		     *
		     * function isEven(n) {
		     *   return n % 2 == 0;
		     * }
		     *
		     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
		     * // => [1, 3, 5]
		     */
		    function negate(predicate) {
		      if (typeof predicate != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      return function() {
		        var args = arguments;
		        switch (args.length) {
		          case 0: return !predicate.call(this);
		          case 1: return !predicate.call(this, args[0]);
		          case 2: return !predicate.call(this, args[0], args[1]);
		          case 3: return !predicate.call(this, args[0], args[1], args[2]);
		        }
		        return !predicate.apply(this, args);
		      };
		    }

		    /**
		     * Creates a function that is restricted to invoking `func` once. Repeat calls
		     * to the function return the value of the first invocation. The `func` is
		     * invoked with the `this` binding and arguments of the created function.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new restricted function.
		     * @example
		     *
		     * var initialize = _.once(createApplication);
		     * initialize();
		     * initialize();
		     * // => `createApplication` is invoked once
		     */
		    function once(func) {
		      return before(2, func);
		    }

		    /**
		     * Creates a function that invokes `func` with its arguments transformed.
		     *
		     * @static
		     * @since 4.0.0
		     * @memberOf _
		     * @category Function
		     * @param {Function} func The function to wrap.
		     * @param {...(Function|Function[])} [transforms=[_.identity]]
		     *  The argument transforms.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * function doubled(n) {
		     *   return n * 2;
		     * }
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var func = _.overArgs(function(x, y) {
		     *   return [x, y];
		     * }, [square, doubled]);
		     *
		     * func(9, 3);
		     * // => [81, 6]
		     *
		     * func(10, 5);
		     * // => [100, 10]
		     */
		    var overArgs = castRest(function(func, transforms) {
		      transforms = (transforms.length == 1 && isArray(transforms[0]))
		        ? arrayMap(transforms[0], baseUnary(getIteratee()))
		        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

		      var funcsLength = transforms.length;
		      return baseRest(function(args) {
		        var index = -1,
		            length = nativeMin(args.length, funcsLength);

		        while (++index < length) {
		          args[index] = transforms[index].call(this, args[index]);
		        }
		        return apply(func, this, args);
		      });
		    });

		    /**
		     * Creates a function that invokes `func` with `partials` prepended to the
		     * arguments it receives. This method is like `_.bind` except it does **not**
		     * alter the `this` binding.
		     *
		     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for partially applied arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of partially
		     * applied functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.2.0
		     * @category Function
		     * @param {Function} func The function to partially apply arguments to.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new partially applied function.
		     * @example
		     *
		     * function greet(greeting, name) {
		     *   return greeting + ' ' + name;
		     * }
		     *
		     * var sayHelloTo = _.partial(greet, 'hello');
		     * sayHelloTo('fred');
		     * // => 'hello fred'
		     *
		     * // Partially applied with placeholders.
		     * var greetFred = _.partial(greet, _, 'fred');
		     * greetFred('hi');
		     * // => 'hi fred'
		     */
		    var partial = baseRest(function(func, partials) {
		      var holders = replaceHolders(partials, getHolder(partial));
		      return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
		    });

		    /**
		     * This method is like `_.partial` except that partially applied arguments
		     * are appended to the arguments it receives.
		     *
		     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for partially applied arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of partially
		     * applied functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.0.0
		     * @category Function
		     * @param {Function} func The function to partially apply arguments to.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new partially applied function.
		     * @example
		     *
		     * function greet(greeting, name) {
		     *   return greeting + ' ' + name;
		     * }
		     *
		     * var greetFred = _.partialRight(greet, 'fred');
		     * greetFred('hi');
		     * // => 'hi fred'
		     *
		     * // Partially applied with placeholders.
		     * var sayHelloTo = _.partialRight(greet, 'hello', _);
		     * sayHelloTo('fred');
		     * // => 'hello fred'
		     */
		    var partialRight = baseRest(function(func, partials) {
		      var holders = replaceHolders(partials, getHolder(partialRight));
		      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
		    });

		    /**
		     * Creates a function that invokes `func` with arguments arranged according
		     * to the specified `indexes` where the argument value at the first index is
		     * provided as the first argument, the argument value at the second index is
		     * provided as the second argument, and so on.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} func The function to rearrange arguments for.
		     * @param {...(number|number[])} indexes The arranged argument indexes.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var rearged = _.rearg(function(a, b, c) {
		     *   return [a, b, c];
		     * }, [2, 0, 1]);
		     *
		     * rearged('b', 'c', 'a')
		     * // => ['a', 'b', 'c']
		     */
		    var rearg = flatRest(function(func, indexes) {
		      return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
		    });

		    /**
		     * Creates a function that invokes `func` with the `this` binding of the
		     * created function and arguments from `start` and beyond provided as
		     * an array.
		     *
		     * **Note:** This method is based on the
		     * [rest parameter](https://mdn.io/rest_parameters).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Function
		     * @param {Function} func The function to apply a rest parameter to.
		     * @param {number} [start=func.length-1] The start position of the rest parameter.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var say = _.rest(function(what, names) {
		     *   return what + ' ' + _.initial(names).join(', ') +
		     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
		     * });
		     *
		     * say('hello', 'fred', 'barney', 'pebbles');
		     * // => 'hello fred, barney, & pebbles'
		     */
		    function rest(func, start) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      start = start === undefined$1 ? start : toInteger(start);
		      return baseRest(func, start);
		    }

		    /**
		     * Creates a function that invokes `func` with the `this` binding of the
		     * create function and an array of arguments much like
		     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
		     *
		     * **Note:** This method is based on the
		     * [spread operator](https://mdn.io/spread_operator).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.2.0
		     * @category Function
		     * @param {Function} func The function to spread arguments over.
		     * @param {number} [start=0] The start position of the spread.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var say = _.spread(function(who, what) {
		     *   return who + ' says ' + what;
		     * });
		     *
		     * say(['fred', 'hello']);
		     * // => 'fred says hello'
		     *
		     * var numbers = Promise.all([
		     *   Promise.resolve(40),
		     *   Promise.resolve(36)
		     * ]);
		     *
		     * numbers.then(_.spread(function(x, y) {
		     *   return x + y;
		     * }));
		     * // => a Promise of 76
		     */
		    function spread(func, start) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      start = start == null ? 0 : nativeMax(toInteger(start), 0);
		      return baseRest(function(args) {
		        var array = args[start],
		            otherArgs = castSlice(args, 0, start);

		        if (array) {
		          arrayPush(otherArgs, array);
		        }
		        return apply(func, this, otherArgs);
		      });
		    }

		    /**
		     * Creates a throttled function that only invokes `func` at most once per
		     * every `wait` milliseconds. The throttled function comes with a `cancel`
		     * method to cancel delayed `func` invocations and a `flush` method to
		     * immediately invoke them. Provide `options` to indicate whether `func`
		     * should be invoked on the leading and/or trailing edge of the `wait`
		     * timeout. The `func` is invoked with the last arguments provided to the
		     * throttled function. Subsequent calls to the throttled function return the
		     * result of the last `func` invocation.
		     *
		     * **Note:** If `leading` and `trailing` options are `true`, `func` is
		     * invoked on the trailing edge of the timeout only if the throttled function
		     * is invoked more than once during the `wait` timeout.
		     *
		     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
		     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
		     *
		     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
		     * for details over the differences between `_.throttle` and `_.debounce`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to throttle.
		     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
		     * @param {Object} [options={}] The options object.
		     * @param {boolean} [options.leading=true]
		     *  Specify invoking on the leading edge of the timeout.
		     * @param {boolean} [options.trailing=true]
		     *  Specify invoking on the trailing edge of the timeout.
		     * @returns {Function} Returns the new throttled function.
		     * @example
		     *
		     * // Avoid excessively updating the position while scrolling.
		     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
		     *
		     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
		     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
		     * jQuery(element).on('click', throttled);
		     *
		     * // Cancel the trailing throttled invocation.
		     * jQuery(window).on('popstate', throttled.cancel);
		     */
		    function throttle(func, wait, options) {
		      var leading = true,
		          trailing = true;

		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      if (isObject(options)) {
		        leading = 'leading' in options ? !!options.leading : leading;
		        trailing = 'trailing' in options ? !!options.trailing : trailing;
		      }
		      return debounce(func, wait, {
		        'leading': leading,
		        'maxWait': wait,
		        'trailing': trailing
		      });
		    }

		    /**
		     * Creates a function that accepts up to one argument, ignoring any
		     * additional arguments.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Function
		     * @param {Function} func The function to cap arguments for.
		     * @returns {Function} Returns the new capped function.
		     * @example
		     *
		     * _.map(['6', '8', '10'], _.unary(parseInt));
		     * // => [6, 8, 10]
		     */
		    function unary(func) {
		      return ary(func, 1);
		    }

		    /**
		     * Creates a function that provides `value` to `wrapper` as its first
		     * argument. Any additional arguments provided to the function are appended
		     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
		     * binding of the created function.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {*} value The value to wrap.
		     * @param {Function} [wrapper=identity] The wrapper function.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var p = _.wrap(_.escape, function(func, text) {
		     *   return '<p>' + func(text) + '</p>';
		     * });
		     *
		     * p('fred, barney, & pebbles');
		     * // => '<p>fred, barney, &amp; pebbles</p>'
		     */
		    function wrap(value, wrapper) {
		      return partial(castFunction(wrapper), value);
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Casts `value` as an array if it's not one.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.4.0
		     * @category Lang
		     * @param {*} value The value to inspect.
		     * @returns {Array} Returns the cast array.
		     * @example
		     *
		     * _.castArray(1);
		     * // => [1]
		     *
		     * _.castArray({ 'a': 1 });
		     * // => [{ 'a': 1 }]
		     *
		     * _.castArray('abc');
		     * // => ['abc']
		     *
		     * _.castArray(null);
		     * // => [null]
		     *
		     * _.castArray(undefined);
		     * // => [undefined]
		     *
		     * _.castArray();
		     * // => []
		     *
		     * var array = [1, 2, 3];
		     * console.log(_.castArray(array) === array);
		     * // => true
		     */
		    function castArray() {
		      if (!arguments.length) {
		        return [];
		      }
		      var value = arguments[0];
		      return isArray(value) ? value : [value];
		    }

		    /**
		     * Creates a shallow clone of `value`.
		     *
		     * **Note:** This method is loosely based on the
		     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
		     * and supports cloning arrays, array buffers, booleans, date objects, maps,
		     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
		     * arrays. The own enumerable properties of `arguments` objects are cloned
		     * as plain objects. An empty object is returned for uncloneable values such
		     * as error objects, functions, DOM nodes, and WeakMaps.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to clone.
		     * @returns {*} Returns the cloned value.
		     * @see _.cloneDeep
		     * @example
		     *
		     * var objects = [{ 'a': 1 }, { 'b': 2 }];
		     *
		     * var shallow = _.clone(objects);
		     * console.log(shallow[0] === objects[0]);
		     * // => true
		     */
		    function clone(value) {
		      return baseClone(value, CLONE_SYMBOLS_FLAG);
		    }

		    /**
		     * This method is like `_.clone` except that it accepts `customizer` which
		     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
		     * cloning is handled by the method instead. The `customizer` is invoked with
		     * up to four arguments; (value [, index|key, object, stack]).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to clone.
		     * @param {Function} [customizer] The function to customize cloning.
		     * @returns {*} Returns the cloned value.
		     * @see _.cloneDeepWith
		     * @example
		     *
		     * function customizer(value) {
		     *   if (_.isElement(value)) {
		     *     return value.cloneNode(false);
		     *   }
		     * }
		     *
		     * var el = _.cloneWith(document.body, customizer);
		     *
		     * console.log(el === document.body);
		     * // => false
		     * console.log(el.nodeName);
		     * // => 'BODY'
		     * console.log(el.childNodes.length);
		     * // => 0
		     */
		    function cloneWith(value, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
		    }

		    /**
		     * This method is like `_.clone` except that it recursively clones `value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.0.0
		     * @category Lang
		     * @param {*} value The value to recursively clone.
		     * @returns {*} Returns the deep cloned value.
		     * @see _.clone
		     * @example
		     *
		     * var objects = [{ 'a': 1 }, { 'b': 2 }];
		     *
		     * var deep = _.cloneDeep(objects);
		     * console.log(deep[0] === objects[0]);
		     * // => false
		     */
		    function cloneDeep(value) {
		      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
		    }

		    /**
		     * This method is like `_.cloneWith` except that it recursively clones `value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to recursively clone.
		     * @param {Function} [customizer] The function to customize cloning.
		     * @returns {*} Returns the deep cloned value.
		     * @see _.cloneWith
		     * @example
		     *
		     * function customizer(value) {
		     *   if (_.isElement(value)) {
		     *     return value.cloneNode(true);
		     *   }
		     * }
		     *
		     * var el = _.cloneDeepWith(document.body, customizer);
		     *
		     * console.log(el === document.body);
		     * // => false
		     * console.log(el.nodeName);
		     * // => 'BODY'
		     * console.log(el.childNodes.length);
		     * // => 20
		     */
		    function cloneDeepWith(value, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
		    }

		    /**
		     * Checks if `object` conforms to `source` by invoking the predicate
		     * properties of `source` with the corresponding property values of `object`.
		     *
		     * **Note:** This method is equivalent to `_.conforms` when `source` is
		     * partially applied.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.14.0
		     * @category Lang
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property predicates to conform to.
		     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2 };
		     *
		     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
		     * // => true
		     *
		     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
		     * // => false
		     */
		    function conformsTo(object, source) {
		      return source == null || baseConformsTo(object, source, keys(source));
		    }

		    /**
		     * Performs a
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * comparison between two values to determine if they are equivalent.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     * @example
		     *
		     * var object = { 'a': 1 };
		     * var other = { 'a': 1 };
		     *
		     * _.eq(object, object);
		     * // => true
		     *
		     * _.eq(object, other);
		     * // => false
		     *
		     * _.eq('a', 'a');
		     * // => true
		     *
		     * _.eq('a', Object('a'));
		     * // => false
		     *
		     * _.eq(NaN, NaN);
		     * // => true
		     */
		    function eq(value, other) {
		      return value === other || (value !== value && other !== other);
		    }

		    /**
		     * Checks if `value` is greater than `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is greater than `other`,
		     *  else `false`.
		     * @see _.lt
		     * @example
		     *
		     * _.gt(3, 1);
		     * // => true
		     *
		     * _.gt(3, 3);
		     * // => false
		     *
		     * _.gt(1, 3);
		     * // => false
		     */
		    var gt = createRelationalOperation(baseGt);

		    /**
		     * Checks if `value` is greater than or equal to `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is greater than or equal to
		     *  `other`, else `false`.
		     * @see _.lte
		     * @example
		     *
		     * _.gte(3, 1);
		     * // => true
		     *
		     * _.gte(3, 3);
		     * // => true
		     *
		     * _.gte(1, 3);
		     * // => false
		     */
		    var gte = createRelationalOperation(function(value, other) {
		      return value >= other;
		    });

		    /**
		     * Checks if `value` is likely an `arguments` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
		     *  else `false`.
		     * @example
		     *
		     * _.isArguments(function() { return arguments; }());
		     * // => true
		     *
		     * _.isArguments([1, 2, 3]);
		     * // => false
		     */
		    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
		      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
		        !propertyIsEnumerable.call(value, 'callee');
		    };

		    /**
		     * Checks if `value` is classified as an `Array` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
		     * @example
		     *
		     * _.isArray([1, 2, 3]);
		     * // => true
		     *
		     * _.isArray(document.body.children);
		     * // => false
		     *
		     * _.isArray('abc');
		     * // => false
		     *
		     * _.isArray(_.noop);
		     * // => false
		     */
		    var isArray = Array.isArray;

		    /**
		     * Checks if `value` is classified as an `ArrayBuffer` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
		     * @example
		     *
		     * _.isArrayBuffer(new ArrayBuffer(2));
		     * // => true
		     *
		     * _.isArrayBuffer(new Array(2));
		     * // => false
		     */
		    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

		    /**
		     * Checks if `value` is array-like. A value is considered array-like if it's
		     * not a function and has a `value.length` that's an integer greater than or
		     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
		     * @example
		     *
		     * _.isArrayLike([1, 2, 3]);
		     * // => true
		     *
		     * _.isArrayLike(document.body.children);
		     * // => true
		     *
		     * _.isArrayLike('abc');
		     * // => true
		     *
		     * _.isArrayLike(_.noop);
		     * // => false
		     */
		    function isArrayLike(value) {
		      return value != null && isLength(value.length) && !isFunction(value);
		    }

		    /**
		     * This method is like `_.isArrayLike` except that it also checks if `value`
		     * is an object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an array-like object,
		     *  else `false`.
		     * @example
		     *
		     * _.isArrayLikeObject([1, 2, 3]);
		     * // => true
		     *
		     * _.isArrayLikeObject(document.body.children);
		     * // => true
		     *
		     * _.isArrayLikeObject('abc');
		     * // => false
		     *
		     * _.isArrayLikeObject(_.noop);
		     * // => false
		     */
		    function isArrayLikeObject(value) {
		      return isObjectLike(value) && isArrayLike(value);
		    }

		    /**
		     * Checks if `value` is classified as a boolean primitive or object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
		     * @example
		     *
		     * _.isBoolean(false);
		     * // => true
		     *
		     * _.isBoolean(null);
		     * // => false
		     */
		    function isBoolean(value) {
		      return value === true || value === false ||
		        (isObjectLike(value) && baseGetTag(value) == boolTag);
		    }

		    /**
		     * Checks if `value` is a buffer.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
		     * @example
		     *
		     * _.isBuffer(new Buffer(2));
		     * // => true
		     *
		     * _.isBuffer(new Uint8Array(2));
		     * // => false
		     */
		    var isBuffer = nativeIsBuffer || stubFalse;

		    /**
		     * Checks if `value` is classified as a `Date` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
		     * @example
		     *
		     * _.isDate(new Date);
		     * // => true
		     *
		     * _.isDate('Mon April 23 2012');
		     * // => false
		     */
		    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

		    /**
		     * Checks if `value` is likely a DOM element.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
		     * @example
		     *
		     * _.isElement(document.body);
		     * // => true
		     *
		     * _.isElement('<body>');
		     * // => false
		     */
		    function isElement(value) {
		      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
		    }

		    /**
		     * Checks if `value` is an empty object, collection, map, or set.
		     *
		     * Objects are considered empty if they have no own enumerable string keyed
		     * properties.
		     *
		     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
		     * jQuery-like collections are considered empty if they have a `length` of `0`.
		     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
		     * @example
		     *
		     * _.isEmpty(null);
		     * // => true
		     *
		     * _.isEmpty(true);
		     * // => true
		     *
		     * _.isEmpty(1);
		     * // => true
		     *
		     * _.isEmpty([1, 2, 3]);
		     * // => false
		     *
		     * _.isEmpty({ 'a': 1 });
		     * // => false
		     */
		    function isEmpty(value) {
		      if (value == null) {
		        return true;
		      }
		      if (isArrayLike(value) &&
		          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
		            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
		        return !value.length;
		      }
		      var tag = getTag(value);
		      if (tag == mapTag || tag == setTag) {
		        return !value.size;
		      }
		      if (isPrototype(value)) {
		        return !baseKeys(value).length;
		      }
		      for (var key in value) {
		        if (hasOwnProperty.call(value, key)) {
		          return false;
		        }
		      }
		      return true;
		    }

		    /**
		     * Performs a deep comparison between two values to determine if they are
		     * equivalent.
		     *
		     * **Note:** This method supports comparing arrays, array buffers, booleans,
		     * date objects, error objects, maps, numbers, `Object` objects, regexes,
		     * sets, strings, symbols, and typed arrays. `Object` objects are compared
		     * by their own, not inherited, enumerable properties. Functions and DOM
		     * nodes are compared by strict equality, i.e. `===`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     * @example
		     *
		     * var object = { 'a': 1 };
		     * var other = { 'a': 1 };
		     *
		     * _.isEqual(object, other);
		     * // => true
		     *
		     * object === other;
		     * // => false
		     */
		    function isEqual(value, other) {
		      return baseIsEqual(value, other);
		    }

		    /**
		     * This method is like `_.isEqual` except that it accepts `customizer` which
		     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
		     * are handled by the method instead. The `customizer` is invoked with up to
		     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     * @example
		     *
		     * function isGreeting(value) {
		     *   return /^h(?:i|ello)$/.test(value);
		     * }
		     *
		     * function customizer(objValue, othValue) {
		     *   if (isGreeting(objValue) && isGreeting(othValue)) {
		     *     return true;
		     *   }
		     * }
		     *
		     * var array = ['hello', 'goodbye'];
		     * var other = ['hi', 'goodbye'];
		     *
		     * _.isEqualWith(array, other, customizer);
		     * // => true
		     */
		    function isEqualWith(value, other, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      var result = customizer ? customizer(value, other) : undefined$1;
		      return result === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result;
		    }

		    /**
		     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
		     * `SyntaxError`, `TypeError`, or `URIError` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
		     * @example
		     *
		     * _.isError(new Error);
		     * // => true
		     *
		     * _.isError(Error);
		     * // => false
		     */
		    function isError(value) {
		      if (!isObjectLike(value)) {
		        return false;
		      }
		      var tag = baseGetTag(value);
		      return tag == errorTag || tag == domExcTag ||
		        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
		    }

		    /**
		     * Checks if `value` is a finite primitive number.
		     *
		     * **Note:** This method is based on
		     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
		     * @example
		     *
		     * _.isFinite(3);
		     * // => true
		     *
		     * _.isFinite(Number.MIN_VALUE);
		     * // => true
		     *
		     * _.isFinite(Infinity);
		     * // => false
		     *
		     * _.isFinite('3');
		     * // => false
		     */
		    function isFinite(value) {
		      return typeof value == 'number' && nativeIsFinite(value);
		    }

		    /**
		     * Checks if `value` is classified as a `Function` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
		     * @example
		     *
		     * _.isFunction(_);
		     * // => true
		     *
		     * _.isFunction(/abc/);
		     * // => false
		     */
		    function isFunction(value) {
		      if (!isObject(value)) {
		        return false;
		      }
		      // The use of `Object#toString` avoids issues with the `typeof` operator
		      // in Safari 9 which returns 'object' for typed arrays and other constructors.
		      var tag = baseGetTag(value);
		      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
		    }

		    /**
		     * Checks if `value` is an integer.
		     *
		     * **Note:** This method is based on
		     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
		     * @example
		     *
		     * _.isInteger(3);
		     * // => true
		     *
		     * _.isInteger(Number.MIN_VALUE);
		     * // => false
		     *
		     * _.isInteger(Infinity);
		     * // => false
		     *
		     * _.isInteger('3');
		     * // => false
		     */
		    function isInteger(value) {
		      return typeof value == 'number' && value == toInteger(value);
		    }

		    /**
		     * Checks if `value` is a valid array-like length.
		     *
		     * **Note:** This method is loosely based on
		     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
		     * @example
		     *
		     * _.isLength(3);
		     * // => true
		     *
		     * _.isLength(Number.MIN_VALUE);
		     * // => false
		     *
		     * _.isLength(Infinity);
		     * // => false
		     *
		     * _.isLength('3');
		     * // => false
		     */
		    function isLength(value) {
		      return typeof value == 'number' &&
		        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
		    }

		    /**
		     * Checks if `value` is the
		     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
		     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
		     * @example
		     *
		     * _.isObject({});
		     * // => true
		     *
		     * _.isObject([1, 2, 3]);
		     * // => true
		     *
		     * _.isObject(_.noop);
		     * // => true
		     *
		     * _.isObject(null);
		     * // => false
		     */
		    function isObject(value) {
		      var type = typeof value;
		      return value != null && (type == 'object' || type == 'function');
		    }

		    /**
		     * Checks if `value` is object-like. A value is object-like if it's not `null`
		     * and has a `typeof` result of "object".
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
		     * @example
		     *
		     * _.isObjectLike({});
		     * // => true
		     *
		     * _.isObjectLike([1, 2, 3]);
		     * // => true
		     *
		     * _.isObjectLike(_.noop);
		     * // => false
		     *
		     * _.isObjectLike(null);
		     * // => false
		     */
		    function isObjectLike(value) {
		      return value != null && typeof value == 'object';
		    }

		    /**
		     * Checks if `value` is classified as a `Map` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
		     * @example
		     *
		     * _.isMap(new Map);
		     * // => true
		     *
		     * _.isMap(new WeakMap);
		     * // => false
		     */
		    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

		    /**
		     * Performs a partial deep comparison between `object` and `source` to
		     * determine if `object` contains equivalent property values.
		     *
		     * **Note:** This method is equivalent to `_.matches` when `source` is
		     * partially applied.
		     *
		     * Partial comparisons will match empty array and empty object `source`
		     * values against any array or object value, respectively. See `_.isEqual`
		     * for a list of supported value comparisons.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property values to match.
		     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2 };
		     *
		     * _.isMatch(object, { 'b': 2 });
		     * // => true
		     *
		     * _.isMatch(object, { 'b': 1 });
		     * // => false
		     */
		    function isMatch(object, source) {
		      return object === source || baseIsMatch(object, source, getMatchData(source));
		    }

		    /**
		     * This method is like `_.isMatch` except that it accepts `customizer` which
		     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
		     * are handled by the method instead. The `customizer` is invoked with five
		     * arguments: (objValue, srcValue, index|key, object, source).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property values to match.
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
		     * @example
		     *
		     * function isGreeting(value) {
		     *   return /^h(?:i|ello)$/.test(value);
		     * }
		     *
		     * function customizer(objValue, srcValue) {
		     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
		     *     return true;
		     *   }
		     * }
		     *
		     * var object = { 'greeting': 'hello' };
		     * var source = { 'greeting': 'hi' };
		     *
		     * _.isMatchWith(object, source, customizer);
		     * // => true
		     */
		    function isMatchWith(object, source, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return baseIsMatch(object, source, getMatchData(source), customizer);
		    }

		    /**
		     * Checks if `value` is `NaN`.
		     *
		     * **Note:** This method is based on
		     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
		     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
		     * `undefined` and other non-number values.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
		     * @example
		     *
		     * _.isNaN(NaN);
		     * // => true
		     *
		     * _.isNaN(new Number(NaN));
		     * // => true
		     *
		     * isNaN(undefined);
		     * // => true
		     *
		     * _.isNaN(undefined);
		     * // => false
		     */
		    function isNaN(value) {
		      // An `NaN` primitive is the only value that is not equal to itself.
		      // Perform the `toStringTag` check first to avoid errors with some
		      // ActiveX objects in IE.
		      return isNumber(value) && value != +value;
		    }

		    /**
		     * Checks if `value` is a pristine native function.
		     *
		     * **Note:** This method can't reliably detect native functions in the presence
		     * of the core-js package because core-js circumvents this kind of detection.
		     * Despite multiple requests, the core-js maintainer has made it clear: any
		     * attempt to fix the detection will be obstructed. As a result, we're left
		     * with little choice but to throw an error. Unfortunately, this also affects
		     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
		     * which rely on core-js.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a native function,
		     *  else `false`.
		     * @example
		     *
		     * _.isNative(Array.prototype.push);
		     * // => true
		     *
		     * _.isNative(_);
		     * // => false
		     */
		    function isNative(value) {
		      if (isMaskable(value)) {
		        throw new Error(CORE_ERROR_TEXT);
		      }
		      return baseIsNative(value);
		    }

		    /**
		     * Checks if `value` is `null`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
		     * @example
		     *
		     * _.isNull(null);
		     * // => true
		     *
		     * _.isNull(void 0);
		     * // => false
		     */
		    function isNull(value) {
		      return value === null;
		    }

		    /**
		     * Checks if `value` is `null` or `undefined`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
		     * @example
		     *
		     * _.isNil(null);
		     * // => true
		     *
		     * _.isNil(void 0);
		     * // => true
		     *
		     * _.isNil(NaN);
		     * // => false
		     */
		    function isNil(value) {
		      return value == null;
		    }

		    /**
		     * Checks if `value` is classified as a `Number` primitive or object.
		     *
		     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
		     * classified as numbers, use the `_.isFinite` method.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
		     * @example
		     *
		     * _.isNumber(3);
		     * // => true
		     *
		     * _.isNumber(Number.MIN_VALUE);
		     * // => true
		     *
		     * _.isNumber(Infinity);
		     * // => true
		     *
		     * _.isNumber('3');
		     * // => false
		     */
		    function isNumber(value) {
		      return typeof value == 'number' ||
		        (isObjectLike(value) && baseGetTag(value) == numberTag);
		    }

		    /**
		     * Checks if `value` is a plain object, that is, an object created by the
		     * `Object` constructor or one with a `[[Prototype]]` of `null`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.8.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     * }
		     *
		     * _.isPlainObject(new Foo);
		     * // => false
		     *
		     * _.isPlainObject([1, 2, 3]);
		     * // => false
		     *
		     * _.isPlainObject({ 'x': 0, 'y': 0 });
		     * // => true
		     *
		     * _.isPlainObject(Object.create(null));
		     * // => true
		     */
		    function isPlainObject(value) {
		      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
		        return false;
		      }
		      var proto = getPrototype(value);
		      if (proto === null) {
		        return true;
		      }
		      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
		      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
		        funcToString.call(Ctor) == objectCtorString;
		    }

		    /**
		     * Checks if `value` is classified as a `RegExp` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
		     * @example
		     *
		     * _.isRegExp(/abc/);
		     * // => true
		     *
		     * _.isRegExp('/abc/');
		     * // => false
		     */
		    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

		    /**
		     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
		     * double precision number which isn't the result of a rounded unsafe integer.
		     *
		     * **Note:** This method is based on
		     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
		     * @example
		     *
		     * _.isSafeInteger(3);
		     * // => true
		     *
		     * _.isSafeInteger(Number.MIN_VALUE);
		     * // => false
		     *
		     * _.isSafeInteger(Infinity);
		     * // => false
		     *
		     * _.isSafeInteger('3');
		     * // => false
		     */
		    function isSafeInteger(value) {
		      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
		    }

		    /**
		     * Checks if `value` is classified as a `Set` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
		     * @example
		     *
		     * _.isSet(new Set);
		     * // => true
		     *
		     * _.isSet(new WeakSet);
		     * // => false
		     */
		    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

		    /**
		     * Checks if `value` is classified as a `String` primitive or object.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
		     * @example
		     *
		     * _.isString('abc');
		     * // => true
		     *
		     * _.isString(1);
		     * // => false
		     */
		    function isString(value) {
		      return typeof value == 'string' ||
		        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
		    }

		    /**
		     * Checks if `value` is classified as a `Symbol` primitive or object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
		     * @example
		     *
		     * _.isSymbol(Symbol.iterator);
		     * // => true
		     *
		     * _.isSymbol('abc');
		     * // => false
		     */
		    function isSymbol(value) {
		      return typeof value == 'symbol' ||
		        (isObjectLike(value) && baseGetTag(value) == symbolTag);
		    }

		    /**
		     * Checks if `value` is classified as a typed array.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
		     * @example
		     *
		     * _.isTypedArray(new Uint8Array);
		     * // => true
		     *
		     * _.isTypedArray([]);
		     * // => false
		     */
		    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

		    /**
		     * Checks if `value` is `undefined`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
		     * @example
		     *
		     * _.isUndefined(void 0);
		     * // => true
		     *
		     * _.isUndefined(null);
		     * // => false
		     */
		    function isUndefined(value) {
		      return value === undefined$1;
		    }

		    /**
		     * Checks if `value` is classified as a `WeakMap` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
		     * @example
		     *
		     * _.isWeakMap(new WeakMap);
		     * // => true
		     *
		     * _.isWeakMap(new Map);
		     * // => false
		     */
		    function isWeakMap(value) {
		      return isObjectLike(value) && getTag(value) == weakMapTag;
		    }

		    /**
		     * Checks if `value` is classified as a `WeakSet` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
		     * @example
		     *
		     * _.isWeakSet(new WeakSet);
		     * // => true
		     *
		     * _.isWeakSet(new Set);
		     * // => false
		     */
		    function isWeakSet(value) {
		      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
		    }

		    /**
		     * Checks if `value` is less than `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is less than `other`,
		     *  else `false`.
		     * @see _.gt
		     * @example
		     *
		     * _.lt(1, 3);
		     * // => true
		     *
		     * _.lt(3, 3);
		     * // => false
		     *
		     * _.lt(3, 1);
		     * // => false
		     */
		    var lt = createRelationalOperation(baseLt);

		    /**
		     * Checks if `value` is less than or equal to `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is less than or equal to
		     *  `other`, else `false`.
		     * @see _.gte
		     * @example
		     *
		     * _.lte(1, 3);
		     * // => true
		     *
		     * _.lte(3, 3);
		     * // => true
		     *
		     * _.lte(3, 1);
		     * // => false
		     */
		    var lte = createRelationalOperation(function(value, other) {
		      return value <= other;
		    });

		    /**
		     * Converts `value` to an array.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {Array} Returns the converted array.
		     * @example
		     *
		     * _.toArray({ 'a': 1, 'b': 2 });
		     * // => [1, 2]
		     *
		     * _.toArray('abc');
		     * // => ['a', 'b', 'c']
		     *
		     * _.toArray(1);
		     * // => []
		     *
		     * _.toArray(null);
		     * // => []
		     */
		    function toArray(value) {
		      if (!value) {
		        return [];
		      }
		      if (isArrayLike(value)) {
		        return isString(value) ? stringToArray(value) : copyArray(value);
		      }
		      if (symIterator && value[symIterator]) {
		        return iteratorToArray(value[symIterator]());
		      }
		      var tag = getTag(value),
		          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

		      return func(value);
		    }

		    /**
		     * Converts `value` to a finite number.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.12.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted number.
		     * @example
		     *
		     * _.toFinite(3.2);
		     * // => 3.2
		     *
		     * _.toFinite(Number.MIN_VALUE);
		     * // => 5e-324
		     *
		     * _.toFinite(Infinity);
		     * // => 1.7976931348623157e+308
		     *
		     * _.toFinite('3.2');
		     * // => 3.2
		     */
		    function toFinite(value) {
		      if (!value) {
		        return value === 0 ? value : 0;
		      }
		      value = toNumber(value);
		      if (value === INFINITY || value === -INFINITY) {
		        var sign = (value < 0 ? -1 : 1);
		        return sign * MAX_INTEGER;
		      }
		      return value === value ? value : 0;
		    }

		    /**
		     * Converts `value` to an integer.
		     *
		     * **Note:** This method is loosely based on
		     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.toInteger(3.2);
		     * // => 3
		     *
		     * _.toInteger(Number.MIN_VALUE);
		     * // => 0
		     *
		     * _.toInteger(Infinity);
		     * // => 1.7976931348623157e+308
		     *
		     * _.toInteger('3.2');
		     * // => 3
		     */
		    function toInteger(value) {
		      var result = toFinite(value),
		          remainder = result % 1;

		      return result === result ? (remainder ? result - remainder : result) : 0;
		    }

		    /**
		     * Converts `value` to an integer suitable for use as the length of an
		     * array-like object.
		     *
		     * **Note:** This method is based on
		     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.toLength(3.2);
		     * // => 3
		     *
		     * _.toLength(Number.MIN_VALUE);
		     * // => 0
		     *
		     * _.toLength(Infinity);
		     * // => 4294967295
		     *
		     * _.toLength('3.2');
		     * // => 3
		     */
		    function toLength(value) {
		      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
		    }

		    /**
		     * Converts `value` to a number.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to process.
		     * @returns {number} Returns the number.
		     * @example
		     *
		     * _.toNumber(3.2);
		     * // => 3.2
		     *
		     * _.toNumber(Number.MIN_VALUE);
		     * // => 5e-324
		     *
		     * _.toNumber(Infinity);
		     * // => Infinity
		     *
		     * _.toNumber('3.2');
		     * // => 3.2
		     */
		    function toNumber(value) {
		      if (typeof value == 'number') {
		        return value;
		      }
		      if (isSymbol(value)) {
		        return NAN;
		      }
		      if (isObject(value)) {
		        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
		        value = isObject(other) ? (other + '') : other;
		      }
		      if (typeof value != 'string') {
		        return value === 0 ? value : +value;
		      }
		      value = baseTrim(value);
		      var isBinary = reIsBinary.test(value);
		      return (isBinary || reIsOctal.test(value))
		        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
		        : (reIsBadHex.test(value) ? NAN : +value);
		    }

		    /**
		     * Converts `value` to a plain object flattening inherited enumerable string
		     * keyed properties of `value` to own properties of the plain object.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {Object} Returns the converted plain object.
		     * @example
		     *
		     * function Foo() {
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.assign({ 'a': 1 }, new Foo);
		     * // => { 'a': 1, 'b': 2 }
		     *
		     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
		     * // => { 'a': 1, 'b': 2, 'c': 3 }
		     */
		    function toPlainObject(value) {
		      return copyObject(value, keysIn(value));
		    }

		    /**
		     * Converts `value` to a safe integer. A safe integer can be compared and
		     * represented correctly.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.toSafeInteger(3.2);
		     * // => 3
		     *
		     * _.toSafeInteger(Number.MIN_VALUE);
		     * // => 0
		     *
		     * _.toSafeInteger(Infinity);
		     * // => 9007199254740991
		     *
		     * _.toSafeInteger('3.2');
		     * // => 3
		     */
		    function toSafeInteger(value) {
		      return value
		        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
		        : (value === 0 ? value : 0);
		    }

		    /**
		     * Converts `value` to a string. An empty string is returned for `null`
		     * and `undefined` values. The sign of `-0` is preserved.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {string} Returns the converted string.
		     * @example
		     *
		     * _.toString(null);
		     * // => ''
		     *
		     * _.toString(-0);
		     * // => '-0'
		     *
		     * _.toString([1, 2, 3]);
		     * // => '1,2,3'
		     */
		    function toString(value) {
		      return value == null ? '' : baseToString(value);
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Assigns own enumerable string keyed properties of source objects to the
		     * destination object. Source objects are applied from left to right.
		     * Subsequent sources overwrite property assignments of previous sources.
		     *
		     * **Note:** This method mutates `object` and is loosely based on
		     * [`Object.assign`](https://mdn.io/Object/assign).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.10.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @see _.assignIn
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     * }
		     *
		     * function Bar() {
		     *   this.c = 3;
		     * }
		     *
		     * Foo.prototype.b = 2;
		     * Bar.prototype.d = 4;
		     *
		     * _.assign({ 'a': 0 }, new Foo, new Bar);
		     * // => { 'a': 1, 'c': 3 }
		     */
		    var assign = createAssigner(function(object, source) {
		      if (isPrototype(source) || isArrayLike(source)) {
		        copyObject(source, keys(source), object);
		        return;
		      }
		      for (var key in source) {
		        if (hasOwnProperty.call(source, key)) {
		          assignValue(object, key, source[key]);
		        }
		      }
		    });

		    /**
		     * This method is like `_.assign` except that it iterates over own and
		     * inherited source properties.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias extend
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @see _.assign
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     * }
		     *
		     * function Bar() {
		     *   this.c = 3;
		     * }
		     *
		     * Foo.prototype.b = 2;
		     * Bar.prototype.d = 4;
		     *
		     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
		     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
		     */
		    var assignIn = createAssigner(function(object, source) {
		      copyObject(source, keysIn(source), object);
		    });

		    /**
		     * This method is like `_.assignIn` except that it accepts `customizer`
		     * which is invoked to produce the assigned values. If `customizer` returns
		     * `undefined`, assignment is handled by the method instead. The `customizer`
		     * is invoked with five arguments: (objValue, srcValue, key, object, source).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias extendWith
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} sources The source objects.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @see _.assignWith
		     * @example
		     *
		     * function customizer(objValue, srcValue) {
		     *   return _.isUndefined(objValue) ? srcValue : objValue;
		     * }
		     *
		     * var defaults = _.partialRight(_.assignInWith, customizer);
		     *
		     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
		     * // => { 'a': 1, 'b': 2 }
		     */
		    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
		      copyObject(source, keysIn(source), object, customizer);
		    });

		    /**
		     * This method is like `_.assign` except that it accepts `customizer`
		     * which is invoked to produce the assigned values. If `customizer` returns
		     * `undefined`, assignment is handled by the method instead. The `customizer`
		     * is invoked with five arguments: (objValue, srcValue, key, object, source).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} sources The source objects.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @see _.assignInWith
		     * @example
		     *
		     * function customizer(objValue, srcValue) {
		     *   return _.isUndefined(objValue) ? srcValue : objValue;
		     * }
		     *
		     * var defaults = _.partialRight(_.assignWith, customizer);
		     *
		     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
		     * // => { 'a': 1, 'b': 2 }
		     */
		    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
		      copyObject(source, keys(source), object, customizer);
		    });

		    /**
		     * Creates an array of values corresponding to `paths` of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.0.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {...(string|string[])} [paths] The property paths to pick.
		     * @returns {Array} Returns the picked values.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
		     *
		     * _.at(object, ['a[0].b.c', 'a[1]']);
		     * // => [3, 4]
		     */
		    var at = flatRest(baseAt);

		    /**
		     * Creates an object that inherits from the `prototype` object. If a
		     * `properties` object is given, its own enumerable string keyed properties
		     * are assigned to the created object.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.3.0
		     * @category Object
		     * @param {Object} prototype The object to inherit from.
		     * @param {Object} [properties] The properties to assign to the object.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * function Shape() {
		     *   this.x = 0;
		     *   this.y = 0;
		     * }
		     *
		     * function Circle() {
		     *   Shape.call(this);
		     * }
		     *
		     * Circle.prototype = _.create(Shape.prototype, {
		     *   'constructor': Circle
		     * });
		     *
		     * var circle = new Circle;
		     * circle instanceof Circle;
		     * // => true
		     *
		     * circle instanceof Shape;
		     * // => true
		     */
		    function create(prototype, properties) {
		      var result = baseCreate(prototype);
		      return properties == null ? result : baseAssign(result, properties);
		    }

		    /**
		     * Assigns own and inherited enumerable string keyed properties of source
		     * objects to the destination object for all destination properties that
		     * resolve to `undefined`. Source objects are applied from left to right.
		     * Once a property is set, additional values of the same property are ignored.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @see _.defaultsDeep
		     * @example
		     *
		     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
		     * // => { 'a': 1, 'b': 2 }
		     */
		    var defaults = baseRest(function(object, sources) {
		      object = Object(object);

		      var index = -1;
		      var length = sources.length;
		      var guard = length > 2 ? sources[2] : undefined$1;

		      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
		        length = 1;
		      }

		      while (++index < length) {
		        var source = sources[index];
		        var props = keysIn(source);
		        var propsIndex = -1;
		        var propsLength = props.length;

		        while (++propsIndex < propsLength) {
		          var key = props[propsIndex];
		          var value = object[key];

		          if (value === undefined$1 ||
		              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
		            object[key] = source[key];
		          }
		        }
		      }

		      return object;
		    });

		    /**
		     * This method is like `_.defaults` except that it recursively assigns
		     * default properties.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @see _.defaults
		     * @example
		     *
		     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
		     * // => { 'a': { 'b': 2, 'c': 3 } }
		     */
		    var defaultsDeep = baseRest(function(args) {
		      args.push(undefined$1, customDefaultsMerge);
		      return apply(mergeWith, undefined$1, args);
		    });

		    /**
		     * This method is like `_.find` except that it returns the key of the first
		     * element `predicate` returns truthy for instead of the element itself.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.1.0
		     * @category Object
		     * @param {Object} object The object to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {string|undefined} Returns the key of the matched element,
		     *  else `undefined`.
		     * @example
		     *
		     * var users = {
		     *   'barney':  { 'age': 36, 'active': true },
		     *   'fred':    { 'age': 40, 'active': false },
		     *   'pebbles': { 'age': 1,  'active': true }
		     * };
		     *
		     * _.findKey(users, function(o) { return o.age < 40; });
		     * // => 'barney' (iteration order is not guaranteed)
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findKey(users, { 'age': 1, 'active': true });
		     * // => 'pebbles'
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findKey(users, ['active', false]);
		     * // => 'fred'
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findKey(users, 'active');
		     * // => 'barney'
		     */
		    function findKey(object, predicate) {
		      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
		    }

		    /**
		     * This method is like `_.findKey` except that it iterates over elements of
		     * a collection in the opposite order.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Object
		     * @param {Object} object The object to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {string|undefined} Returns the key of the matched element,
		     *  else `undefined`.
		     * @example
		     *
		     * var users = {
		     *   'barney':  { 'age': 36, 'active': true },
		     *   'fred':    { 'age': 40, 'active': false },
		     *   'pebbles': { 'age': 1,  'active': true }
		     * };
		     *
		     * _.findLastKey(users, function(o) { return o.age < 40; });
		     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findLastKey(users, { 'age': 36, 'active': true });
		     * // => 'barney'
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findLastKey(users, ['active', false]);
		     * // => 'fred'
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findLastKey(users, 'active');
		     * // => 'pebbles'
		     */
		    function findLastKey(object, predicate) {
		      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
		    }

		    /**
		     * Iterates over own and inherited enumerable string keyed properties of an
		     * object and invokes `iteratee` for each property. The iteratee is invoked
		     * with three arguments: (value, key, object). Iteratee functions may exit
		     * iteration early by explicitly returning `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.3.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @see _.forInRight
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forIn(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
		     */
		    function forIn(object, iteratee) {
		      return object == null
		        ? object
		        : baseFor(object, getIteratee(iteratee, 3), keysIn);
		    }

		    /**
		     * This method is like `_.forIn` except that it iterates over properties of
		     * `object` in the opposite order.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @see _.forIn
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forInRight(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
		     */
		    function forInRight(object, iteratee) {
		      return object == null
		        ? object
		        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
		    }

		    /**
		     * Iterates over own enumerable string keyed properties of an object and
		     * invokes `iteratee` for each property. The iteratee is invoked with three
		     * arguments: (value, key, object). Iteratee functions may exit iteration
		     * early by explicitly returning `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.3.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @see _.forOwnRight
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forOwn(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
		     */
		    function forOwn(object, iteratee) {
		      return object && baseForOwn(object, getIteratee(iteratee, 3));
		    }

		    /**
		     * This method is like `_.forOwn` except that it iterates over properties of
		     * `object` in the opposite order.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @see _.forOwn
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forOwnRight(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
		     */
		    function forOwnRight(object, iteratee) {
		      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
		    }

		    /**
		     * Creates an array of function property names from own enumerable properties
		     * of `object`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to inspect.
		     * @returns {Array} Returns the function names.
		     * @see _.functionsIn
		     * @example
		     *
		     * function Foo() {
		     *   this.a = _.constant('a');
		     *   this.b = _.constant('b');
		     * }
		     *
		     * Foo.prototype.c = _.constant('c');
		     *
		     * _.functions(new Foo);
		     * // => ['a', 'b']
		     */
		    function functions(object) {
		      return object == null ? [] : baseFunctions(object, keys(object));
		    }

		    /**
		     * Creates an array of function property names from own and inherited
		     * enumerable properties of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to inspect.
		     * @returns {Array} Returns the function names.
		     * @see _.functions
		     * @example
		     *
		     * function Foo() {
		     *   this.a = _.constant('a');
		     *   this.b = _.constant('b');
		     * }
		     *
		     * Foo.prototype.c = _.constant('c');
		     *
		     * _.functionsIn(new Foo);
		     * // => ['a', 'b', 'c']
		     */
		    function functionsIn(object) {
		      return object == null ? [] : baseFunctions(object, keysIn(object));
		    }

		    /**
		     * Gets the value at `path` of `object`. If the resolved value is
		     * `undefined`, the `defaultValue` is returned in its place.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the property to get.
		     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
		     * @returns {*} Returns the resolved value.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
		     *
		     * _.get(object, 'a[0].b.c');
		     * // => 3
		     *
		     * _.get(object, ['a', '0', 'b', 'c']);
		     * // => 3
		     *
		     * _.get(object, 'a.b.c', 'default');
		     * // => 'default'
		     */
		    function get(object, path, defaultValue) {
		      var result = object == null ? undefined$1 : baseGet(object, path);
		      return result === undefined$1 ? defaultValue : result;
		    }

		    /**
		     * Checks if `path` is a direct property of `object`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path to check.
		     * @returns {boolean} Returns `true` if `path` exists, else `false`.
		     * @example
		     *
		     * var object = { 'a': { 'b': 2 } };
		     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
		     *
		     * _.has(object, 'a');
		     * // => true
		     *
		     * _.has(object, 'a.b');
		     * // => true
		     *
		     * _.has(object, ['a', 'b']);
		     * // => true
		     *
		     * _.has(other, 'a');
		     * // => false
		     */
		    function has(object, path) {
		      return object != null && hasPath(object, path, baseHas);
		    }

		    /**
		     * Checks if `path` is a direct or inherited property of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path to check.
		     * @returns {boolean} Returns `true` if `path` exists, else `false`.
		     * @example
		     *
		     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
		     *
		     * _.hasIn(object, 'a');
		     * // => true
		     *
		     * _.hasIn(object, 'a.b');
		     * // => true
		     *
		     * _.hasIn(object, ['a', 'b']);
		     * // => true
		     *
		     * _.hasIn(object, 'b');
		     * // => false
		     */
		    function hasIn(object, path) {
		      return object != null && hasPath(object, path, baseHasIn);
		    }

		    /**
		     * Creates an object composed of the inverted keys and values of `object`.
		     * If `object` contains duplicate values, subsequent values overwrite
		     * property assignments of previous values.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.7.0
		     * @category Object
		     * @param {Object} object The object to invert.
		     * @returns {Object} Returns the new inverted object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2, 'c': 1 };
		     *
		     * _.invert(object);
		     * // => { '1': 'c', '2': 'b' }
		     */
		    var invert = createInverter(function(result, value, key) {
		      if (value != null &&
		          typeof value.toString != 'function') {
		        value = nativeObjectToString.call(value);
		      }

		      result[value] = key;
		    }, constant(identity));

		    /**
		     * This method is like `_.invert` except that the inverted object is generated
		     * from the results of running each element of `object` thru `iteratee`. The
		     * corresponding inverted value of each inverted key is an array of keys
		     * responsible for generating the inverted value. The iteratee is invoked
		     * with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.1.0
		     * @category Object
		     * @param {Object} object The object to invert.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Object} Returns the new inverted object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2, 'c': 1 };
		     *
		     * _.invertBy(object);
		     * // => { '1': ['a', 'c'], '2': ['b'] }
		     *
		     * _.invertBy(object, function(value) {
		     *   return 'group' + value;
		     * });
		     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
		     */
		    var invertBy = createInverter(function(result, value, key) {
		      if (value != null &&
		          typeof value.toString != 'function') {
		        value = nativeObjectToString.call(value);
		      }

		      if (hasOwnProperty.call(result, value)) {
		        result[value].push(key);
		      } else {
		        result[value] = [key];
		      }
		    }, getIteratee);

		    /**
		     * Invokes the method at `path` of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the method to invoke.
		     * @param {...*} [args] The arguments to invoke the method with.
		     * @returns {*} Returns the result of the invoked method.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
		     *
		     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
		     * // => [2, 3]
		     */
		    var invoke = baseRest(baseInvoke);

		    /**
		     * Creates an array of the own enumerable property names of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects. See the
		     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
		     * for more details.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.keys(new Foo);
		     * // => ['a', 'b'] (iteration order is not guaranteed)
		     *
		     * _.keys('hi');
		     * // => ['0', '1']
		     */
		    function keys(object) {
		      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
		    }

		    /**
		     * Creates an array of the own and inherited enumerable property names of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.keysIn(new Foo);
		     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
		     */
		    function keysIn(object) {
		      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
		    }

		    /**
		     * The opposite of `_.mapValues`; this method creates an object with the
		     * same values as `object` and keys generated by running each own enumerable
		     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
		     * with three arguments: (value, key, object).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.8.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns the new mapped object.
		     * @see _.mapValues
		     * @example
		     *
		     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
		     *   return key + value;
		     * });
		     * // => { 'a1': 1, 'b2': 2 }
		     */
		    function mapKeys(object, iteratee) {
		      var result = {};
		      iteratee = getIteratee(iteratee, 3);

		      baseForOwn(object, function(value, key, object) {
		        baseAssignValue(result, iteratee(value, key, object), value);
		      });
		      return result;
		    }

		    /**
		     * Creates an object with the same keys as `object` and values generated
		     * by running each own enumerable string keyed property of `object` thru
		     * `iteratee`. The iteratee is invoked with three arguments:
		     * (value, key, object).
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns the new mapped object.
		     * @see _.mapKeys
		     * @example
		     *
		     * var users = {
		     *   'fred':    { 'user': 'fred',    'age': 40 },
		     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
		     * };
		     *
		     * _.mapValues(users, function(o) { return o.age; });
		     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.mapValues(users, 'age');
		     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
		     */
		    function mapValues(object, iteratee) {
		      var result = {};
		      iteratee = getIteratee(iteratee, 3);

		      baseForOwn(object, function(value, key, object) {
		        baseAssignValue(result, key, iteratee(value, key, object));
		      });
		      return result;
		    }

		    /**
		     * This method is like `_.assign` except that it recursively merges own and
		     * inherited enumerable string keyed properties of source objects into the
		     * destination object. Source properties that resolve to `undefined` are
		     * skipped if a destination value exists. Array and plain object properties
		     * are merged recursively. Other objects and value types are overridden by
		     * assignment. Source objects are applied from left to right. Subsequent
		     * sources overwrite property assignments of previous sources.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.5.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = {
		     *   'a': [{ 'b': 2 }, { 'd': 4 }]
		     * };
		     *
		     * var other = {
		     *   'a': [{ 'c': 3 }, { 'e': 5 }]
		     * };
		     *
		     * _.merge(object, other);
		     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
		     */
		    var merge = createAssigner(function(object, source, srcIndex) {
		      baseMerge(object, source, srcIndex);
		    });

		    /**
		     * This method is like `_.merge` except that it accepts `customizer` which
		     * is invoked to produce the merged values of the destination and source
		     * properties. If `customizer` returns `undefined`, merging is handled by the
		     * method instead. The `customizer` is invoked with six arguments:
		     * (objValue, srcValue, key, object, source, stack).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} sources The source objects.
		     * @param {Function} customizer The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * function customizer(objValue, srcValue) {
		     *   if (_.isArray(objValue)) {
		     *     return objValue.concat(srcValue);
		     *   }
		     * }
		     *
		     * var object = { 'a': [1], 'b': [2] };
		     * var other = { 'a': [3], 'b': [4] };
		     *
		     * _.mergeWith(object, other, customizer);
		     * // => { 'a': [1, 3], 'b': [2, 4] }
		     */
		    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
		      baseMerge(object, source, srcIndex, customizer);
		    });

		    /**
		     * The opposite of `_.pick`; this method creates an object composed of the
		     * own and inherited enumerable property paths of `object` that are not omitted.
		     *
		     * **Note:** This method is considerably slower than `_.pick`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {...(string|string[])} [paths] The property paths to omit.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.omit(object, ['a', 'c']);
		     * // => { 'b': '2' }
		     */
		    var omit = flatRest(function(object, paths) {
		      var result = {};
		      if (object == null) {
		        return result;
		      }
		      var isDeep = false;
		      paths = arrayMap(paths, function(path) {
		        path = castPath(path, object);
		        isDeep || (isDeep = path.length > 1);
		        return path;
		      });
		      copyObject(object, getAllKeysIn(object), result);
		      if (isDeep) {
		        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
		      }
		      var length = paths.length;
		      while (length--) {
		        baseUnset(result, paths[length]);
		      }
		      return result;
		    });

		    /**
		     * The opposite of `_.pickBy`; this method creates an object composed of
		     * the own and inherited enumerable string keyed properties of `object` that
		     * `predicate` doesn't return truthy for. The predicate is invoked with two
		     * arguments: (value, key).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {Function} [predicate=_.identity] The function invoked per property.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.omitBy(object, _.isNumber);
		     * // => { 'b': '2' }
		     */
		    function omitBy(object, predicate) {
		      return pickBy(object, negate(getIteratee(predicate)));
		    }

		    /**
		     * Creates an object composed of the picked `object` properties.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {...(string|string[])} [paths] The property paths to pick.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.pick(object, ['a', 'c']);
		     * // => { 'a': 1, 'c': 3 }
		     */
		    var pick = flatRest(function(object, paths) {
		      return object == null ? {} : basePick(object, paths);
		    });

		    /**
		     * Creates an object composed of the `object` properties `predicate` returns
		     * truthy for. The predicate is invoked with two arguments: (value, key).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {Function} [predicate=_.identity] The function invoked per property.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.pickBy(object, _.isNumber);
		     * // => { 'a': 1, 'c': 3 }
		     */
		    function pickBy(object, predicate) {
		      if (object == null) {
		        return {};
		      }
		      var props = arrayMap(getAllKeysIn(object), function(prop) {
		        return [prop];
		      });
		      predicate = getIteratee(predicate);
		      return basePickBy(object, props, function(value, path) {
		        return predicate(value, path[0]);
		      });
		    }

		    /**
		     * This method is like `_.get` except that if the resolved value is a
		     * function it's invoked with the `this` binding of its parent object and
		     * its result is returned.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the property to resolve.
		     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
		     * @returns {*} Returns the resolved value.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
		     *
		     * _.result(object, 'a[0].b.c1');
		     * // => 3
		     *
		     * _.result(object, 'a[0].b.c2');
		     * // => 4
		     *
		     * _.result(object, 'a[0].b.c3', 'default');
		     * // => 'default'
		     *
		     * _.result(object, 'a[0].b.c3', _.constant('default'));
		     * // => 'default'
		     */
		    function result(object, path, defaultValue) {
		      path = castPath(path, object);

		      var index = -1,
		          length = path.length;

		      // Ensure the loop is entered when path is empty.
		      if (!length) {
		        length = 1;
		        object = undefined$1;
		      }
		      while (++index < length) {
		        var value = object == null ? undefined$1 : object[toKey(path[index])];
		        if (value === undefined$1) {
		          index = length;
		          value = defaultValue;
		        }
		        object = isFunction(value) ? value.call(object) : value;
		      }
		      return object;
		    }

		    /**
		     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
		     * it's created. Arrays are created for missing index properties while objects
		     * are created for all other missing properties. Use `_.setWith` to customize
		     * `path` creation.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
		     *
		     * _.set(object, 'a[0].b.c', 4);
		     * console.log(object.a[0].b.c);
		     * // => 4
		     *
		     * _.set(object, ['x', '0', 'y', 'z'], 5);
		     * console.log(object.x[0].y.z);
		     * // => 5
		     */
		    function set(object, path, value) {
		      return object == null ? object : baseSet(object, path, value);
		    }

		    /**
		     * This method is like `_.set` except that it accepts `customizer` which is
		     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
		     * path creation is handled by the method instead. The `customizer` is invoked
		     * with three arguments: (nsValue, key, nsObject).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {*} value The value to set.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = {};
		     *
		     * _.setWith(object, '[0][1]', 'a', Object);
		     * // => { '0': { '1': 'a' } }
		     */
		    function setWith(object, path, value, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return object == null ? object : baseSet(object, path, value, customizer);
		    }

		    /**
		     * Creates an array of own enumerable string keyed-value pairs for `object`
		     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
		     * entries are returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias entries
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the key-value pairs.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.toPairs(new Foo);
		     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
		     */
		    var toPairs = createToPairs(keys);

		    /**
		     * Creates an array of own and inherited enumerable string keyed-value pairs
		     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
		     * or set, its entries are returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias entriesIn
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the key-value pairs.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.toPairsIn(new Foo);
		     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
		     */
		    var toPairsIn = createToPairs(keysIn);

		    /**
		     * An alternative to `_.reduce`; this method transforms `object` to a new
		     * `accumulator` object which is the result of running each of its own
		     * enumerable string keyed properties thru `iteratee`, with each invocation
		     * potentially mutating the `accumulator` object. If `accumulator` is not
		     * provided, a new object with the same `[[Prototype]]` will be used. The
		     * iteratee is invoked with four arguments: (accumulator, value, key, object).
		     * Iteratee functions may exit iteration early by explicitly returning `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.3.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {*} [accumulator] The custom accumulator value.
		     * @returns {*} Returns the accumulated value.
		     * @example
		     *
		     * _.transform([2, 3, 4], function(result, n) {
		     *   result.push(n *= n);
		     *   return n % 2 == 0;
		     * }, []);
		     * // => [4, 9]
		     *
		     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
		     *   (result[value] || (result[value] = [])).push(key);
		     * }, {});
		     * // => { '1': ['a', 'c'], '2': ['b'] }
		     */
		    function transform(object, iteratee, accumulator) {
		      var isArr = isArray(object),
		          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

		      iteratee = getIteratee(iteratee, 4);
		      if (accumulator == null) {
		        var Ctor = object && object.constructor;
		        if (isArrLike) {
		          accumulator = isArr ? new Ctor : [];
		        }
		        else if (isObject(object)) {
		          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
		        }
		        else {
		          accumulator = {};
		        }
		      }
		      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
		        return iteratee(accumulator, value, index, object);
		      });
		      return accumulator;
		    }

		    /**
		     * Removes the property at `path` of `object`.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to unset.
		     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
		     * _.unset(object, 'a[0].b.c');
		     * // => true
		     *
		     * console.log(object);
		     * // => { 'a': [{ 'b': {} }] };
		     *
		     * _.unset(object, ['a', '0', 'b', 'c']);
		     * // => true
		     *
		     * console.log(object);
		     * // => { 'a': [{ 'b': {} }] };
		     */
		    function unset(object, path) {
		      return object == null ? true : baseUnset(object, path);
		    }

		    /**
		     * This method is like `_.set` except that accepts `updater` to produce the
		     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
		     * is invoked with one argument: (value).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.6.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {Function} updater The function to produce the updated value.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
		     *
		     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
		     * console.log(object.a[0].b.c);
		     * // => 9
		     *
		     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
		     * console.log(object.x[0].y.z);
		     * // => 0
		     */
		    function update(object, path, updater) {
		      return object == null ? object : baseUpdate(object, path, castFunction(updater));
		    }

		    /**
		     * This method is like `_.update` except that it accepts `customizer` which is
		     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
		     * path creation is handled by the method instead. The `customizer` is invoked
		     * with three arguments: (nsValue, key, nsObject).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.6.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {Function} updater The function to produce the updated value.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = {};
		     *
		     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
		     * // => { '0': { '1': 'a' } }
		     */
		    function updateWith(object, path, updater, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
		    }

		    /**
		     * Creates an array of the own enumerable string keyed property values of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property values.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.values(new Foo);
		     * // => [1, 2] (iteration order is not guaranteed)
		     *
		     * _.values('hi');
		     * // => ['h', 'i']
		     */
		    function values(object) {
		      return object == null ? [] : baseValues(object, keys(object));
		    }

		    /**
		     * Creates an array of the own and inherited enumerable string keyed property
		     * values of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property values.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.valuesIn(new Foo);
		     * // => [1, 2, 3] (iteration order is not guaranteed)
		     */
		    function valuesIn(object) {
		      return object == null ? [] : baseValues(object, keysIn(object));
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Clamps `number` within the inclusive `lower` and `upper` bounds.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Number
		     * @param {number} number The number to clamp.
		     * @param {number} [lower] The lower bound.
		     * @param {number} upper The upper bound.
		     * @returns {number} Returns the clamped number.
		     * @example
		     *
		     * _.clamp(-10, -5, 5);
		     * // => -5
		     *
		     * _.clamp(10, -5, 5);
		     * // => 5
		     */
		    function clamp(number, lower, upper) {
		      if (upper === undefined$1) {
		        upper = lower;
		        lower = undefined$1;
		      }
		      if (upper !== undefined$1) {
		        upper = toNumber(upper);
		        upper = upper === upper ? upper : 0;
		      }
		      if (lower !== undefined$1) {
		        lower = toNumber(lower);
		        lower = lower === lower ? lower : 0;
		      }
		      return baseClamp(toNumber(number), lower, upper);
		    }

		    /**
		     * Checks if `n` is between `start` and up to, but not including, `end`. If
		     * `end` is not specified, it's set to `start` with `start` then set to `0`.
		     * If `start` is greater than `end` the params are swapped to support
		     * negative ranges.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.3.0
		     * @category Number
		     * @param {number} number The number to check.
		     * @param {number} [start=0] The start of the range.
		     * @param {number} end The end of the range.
		     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
		     * @see _.range, _.rangeRight
		     * @example
		     *
		     * _.inRange(3, 2, 4);
		     * // => true
		     *
		     * _.inRange(4, 8);
		     * // => true
		     *
		     * _.inRange(4, 2);
		     * // => false
		     *
		     * _.inRange(2, 2);
		     * // => false
		     *
		     * _.inRange(1.2, 2);
		     * // => true
		     *
		     * _.inRange(5.2, 4);
		     * // => false
		     *
		     * _.inRange(-3, -2, -6);
		     * // => true
		     */
		    function inRange(number, start, end) {
		      start = toFinite(start);
		      if (end === undefined$1) {
		        end = start;
		        start = 0;
		      } else {
		        end = toFinite(end);
		      }
		      number = toNumber(number);
		      return baseInRange(number, start, end);
		    }

		    /**
		     * Produces a random number between the inclusive `lower` and `upper` bounds.
		     * If only one argument is provided a number between `0` and the given number
		     * is returned. If `floating` is `true`, or either `lower` or `upper` are
		     * floats, a floating-point number is returned instead of an integer.
		     *
		     * **Note:** JavaScript follows the IEEE-754 standard for resolving
		     * floating-point values which can produce unexpected results.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.7.0
		     * @category Number
		     * @param {number} [lower=0] The lower bound.
		     * @param {number} [upper=1] The upper bound.
		     * @param {boolean} [floating] Specify returning a floating-point number.
		     * @returns {number} Returns the random number.
		     * @example
		     *
		     * _.random(0, 5);
		     * // => an integer between 0 and 5
		     *
		     * _.random(5);
		     * // => also an integer between 0 and 5
		     *
		     * _.random(5, true);
		     * // => a floating-point number between 0 and 5
		     *
		     * _.random(1.2, 5.2);
		     * // => a floating-point number between 1.2 and 5.2
		     */
		    function random(lower, upper, floating) {
		      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
		        upper = floating = undefined$1;
		      }
		      if (floating === undefined$1) {
		        if (typeof upper == 'boolean') {
		          floating = upper;
		          upper = undefined$1;
		        }
		        else if (typeof lower == 'boolean') {
		          floating = lower;
		          lower = undefined$1;
		        }
		      }
		      if (lower === undefined$1 && upper === undefined$1) {
		        lower = 0;
		        upper = 1;
		      }
		      else {
		        lower = toFinite(lower);
		        if (upper === undefined$1) {
		          upper = lower;
		          lower = 0;
		        } else {
		          upper = toFinite(upper);
		        }
		      }
		      if (lower > upper) {
		        var temp = lower;
		        lower = upper;
		        upper = temp;
		      }
		      if (floating || lower % 1 || upper % 1) {
		        var rand = nativeRandom();
		        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
		      }
		      return baseRandom(lower, upper);
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the camel cased string.
		     * @example
		     *
		     * _.camelCase('Foo Bar');
		     * // => 'fooBar'
		     *
		     * _.camelCase('--foo-bar--');
		     * // => 'fooBar'
		     *
		     * _.camelCase('__FOO_BAR__');
		     * // => 'fooBar'
		     */
		    var camelCase = createCompounder(function(result, word, index) {
		      word = word.toLowerCase();
		      return result + (index ? capitalize(word) : word);
		    });

		    /**
		     * Converts the first character of `string` to upper case and the remaining
		     * to lower case.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to capitalize.
		     * @returns {string} Returns the capitalized string.
		     * @example
		     *
		     * _.capitalize('FRED');
		     * // => 'Fred'
		     */
		    function capitalize(string) {
		      return upperFirst(toString(string).toLowerCase());
		    }

		    /**
		     * Deburrs `string` by converting
		     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
		     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
		     * letters to basic Latin letters and removing
		     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to deburr.
		     * @returns {string} Returns the deburred string.
		     * @example
		     *
		     * _.deburr('déjà vu');
		     * // => 'deja vu'
		     */
		    function deburr(string) {
		      string = toString(string);
		      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
		    }

		    /**
		     * Checks if `string` ends with the given target string.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to inspect.
		     * @param {string} [target] The string to search for.
		     * @param {number} [position=string.length] The position to search up to.
		     * @returns {boolean} Returns `true` if `string` ends with `target`,
		     *  else `false`.
		     * @example
		     *
		     * _.endsWith('abc', 'c');
		     * // => true
		     *
		     * _.endsWith('abc', 'b');
		     * // => false
		     *
		     * _.endsWith('abc', 'b', 2);
		     * // => true
		     */
		    function endsWith(string, target, position) {
		      string = toString(string);
		      target = baseToString(target);

		      var length = string.length;
		      position = position === undefined$1
		        ? length
		        : baseClamp(toInteger(position), 0, length);

		      var end = position;
		      position -= target.length;
		      return position >= 0 && string.slice(position, end) == target;
		    }

		    /**
		     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
		     * corresponding HTML entities.
		     *
		     * **Note:** No other characters are escaped. To escape additional
		     * characters use a third-party library like [_he_](https://mths.be/he).
		     *
		     * Though the ">" character is escaped for symmetry, characters like
		     * ">" and "/" don't need escaping in HTML and have no special meaning
		     * unless they're part of a tag or unquoted attribute value. See
		     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
		     * (under "semi-related fun fact") for more details.
		     *
		     * When working with HTML you should always
		     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
		     * XSS vectors.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category String
		     * @param {string} [string=''] The string to escape.
		     * @returns {string} Returns the escaped string.
		     * @example
		     *
		     * _.escape('fred, barney, & pebbles');
		     * // => 'fred, barney, &amp; pebbles'
		     */
		    function escape(string) {
		      string = toString(string);
		      return (string && reHasUnescapedHtml.test(string))
		        ? string.replace(reUnescapedHtml, escapeHtmlChar)
		        : string;
		    }

		    /**
		     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
		     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to escape.
		     * @returns {string} Returns the escaped string.
		     * @example
		     *
		     * _.escapeRegExp('[lodash](https://lodash.com/)');
		     * // => '\[lodash\]\(https://lodash\.com/\)'
		     */
		    function escapeRegExp(string) {
		      string = toString(string);
		      return (string && reHasRegExpChar.test(string))
		        ? string.replace(reRegExpChar, '\\$&')
		        : string;
		    }

		    /**
		     * Converts `string` to
		     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the kebab cased string.
		     * @example
		     *
		     * _.kebabCase('Foo Bar');
		     * // => 'foo-bar'
		     *
		     * _.kebabCase('fooBar');
		     * // => 'foo-bar'
		     *
		     * _.kebabCase('__FOO_BAR__');
		     * // => 'foo-bar'
		     */
		    var kebabCase = createCompounder(function(result, word, index) {
		      return result + (index ? '-' : '') + word.toLowerCase();
		    });

		    /**
		     * Converts `string`, as space separated words, to lower case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the lower cased string.
		     * @example
		     *
		     * _.lowerCase('--Foo-Bar--');
		     * // => 'foo bar'
		     *
		     * _.lowerCase('fooBar');
		     * // => 'foo bar'
		     *
		     * _.lowerCase('__FOO_BAR__');
		     * // => 'foo bar'
		     */
		    var lowerCase = createCompounder(function(result, word, index) {
		      return result + (index ? ' ' : '') + word.toLowerCase();
		    });

		    /**
		     * Converts the first character of `string` to lower case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the converted string.
		     * @example
		     *
		     * _.lowerFirst('Fred');
		     * // => 'fred'
		     *
		     * _.lowerFirst('FRED');
		     * // => 'fRED'
		     */
		    var lowerFirst = createCaseFirst('toLowerCase');

		    /**
		     * Pads `string` on the left and right sides if it's shorter than `length`.
		     * Padding characters are truncated if they can't be evenly divided by `length`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to pad.
		     * @param {number} [length=0] The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padded string.
		     * @example
		     *
		     * _.pad('abc', 8);
		     * // => '  abc   '
		     *
		     * _.pad('abc', 8, '_-');
		     * // => '_-abc_-_'
		     *
		     * _.pad('abc', 3);
		     * // => 'abc'
		     */
		    function pad(string, length, chars) {
		      string = toString(string);
		      length = toInteger(length);

		      var strLength = length ? stringSize(string) : 0;
		      if (!length || strLength >= length) {
		        return string;
		      }
		      var mid = (length - strLength) / 2;
		      return (
		        createPadding(nativeFloor(mid), chars) +
		        string +
		        createPadding(nativeCeil(mid), chars)
		      );
		    }

		    /**
		     * Pads `string` on the right side if it's shorter than `length`. Padding
		     * characters are truncated if they exceed `length`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to pad.
		     * @param {number} [length=0] The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padded string.
		     * @example
		     *
		     * _.padEnd('abc', 6);
		     * // => 'abc   '
		     *
		     * _.padEnd('abc', 6, '_-');
		     * // => 'abc_-_'
		     *
		     * _.padEnd('abc', 3);
		     * // => 'abc'
		     */
		    function padEnd(string, length, chars) {
		      string = toString(string);
		      length = toInteger(length);

		      var strLength = length ? stringSize(string) : 0;
		      return (length && strLength < length)
		        ? (string + createPadding(length - strLength, chars))
		        : string;
		    }

		    /**
		     * Pads `string` on the left side if it's shorter than `length`. Padding
		     * characters are truncated if they exceed `length`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to pad.
		     * @param {number} [length=0] The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padded string.
		     * @example
		     *
		     * _.padStart('abc', 6);
		     * // => '   abc'
		     *
		     * _.padStart('abc', 6, '_-');
		     * // => '_-_abc'
		     *
		     * _.padStart('abc', 3);
		     * // => 'abc'
		     */
		    function padStart(string, length, chars) {
		      string = toString(string);
		      length = toInteger(length);

		      var strLength = length ? stringSize(string) : 0;
		      return (length && strLength < length)
		        ? (createPadding(length - strLength, chars) + string)
		        : string;
		    }

		    /**
		     * Converts `string` to an integer of the specified radix. If `radix` is
		     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
		     * hexadecimal, in which case a `radix` of `16` is used.
		     *
		     * **Note:** This method aligns with the
		     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.1.0
		     * @category String
		     * @param {string} string The string to convert.
		     * @param {number} [radix=10] The radix to interpret `value` by.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.parseInt('08');
		     * // => 8
		     *
		     * _.map(['6', '08', '10'], _.parseInt);
		     * // => [6, 8, 10]
		     */
		    function parseInt(string, radix, guard) {
		      if (guard || radix == null) {
		        radix = 0;
		      } else if (radix) {
		        radix = +radix;
		      }
		      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
		    }

		    /**
		     * Repeats the given string `n` times.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to repeat.
		     * @param {number} [n=1] The number of times to repeat the string.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the repeated string.
		     * @example
		     *
		     * _.repeat('*', 3);
		     * // => '***'
		     *
		     * _.repeat('abc', 2);
		     * // => 'abcabc'
		     *
		     * _.repeat('abc', 0);
		     * // => ''
		     */
		    function repeat(string, n, guard) {
		      if ((guard ? isIterateeCall(string, n, guard) : n === undefined$1)) {
		        n = 1;
		      } else {
		        n = toInteger(n);
		      }
		      return baseRepeat(toString(string), n);
		    }

		    /**
		     * Replaces matches for `pattern` in `string` with `replacement`.
		     *
		     * **Note:** This method is based on
		     * [`String#replace`](https://mdn.io/String/replace).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to modify.
		     * @param {RegExp|string} pattern The pattern to replace.
		     * @param {Function|string} replacement The match replacement.
		     * @returns {string} Returns the modified string.
		     * @example
		     *
		     * _.replace('Hi Fred', 'Fred', 'Barney');
		     * // => 'Hi Barney'
		     */
		    function replace() {
		      var args = arguments,
		          string = toString(args[0]);

		      return args.length < 3 ? string : string.replace(args[1], args[2]);
		    }

		    /**
		     * Converts `string` to
		     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the snake cased string.
		     * @example
		     *
		     * _.snakeCase('Foo Bar');
		     * // => 'foo_bar'
		     *
		     * _.snakeCase('fooBar');
		     * // => 'foo_bar'
		     *
		     * _.snakeCase('--FOO-BAR--');
		     * // => 'foo_bar'
		     */
		    var snakeCase = createCompounder(function(result, word, index) {
		      return result + (index ? '_' : '') + word.toLowerCase();
		    });

		    /**
		     * Splits `string` by `separator`.
		     *
		     * **Note:** This method is based on
		     * [`String#split`](https://mdn.io/String/split).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to split.
		     * @param {RegExp|string} separator The separator pattern to split by.
		     * @param {number} [limit] The length to truncate results to.
		     * @returns {Array} Returns the string segments.
		     * @example
		     *
		     * _.split('a-b-c', '-', 2);
		     * // => ['a', 'b']
		     */
		    function split(string, separator, limit) {
		      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
		        separator = limit = undefined$1;
		      }
		      limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
		      if (!limit) {
		        return [];
		      }
		      string = toString(string);
		      if (string && (
		            typeof separator == 'string' ||
		            (separator != null && !isRegExp(separator))
		          )) {
		        separator = baseToString(separator);
		        if (!separator && hasUnicode(string)) {
		          return castSlice(stringToArray(string), 0, limit);
		        }
		      }
		      return string.split(separator, limit);
		    }

		    /**
		     * Converts `string` to
		     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.1.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the start cased string.
		     * @example
		     *
		     * _.startCase('--foo-bar--');
		     * // => 'Foo Bar'
		     *
		     * _.startCase('fooBar');
		     * // => 'Foo Bar'
		     *
		     * _.startCase('__FOO_BAR__');
		     * // => 'FOO BAR'
		     */
		    var startCase = createCompounder(function(result, word, index) {
		      return result + (index ? ' ' : '') + upperFirst(word);
		    });

		    /**
		     * Checks if `string` starts with the given target string.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to inspect.
		     * @param {string} [target] The string to search for.
		     * @param {number} [position=0] The position to search from.
		     * @returns {boolean} Returns `true` if `string` starts with `target`,
		     *  else `false`.
		     * @example
		     *
		     * _.startsWith('abc', 'a');
		     * // => true
		     *
		     * _.startsWith('abc', 'b');
		     * // => false
		     *
		     * _.startsWith('abc', 'b', 1);
		     * // => true
		     */
		    function startsWith(string, target, position) {
		      string = toString(string);
		      position = position == null
		        ? 0
		        : baseClamp(toInteger(position), 0, string.length);

		      target = baseToString(target);
		      return string.slice(position, position + target.length) == target;
		    }

		    /**
		     * Creates a compiled template function that can interpolate data properties
		     * in "interpolate" delimiters, HTML-escape interpolated data properties in
		     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
		     * properties may be accessed as free variables in the template. If a setting
		     * object is given, it takes precedence over `_.templateSettings` values.
		     *
		     * **Note:** In the development build `_.template` utilizes
		     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
		     * for easier debugging.
		     *
		     * For more information on precompiling templates see
		     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
		     *
		     * For more information on Chrome extension sandboxes see
		     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category String
		     * @param {string} [string=''] The template string.
		     * @param {Object} [options={}] The options object.
		     * @param {RegExp} [options.escape=_.templateSettings.escape]
		     *  The HTML "escape" delimiter.
		     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
		     *  The "evaluate" delimiter.
		     * @param {Object} [options.imports=_.templateSettings.imports]
		     *  An object to import into the template as free variables.
		     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
		     *  The "interpolate" delimiter.
		     * @param {string} [options.sourceURL='lodash.templateSources[n]']
		     *  The sourceURL of the compiled template.
		     * @param {string} [options.variable='obj']
		     *  The data object variable name.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the compiled template function.
		     * @example
		     *
		     * // Use the "interpolate" delimiter to create a compiled template.
		     * var compiled = _.template('hello <%= user %>!');
		     * compiled({ 'user': 'fred' });
		     * // => 'hello fred!'
		     *
		     * // Use the HTML "escape" delimiter to escape data property values.
		     * var compiled = _.template('<b><%- value %></b>');
		     * compiled({ 'value': '<script>' });
		     * // => '<b>&lt;script&gt;</b>'
		     *
		     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
		     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
		     * compiled({ 'users': ['fred', 'barney'] });
		     * // => '<li>fred</li><li>barney</li>'
		     *
		     * // Use the internal `print` function in "evaluate" delimiters.
		     * var compiled = _.template('<% print("hello " + user); %>!');
		     * compiled({ 'user': 'barney' });
		     * // => 'hello barney!'
		     *
		     * // Use the ES template literal delimiter as an "interpolate" delimiter.
		     * // Disable support by replacing the "interpolate" delimiter.
		     * var compiled = _.template('hello ${ user }!');
		     * compiled({ 'user': 'pebbles' });
		     * // => 'hello pebbles!'
		     *
		     * // Use backslashes to treat delimiters as plain text.
		     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
		     * compiled({ 'value': 'ignored' });
		     * // => '<%- value %>'
		     *
		     * // Use the `imports` option to import `jQuery` as `jq`.
		     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
		     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
		     * compiled({ 'users': ['fred', 'barney'] });
		     * // => '<li>fred</li><li>barney</li>'
		     *
		     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
		     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
		     * compiled(data);
		     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
		     *
		     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
		     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
		     * compiled.source;
		     * // => function(data) {
		     * //   var __t, __p = '';
		     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
		     * //   return __p;
		     * // }
		     *
		     * // Use custom template delimiters.
		     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
		     * var compiled = _.template('hello {{ user }}!');
		     * compiled({ 'user': 'mustache' });
		     * // => 'hello mustache!'
		     *
		     * // Use the `source` property to inline compiled templates for meaningful
		     * // line numbers in error messages and stack traces.
		     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
		     *   var JST = {\
		     *     "main": ' + _.template(mainText).source + '\
		     *   };\
		     * ');
		     */
		    function template(string, options, guard) {
		      // Based on John Resig's `tmpl` implementation
		      // (http://ejohn.org/blog/javascript-micro-templating/)
		      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
		      var settings = lodash.templateSettings;

		      if (guard && isIterateeCall(string, options, guard)) {
		        options = undefined$1;
		      }
		      string = toString(string);
		      options = assignInWith({}, options, settings, customDefaultsAssignIn);

		      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
		          importsKeys = keys(imports),
		          importsValues = baseValues(imports, importsKeys);

		      var isEscaping,
		          isEvaluating,
		          index = 0,
		          interpolate = options.interpolate || reNoMatch,
		          source = "__p += '";

		      // Compile the regexp to match each delimiter.
		      var reDelimiters = RegExp(
		        (options.escape || reNoMatch).source + '|' +
		        interpolate.source + '|' +
		        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
		        (options.evaluate || reNoMatch).source + '|$'
		      , 'g');

		      // Use a sourceURL for easier debugging.
		      // The sourceURL gets injected into the source that's eval-ed, so be careful
		      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
		      // and escape the comment, thus injecting code that gets evaled.
		      var sourceURL = '//# sourceURL=' +
		        (hasOwnProperty.call(options, 'sourceURL')
		          ? (options.sourceURL + '').replace(/\s/g, ' ')
		          : ('lodash.templateSources[' + (++templateCounter) + ']')
		        ) + '\n';

		      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
		        interpolateValue || (interpolateValue = esTemplateValue);

		        // Escape characters that can't be included in string literals.
		        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

		        // Replace delimiters with snippets.
		        if (escapeValue) {
		          isEscaping = true;
		          source += "' +\n__e(" + escapeValue + ") +\n'";
		        }
		        if (evaluateValue) {
		          isEvaluating = true;
		          source += "';\n" + evaluateValue + ";\n__p += '";
		        }
		        if (interpolateValue) {
		          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
		        }
		        index = offset + match.length;

		        // The JS engine embedded in Adobe products needs `match` returned in
		        // order to produce the correct `offset` value.
		        return match;
		      });

		      source += "';\n";

		      // If `variable` is not specified wrap a with-statement around the generated
		      // code to add the data object to the top of the scope chain.
		      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
		      if (!variable) {
		        source = 'with (obj) {\n' + source + '\n}\n';
		      }
		      // Throw an error if a forbidden character was found in `variable`, to prevent
		      // potential command injection attacks.
		      else if (reForbiddenIdentifierChars.test(variable)) {
		        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
		      }

		      // Cleanup code by stripping empty strings.
		      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
		        .replace(reEmptyStringMiddle, '$1')
		        .replace(reEmptyStringTrailing, '$1;');

		      // Frame code as the function body.
		      source = 'function(' + (variable || 'obj') + ') {\n' +
		        (variable
		          ? ''
		          : 'obj || (obj = {});\n'
		        ) +
		        "var __t, __p = ''" +
		        (isEscaping
		           ? ', __e = _.escape'
		           : ''
		        ) +
		        (isEvaluating
		          ? ', __j = Array.prototype.join;\n' +
		            "function print() { __p += __j.call(arguments, '') }\n"
		          : ';\n'
		        ) +
		        source +
		        'return __p\n}';

		      var result = attempt(function() {
		        return Function(importsKeys, sourceURL + 'return ' + source)
		          .apply(undefined$1, importsValues);
		      });

		      // Provide the compiled function's source by its `toString` method or
		      // the `source` property as a convenience for inlining compiled templates.
		      result.source = source;
		      if (isError(result)) {
		        throw result;
		      }
		      return result;
		    }

		    /**
		     * Converts `string`, as a whole, to lower case just like
		     * [String#toLowerCase](https://mdn.io/toLowerCase).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the lower cased string.
		     * @example
		     *
		     * _.toLower('--Foo-Bar--');
		     * // => '--foo-bar--'
		     *
		     * _.toLower('fooBar');
		     * // => 'foobar'
		     *
		     * _.toLower('__FOO_BAR__');
		     * // => '__foo_bar__'
		     */
		    function toLower(value) {
		      return toString(value).toLowerCase();
		    }

		    /**
		     * Converts `string`, as a whole, to upper case just like
		     * [String#toUpperCase](https://mdn.io/toUpperCase).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the upper cased string.
		     * @example
		     *
		     * _.toUpper('--foo-bar--');
		     * // => '--FOO-BAR--'
		     *
		     * _.toUpper('fooBar');
		     * // => 'FOOBAR'
		     *
		     * _.toUpper('__foo_bar__');
		     * // => '__FOO_BAR__'
		     */
		    function toUpper(value) {
		      return toString(value).toUpperCase();
		    }

		    /**
		     * Removes leading and trailing whitespace or specified characters from `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to trim.
		     * @param {string} [chars=whitespace] The characters to trim.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the trimmed string.
		     * @example
		     *
		     * _.trim('  abc  ');
		     * // => 'abc'
		     *
		     * _.trim('-_-abc-_-', '_-');
		     * // => 'abc'
		     *
		     * _.map(['  foo  ', '  bar  '], _.trim);
		     * // => ['foo', 'bar']
		     */
		    function trim(string, chars, guard) {
		      string = toString(string);
		      if (string && (guard || chars === undefined$1)) {
		        return baseTrim(string);
		      }
		      if (!string || !(chars = baseToString(chars))) {
		        return string;
		      }
		      var strSymbols = stringToArray(string),
		          chrSymbols = stringToArray(chars),
		          start = charsStartIndex(strSymbols, chrSymbols),
		          end = charsEndIndex(strSymbols, chrSymbols) + 1;

		      return castSlice(strSymbols, start, end).join('');
		    }

		    /**
		     * Removes trailing whitespace or specified characters from `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to trim.
		     * @param {string} [chars=whitespace] The characters to trim.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the trimmed string.
		     * @example
		     *
		     * _.trimEnd('  abc  ');
		     * // => '  abc'
		     *
		     * _.trimEnd('-_-abc-_-', '_-');
		     * // => '-_-abc'
		     */
		    function trimEnd(string, chars, guard) {
		      string = toString(string);
		      if (string && (guard || chars === undefined$1)) {
		        return string.slice(0, trimmedEndIndex(string) + 1);
		      }
		      if (!string || !(chars = baseToString(chars))) {
		        return string;
		      }
		      var strSymbols = stringToArray(string),
		          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

		      return castSlice(strSymbols, 0, end).join('');
		    }

		    /**
		     * Removes leading whitespace or specified characters from `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to trim.
		     * @param {string} [chars=whitespace] The characters to trim.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the trimmed string.
		     * @example
		     *
		     * _.trimStart('  abc  ');
		     * // => 'abc  '
		     *
		     * _.trimStart('-_-abc-_-', '_-');
		     * // => 'abc-_-'
		     */
		    function trimStart(string, chars, guard) {
		      string = toString(string);
		      if (string && (guard || chars === undefined$1)) {
		        return string.replace(reTrimStart, '');
		      }
		      if (!string || !(chars = baseToString(chars))) {
		        return string;
		      }
		      var strSymbols = stringToArray(string),
		          start = charsStartIndex(strSymbols, stringToArray(chars));

		      return castSlice(strSymbols, start).join('');
		    }

		    /**
		     * Truncates `string` if it's longer than the given maximum string length.
		     * The last characters of the truncated string are replaced with the omission
		     * string which defaults to "...".
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to truncate.
		     * @param {Object} [options={}] The options object.
		     * @param {number} [options.length=30] The maximum string length.
		     * @param {string} [options.omission='...'] The string to indicate text is omitted.
		     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
		     * @returns {string} Returns the truncated string.
		     * @example
		     *
		     * _.truncate('hi-diddly-ho there, neighborino');
		     * // => 'hi-diddly-ho there, neighbo...'
		     *
		     * _.truncate('hi-diddly-ho there, neighborino', {
		     *   'length': 24,
		     *   'separator': ' '
		     * });
		     * // => 'hi-diddly-ho there,...'
		     *
		     * _.truncate('hi-diddly-ho there, neighborino', {
		     *   'length': 24,
		     *   'separator': /,? +/
		     * });
		     * // => 'hi-diddly-ho there...'
		     *
		     * _.truncate('hi-diddly-ho there, neighborino', {
		     *   'omission': ' [...]'
		     * });
		     * // => 'hi-diddly-ho there, neig [...]'
		     */
		    function truncate(string, options) {
		      var length = DEFAULT_TRUNC_LENGTH,
		          omission = DEFAULT_TRUNC_OMISSION;

		      if (isObject(options)) {
		        var separator = 'separator' in options ? options.separator : separator;
		        length = 'length' in options ? toInteger(options.length) : length;
		        omission = 'omission' in options ? baseToString(options.omission) : omission;
		      }
		      string = toString(string);

		      var strLength = string.length;
		      if (hasUnicode(string)) {
		        var strSymbols = stringToArray(string);
		        strLength = strSymbols.length;
		      }
		      if (length >= strLength) {
		        return string;
		      }
		      var end = length - stringSize(omission);
		      if (end < 1) {
		        return omission;
		      }
		      var result = strSymbols
		        ? castSlice(strSymbols, 0, end).join('')
		        : string.slice(0, end);

		      if (separator === undefined$1) {
		        return result + omission;
		      }
		      if (strSymbols) {
		        end += (result.length - end);
		      }
		      if (isRegExp(separator)) {
		        if (string.slice(end).search(separator)) {
		          var match,
		              substring = result;

		          if (!separator.global) {
		            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
		          }
		          separator.lastIndex = 0;
		          while ((match = separator.exec(substring))) {
		            var newEnd = match.index;
		          }
		          result = result.slice(0, newEnd === undefined$1 ? end : newEnd);
		        }
		      } else if (string.indexOf(baseToString(separator), end) != end) {
		        var index = result.lastIndexOf(separator);
		        if (index > -1) {
		          result = result.slice(0, index);
		        }
		      }
		      return result + omission;
		    }

		    /**
		     * The inverse of `_.escape`; this method converts the HTML entities
		     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
		     * their corresponding characters.
		     *
		     * **Note:** No other HTML entities are unescaped. To unescape additional
		     * HTML entities use a third-party library like [_he_](https://mths.be/he).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.6.0
		     * @category String
		     * @param {string} [string=''] The string to unescape.
		     * @returns {string} Returns the unescaped string.
		     * @example
		     *
		     * _.unescape('fred, barney, &amp; pebbles');
		     * // => 'fred, barney, & pebbles'
		     */
		    function unescape(string) {
		      string = toString(string);
		      return (string && reHasEscapedHtml.test(string))
		        ? string.replace(reEscapedHtml, unescapeHtmlChar)
		        : string;
		    }

		    /**
		     * Converts `string`, as space separated words, to upper case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the upper cased string.
		     * @example
		     *
		     * _.upperCase('--foo-bar');
		     * // => 'FOO BAR'
		     *
		     * _.upperCase('fooBar');
		     * // => 'FOO BAR'
		     *
		     * _.upperCase('__foo_bar__');
		     * // => 'FOO BAR'
		     */
		    var upperCase = createCompounder(function(result, word, index) {
		      return result + (index ? ' ' : '') + word.toUpperCase();
		    });

		    /**
		     * Converts the first character of `string` to upper case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the converted string.
		     * @example
		     *
		     * _.upperFirst('fred');
		     * // => 'Fred'
		     *
		     * _.upperFirst('FRED');
		     * // => 'FRED'
		     */
		    var upperFirst = createCaseFirst('toUpperCase');

		    /**
		     * Splits `string` into an array of its words.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to inspect.
		     * @param {RegExp|string} [pattern] The pattern to match words.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the words of `string`.
		     * @example
		     *
		     * _.words('fred, barney, & pebbles');
		     * // => ['fred', 'barney', 'pebbles']
		     *
		     * _.words('fred, barney, & pebbles', /[^, ]+/g);
		     * // => ['fred', 'barney', '&', 'pebbles']
		     */
		    function words(string, pattern, guard) {
		      string = toString(string);
		      pattern = guard ? undefined$1 : pattern;

		      if (pattern === undefined$1) {
		        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
		      }
		      return string.match(pattern) || [];
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Attempts to invoke `func`, returning either the result or the caught error
		     * object. Any additional arguments are provided to `func` when it's invoked.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {Function} func The function to attempt.
		     * @param {...*} [args] The arguments to invoke `func` with.
		     * @returns {*} Returns the `func` result or error object.
		     * @example
		     *
		     * // Avoid throwing errors for invalid selectors.
		     * var elements = _.attempt(function(selector) {
		     *   return document.querySelectorAll(selector);
		     * }, '>_>');
		     *
		     * if (_.isError(elements)) {
		     *   elements = [];
		     * }
		     */
		    var attempt = baseRest(function(func, args) {
		      try {
		        return apply(func, undefined$1, args);
		      } catch (e) {
		        return isError(e) ? e : new Error(e);
		      }
		    });

		    /**
		     * Binds methods of an object to the object itself, overwriting the existing
		     * method.
		     *
		     * **Note:** This method doesn't set the "length" property of bound functions.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {Object} object The object to bind and assign the bound methods to.
		     * @param {...(string|string[])} methodNames The object method names to bind.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var view = {
		     *   'label': 'docs',
		     *   'click': function() {
		     *     console.log('clicked ' + this.label);
		     *   }
		     * };
		     *
		     * _.bindAll(view, ['click']);
		     * jQuery(element).on('click', view.click);
		     * // => Logs 'clicked docs' when clicked.
		     */
		    var bindAll = flatRest(function(object, methodNames) {
		      arrayEach(methodNames, function(key) {
		        key = toKey(key);
		        baseAssignValue(object, key, bind(object[key], object));
		      });
		      return object;
		    });

		    /**
		     * Creates a function that iterates over `pairs` and invokes the corresponding
		     * function of the first predicate to return truthy. The predicate-function
		     * pairs are invoked with the `this` binding and arguments of the created
		     * function.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {Array} pairs The predicate-function pairs.
		     * @returns {Function} Returns the new composite function.
		     * @example
		     *
		     * var func = _.cond([
		     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
		     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
		     *   [_.stubTrue,                      _.constant('no match')]
		     * ]);
		     *
		     * func({ 'a': 1, 'b': 2 });
		     * // => 'matches A'
		     *
		     * func({ 'a': 0, 'b': 1 });
		     * // => 'matches B'
		     *
		     * func({ 'a': '1', 'b': '2' });
		     * // => 'no match'
		     */
		    function cond(pairs) {
		      var length = pairs == null ? 0 : pairs.length,
		          toIteratee = getIteratee();

		      pairs = !length ? [] : arrayMap(pairs, function(pair) {
		        if (typeof pair[1] != 'function') {
		          throw new TypeError(FUNC_ERROR_TEXT);
		        }
		        return [toIteratee(pair[0]), pair[1]];
		      });

		      return baseRest(function(args) {
		        var index = -1;
		        while (++index < length) {
		          var pair = pairs[index];
		          if (apply(pair[0], this, args)) {
		            return apply(pair[1], this, args);
		          }
		        }
		      });
		    }

		    /**
		     * Creates a function that invokes the predicate properties of `source` with
		     * the corresponding property values of a given object, returning `true` if
		     * all predicates return truthy, else `false`.
		     *
		     * **Note:** The created function is equivalent to `_.conformsTo` with
		     * `source` partially applied.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {Object} source The object of property predicates to conform to.
		     * @returns {Function} Returns the new spec function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': 2, 'b': 1 },
		     *   { 'a': 1, 'b': 2 }
		     * ];
		     *
		     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
		     * // => [{ 'a': 1, 'b': 2 }]
		     */
		    function conforms(source) {
		      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
		    }

		    /**
		     * Creates a function that returns `value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Util
		     * @param {*} value The value to return from the new function.
		     * @returns {Function} Returns the new constant function.
		     * @example
		     *
		     * var objects = _.times(2, _.constant({ 'a': 1 }));
		     *
		     * console.log(objects);
		     * // => [{ 'a': 1 }, { 'a': 1 }]
		     *
		     * console.log(objects[0] === objects[1]);
		     * // => true
		     */
		    function constant(value) {
		      return function() {
		        return value;
		      };
		    }

		    /**
		     * Checks `value` to determine whether a default value should be returned in
		     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
		     * or `undefined`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.14.0
		     * @category Util
		     * @param {*} value The value to check.
		     * @param {*} defaultValue The default value.
		     * @returns {*} Returns the resolved value.
		     * @example
		     *
		     * _.defaultTo(1, 10);
		     * // => 1
		     *
		     * _.defaultTo(undefined, 10);
		     * // => 10
		     */
		    function defaultTo(value, defaultValue) {
		      return (value == null || value !== value) ? defaultValue : value;
		    }

		    /**
		     * Creates a function that returns the result of invoking the given functions
		     * with the `this` binding of the created function, where each successive
		     * invocation is supplied the return value of the previous.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {...(Function|Function[])} [funcs] The functions to invoke.
		     * @returns {Function} Returns the new composite function.
		     * @see _.flowRight
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var addSquare = _.flow([_.add, square]);
		     * addSquare(1, 2);
		     * // => 9
		     */
		    var flow = createFlow();

		    /**
		     * This method is like `_.flow` except that it creates a function that
		     * invokes the given functions from right to left.
		     *
		     * @static
		     * @since 3.0.0
		     * @memberOf _
		     * @category Util
		     * @param {...(Function|Function[])} [funcs] The functions to invoke.
		     * @returns {Function} Returns the new composite function.
		     * @see _.flow
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var addSquare = _.flowRight([square, _.add]);
		     * addSquare(1, 2);
		     * // => 9
		     */
		    var flowRight = createFlow(true);

		    /**
		     * This method returns the first argument it receives.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {*} value Any value.
		     * @returns {*} Returns `value`.
		     * @example
		     *
		     * var object = { 'a': 1 };
		     *
		     * console.log(_.identity(object) === object);
		     * // => true
		     */
		    function identity(value) {
		      return value;
		    }

		    /**
		     * Creates a function that invokes `func` with the arguments of the created
		     * function. If `func` is a property name, the created function returns the
		     * property value for a given element. If `func` is an array or object, the
		     * created function returns `true` for elements that contain the equivalent
		     * source properties, otherwise it returns `false`.
		     *
		     * @static
		     * @since 4.0.0
		     * @memberOf _
		     * @category Util
		     * @param {*} [func=_.identity] The value to convert to a callback.
		     * @returns {Function} Returns the callback.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': true },
		     *   { 'user': 'fred',   'age': 40, 'active': false }
		     * ];
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
		     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.filter(users, _.iteratee(['user', 'fred']));
		     * // => [{ 'user': 'fred', 'age': 40 }]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.map(users, _.iteratee('user'));
		     * // => ['barney', 'fred']
		     *
		     * // Create custom iteratee shorthands.
		     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
		     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
		     *     return func.test(string);
		     *   };
		     * });
		     *
		     * _.filter(['abc', 'def'], /ef/);
		     * // => ['def']
		     */
		    function iteratee(func) {
		      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
		    }

		    /**
		     * Creates a function that performs a partial deep comparison between a given
		     * object and `source`, returning `true` if the given object has equivalent
		     * property values, else `false`.
		     *
		     * **Note:** The created function is equivalent to `_.isMatch` with `source`
		     * partially applied.
		     *
		     * Partial comparisons will match empty array and empty object `source`
		     * values against any array or object value, respectively. See `_.isEqual`
		     * for a list of supported value comparisons.
		     *
		     * **Note:** Multiple values can be checked by combining several matchers
		     * using `_.overSome`
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {Object} source The object of property values to match.
		     * @returns {Function} Returns the new spec function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': 1, 'b': 2, 'c': 3 },
		     *   { 'a': 4, 'b': 5, 'c': 6 }
		     * ];
		     *
		     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
		     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
		     *
		     * // Checking for several possible values
		     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
		     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
		     */
		    function matches(source) {
		      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
		    }

		    /**
		     * Creates a function that performs a partial deep comparison between the
		     * value at `path` of a given object to `srcValue`, returning `true` if the
		     * object value is equivalent, else `false`.
		     *
		     * **Note:** Partial comparisons will match empty array and empty object
		     * `srcValue` values against any array or object value, respectively. See
		     * `_.isEqual` for a list of supported value comparisons.
		     *
		     * **Note:** Multiple values can be checked by combining several matchers
		     * using `_.overSome`
		     *
		     * @static
		     * @memberOf _
		     * @since 3.2.0
		     * @category Util
		     * @param {Array|string} path The path of the property to get.
		     * @param {*} srcValue The value to match.
		     * @returns {Function} Returns the new spec function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': 1, 'b': 2, 'c': 3 },
		     *   { 'a': 4, 'b': 5, 'c': 6 }
		     * ];
		     *
		     * _.find(objects, _.matchesProperty('a', 4));
		     * // => { 'a': 4, 'b': 5, 'c': 6 }
		     *
		     * // Checking for several possible values
		     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
		     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
		     */
		    function matchesProperty(path, srcValue) {
		      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
		    }

		    /**
		     * Creates a function that invokes the method at `path` of a given object.
		     * Any additional arguments are provided to the invoked method.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Util
		     * @param {Array|string} path The path of the method to invoke.
		     * @param {...*} [args] The arguments to invoke the method with.
		     * @returns {Function} Returns the new invoker function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': { 'b': _.constant(2) } },
		     *   { 'a': { 'b': _.constant(1) } }
		     * ];
		     *
		     * _.map(objects, _.method('a.b'));
		     * // => [2, 1]
		     *
		     * _.map(objects, _.method(['a', 'b']));
		     * // => [2, 1]
		     */
		    var method = baseRest(function(path, args) {
		      return function(object) {
		        return baseInvoke(object, path, args);
		      };
		    });

		    /**
		     * The opposite of `_.method`; this method creates a function that invokes
		     * the method at a given path of `object`. Any additional arguments are
		     * provided to the invoked method.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Util
		     * @param {Object} object The object to query.
		     * @param {...*} [args] The arguments to invoke the method with.
		     * @returns {Function} Returns the new invoker function.
		     * @example
		     *
		     * var array = _.times(3, _.constant),
		     *     object = { 'a': array, 'b': array, 'c': array };
		     *
		     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
		     * // => [2, 0]
		     *
		     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
		     * // => [2, 0]
		     */
		    var methodOf = baseRest(function(object, args) {
		      return function(path) {
		        return baseInvoke(object, path, args);
		      };
		    });

		    /**
		     * Adds all own enumerable string keyed function properties of a source
		     * object to the destination object. If `object` is a function, then methods
		     * are added to its prototype as well.
		     *
		     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
		     * avoid conflicts caused by modifying the original.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {Function|Object} [object=lodash] The destination object.
		     * @param {Object} source The object of functions to add.
		     * @param {Object} [options={}] The options object.
		     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
		     * @returns {Function|Object} Returns `object`.
		     * @example
		     *
		     * function vowels(string) {
		     *   return _.filter(string, function(v) {
		     *     return /[aeiou]/i.test(v);
		     *   });
		     * }
		     *
		     * _.mixin({ 'vowels': vowels });
		     * _.vowels('fred');
		     * // => ['e']
		     *
		     * _('fred').vowels().value();
		     * // => ['e']
		     *
		     * _.mixin({ 'vowels': vowels }, { 'chain': false });
		     * _('fred').vowels();
		     * // => ['e']
		     */
		    function mixin(object, source, options) {
		      var props = keys(source),
		          methodNames = baseFunctions(source, props);

		      if (options == null &&
		          !(isObject(source) && (methodNames.length || !props.length))) {
		        options = source;
		        source = object;
		        object = this;
		        methodNames = baseFunctions(source, keys(source));
		      }
		      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
		          isFunc = isFunction(object);

		      arrayEach(methodNames, function(methodName) {
		        var func = source[methodName];
		        object[methodName] = func;
		        if (isFunc) {
		          object.prototype[methodName] = function() {
		            var chainAll = this.__chain__;
		            if (chain || chainAll) {
		              var result = object(this.__wrapped__),
		                  actions = result.__actions__ = copyArray(this.__actions__);

		              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
		              result.__chain__ = chainAll;
		              return result;
		            }
		            return func.apply(object, arrayPush([this.value()], arguments));
		          };
		        }
		      });

		      return object;
		    }

		    /**
		     * Reverts the `_` variable to its previous value and returns a reference to
		     * the `lodash` function.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @returns {Function} Returns the `lodash` function.
		     * @example
		     *
		     * var lodash = _.noConflict();
		     */
		    function noConflict() {
		      if (root._ === this) {
		        root._ = oldDash;
		      }
		      return this;
		    }

		    /**
		     * This method returns `undefined`.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.3.0
		     * @category Util
		     * @example
		     *
		     * _.times(2, _.noop);
		     * // => [undefined, undefined]
		     */
		    function noop() {
		      // No operation performed.
		    }

		    /**
		     * Creates a function that gets the argument at index `n`. If `n` is negative,
		     * the nth argument from the end is returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {number} [n=0] The index of the argument to return.
		     * @returns {Function} Returns the new pass-thru function.
		     * @example
		     *
		     * var func = _.nthArg(1);
		     * func('a', 'b', 'c', 'd');
		     * // => 'b'
		     *
		     * var func = _.nthArg(-2);
		     * func('a', 'b', 'c', 'd');
		     * // => 'c'
		     */
		    function nthArg(n) {
		      n = toInteger(n);
		      return baseRest(function(args) {
		        return baseNth(args, n);
		      });
		    }

		    /**
		     * Creates a function that invokes `iteratees` with the arguments it receives
		     * and returns their results.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {...(Function|Function[])} [iteratees=[_.identity]]
		     *  The iteratees to invoke.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var func = _.over([Math.max, Math.min]);
		     *
		     * func(1, 2, 3, 4);
		     * // => [4, 1]
		     */
		    var over = createOver(arrayMap);

		    /**
		     * Creates a function that checks if **all** of the `predicates` return
		     * truthy when invoked with the arguments it receives.
		     *
		     * Following shorthands are possible for providing predicates.
		     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
		     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {...(Function|Function[])} [predicates=[_.identity]]
		     *  The predicates to check.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var func = _.overEvery([Boolean, isFinite]);
		     *
		     * func('1');
		     * // => true
		     *
		     * func(null);
		     * // => false
		     *
		     * func(NaN);
		     * // => false
		     */
		    var overEvery = createOver(arrayEvery);

		    /**
		     * Creates a function that checks if **any** of the `predicates` return
		     * truthy when invoked with the arguments it receives.
		     *
		     * Following shorthands are possible for providing predicates.
		     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
		     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {...(Function|Function[])} [predicates=[_.identity]]
		     *  The predicates to check.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var func = _.overSome([Boolean, isFinite]);
		     *
		     * func('1');
		     * // => true
		     *
		     * func(null);
		     * // => true
		     *
		     * func(NaN);
		     * // => false
		     *
		     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
		     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
		     */
		    var overSome = createOver(arraySome);

		    /**
		     * Creates a function that returns the value at `path` of a given object.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Util
		     * @param {Array|string} path The path of the property to get.
		     * @returns {Function} Returns the new accessor function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': { 'b': 2 } },
		     *   { 'a': { 'b': 1 } }
		     * ];
		     *
		     * _.map(objects, _.property('a.b'));
		     * // => [2, 1]
		     *
		     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
		     * // => [1, 2]
		     */
		    function property(path) {
		      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
		    }

		    /**
		     * The opposite of `_.property`; this method creates a function that returns
		     * the value at a given path of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {Object} object The object to query.
		     * @returns {Function} Returns the new accessor function.
		     * @example
		     *
		     * var array = [0, 1, 2],
		     *     object = { 'a': array, 'b': array, 'c': array };
		     *
		     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
		     * // => [2, 0]
		     *
		     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
		     * // => [2, 0]
		     */
		    function propertyOf(object) {
		      return function(path) {
		        return object == null ? undefined$1 : baseGet(object, path);
		      };
		    }

		    /**
		     * Creates an array of numbers (positive and/or negative) progressing from
		     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
		     * `start` is specified without an `end` or `step`. If `end` is not specified,
		     * it's set to `start` with `start` then set to `0`.
		     *
		     * **Note:** JavaScript follows the IEEE-754 standard for resolving
		     * floating-point values which can produce unexpected results.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {number} [start=0] The start of the range.
		     * @param {number} end The end of the range.
		     * @param {number} [step=1] The value to increment or decrement by.
		     * @returns {Array} Returns the range of numbers.
		     * @see _.inRange, _.rangeRight
		     * @example
		     *
		     * _.range(4);
		     * // => [0, 1, 2, 3]
		     *
		     * _.range(-4);
		     * // => [0, -1, -2, -3]
		     *
		     * _.range(1, 5);
		     * // => [1, 2, 3, 4]
		     *
		     * _.range(0, 20, 5);
		     * // => [0, 5, 10, 15]
		     *
		     * _.range(0, -4, -1);
		     * // => [0, -1, -2, -3]
		     *
		     * _.range(1, 4, 0);
		     * // => [1, 1, 1]
		     *
		     * _.range(0);
		     * // => []
		     */
		    var range = createRange();

		    /**
		     * This method is like `_.range` except that it populates values in
		     * descending order.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {number} [start=0] The start of the range.
		     * @param {number} end The end of the range.
		     * @param {number} [step=1] The value to increment or decrement by.
		     * @returns {Array} Returns the range of numbers.
		     * @see _.inRange, _.range
		     * @example
		     *
		     * _.rangeRight(4);
		     * // => [3, 2, 1, 0]
		     *
		     * _.rangeRight(-4);
		     * // => [-3, -2, -1, 0]
		     *
		     * _.rangeRight(1, 5);
		     * // => [4, 3, 2, 1]
		     *
		     * _.rangeRight(0, 20, 5);
		     * // => [15, 10, 5, 0]
		     *
		     * _.rangeRight(0, -4, -1);
		     * // => [-3, -2, -1, 0]
		     *
		     * _.rangeRight(1, 4, 0);
		     * // => [1, 1, 1]
		     *
		     * _.rangeRight(0);
		     * // => []
		     */
		    var rangeRight = createRange(true);

		    /**
		     * This method returns a new empty array.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {Array} Returns the new empty array.
		     * @example
		     *
		     * var arrays = _.times(2, _.stubArray);
		     *
		     * console.log(arrays);
		     * // => [[], []]
		     *
		     * console.log(arrays[0] === arrays[1]);
		     * // => false
		     */
		    function stubArray() {
		      return [];
		    }

		    /**
		     * This method returns `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {boolean} Returns `false`.
		     * @example
		     *
		     * _.times(2, _.stubFalse);
		     * // => [false, false]
		     */
		    function stubFalse() {
		      return false;
		    }

		    /**
		     * This method returns a new empty object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {Object} Returns the new empty object.
		     * @example
		     *
		     * var objects = _.times(2, _.stubObject);
		     *
		     * console.log(objects);
		     * // => [{}, {}]
		     *
		     * console.log(objects[0] === objects[1]);
		     * // => false
		     */
		    function stubObject() {
		      return {};
		    }

		    /**
		     * This method returns an empty string.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {string} Returns the empty string.
		     * @example
		     *
		     * _.times(2, _.stubString);
		     * // => ['', '']
		     */
		    function stubString() {
		      return '';
		    }

		    /**
		     * This method returns `true`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {boolean} Returns `true`.
		     * @example
		     *
		     * _.times(2, _.stubTrue);
		     * // => [true, true]
		     */
		    function stubTrue() {
		      return true;
		    }

		    /**
		     * Invokes the iteratee `n` times, returning an array of the results of
		     * each invocation. The iteratee is invoked with one argument; (index).
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {number} n The number of times to invoke `iteratee`.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the array of results.
		     * @example
		     *
		     * _.times(3, String);
		     * // => ['0', '1', '2']
		     *
		     *  _.times(4, _.constant(0));
		     * // => [0, 0, 0, 0]
		     */
		    function times(n, iteratee) {
		      n = toInteger(n);
		      if (n < 1 || n > MAX_SAFE_INTEGER) {
		        return [];
		      }
		      var index = MAX_ARRAY_LENGTH,
		          length = nativeMin(n, MAX_ARRAY_LENGTH);

		      iteratee = getIteratee(iteratee);
		      n -= MAX_ARRAY_LENGTH;

		      var result = baseTimes(length, iteratee);
		      while (++index < n) {
		        iteratee(index);
		      }
		      return result;
		    }

		    /**
		     * Converts `value` to a property path array.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {*} value The value to convert.
		     * @returns {Array} Returns the new property path array.
		     * @example
		     *
		     * _.toPath('a.b.c');
		     * // => ['a', 'b', 'c']
		     *
		     * _.toPath('a[0].b.c');
		     * // => ['a', '0', 'b', 'c']
		     */
		    function toPath(value) {
		      if (isArray(value)) {
		        return arrayMap(value, toKey);
		      }
		      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
		    }

		    /**
		     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {string} [prefix=''] The value to prefix the ID with.
		     * @returns {string} Returns the unique ID.
		     * @example
		     *
		     * _.uniqueId('contact_');
		     * // => 'contact_104'
		     *
		     * _.uniqueId();
		     * // => '105'
		     */
		    function uniqueId(prefix) {
		      var id = ++idCounter;
		      return toString(prefix) + id;
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Adds two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.4.0
		     * @category Math
		     * @param {number} augend The first number in an addition.
		     * @param {number} addend The second number in an addition.
		     * @returns {number} Returns the total.
		     * @example
		     *
		     * _.add(6, 4);
		     * // => 10
		     */
		    var add = createMathOperation(function(augend, addend) {
		      return augend + addend;
		    }, 0);

		    /**
		     * Computes `number` rounded up to `precision`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Math
		     * @param {number} number The number to round up.
		     * @param {number} [precision=0] The precision to round up to.
		     * @returns {number} Returns the rounded up number.
		     * @example
		     *
		     * _.ceil(4.006);
		     * // => 5
		     *
		     * _.ceil(6.004, 2);
		     * // => 6.01
		     *
		     * _.ceil(6040, -2);
		     * // => 6100
		     */
		    var ceil = createRound('ceil');

		    /**
		     * Divide two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Math
		     * @param {number} dividend The first number in a division.
		     * @param {number} divisor The second number in a division.
		     * @returns {number} Returns the quotient.
		     * @example
		     *
		     * _.divide(6, 4);
		     * // => 1.5
		     */
		    var divide = createMathOperation(function(dividend, divisor) {
		      return dividend / divisor;
		    }, 1);

		    /**
		     * Computes `number` rounded down to `precision`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Math
		     * @param {number} number The number to round down.
		     * @param {number} [precision=0] The precision to round down to.
		     * @returns {number} Returns the rounded down number.
		     * @example
		     *
		     * _.floor(4.006);
		     * // => 4
		     *
		     * _.floor(0.046, 2);
		     * // => 0.04
		     *
		     * _.floor(4060, -2);
		     * // => 4000
		     */
		    var floor = createRound('floor');

		    /**
		     * Computes the maximum value of `array`. If `array` is empty or falsey,
		     * `undefined` is returned.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {*} Returns the maximum value.
		     * @example
		     *
		     * _.max([4, 2, 8, 6]);
		     * // => 8
		     *
		     * _.max([]);
		     * // => undefined
		     */
		    function max(array) {
		      return (array && array.length)
		        ? baseExtremum(array, identity, baseGt)
		        : undefined$1;
		    }

		    /**
		     * This method is like `_.max` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the criterion by which
		     * the value is ranked. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {*} Returns the maximum value.
		     * @example
		     *
		     * var objects = [{ 'n': 1 }, { 'n': 2 }];
		     *
		     * _.maxBy(objects, function(o) { return o.n; });
		     * // => { 'n': 2 }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.maxBy(objects, 'n');
		     * // => { 'n': 2 }
		     */
		    function maxBy(array, iteratee) {
		      return (array && array.length)
		        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
		        : undefined$1;
		    }

		    /**
		     * Computes the mean of the values in `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {number} Returns the mean.
		     * @example
		     *
		     * _.mean([4, 2, 8, 6]);
		     * // => 5
		     */
		    function mean(array) {
		      return baseMean(array, identity);
		    }

		    /**
		     * This method is like `_.mean` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the value to be averaged.
		     * The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {number} Returns the mean.
		     * @example
		     *
		     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
		     *
		     * _.meanBy(objects, function(o) { return o.n; });
		     * // => 5
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.meanBy(objects, 'n');
		     * // => 5
		     */
		    function meanBy(array, iteratee) {
		      return baseMean(array, getIteratee(iteratee, 2));
		    }

		    /**
		     * Computes the minimum value of `array`. If `array` is empty or falsey,
		     * `undefined` is returned.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {*} Returns the minimum value.
		     * @example
		     *
		     * _.min([4, 2, 8, 6]);
		     * // => 2
		     *
		     * _.min([]);
		     * // => undefined
		     */
		    function min(array) {
		      return (array && array.length)
		        ? baseExtremum(array, identity, baseLt)
		        : undefined$1;
		    }

		    /**
		     * This method is like `_.min` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the criterion by which
		     * the value is ranked. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {*} Returns the minimum value.
		     * @example
		     *
		     * var objects = [{ 'n': 1 }, { 'n': 2 }];
		     *
		     * _.minBy(objects, function(o) { return o.n; });
		     * // => { 'n': 1 }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.minBy(objects, 'n');
		     * // => { 'n': 1 }
		     */
		    function minBy(array, iteratee) {
		      return (array && array.length)
		        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
		        : undefined$1;
		    }

		    /**
		     * Multiply two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Math
		     * @param {number} multiplier The first number in a multiplication.
		     * @param {number} multiplicand The second number in a multiplication.
		     * @returns {number} Returns the product.
		     * @example
		     *
		     * _.multiply(6, 4);
		     * // => 24
		     */
		    var multiply = createMathOperation(function(multiplier, multiplicand) {
		      return multiplier * multiplicand;
		    }, 1);

		    /**
		     * Computes `number` rounded to `precision`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Math
		     * @param {number} number The number to round.
		     * @param {number} [precision=0] The precision to round to.
		     * @returns {number} Returns the rounded number.
		     * @example
		     *
		     * _.round(4.006);
		     * // => 4
		     *
		     * _.round(4.006, 2);
		     * // => 4.01
		     *
		     * _.round(4060, -2);
		     * // => 4100
		     */
		    var round = createRound('round');

		    /**
		     * Subtract two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {number} minuend The first number in a subtraction.
		     * @param {number} subtrahend The second number in a subtraction.
		     * @returns {number} Returns the difference.
		     * @example
		     *
		     * _.subtract(6, 4);
		     * // => 2
		     */
		    var subtract = createMathOperation(function(minuend, subtrahend) {
		      return minuend - subtrahend;
		    }, 0);

		    /**
		     * Computes the sum of the values in `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.4.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {number} Returns the sum.
		     * @example
		     *
		     * _.sum([4, 2, 8, 6]);
		     * // => 20
		     */
		    function sum(array) {
		      return (array && array.length)
		        ? baseSum(array, identity)
		        : 0;
		    }

		    /**
		     * This method is like `_.sum` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the value to be summed.
		     * The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {number} Returns the sum.
		     * @example
		     *
		     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
		     *
		     * _.sumBy(objects, function(o) { return o.n; });
		     * // => 20
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.sumBy(objects, 'n');
		     * // => 20
		     */
		    function sumBy(array, iteratee) {
		      return (array && array.length)
		        ? baseSum(array, getIteratee(iteratee, 2))
		        : 0;
		    }

		    /*------------------------------------------------------------------------*/

		    // Add methods that return wrapped values in chain sequences.
		    lodash.after = after;
		    lodash.ary = ary;
		    lodash.assign = assign;
		    lodash.assignIn = assignIn;
		    lodash.assignInWith = assignInWith;
		    lodash.assignWith = assignWith;
		    lodash.at = at;
		    lodash.before = before;
		    lodash.bind = bind;
		    lodash.bindAll = bindAll;
		    lodash.bindKey = bindKey;
		    lodash.castArray = castArray;
		    lodash.chain = chain;
		    lodash.chunk = chunk;
		    lodash.compact = compact;
		    lodash.concat = concat;
		    lodash.cond = cond;
		    lodash.conforms = conforms;
		    lodash.constant = constant;
		    lodash.countBy = countBy;
		    lodash.create = create;
		    lodash.curry = curry;
		    lodash.curryRight = curryRight;
		    lodash.debounce = debounce;
		    lodash.defaults = defaults;
		    lodash.defaultsDeep = defaultsDeep;
		    lodash.defer = defer;
		    lodash.delay = delay;
		    lodash.difference = difference;
		    lodash.differenceBy = differenceBy;
		    lodash.differenceWith = differenceWith;
		    lodash.drop = drop;
		    lodash.dropRight = dropRight;
		    lodash.dropRightWhile = dropRightWhile;
		    lodash.dropWhile = dropWhile;
		    lodash.fill = fill;
		    lodash.filter = filter;
		    lodash.flatMap = flatMap;
		    lodash.flatMapDeep = flatMapDeep;
		    lodash.flatMapDepth = flatMapDepth;
		    lodash.flatten = flatten;
		    lodash.flattenDeep = flattenDeep;
		    lodash.flattenDepth = flattenDepth;
		    lodash.flip = flip;
		    lodash.flow = flow;
		    lodash.flowRight = flowRight;
		    lodash.fromPairs = fromPairs;
		    lodash.functions = functions;
		    lodash.functionsIn = functionsIn;
		    lodash.groupBy = groupBy;
		    lodash.initial = initial;
		    lodash.intersection = intersection;
		    lodash.intersectionBy = intersectionBy;
		    lodash.intersectionWith = intersectionWith;
		    lodash.invert = invert;
		    lodash.invertBy = invertBy;
		    lodash.invokeMap = invokeMap;
		    lodash.iteratee = iteratee;
		    lodash.keyBy = keyBy;
		    lodash.keys = keys;
		    lodash.keysIn = keysIn;
		    lodash.map = map;
		    lodash.mapKeys = mapKeys;
		    lodash.mapValues = mapValues;
		    lodash.matches = matches;
		    lodash.matchesProperty = matchesProperty;
		    lodash.memoize = memoize;
		    lodash.merge = merge;
		    lodash.mergeWith = mergeWith;
		    lodash.method = method;
		    lodash.methodOf = methodOf;
		    lodash.mixin = mixin;
		    lodash.negate = negate;
		    lodash.nthArg = nthArg;
		    lodash.omit = omit;
		    lodash.omitBy = omitBy;
		    lodash.once = once;
		    lodash.orderBy = orderBy;
		    lodash.over = over;
		    lodash.overArgs = overArgs;
		    lodash.overEvery = overEvery;
		    lodash.overSome = overSome;
		    lodash.partial = partial;
		    lodash.partialRight = partialRight;
		    lodash.partition = partition;
		    lodash.pick = pick;
		    lodash.pickBy = pickBy;
		    lodash.property = property;
		    lodash.propertyOf = propertyOf;
		    lodash.pull = pull;
		    lodash.pullAll = pullAll;
		    lodash.pullAllBy = pullAllBy;
		    lodash.pullAllWith = pullAllWith;
		    lodash.pullAt = pullAt;
		    lodash.range = range;
		    lodash.rangeRight = rangeRight;
		    lodash.rearg = rearg;
		    lodash.reject = reject;
		    lodash.remove = remove;
		    lodash.rest = rest;
		    lodash.reverse = reverse;
		    lodash.sampleSize = sampleSize;
		    lodash.set = set;
		    lodash.setWith = setWith;
		    lodash.shuffle = shuffle;
		    lodash.slice = slice;
		    lodash.sortBy = sortBy;
		    lodash.sortedUniq = sortedUniq;
		    lodash.sortedUniqBy = sortedUniqBy;
		    lodash.split = split;
		    lodash.spread = spread;
		    lodash.tail = tail;
		    lodash.take = take;
		    lodash.takeRight = takeRight;
		    lodash.takeRightWhile = takeRightWhile;
		    lodash.takeWhile = takeWhile;
		    lodash.tap = tap;
		    lodash.throttle = throttle;
		    lodash.thru = thru;
		    lodash.toArray = toArray;
		    lodash.toPairs = toPairs;
		    lodash.toPairsIn = toPairsIn;
		    lodash.toPath = toPath;
		    lodash.toPlainObject = toPlainObject;
		    lodash.transform = transform;
		    lodash.unary = unary;
		    lodash.union = union;
		    lodash.unionBy = unionBy;
		    lodash.unionWith = unionWith;
		    lodash.uniq = uniq;
		    lodash.uniqBy = uniqBy;
		    lodash.uniqWith = uniqWith;
		    lodash.unset = unset;
		    lodash.unzip = unzip;
		    lodash.unzipWith = unzipWith;
		    lodash.update = update;
		    lodash.updateWith = updateWith;
		    lodash.values = values;
		    lodash.valuesIn = valuesIn;
		    lodash.without = without;
		    lodash.words = words;
		    lodash.wrap = wrap;
		    lodash.xor = xor;
		    lodash.xorBy = xorBy;
		    lodash.xorWith = xorWith;
		    lodash.zip = zip;
		    lodash.zipObject = zipObject;
		    lodash.zipObjectDeep = zipObjectDeep;
		    lodash.zipWith = zipWith;

		    // Add aliases.
		    lodash.entries = toPairs;
		    lodash.entriesIn = toPairsIn;
		    lodash.extend = assignIn;
		    lodash.extendWith = assignInWith;

		    // Add methods to `lodash.prototype`.
		    mixin(lodash, lodash);

		    /*------------------------------------------------------------------------*/

		    // Add methods that return unwrapped values in chain sequences.
		    lodash.add = add;
		    lodash.attempt = attempt;
		    lodash.camelCase = camelCase;
		    lodash.capitalize = capitalize;
		    lodash.ceil = ceil;
		    lodash.clamp = clamp;
		    lodash.clone = clone;
		    lodash.cloneDeep = cloneDeep;
		    lodash.cloneDeepWith = cloneDeepWith;
		    lodash.cloneWith = cloneWith;
		    lodash.conformsTo = conformsTo;
		    lodash.deburr = deburr;
		    lodash.defaultTo = defaultTo;
		    lodash.divide = divide;
		    lodash.endsWith = endsWith;
		    lodash.eq = eq;
		    lodash.escape = escape;
		    lodash.escapeRegExp = escapeRegExp;
		    lodash.every = every;
		    lodash.find = find;
		    lodash.findIndex = findIndex;
		    lodash.findKey = findKey;
		    lodash.findLast = findLast;
		    lodash.findLastIndex = findLastIndex;
		    lodash.findLastKey = findLastKey;
		    lodash.floor = floor;
		    lodash.forEach = forEach;
		    lodash.forEachRight = forEachRight;
		    lodash.forIn = forIn;
		    lodash.forInRight = forInRight;
		    lodash.forOwn = forOwn;
		    lodash.forOwnRight = forOwnRight;
		    lodash.get = get;
		    lodash.gt = gt;
		    lodash.gte = gte;
		    lodash.has = has;
		    lodash.hasIn = hasIn;
		    lodash.head = head;
		    lodash.identity = identity;
		    lodash.includes = includes;
		    lodash.indexOf = indexOf;
		    lodash.inRange = inRange;
		    lodash.invoke = invoke;
		    lodash.isArguments = isArguments;
		    lodash.isArray = isArray;
		    lodash.isArrayBuffer = isArrayBuffer;
		    lodash.isArrayLike = isArrayLike;
		    lodash.isArrayLikeObject = isArrayLikeObject;
		    lodash.isBoolean = isBoolean;
		    lodash.isBuffer = isBuffer;
		    lodash.isDate = isDate;
		    lodash.isElement = isElement;
		    lodash.isEmpty = isEmpty;
		    lodash.isEqual = isEqual;
		    lodash.isEqualWith = isEqualWith;
		    lodash.isError = isError;
		    lodash.isFinite = isFinite;
		    lodash.isFunction = isFunction;
		    lodash.isInteger = isInteger;
		    lodash.isLength = isLength;
		    lodash.isMap = isMap;
		    lodash.isMatch = isMatch;
		    lodash.isMatchWith = isMatchWith;
		    lodash.isNaN = isNaN;
		    lodash.isNative = isNative;
		    lodash.isNil = isNil;
		    lodash.isNull = isNull;
		    lodash.isNumber = isNumber;
		    lodash.isObject = isObject;
		    lodash.isObjectLike = isObjectLike;
		    lodash.isPlainObject = isPlainObject;
		    lodash.isRegExp = isRegExp;
		    lodash.isSafeInteger = isSafeInteger;
		    lodash.isSet = isSet;
		    lodash.isString = isString;
		    lodash.isSymbol = isSymbol;
		    lodash.isTypedArray = isTypedArray;
		    lodash.isUndefined = isUndefined;
		    lodash.isWeakMap = isWeakMap;
		    lodash.isWeakSet = isWeakSet;
		    lodash.join = join;
		    lodash.kebabCase = kebabCase;
		    lodash.last = last;
		    lodash.lastIndexOf = lastIndexOf;
		    lodash.lowerCase = lowerCase;
		    lodash.lowerFirst = lowerFirst;
		    lodash.lt = lt;
		    lodash.lte = lte;
		    lodash.max = max;
		    lodash.maxBy = maxBy;
		    lodash.mean = mean;
		    lodash.meanBy = meanBy;
		    lodash.min = min;
		    lodash.minBy = minBy;
		    lodash.stubArray = stubArray;
		    lodash.stubFalse = stubFalse;
		    lodash.stubObject = stubObject;
		    lodash.stubString = stubString;
		    lodash.stubTrue = stubTrue;
		    lodash.multiply = multiply;
		    lodash.nth = nth;
		    lodash.noConflict = noConflict;
		    lodash.noop = noop;
		    lodash.now = now;
		    lodash.pad = pad;
		    lodash.padEnd = padEnd;
		    lodash.padStart = padStart;
		    lodash.parseInt = parseInt;
		    lodash.random = random;
		    lodash.reduce = reduce;
		    lodash.reduceRight = reduceRight;
		    lodash.repeat = repeat;
		    lodash.replace = replace;
		    lodash.result = result;
		    lodash.round = round;
		    lodash.runInContext = runInContext;
		    lodash.sample = sample;
		    lodash.size = size;
		    lodash.snakeCase = snakeCase;
		    lodash.some = some;
		    lodash.sortedIndex = sortedIndex;
		    lodash.sortedIndexBy = sortedIndexBy;
		    lodash.sortedIndexOf = sortedIndexOf;
		    lodash.sortedLastIndex = sortedLastIndex;
		    lodash.sortedLastIndexBy = sortedLastIndexBy;
		    lodash.sortedLastIndexOf = sortedLastIndexOf;
		    lodash.startCase = startCase;
		    lodash.startsWith = startsWith;
		    lodash.subtract = subtract;
		    lodash.sum = sum;
		    lodash.sumBy = sumBy;
		    lodash.template = template;
		    lodash.times = times;
		    lodash.toFinite = toFinite;
		    lodash.toInteger = toInteger;
		    lodash.toLength = toLength;
		    lodash.toLower = toLower;
		    lodash.toNumber = toNumber;
		    lodash.toSafeInteger = toSafeInteger;
		    lodash.toString = toString;
		    lodash.toUpper = toUpper;
		    lodash.trim = trim;
		    lodash.trimEnd = trimEnd;
		    lodash.trimStart = trimStart;
		    lodash.truncate = truncate;
		    lodash.unescape = unescape;
		    lodash.uniqueId = uniqueId;
		    lodash.upperCase = upperCase;
		    lodash.upperFirst = upperFirst;

		    // Add aliases.
		    lodash.each = forEach;
		    lodash.eachRight = forEachRight;
		    lodash.first = head;

		    mixin(lodash, (function() {
		      var source = {};
		      baseForOwn(lodash, function(func, methodName) {
		        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
		          source[methodName] = func;
		        }
		      });
		      return source;
		    }()), { 'chain': false });

		    /*------------------------------------------------------------------------*/

		    /**
		     * The semantic version number.
		     *
		     * @static
		     * @memberOf _
		     * @type {string}
		     */
		    lodash.VERSION = VERSION;

		    // Assign default placeholders.
		    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
		      lodash[methodName].placeholder = lodash;
		    });

		    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
		    arrayEach(['drop', 'take'], function(methodName, index) {
		      LazyWrapper.prototype[methodName] = function(n) {
		        n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);

		        var result = (this.__filtered__ && !index)
		          ? new LazyWrapper(this)
		          : this.clone();

		        if (result.__filtered__) {
		          result.__takeCount__ = nativeMin(n, result.__takeCount__);
		        } else {
		          result.__views__.push({
		            'size': nativeMin(n, MAX_ARRAY_LENGTH),
		            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
		          });
		        }
		        return result;
		      };

		      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
		        return this.reverse()[methodName](n).reverse();
		      };
		    });

		    // Add `LazyWrapper` methods that accept an `iteratee` value.
		    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
		      var type = index + 1,
		          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

		      LazyWrapper.prototype[methodName] = function(iteratee) {
		        var result = this.clone();
		        result.__iteratees__.push({
		          'iteratee': getIteratee(iteratee, 3),
		          'type': type
		        });
		        result.__filtered__ = result.__filtered__ || isFilter;
		        return result;
		      };
		    });

		    // Add `LazyWrapper` methods for `_.head` and `_.last`.
		    arrayEach(['head', 'last'], function(methodName, index) {
		      var takeName = 'take' + (index ? 'Right' : '');

		      LazyWrapper.prototype[methodName] = function() {
		        return this[takeName](1).value()[0];
		      };
		    });

		    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
		    arrayEach(['initial', 'tail'], function(methodName, index) {
		      var dropName = 'drop' + (index ? '' : 'Right');

		      LazyWrapper.prototype[methodName] = function() {
		        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
		      };
		    });

		    LazyWrapper.prototype.compact = function() {
		      return this.filter(identity);
		    };

		    LazyWrapper.prototype.find = function(predicate) {
		      return this.filter(predicate).head();
		    };

		    LazyWrapper.prototype.findLast = function(predicate) {
		      return this.reverse().find(predicate);
		    };

		    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
		      if (typeof path == 'function') {
		        return new LazyWrapper(this);
		      }
		      return this.map(function(value) {
		        return baseInvoke(value, path, args);
		      });
		    });

		    LazyWrapper.prototype.reject = function(predicate) {
		      return this.filter(negate(getIteratee(predicate)));
		    };

		    LazyWrapper.prototype.slice = function(start, end) {
		      start = toInteger(start);

		      var result = this;
		      if (result.__filtered__ && (start > 0 || end < 0)) {
		        return new LazyWrapper(result);
		      }
		      if (start < 0) {
		        result = result.takeRight(-start);
		      } else if (start) {
		        result = result.drop(start);
		      }
		      if (end !== undefined$1) {
		        end = toInteger(end);
		        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
		      }
		      return result;
		    };

		    LazyWrapper.prototype.takeRightWhile = function(predicate) {
		      return this.reverse().takeWhile(predicate).reverse();
		    };

		    LazyWrapper.prototype.toArray = function() {
		      return this.take(MAX_ARRAY_LENGTH);
		    };

		    // Add `LazyWrapper` methods to `lodash.prototype`.
		    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
		      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
		          isTaker = /^(?:head|last)$/.test(methodName),
		          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
		          retUnwrapped = isTaker || /^find/.test(methodName);

		      if (!lodashFunc) {
		        return;
		      }
		      lodash.prototype[methodName] = function() {
		        var value = this.__wrapped__,
		            args = isTaker ? [1] : arguments,
		            isLazy = value instanceof LazyWrapper,
		            iteratee = args[0],
		            useLazy = isLazy || isArray(value);

		        var interceptor = function(value) {
		          var result = lodashFunc.apply(lodash, arrayPush([value], args));
		          return (isTaker && chainAll) ? result[0] : result;
		        };

		        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
		          // Avoid lazy use if the iteratee has a "length" value other than `1`.
		          isLazy = useLazy = false;
		        }
		        var chainAll = this.__chain__,
		            isHybrid = !!this.__actions__.length,
		            isUnwrapped = retUnwrapped && !chainAll,
		            onlyLazy = isLazy && !isHybrid;

		        if (!retUnwrapped && useLazy) {
		          value = onlyLazy ? value : new LazyWrapper(this);
		          var result = func.apply(value, args);
		          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined$1 });
		          return new LodashWrapper(result, chainAll);
		        }
		        if (isUnwrapped && onlyLazy) {
		          return func.apply(this, args);
		        }
		        result = this.thru(interceptor);
		        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
		      };
		    });

		    // Add `Array` methods to `lodash.prototype`.
		    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
		      var func = arrayProto[methodName],
		          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
		          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

		      lodash.prototype[methodName] = function() {
		        var args = arguments;
		        if (retUnwrapped && !this.__chain__) {
		          var value = this.value();
		          return func.apply(isArray(value) ? value : [], args);
		        }
		        return this[chainName](function(value) {
		          return func.apply(isArray(value) ? value : [], args);
		        });
		      };
		    });

		    // Map minified method names to their real names.
		    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
		      var lodashFunc = lodash[methodName];
		      if (lodashFunc) {
		        var key = lodashFunc.name + '';
		        if (!hasOwnProperty.call(realNames, key)) {
		          realNames[key] = [];
		        }
		        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
		      }
		    });

		    realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
		      'name': 'wrapper',
		      'func': undefined$1
		    }];

		    // Add methods to `LazyWrapper`.
		    LazyWrapper.prototype.clone = lazyClone;
		    LazyWrapper.prototype.reverse = lazyReverse;
		    LazyWrapper.prototype.value = lazyValue;

		    // Add chain sequence methods to the `lodash` wrapper.
		    lodash.prototype.at = wrapperAt;
		    lodash.prototype.chain = wrapperChain;
		    lodash.prototype.commit = wrapperCommit;
		    lodash.prototype.next = wrapperNext;
		    lodash.prototype.plant = wrapperPlant;
		    lodash.prototype.reverse = wrapperReverse;
		    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

		    // Add lazy aliases.
		    lodash.prototype.first = lodash.prototype.head;

		    if (symIterator) {
		      lodash.prototype[symIterator] = wrapperToIterator;
		    }
		    return lodash;
		  });

		  /*--------------------------------------------------------------------------*/

		  // Export lodash.
		  var _ = runInContext();

		  // Some AMD build optimizers, like r.js, check for condition patterns like:
		  if (freeModule) {
		    // Export for Node.js.
		    (freeModule.exports = _)._ = _;
		    // Export for CommonJS support.
		    freeExports._ = _;
		  }
		  else {
		    // Export to the global object.
		    root._ = _;
		  }
		}.call(lodash)); 
	} (lodash$1, lodash$1.exports));
	return lodash$1.exports;
}

var nodeProgress = {exports: {}};

/*!
 * node-progress
 * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

var hasRequiredNodeProgress;

function requireNodeProgress () {
	if (hasRequiredNodeProgress) return nodeProgress.exports;
	hasRequiredNodeProgress = 1;
	(function (module, exports) {
		/**
		 * Expose `ProgressBar`.
		 */

		module.exports = ProgressBar;

		/**
		 * Initialize a `ProgressBar` with the given `fmt` string and `options` or
		 * `total`.
		 *
		 * Options:
		 *
		 *   - `curr` current completed index
		 *   - `total` total number of ticks to complete
		 *   - `width` the displayed width of the progress bar defaulting to total
		 *   - `stream` the output stream defaulting to stderr
		 *   - `head` head character defaulting to complete character
		 *   - `complete` completion character defaulting to "="
		 *   - `incomplete` incomplete character defaulting to "-"
		 *   - `renderThrottle` minimum time between updates in milliseconds defaulting to 16
		 *   - `callback` optional function to call when the progress bar completes
		 *   - `clear` will clear the progress bar upon termination
		 *
		 * Tokens:
		 *
		 *   - `:bar` the progress bar itself
		 *   - `:current` current tick number
		 *   - `:total` total ticks
		 *   - `:elapsed` time elapsed in seconds
		 *   - `:percent` completion percentage
		 *   - `:eta` eta in seconds
		 *   - `:rate` rate of ticks per second
		 *
		 * @param {string} fmt
		 * @param {object|number} options or total
		 * @api public
		 */

		function ProgressBar(fmt, options) {
		  this.stream = options.stream || process.stderr;

		  if (typeof(options) == 'number') {
		    var total = options;
		    options = {};
		    options.total = total;
		  } else {
		    options = options || {};
		    if ('string' != typeof fmt) throw new Error('format required');
		    if ('number' != typeof options.total) throw new Error('total required');
		  }

		  this.fmt = fmt;
		  this.curr = options.curr || 0;
		  this.total = options.total;
		  this.width = options.width || this.total;
		  this.clear = options.clear;
		  this.chars = {
		    complete   : options.complete || '=',
		    incomplete : options.incomplete || '-',
		    head       : options.head || (options.complete || '=')
		  };
		  this.renderThrottle = options.renderThrottle !== 0 ? (options.renderThrottle || 16) : 0;
		  this.lastRender = -Infinity;
		  this.callback = options.callback || function () {};
		  this.tokens = {};
		  this.lastDraw = '';
		}

		/**
		 * "tick" the progress bar with optional `len` and optional `tokens`.
		 *
		 * @param {number|object} len or tokens
		 * @param {object} tokens
		 * @api public
		 */

		ProgressBar.prototype.tick = function(len, tokens){
		  if (len !== 0)
		    len = len || 1;

		  // swap tokens
		  if ('object' == typeof len) tokens = len, len = 1;
		  if (tokens) this.tokens = tokens;

		  // start time for eta
		  if (0 == this.curr) this.start = new Date;

		  this.curr += len;

		  // try to render
		  this.render();

		  // progress complete
		  if (this.curr >= this.total) {
		    this.render(undefined, true);
		    this.complete = true;
		    this.terminate();
		    this.callback(this);
		    return;
		  }
		};

		/**
		 * Method to render the progress bar with optional `tokens` to place in the
		 * progress bar's `fmt` field.
		 *
		 * @param {object} tokens
		 * @api public
		 */

		ProgressBar.prototype.render = function (tokens, force) {
		  force = force !== undefined ? force : false;
		  if (tokens) this.tokens = tokens;

		  if (!this.stream.isTTY) return;

		  var now = Date.now();
		  var delta = now - this.lastRender;
		  if (!force && (delta < this.renderThrottle)) {
		    return;
		  } else {
		    this.lastRender = now;
		  }

		  var ratio = this.curr / this.total;
		  ratio = Math.min(Math.max(ratio, 0), 1);

		  var percent = Math.floor(ratio * 100);
		  var incomplete, complete, completeLength;
		  var elapsed = new Date - this.start;
		  var eta = (percent == 100) ? 0 : elapsed * (this.total / this.curr - 1);
		  var rate = this.curr / (elapsed / 1000);

		  /* populate the bar template with percentages and timestamps */
		  var str = this.fmt
		    .replace(':current', this.curr)
		    .replace(':total', this.total)
		    .replace(':elapsed', isNaN(elapsed) ? '0.0' : (elapsed / 1000).toFixed(1))
		    .replace(':eta', (isNaN(eta) || !isFinite(eta)) ? '0.0' : (eta / 1000)
		      .toFixed(1))
		    .replace(':percent', percent.toFixed(0) + '%')
		    .replace(':rate', Math.round(rate));

		  /* compute the available space (non-zero) for the bar */
		  var availableSpace = Math.max(0, this.stream.columns - str.replace(':bar', '').length);
		  if(availableSpace && process.platform === 'win32'){
		    availableSpace = availableSpace - 1;
		  }

		  var width = Math.min(this.width, availableSpace);

		  /* TODO: the following assumes the user has one ':bar' token */
		  completeLength = Math.round(width * ratio);
		  complete = Array(Math.max(0, completeLength + 1)).join(this.chars.complete);
		  incomplete = Array(Math.max(0, width - completeLength + 1)).join(this.chars.incomplete);

		  /* add head to the complete string */
		  if(completeLength > 0)
		    complete = complete.slice(0, -1) + this.chars.head;

		  /* fill in the actual progress bar */
		  str = str.replace(':bar', complete + incomplete);

		  /* replace the extra tokens */
		  if (this.tokens) for (var key in this.tokens) str = str.replace(':' + key, this.tokens[key]);

		  if (this.lastDraw !== str) {
		    this.stream.cursorTo(0);
		    this.stream.write(str);
		    this.stream.clearLine(1);
		    this.lastDraw = str;
		  }
		};

		/**
		 * "update" the progress bar to represent an exact percentage.
		 * The ratio (between 0 and 1) specified will be multiplied by `total` and
		 * floored, representing the closest available "tick." For example, if a
		 * progress bar has a length of 3 and `update(0.5)` is called, the progress
		 * will be set to 1.
		 *
		 * A ratio of 0.5 will attempt to set the progress to halfway.
		 *
		 * @param {number} ratio The ratio (between 0 and 1 inclusive) to set the
		 *   overall completion to.
		 * @api public
		 */

		ProgressBar.prototype.update = function (ratio, tokens) {
		  var goal = Math.floor(ratio * this.total);
		  var delta = goal - this.curr;

		  this.tick(delta, tokens);
		};

		/**
		 * "interrupt" the progress bar and write a message above it.
		 * @param {string} message The message to write.
		 * @api public
		 */

		ProgressBar.prototype.interrupt = function (message) {
		  // clear the current line
		  this.stream.clearLine();
		  // move the cursor to the start of the line
		  this.stream.cursorTo(0);
		  // write the message text
		  this.stream.write(message);
		  // terminate the line after writing the message
		  this.stream.write('\n');
		  // re-display the progress bar with its lastDraw
		  this.stream.write(this.lastDraw);
		};

		/**
		 * Terminates a progress bar.
		 *
		 * @api public
		 */

		ProgressBar.prototype.terminate = function () {
		  if (this.clear) {
		    if (this.stream.clearLine) {
		      this.stream.clearLine();
		      this.stream.cursorTo(0);
		    }
		  } else {
		    this.stream.write('\n');
		  }
		}; 
	} (nodeProgress));
	return nodeProgress.exports;
}

var progress;
var hasRequiredProgress;

function requireProgress () {
	if (hasRequiredProgress) return progress;
	hasRequiredProgress = 1;
	progress = requireNodeProgress();
	return progress;
}

var extend;
var hasRequiredExtend;

function requireExtend () {
	if (hasRequiredExtend) return extend;
	hasRequiredExtend = 1;

	var hasOwn = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var defineProperty = Object.defineProperty;
	var gOPD = Object.getOwnPropertyDescriptor;

	var isArray = function isArray(arr) {
		if (typeof Array.isArray === 'function') {
			return Array.isArray(arr);
		}

		return toStr.call(arr) === '[object Array]';
	};

	var isPlainObject = function isPlainObject(obj) {
		if (!obj || toStr.call(obj) !== '[object Object]') {
			return false;
		}

		var hasOwnConstructor = hasOwn.call(obj, 'constructor');
		var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
		// Not own constructor property must be Object
		if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		var key;
		for (key in obj) { /**/ }

		return typeof key === 'undefined' || hasOwn.call(obj, key);
	};

	// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
	var setProperty = function setProperty(target, options) {
		if (defineProperty && options.name === '__proto__') {
			defineProperty(target, options.name, {
				enumerable: true,
				configurable: true,
				value: options.newValue,
				writable: true
			});
		} else {
			target[options.name] = options.newValue;
		}
	};

	// Return undefined instead of __proto__ if '__proto__' is not an own property
	var getProperty = function getProperty(obj, name) {
		if (name === '__proto__') {
			if (!hasOwn.call(obj, name)) {
				return void 0;
			} else if (gOPD) {
				// In early versions of node, obj['__proto__'] is buggy when obj has
				// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
				return gOPD(obj, name).value;
			}
		}

		return obj[name];
	};

	extend = function extend() {
		var options, name, src, copy, copyIsArray, clone;
		var target = arguments[0];
		var i = 1;
		var length = arguments.length;
		var deep = false;

		// Handle a deep copy situation
		if (typeof target === 'boolean') {
			deep = target;
			target = arguments[1] || {};
			// skip the boolean and the target
			i = 2;
		}
		if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
			target = {};
		}

		for (; i < length; ++i) {
			options = arguments[i];
			// Only deal with non-null/undefined values
			if (options != null) {
				// Extend the base object
				for (name in options) {
					src = getProperty(target, name);
					copy = getProperty(options, name);

					// Prevent never-ending loop
					if (target !== copy) {
						// Recurse if we're merging plain objects or arrays
						if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
							if (copyIsArray) {
								copyIsArray = false;
								clone = src && isArray(src) ? src : [];
							} else {
								clone = src && isPlainObject(src) ? src : {};
							}

							// Never move original objects, clone them
							setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

						// Don't bring in undefined values
						} else if (typeof copy !== 'undefined') {
							setProperty(target, { name: name, newValue: copy });
						}
					}
				}
			}
		}

		// Return the modified object
		return target;
	};
	return extend;
}

var cookies = {};

var cookie = {};

var pubsuffixPsl = {};

var psl = {};

var hasRequiredPsl;

function requirePsl () {
	if (hasRequiredPsl) return psl;
	hasRequiredPsl = 1;
	(function (exports) {
Object.defineProperties(exports,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}});function H(a){return a&&a.__esModule&&Object.prototype.hasOwnProperty.call(a,"default")?a.default:a}const b=2147483647,p=36,q=1,y=26,N=38,R=700,O=72,S=128,I="-",V=/^xn--/,W=/[^\0-\x7F]/,P=/[\x2E\u3002\uFF0E\uFF61]/g,G={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},z=p-q,u=Math.floor,x=String.fromCharCode;function h(a){throw new RangeError(G[a])}function U(a,s){const e=[];let o=a.length;for(;o--;)e[o]=s(a[o]);return e}function C(a,s){const e=a.split("@");let o="";e.length>1&&(o=e[0]+"@",a=e[1]),a=a.replace(P,".");const i=a.split("."),n=U(i,s).join(".");return o+n}function L(a){const s=[];let e=0;const o=a.length;for(;e<o;){const i=a.charCodeAt(e++);if(i>=55296&&i<=56319&&e<o){const n=a.charCodeAt(e++);(n&64512)==56320?s.push(((i&1023)<<10)+(n&1023)+65536):(s.push(i),e--);}else s.push(i);}return s}const $=a=>String.fromCodePoint(...a),J=function(a){return a>=48&&a<58?26+(a-48):a>=65&&a<91?a-65:a>=97&&a<123?a-97:p},_=function(a,s){return a+22+75*(a<26)-((s!=0)<<5)},T=function(a,s,e){let o=0;for(a=e?u(a/R):a>>1,a+=u(a/s);a>z*y>>1;o+=p)a=u(a/z);return u(o+(z+1)*a/(a+N))},D=function(a){const s=[],e=a.length;let o=0,i=S,n=O,r=a.lastIndexOf(I);r<0&&(r=0);for(let t=0;t<r;++t)a.charCodeAt(t)>=128&&h("not-basic"),s.push(a.charCodeAt(t));for(let t=r>0?r+1:0;t<e;){const m=o;for(let c=1,k=p;;k+=p){t>=e&&h("invalid-input");const l=J(a.charCodeAt(t++));l>=p&&h("invalid-input"),l>u((b-o)/c)&&h("overflow"),o+=l*c;const j=k<=n?q:k>=n+y?y:k-n;if(l<j)break;const w=p-j;c>u(b/w)&&h("overflow"),c*=w;}const g=s.length+1;n=T(o-m,g,m==0),u(o/g)>b-i&&h("overflow"),i+=u(o/g),o%=g,s.splice(o++,0,i);}return String.fromCodePoint(...s)},E=function(a){const s=[];a=L(a);const e=a.length;let o=S,i=0,n=O;for(const m of a)m<128&&s.push(x(m));const r=s.length;let t=r;for(r&&s.push(I);t<e;){let m=b;for(const c of a)c>=o&&c<m&&(m=c);const g=t+1;m-o>u((b-i)/g)&&h("overflow"),i+=(m-o)*g,o=m;for(const c of a)if(c<o&&++i>b&&h("overflow"),c===o){let k=i;for(let l=p;;l+=p){const j=l<=n?q:l>=n+y?y:l-n;if(k<j)break;const w=k-j,A=p-j;s.push(x(_(j+w%A,0))),k=u(w/A);}s.push(x(_(k,0))),n=T(i,g,t===r),i=0,++t;}++i,++o;}return s.join("")},K=function(a){return C(a,function(s){return V.test(s)?D(s.slice(4).toLowerCase()):s})},Q=function(a){return C(a,function(s){return W.test(s)?"xn--"+E(s):s})},X={version:"2.3.1",ucs2:{decode:L,encode:$},decode:D,encode:E,toASCII:Q,toUnicode:K};var Y=X;const v=H(Y),Z=["ac","com.ac","edu.ac","gov.ac","net.ac","mil.ac","org.ac","ad","ae","co.ae","net.ae","org.ae","sch.ae","ac.ae","gov.ae","mil.ae","aero","airline.aero","airport.aero","accident-investigation.aero","accident-prevention.aero","aerobatic.aero","aeroclub.aero","aerodrome.aero","agents.aero","air-surveillance.aero","air-traffic-control.aero","aircraft.aero","airtraffic.aero","ambulance.aero","association.aero","author.aero","ballooning.aero","broker.aero","caa.aero","cargo.aero","catering.aero","certification.aero","championship.aero","charter.aero","civilaviation.aero","club.aero","conference.aero","consultant.aero","consulting.aero","control.aero","council.aero","crew.aero","design.aero","dgca.aero","educator.aero","emergency.aero","engine.aero","engineer.aero","entertainment.aero","equipment.aero","exchange.aero","express.aero","federation.aero","flight.aero","freight.aero","fuel.aero","gliding.aero","government.aero","groundhandling.aero","group.aero","hanggliding.aero","homebuilt.aero","insurance.aero","journal.aero","journalist.aero","leasing.aero","logistics.aero","magazine.aero","maintenance.aero","marketplace.aero","media.aero","microlight.aero","modelling.aero","navigation.aero","parachuting.aero","paragliding.aero","passenger-association.aero","pilot.aero","press.aero","production.aero","recreation.aero","repbody.aero","res.aero","research.aero","rotorcraft.aero","safety.aero","scientist.aero","services.aero","show.aero","skydiving.aero","software.aero","student.aero","taxi.aero","trader.aero","trading.aero","trainer.aero","union.aero","workinggroup.aero","works.aero","af","com.af","edu.af","gov.af","net.af","org.af","ag","com.ag","org.ag","net.ag","co.ag","nom.ag","ai","off.ai","com.ai","net.ai","org.ai","al","com.al","edu.al","gov.al","mil.al","net.al","org.al","am","co.am","com.am","commune.am","net.am","org.am","ao","ed.ao","edu.ao","gov.ao","gv.ao","og.ao","org.ao","co.ao","pb.ao","it.ao","aq","ar","bet.ar","com.ar","coop.ar","edu.ar","gob.ar","gov.ar","int.ar","mil.ar","musica.ar","mutual.ar","net.ar","org.ar","senasa.ar","tur.ar","arpa","e164.arpa","home.arpa","in-addr.arpa","ip6.arpa","iris.arpa","uri.arpa","urn.arpa","as","gov.as","asia","at","ac.at","co.at","gv.at","or.at","sth.ac.at","au","com.au","net.au","org.au","edu.au","gov.au","asn.au","id.au","conf.au","oz.au","act.au","nsw.au","nt.au","qld.au","sa.au","tas.au","vic.au","wa.au","act.edu.au","catholic.edu.au","nsw.edu.au","nt.edu.au","qld.edu.au","sa.edu.au","tas.edu.au","vic.edu.au","wa.edu.au","qld.gov.au","sa.gov.au","tas.gov.au","vic.gov.au","wa.gov.au","schools.nsw.edu.au","aw","com.aw","ax","az","biz.az","com.az","edu.az","gov.az","info.az","int.az","mil.az","name.az","net.az","org.az","pp.az","pro.az","ba","com.ba","edu.ba","gov.ba","mil.ba","net.ba","org.ba","bb","biz.bb","co.bb","com.bb","edu.bb","gov.bb","info.bb","net.bb","org.bb","store.bb","tv.bb","*.bd","be","ac.be","bf","gov.bf","bg","a.bg","b.bg","c.bg","d.bg","e.bg","f.bg","g.bg","h.bg","i.bg","j.bg","k.bg","l.bg","m.bg","n.bg","o.bg","p.bg","q.bg","r.bg","s.bg","t.bg","u.bg","v.bg","w.bg","x.bg","y.bg","z.bg","0.bg","1.bg","2.bg","3.bg","4.bg","5.bg","6.bg","7.bg","8.bg","9.bg","bh","com.bh","edu.bh","net.bh","org.bh","gov.bh","bi","co.bi","com.bi","edu.bi","or.bi","org.bi","biz","bj","africa.bj","agro.bj","architectes.bj","assur.bj","avocats.bj","co.bj","com.bj","eco.bj","econo.bj","edu.bj","info.bj","loisirs.bj","money.bj","net.bj","org.bj","ote.bj","resto.bj","restaurant.bj","tourism.bj","univ.bj","bm","com.bm","edu.bm","gov.bm","net.bm","org.bm","bn","com.bn","edu.bn","gov.bn","net.bn","org.bn","bo","com.bo","edu.bo","gob.bo","int.bo","mil.bo","net.bo","org.bo","tv.bo","web.bo","academia.bo","agro.bo","arte.bo","blog.bo","bolivia.bo","ciencia.bo","cooperativa.bo","democracia.bo","deporte.bo","ecologia.bo","economia.bo","empresa.bo","indigena.bo","industria.bo","info.bo","medicina.bo","movimiento.bo","musica.bo","natural.bo","nombre.bo","noticias.bo","patria.bo","plurinacional.bo","politica.bo","profesional.bo","pueblo.bo","revista.bo","salud.bo","tecnologia.bo","tksat.bo","transporte.bo","wiki.bo","br","9guacu.br","abc.br","adm.br","adv.br","agr.br","aju.br","am.br","anani.br","aparecida.br","app.br","arq.br","art.br","ato.br","b.br","barueri.br","belem.br","bet.br","bhz.br","bib.br","bio.br","blog.br","bmd.br","boavista.br","bsb.br","campinagrande.br","campinas.br","caxias.br","cim.br","cng.br","cnt.br","com.br","contagem.br","coop.br","coz.br","cri.br","cuiaba.br","curitiba.br","def.br","des.br","det.br","dev.br","ecn.br","eco.br","edu.br","emp.br","enf.br","eng.br","esp.br","etc.br","eti.br","far.br","feira.br","flog.br","floripa.br","fm.br","fnd.br","fortal.br","fot.br","foz.br","fst.br","g12.br","geo.br","ggf.br","goiania.br","gov.br","ac.gov.br","al.gov.br","am.gov.br","ap.gov.br","ba.gov.br","ce.gov.br","df.gov.br","es.gov.br","go.gov.br","ma.gov.br","mg.gov.br","ms.gov.br","mt.gov.br","pa.gov.br","pb.gov.br","pe.gov.br","pi.gov.br","pr.gov.br","rj.gov.br","rn.gov.br","ro.gov.br","rr.gov.br","rs.gov.br","sc.gov.br","se.gov.br","sp.gov.br","to.gov.br","gru.br","imb.br","ind.br","inf.br","jab.br","jampa.br","jdf.br","joinville.br","jor.br","jus.br","leg.br","leilao.br","lel.br","log.br","londrina.br","macapa.br","maceio.br","manaus.br","maringa.br","mat.br","med.br","mil.br","morena.br","mp.br","mus.br","natal.br","net.br","niteroi.br","*.nom.br","not.br","ntr.br","odo.br","ong.br","org.br","osasco.br","palmas.br","poa.br","ppg.br","pro.br","psc.br","psi.br","pvh.br","qsl.br","radio.br","rec.br","recife.br","rep.br","ribeirao.br","rio.br","riobranco.br","riopreto.br","salvador.br","sampa.br","santamaria.br","santoandre.br","saobernardo.br","saogonca.br","seg.br","sjc.br","slg.br","slz.br","sorocaba.br","srv.br","taxi.br","tc.br","tec.br","teo.br","the.br","tmp.br","trd.br","tur.br","tv.br","udi.br","vet.br","vix.br","vlog.br","wiki.br","zlg.br","bs","com.bs","net.bs","org.bs","edu.bs","gov.bs","bt","com.bt","edu.bt","gov.bt","net.bt","org.bt","bv","bw","co.bw","org.bw","by","gov.by","mil.by","com.by","of.by","bz","co.bz","com.bz","net.bz","org.bz","edu.bz","gov.bz","ca","ab.ca","bc.ca","mb.ca","nb.ca","nf.ca","nl.ca","ns.ca","nt.ca","nu.ca","on.ca","pe.ca","qc.ca","sk.ca","yk.ca","gc.ca","cat","cc","cd","gov.cd","cf","cg","ch","ci","org.ci","or.ci","com.ci","co.ci","edu.ci","ed.ci","ac.ci","net.ci","go.ci","asso.ci","aéroport.ci","int.ci","gouv.ci","*.ck","!www.ck","cl","co.cl","gob.cl","gov.cl","mil.cl","cm","co.cm","com.cm","gov.cm","net.cm","cn","ac.cn","com.cn","edu.cn","gov.cn","net.cn","org.cn","mil.cn","公司.cn","网络.cn","網絡.cn","ah.cn","bj.cn","cq.cn","fj.cn","gd.cn","gs.cn","gz.cn","gx.cn","ha.cn","hb.cn","he.cn","hi.cn","hl.cn","hn.cn","jl.cn","js.cn","jx.cn","ln.cn","nm.cn","nx.cn","qh.cn","sc.cn","sd.cn","sh.cn","sn.cn","sx.cn","tj.cn","xj.cn","xz.cn","yn.cn","zj.cn","hk.cn","mo.cn","tw.cn","co","com.co","edu.co","gov.co","mil.co","net.co","nom.co","org.co","com","coop","cr","ac.cr","co.cr","ed.cr","fi.cr","go.cr","or.cr","sa.cr","cu","com.cu","edu.cu","gob.cu","inf.cu","nat.cu","net.cu","org.cu","cv","com.cv","edu.cv","int.cv","nome.cv","org.cv","cw","com.cw","edu.cw","net.cw","org.cw","cx","gov.cx","cy","ac.cy","biz.cy","com.cy","ekloges.cy","gov.cy","ltd.cy","mil.cy","net.cy","org.cy","press.cy","pro.cy","tm.cy","cz","de","dj","dk","dm","co.dm","com.dm","edu.dm","gov.dm","net.dm","org.dm","do","art.do","com.do","edu.do","gob.do","gov.do","mil.do","net.do","org.do","sld.do","web.do","dz","art.dz","asso.dz","com.dz","edu.dz","gov.dz","org.dz","net.dz","pol.dz","soc.dz","tm.dz","ec","com.ec","info.ec","net.ec","fin.ec","k12.ec","med.ec","pro.ec","org.ec","edu.ec","gov.ec","gob.ec","mil.ec","edu","ee","edu.ee","gov.ee","riik.ee","lib.ee","med.ee","com.ee","pri.ee","aip.ee","org.ee","fie.ee","eg","com.eg","edu.eg","eun.eg","gov.eg","mil.eg","name.eg","net.eg","org.eg","sci.eg","*.er","es","com.es","nom.es","org.es","gob.es","edu.es","et","com.et","gov.et","org.et","edu.et","biz.et","name.et","info.et","net.et","eu","fi","aland.fi","fj","ac.fj","biz.fj","com.fj","gov.fj","info.fj","mil.fj","name.fj","net.fj","org.fj","pro.fj","*.fk","com.fm","edu.fm","net.fm","org.fm","fm","fo","fr","asso.fr","com.fr","gouv.fr","nom.fr","prd.fr","tm.fr","avoues.fr","cci.fr","greta.fr","huissier-justice.fr","ga","gb","edu.gd","gov.gd","gd","ge","com.ge","edu.ge","gov.ge","org.ge","mil.ge","net.ge","pvt.ge","gf","gg","co.gg","net.gg","org.gg","gh","com.gh","edu.gh","gov.gh","org.gh","mil.gh","gi","com.gi","ltd.gi","gov.gi","mod.gi","edu.gi","org.gi","gl","co.gl","com.gl","edu.gl","net.gl","org.gl","gm","gn","ac.gn","com.gn","edu.gn","gov.gn","org.gn","net.gn","gov","gp","com.gp","net.gp","mobi.gp","edu.gp","org.gp","asso.gp","gq","gr","com.gr","edu.gr","net.gr","org.gr","gov.gr","gs","gt","com.gt","edu.gt","gob.gt","ind.gt","mil.gt","net.gt","org.gt","gu","com.gu","edu.gu","gov.gu","guam.gu","info.gu","net.gu","org.gu","web.gu","gw","gy","co.gy","com.gy","edu.gy","gov.gy","net.gy","org.gy","hk","com.hk","edu.hk","gov.hk","idv.hk","net.hk","org.hk","公司.hk","教育.hk","敎育.hk","政府.hk","個人.hk","个人.hk","箇人.hk","網络.hk","网络.hk","组織.hk","網絡.hk","网絡.hk","组织.hk","組織.hk","組织.hk","hm","hn","com.hn","edu.hn","org.hn","net.hn","mil.hn","gob.hn","hr","iz.hr","from.hr","name.hr","com.hr","ht","com.ht","shop.ht","firm.ht","info.ht","adult.ht","net.ht","pro.ht","org.ht","med.ht","art.ht","coop.ht","pol.ht","asso.ht","edu.ht","rel.ht","gouv.ht","perso.ht","hu","co.hu","info.hu","org.hu","priv.hu","sport.hu","tm.hu","2000.hu","agrar.hu","bolt.hu","casino.hu","city.hu","erotica.hu","erotika.hu","film.hu","forum.hu","games.hu","hotel.hu","ingatlan.hu","jogasz.hu","konyvelo.hu","lakas.hu","media.hu","news.hu","reklam.hu","sex.hu","shop.hu","suli.hu","szex.hu","tozsde.hu","utazas.hu","video.hu","id","ac.id","biz.id","co.id","desa.id","go.id","mil.id","my.id","net.id","or.id","ponpes.id","sch.id","web.id","ie","gov.ie","il","ac.il","co.il","gov.il","idf.il","k12.il","muni.il","net.il","org.il","ישראל","אקדמיה.ישראל","ישוב.ישראל","צהל.ישראל","ממשל.ישראל","im","ac.im","co.im","com.im","ltd.co.im","net.im","org.im","plc.co.im","tt.im","tv.im","in","5g.in","6g.in","ac.in","ai.in","am.in","bihar.in","biz.in","business.in","ca.in","cn.in","co.in","com.in","coop.in","cs.in","delhi.in","dr.in","edu.in","er.in","firm.in","gen.in","gov.in","gujarat.in","ind.in","info.in","int.in","internet.in","io.in","me.in","mil.in","net.in","nic.in","org.in","pg.in","post.in","pro.in","res.in","travel.in","tv.in","uk.in","up.in","us.in","info","int","eu.int","io","co.io","com.io","edu.io","gov.io","mil.io","net.io","nom.io","org.io","iq","gov.iq","edu.iq","mil.iq","com.iq","org.iq","net.iq","ir","ac.ir","co.ir","gov.ir","id.ir","net.ir","org.ir","sch.ir","ایران.ir","ايران.ir","is","it","gov.it","edu.it","abr.it","abruzzo.it","aosta-valley.it","aostavalley.it","bas.it","basilicata.it","cal.it","calabria.it","cam.it","campania.it","emilia-romagna.it","emiliaromagna.it","emr.it","friuli-v-giulia.it","friuli-ve-giulia.it","friuli-vegiulia.it","friuli-venezia-giulia.it","friuli-veneziagiulia.it","friuli-vgiulia.it","friuliv-giulia.it","friulive-giulia.it","friulivegiulia.it","friulivenezia-giulia.it","friuliveneziagiulia.it","friulivgiulia.it","fvg.it","laz.it","lazio.it","lig.it","liguria.it","lom.it","lombardia.it","lombardy.it","lucania.it","mar.it","marche.it","mol.it","molise.it","piedmont.it","piemonte.it","pmn.it","pug.it","puglia.it","sar.it","sardegna.it","sardinia.it","sic.it","sicilia.it","sicily.it","taa.it","tos.it","toscana.it","trentin-sud-tirol.it","trentin-süd-tirol.it","trentin-sudtirol.it","trentin-südtirol.it","trentin-sued-tirol.it","trentin-suedtirol.it","trentino-a-adige.it","trentino-aadige.it","trentino-alto-adige.it","trentino-altoadige.it","trentino-s-tirol.it","trentino-stirol.it","trentino-sud-tirol.it","trentino-süd-tirol.it","trentino-sudtirol.it","trentino-südtirol.it","trentino-sued-tirol.it","trentino-suedtirol.it","trentino.it","trentinoa-adige.it","trentinoaadige.it","trentinoalto-adige.it","trentinoaltoadige.it","trentinos-tirol.it","trentinostirol.it","trentinosud-tirol.it","trentinosüd-tirol.it","trentinosudtirol.it","trentinosüdtirol.it","trentinosued-tirol.it","trentinosuedtirol.it","trentinsud-tirol.it","trentinsüd-tirol.it","trentinsudtirol.it","trentinsüdtirol.it","trentinsued-tirol.it","trentinsuedtirol.it","tuscany.it","umb.it","umbria.it","val-d-aosta.it","val-daosta.it","vald-aosta.it","valdaosta.it","valle-aosta.it","valle-d-aosta.it","valle-daosta.it","valleaosta.it","valled-aosta.it","valledaosta.it","vallee-aoste.it","vallée-aoste.it","vallee-d-aoste.it","vallée-d-aoste.it","valleeaoste.it","valléeaoste.it","valleedaoste.it","valléedaoste.it","vao.it","vda.it","ven.it","veneto.it","ag.it","agrigento.it","al.it","alessandria.it","alto-adige.it","altoadige.it","an.it","ancona.it","andria-barletta-trani.it","andria-trani-barletta.it","andriabarlettatrani.it","andriatranibarletta.it","ao.it","aosta.it","aoste.it","ap.it","aq.it","aquila.it","ar.it","arezzo.it","ascoli-piceno.it","ascolipiceno.it","asti.it","at.it","av.it","avellino.it","ba.it","balsan-sudtirol.it","balsan-südtirol.it","balsan-suedtirol.it","balsan.it","bari.it","barletta-trani-andria.it","barlettatraniandria.it","belluno.it","benevento.it","bergamo.it","bg.it","bi.it","biella.it","bl.it","bn.it","bo.it","bologna.it","bolzano-altoadige.it","bolzano.it","bozen-sudtirol.it","bozen-südtirol.it","bozen-suedtirol.it","bozen.it","br.it","brescia.it","brindisi.it","bs.it","bt.it","bulsan-sudtirol.it","bulsan-südtirol.it","bulsan-suedtirol.it","bulsan.it","bz.it","ca.it","cagliari.it","caltanissetta.it","campidano-medio.it","campidanomedio.it","campobasso.it","carbonia-iglesias.it","carboniaiglesias.it","carrara-massa.it","carraramassa.it","caserta.it","catania.it","catanzaro.it","cb.it","ce.it","cesena-forli.it","cesena-forlì.it","cesenaforli.it","cesenaforlì.it","ch.it","chieti.it","ci.it","cl.it","cn.it","co.it","como.it","cosenza.it","cr.it","cremona.it","crotone.it","cs.it","ct.it","cuneo.it","cz.it","dell-ogliastra.it","dellogliastra.it","en.it","enna.it","fc.it","fe.it","fermo.it","ferrara.it","fg.it","fi.it","firenze.it","florence.it","fm.it","foggia.it","forli-cesena.it","forlì-cesena.it","forlicesena.it","forlìcesena.it","fr.it","frosinone.it","ge.it","genoa.it","genova.it","go.it","gorizia.it","gr.it","grosseto.it","iglesias-carbonia.it","iglesiascarbonia.it","im.it","imperia.it","is.it","isernia.it","kr.it","la-spezia.it","laquila.it","laspezia.it","latina.it","lc.it","le.it","lecce.it","lecco.it","li.it","livorno.it","lo.it","lodi.it","lt.it","lu.it","lucca.it","macerata.it","mantova.it","massa-carrara.it","massacarrara.it","matera.it","mb.it","mc.it","me.it","medio-campidano.it","mediocampidano.it","messina.it","mi.it","milan.it","milano.it","mn.it","mo.it","modena.it","monza-brianza.it","monza-e-della-brianza.it","monza.it","monzabrianza.it","monzaebrianza.it","monzaedellabrianza.it","ms.it","mt.it","na.it","naples.it","napoli.it","no.it","novara.it","nu.it","nuoro.it","og.it","ogliastra.it","olbia-tempio.it","olbiatempio.it","or.it","oristano.it","ot.it","pa.it","padova.it","padua.it","palermo.it","parma.it","pavia.it","pc.it","pd.it","pe.it","perugia.it","pesaro-urbino.it","pesarourbino.it","pescara.it","pg.it","pi.it","piacenza.it","pisa.it","pistoia.it","pn.it","po.it","pordenone.it","potenza.it","pr.it","prato.it","pt.it","pu.it","pv.it","pz.it","ra.it","ragusa.it","ravenna.it","rc.it","re.it","reggio-calabria.it","reggio-emilia.it","reggiocalabria.it","reggioemilia.it","rg.it","ri.it","rieti.it","rimini.it","rm.it","rn.it","ro.it","roma.it","rome.it","rovigo.it","sa.it","salerno.it","sassari.it","savona.it","si.it","siena.it","siracusa.it","so.it","sondrio.it","sp.it","sr.it","ss.it","suedtirol.it","südtirol.it","sv.it","ta.it","taranto.it","te.it","tempio-olbia.it","tempioolbia.it","teramo.it","terni.it","tn.it","to.it","torino.it","tp.it","tr.it","trani-andria-barletta.it","trani-barletta-andria.it","traniandriabarletta.it","tranibarlettaandria.it","trapani.it","trento.it","treviso.it","trieste.it","ts.it","turin.it","tv.it","ud.it","udine.it","urbino-pesaro.it","urbinopesaro.it","va.it","varese.it","vb.it","vc.it","ve.it","venezia.it","venice.it","verbania.it","vercelli.it","verona.it","vi.it","vibo-valentia.it","vibovalentia.it","vicenza.it","viterbo.it","vr.it","vs.it","vt.it","vv.it","je","co.je","net.je","org.je","*.jm","jo","agri.jo","ai.jo","com.jo","edu.jo","eng.jo","fm.jo","gov.jo","mil.jo","net.jo","org.jo","per.jo","phd.jo","sch.jo","tv.jo","jobs","jp","ac.jp","ad.jp","co.jp","ed.jp","go.jp","gr.jp","lg.jp","ne.jp","or.jp","aichi.jp","akita.jp","aomori.jp","chiba.jp","ehime.jp","fukui.jp","fukuoka.jp","fukushima.jp","gifu.jp","gunma.jp","hiroshima.jp","hokkaido.jp","hyogo.jp","ibaraki.jp","ishikawa.jp","iwate.jp","kagawa.jp","kagoshima.jp","kanagawa.jp","kochi.jp","kumamoto.jp","kyoto.jp","mie.jp","miyagi.jp","miyazaki.jp","nagano.jp","nagasaki.jp","nara.jp","niigata.jp","oita.jp","okayama.jp","okinawa.jp","osaka.jp","saga.jp","saitama.jp","shiga.jp","shimane.jp","shizuoka.jp","tochigi.jp","tokushima.jp","tokyo.jp","tottori.jp","toyama.jp","wakayama.jp","yamagata.jp","yamaguchi.jp","yamanashi.jp","栃木.jp","愛知.jp","愛媛.jp","兵庫.jp","熊本.jp","茨城.jp","北海道.jp","千葉.jp","和歌山.jp","長崎.jp","長野.jp","新潟.jp","青森.jp","静岡.jp","東京.jp","石川.jp","埼玉.jp","三重.jp","京都.jp","佐賀.jp","大分.jp","大阪.jp","奈良.jp","宮城.jp","宮崎.jp","富山.jp","山口.jp","山形.jp","山梨.jp","岩手.jp","岐阜.jp","岡山.jp","島根.jp","広島.jp","徳島.jp","沖縄.jp","滋賀.jp","神奈川.jp","福井.jp","福岡.jp","福島.jp","秋田.jp","群馬.jp","香川.jp","高知.jp","鳥取.jp","鹿児島.jp","*.kawasaki.jp","!city.kawasaki.jp","*.kitakyushu.jp","!city.kitakyushu.jp","*.kobe.jp","!city.kobe.jp","*.nagoya.jp","!city.nagoya.jp","*.sapporo.jp","!city.sapporo.jp","*.sendai.jp","!city.sendai.jp","*.yokohama.jp","!city.yokohama.jp","aisai.aichi.jp","ama.aichi.jp","anjo.aichi.jp","asuke.aichi.jp","chiryu.aichi.jp","chita.aichi.jp","fuso.aichi.jp","gamagori.aichi.jp","handa.aichi.jp","hazu.aichi.jp","hekinan.aichi.jp","higashiura.aichi.jp","ichinomiya.aichi.jp","inazawa.aichi.jp","inuyama.aichi.jp","isshiki.aichi.jp","iwakura.aichi.jp","kanie.aichi.jp","kariya.aichi.jp","kasugai.aichi.jp","kira.aichi.jp","kiyosu.aichi.jp","komaki.aichi.jp","konan.aichi.jp","kota.aichi.jp","mihama.aichi.jp","miyoshi.aichi.jp","nishio.aichi.jp","nisshin.aichi.jp","obu.aichi.jp","oguchi.aichi.jp","oharu.aichi.jp","okazaki.aichi.jp","owariasahi.aichi.jp","seto.aichi.jp","shikatsu.aichi.jp","shinshiro.aichi.jp","shitara.aichi.jp","tahara.aichi.jp","takahama.aichi.jp","tobishima.aichi.jp","toei.aichi.jp","togo.aichi.jp","tokai.aichi.jp","tokoname.aichi.jp","toyoake.aichi.jp","toyohashi.aichi.jp","toyokawa.aichi.jp","toyone.aichi.jp","toyota.aichi.jp","tsushima.aichi.jp","yatomi.aichi.jp","akita.akita.jp","daisen.akita.jp","fujisato.akita.jp","gojome.akita.jp","hachirogata.akita.jp","happou.akita.jp","higashinaruse.akita.jp","honjo.akita.jp","honjyo.akita.jp","ikawa.akita.jp","kamikoani.akita.jp","kamioka.akita.jp","katagami.akita.jp","kazuno.akita.jp","kitaakita.akita.jp","kosaka.akita.jp","kyowa.akita.jp","misato.akita.jp","mitane.akita.jp","moriyoshi.akita.jp","nikaho.akita.jp","noshiro.akita.jp","odate.akita.jp","oga.akita.jp","ogata.akita.jp","semboku.akita.jp","yokote.akita.jp","yurihonjo.akita.jp","aomori.aomori.jp","gonohe.aomori.jp","hachinohe.aomori.jp","hashikami.aomori.jp","hiranai.aomori.jp","hirosaki.aomori.jp","itayanagi.aomori.jp","kuroishi.aomori.jp","misawa.aomori.jp","mutsu.aomori.jp","nakadomari.aomori.jp","noheji.aomori.jp","oirase.aomori.jp","owani.aomori.jp","rokunohe.aomori.jp","sannohe.aomori.jp","shichinohe.aomori.jp","shingo.aomori.jp","takko.aomori.jp","towada.aomori.jp","tsugaru.aomori.jp","tsuruta.aomori.jp","abiko.chiba.jp","asahi.chiba.jp","chonan.chiba.jp","chosei.chiba.jp","choshi.chiba.jp","chuo.chiba.jp","funabashi.chiba.jp","futtsu.chiba.jp","hanamigawa.chiba.jp","ichihara.chiba.jp","ichikawa.chiba.jp","ichinomiya.chiba.jp","inzai.chiba.jp","isumi.chiba.jp","kamagaya.chiba.jp","kamogawa.chiba.jp","kashiwa.chiba.jp","katori.chiba.jp","katsuura.chiba.jp","kimitsu.chiba.jp","kisarazu.chiba.jp","kozaki.chiba.jp","kujukuri.chiba.jp","kyonan.chiba.jp","matsudo.chiba.jp","midori.chiba.jp","mihama.chiba.jp","minamiboso.chiba.jp","mobara.chiba.jp","mutsuzawa.chiba.jp","nagara.chiba.jp","nagareyama.chiba.jp","narashino.chiba.jp","narita.chiba.jp","noda.chiba.jp","oamishirasato.chiba.jp","omigawa.chiba.jp","onjuku.chiba.jp","otaki.chiba.jp","sakae.chiba.jp","sakura.chiba.jp","shimofusa.chiba.jp","shirako.chiba.jp","shiroi.chiba.jp","shisui.chiba.jp","sodegaura.chiba.jp","sosa.chiba.jp","tako.chiba.jp","tateyama.chiba.jp","togane.chiba.jp","tohnosho.chiba.jp","tomisato.chiba.jp","urayasu.chiba.jp","yachimata.chiba.jp","yachiyo.chiba.jp","yokaichiba.chiba.jp","yokoshibahikari.chiba.jp","yotsukaido.chiba.jp","ainan.ehime.jp","honai.ehime.jp","ikata.ehime.jp","imabari.ehime.jp","iyo.ehime.jp","kamijima.ehime.jp","kihoku.ehime.jp","kumakogen.ehime.jp","masaki.ehime.jp","matsuno.ehime.jp","matsuyama.ehime.jp","namikata.ehime.jp","niihama.ehime.jp","ozu.ehime.jp","saijo.ehime.jp","seiyo.ehime.jp","shikokuchuo.ehime.jp","tobe.ehime.jp","toon.ehime.jp","uchiko.ehime.jp","uwajima.ehime.jp","yawatahama.ehime.jp","echizen.fukui.jp","eiheiji.fukui.jp","fukui.fukui.jp","ikeda.fukui.jp","katsuyama.fukui.jp","mihama.fukui.jp","minamiechizen.fukui.jp","obama.fukui.jp","ohi.fukui.jp","ono.fukui.jp","sabae.fukui.jp","sakai.fukui.jp","takahama.fukui.jp","tsuruga.fukui.jp","wakasa.fukui.jp","ashiya.fukuoka.jp","buzen.fukuoka.jp","chikugo.fukuoka.jp","chikuho.fukuoka.jp","chikujo.fukuoka.jp","chikushino.fukuoka.jp","chikuzen.fukuoka.jp","chuo.fukuoka.jp","dazaifu.fukuoka.jp","fukuchi.fukuoka.jp","hakata.fukuoka.jp","higashi.fukuoka.jp","hirokawa.fukuoka.jp","hisayama.fukuoka.jp","iizuka.fukuoka.jp","inatsuki.fukuoka.jp","kaho.fukuoka.jp","kasuga.fukuoka.jp","kasuya.fukuoka.jp","kawara.fukuoka.jp","keisen.fukuoka.jp","koga.fukuoka.jp","kurate.fukuoka.jp","kurogi.fukuoka.jp","kurume.fukuoka.jp","minami.fukuoka.jp","miyako.fukuoka.jp","miyama.fukuoka.jp","miyawaka.fukuoka.jp","mizumaki.fukuoka.jp","munakata.fukuoka.jp","nakagawa.fukuoka.jp","nakama.fukuoka.jp","nishi.fukuoka.jp","nogata.fukuoka.jp","ogori.fukuoka.jp","okagaki.fukuoka.jp","okawa.fukuoka.jp","oki.fukuoka.jp","omuta.fukuoka.jp","onga.fukuoka.jp","onojo.fukuoka.jp","oto.fukuoka.jp","saigawa.fukuoka.jp","sasaguri.fukuoka.jp","shingu.fukuoka.jp","shinyoshitomi.fukuoka.jp","shonai.fukuoka.jp","soeda.fukuoka.jp","sue.fukuoka.jp","tachiarai.fukuoka.jp","tagawa.fukuoka.jp","takata.fukuoka.jp","toho.fukuoka.jp","toyotsu.fukuoka.jp","tsuiki.fukuoka.jp","ukiha.fukuoka.jp","umi.fukuoka.jp","usui.fukuoka.jp","yamada.fukuoka.jp","yame.fukuoka.jp","yanagawa.fukuoka.jp","yukuhashi.fukuoka.jp","aizubange.fukushima.jp","aizumisato.fukushima.jp","aizuwakamatsu.fukushima.jp","asakawa.fukushima.jp","bandai.fukushima.jp","date.fukushima.jp","fukushima.fukushima.jp","furudono.fukushima.jp","futaba.fukushima.jp","hanawa.fukushima.jp","higashi.fukushima.jp","hirata.fukushima.jp","hirono.fukushima.jp","iitate.fukushima.jp","inawashiro.fukushima.jp","ishikawa.fukushima.jp","iwaki.fukushima.jp","izumizaki.fukushima.jp","kagamiishi.fukushima.jp","kaneyama.fukushima.jp","kawamata.fukushima.jp","kitakata.fukushima.jp","kitashiobara.fukushima.jp","koori.fukushima.jp","koriyama.fukushima.jp","kunimi.fukushima.jp","miharu.fukushima.jp","mishima.fukushima.jp","namie.fukushima.jp","nango.fukushima.jp","nishiaizu.fukushima.jp","nishigo.fukushima.jp","okuma.fukushima.jp","omotego.fukushima.jp","ono.fukushima.jp","otama.fukushima.jp","samegawa.fukushima.jp","shimogo.fukushima.jp","shirakawa.fukushima.jp","showa.fukushima.jp","soma.fukushima.jp","sukagawa.fukushima.jp","taishin.fukushima.jp","tamakawa.fukushima.jp","tanagura.fukushima.jp","tenei.fukushima.jp","yabuki.fukushima.jp","yamato.fukushima.jp","yamatsuri.fukushima.jp","yanaizu.fukushima.jp","yugawa.fukushima.jp","anpachi.gifu.jp","ena.gifu.jp","gifu.gifu.jp","ginan.gifu.jp","godo.gifu.jp","gujo.gifu.jp","hashima.gifu.jp","hichiso.gifu.jp","hida.gifu.jp","higashishirakawa.gifu.jp","ibigawa.gifu.jp","ikeda.gifu.jp","kakamigahara.gifu.jp","kani.gifu.jp","kasahara.gifu.jp","kasamatsu.gifu.jp","kawaue.gifu.jp","kitagata.gifu.jp","mino.gifu.jp","minokamo.gifu.jp","mitake.gifu.jp","mizunami.gifu.jp","motosu.gifu.jp","nakatsugawa.gifu.jp","ogaki.gifu.jp","sakahogi.gifu.jp","seki.gifu.jp","sekigahara.gifu.jp","shirakawa.gifu.jp","tajimi.gifu.jp","takayama.gifu.jp","tarui.gifu.jp","toki.gifu.jp","tomika.gifu.jp","wanouchi.gifu.jp","yamagata.gifu.jp","yaotsu.gifu.jp","yoro.gifu.jp","annaka.gunma.jp","chiyoda.gunma.jp","fujioka.gunma.jp","higashiagatsuma.gunma.jp","isesaki.gunma.jp","itakura.gunma.jp","kanna.gunma.jp","kanra.gunma.jp","katashina.gunma.jp","kawaba.gunma.jp","kiryu.gunma.jp","kusatsu.gunma.jp","maebashi.gunma.jp","meiwa.gunma.jp","midori.gunma.jp","minakami.gunma.jp","naganohara.gunma.jp","nakanojo.gunma.jp","nanmoku.gunma.jp","numata.gunma.jp","oizumi.gunma.jp","ora.gunma.jp","ota.gunma.jp","shibukawa.gunma.jp","shimonita.gunma.jp","shinto.gunma.jp","showa.gunma.jp","takasaki.gunma.jp","takayama.gunma.jp","tamamura.gunma.jp","tatebayashi.gunma.jp","tomioka.gunma.jp","tsukiyono.gunma.jp","tsumagoi.gunma.jp","ueno.gunma.jp","yoshioka.gunma.jp","asaminami.hiroshima.jp","daiwa.hiroshima.jp","etajima.hiroshima.jp","fuchu.hiroshima.jp","fukuyama.hiroshima.jp","hatsukaichi.hiroshima.jp","higashihiroshima.hiroshima.jp","hongo.hiroshima.jp","jinsekikogen.hiroshima.jp","kaita.hiroshima.jp","kui.hiroshima.jp","kumano.hiroshima.jp","kure.hiroshima.jp","mihara.hiroshima.jp","miyoshi.hiroshima.jp","naka.hiroshima.jp","onomichi.hiroshima.jp","osakikamijima.hiroshima.jp","otake.hiroshima.jp","saka.hiroshima.jp","sera.hiroshima.jp","seranishi.hiroshima.jp","shinichi.hiroshima.jp","shobara.hiroshima.jp","takehara.hiroshima.jp","abashiri.hokkaido.jp","abira.hokkaido.jp","aibetsu.hokkaido.jp","akabira.hokkaido.jp","akkeshi.hokkaido.jp","asahikawa.hokkaido.jp","ashibetsu.hokkaido.jp","ashoro.hokkaido.jp","assabu.hokkaido.jp","atsuma.hokkaido.jp","bibai.hokkaido.jp","biei.hokkaido.jp","bifuka.hokkaido.jp","bihoro.hokkaido.jp","biratori.hokkaido.jp","chippubetsu.hokkaido.jp","chitose.hokkaido.jp","date.hokkaido.jp","ebetsu.hokkaido.jp","embetsu.hokkaido.jp","eniwa.hokkaido.jp","erimo.hokkaido.jp","esan.hokkaido.jp","esashi.hokkaido.jp","fukagawa.hokkaido.jp","fukushima.hokkaido.jp","furano.hokkaido.jp","furubira.hokkaido.jp","haboro.hokkaido.jp","hakodate.hokkaido.jp","hamatonbetsu.hokkaido.jp","hidaka.hokkaido.jp","higashikagura.hokkaido.jp","higashikawa.hokkaido.jp","hiroo.hokkaido.jp","hokuryu.hokkaido.jp","hokuto.hokkaido.jp","honbetsu.hokkaido.jp","horokanai.hokkaido.jp","horonobe.hokkaido.jp","ikeda.hokkaido.jp","imakane.hokkaido.jp","ishikari.hokkaido.jp","iwamizawa.hokkaido.jp","iwanai.hokkaido.jp","kamifurano.hokkaido.jp","kamikawa.hokkaido.jp","kamishihoro.hokkaido.jp","kamisunagawa.hokkaido.jp","kamoenai.hokkaido.jp","kayabe.hokkaido.jp","kembuchi.hokkaido.jp","kikonai.hokkaido.jp","kimobetsu.hokkaido.jp","kitahiroshima.hokkaido.jp","kitami.hokkaido.jp","kiyosato.hokkaido.jp","koshimizu.hokkaido.jp","kunneppu.hokkaido.jp","kuriyama.hokkaido.jp","kuromatsunai.hokkaido.jp","kushiro.hokkaido.jp","kutchan.hokkaido.jp","kyowa.hokkaido.jp","mashike.hokkaido.jp","matsumae.hokkaido.jp","mikasa.hokkaido.jp","minamifurano.hokkaido.jp","mombetsu.hokkaido.jp","moseushi.hokkaido.jp","mukawa.hokkaido.jp","muroran.hokkaido.jp","naie.hokkaido.jp","nakagawa.hokkaido.jp","nakasatsunai.hokkaido.jp","nakatombetsu.hokkaido.jp","nanae.hokkaido.jp","nanporo.hokkaido.jp","nayoro.hokkaido.jp","nemuro.hokkaido.jp","niikappu.hokkaido.jp","niki.hokkaido.jp","nishiokoppe.hokkaido.jp","noboribetsu.hokkaido.jp","numata.hokkaido.jp","obihiro.hokkaido.jp","obira.hokkaido.jp","oketo.hokkaido.jp","okoppe.hokkaido.jp","otaru.hokkaido.jp","otobe.hokkaido.jp","otofuke.hokkaido.jp","otoineppu.hokkaido.jp","oumu.hokkaido.jp","ozora.hokkaido.jp","pippu.hokkaido.jp","rankoshi.hokkaido.jp","rebun.hokkaido.jp","rikubetsu.hokkaido.jp","rishiri.hokkaido.jp","rishirifuji.hokkaido.jp","saroma.hokkaido.jp","sarufutsu.hokkaido.jp","shakotan.hokkaido.jp","shari.hokkaido.jp","shibecha.hokkaido.jp","shibetsu.hokkaido.jp","shikabe.hokkaido.jp","shikaoi.hokkaido.jp","shimamaki.hokkaido.jp","shimizu.hokkaido.jp","shimokawa.hokkaido.jp","shinshinotsu.hokkaido.jp","shintoku.hokkaido.jp","shiranuka.hokkaido.jp","shiraoi.hokkaido.jp","shiriuchi.hokkaido.jp","sobetsu.hokkaido.jp","sunagawa.hokkaido.jp","taiki.hokkaido.jp","takasu.hokkaido.jp","takikawa.hokkaido.jp","takinoue.hokkaido.jp","teshikaga.hokkaido.jp","tobetsu.hokkaido.jp","tohma.hokkaido.jp","tomakomai.hokkaido.jp","tomari.hokkaido.jp","toya.hokkaido.jp","toyako.hokkaido.jp","toyotomi.hokkaido.jp","toyoura.hokkaido.jp","tsubetsu.hokkaido.jp","tsukigata.hokkaido.jp","urakawa.hokkaido.jp","urausu.hokkaido.jp","uryu.hokkaido.jp","utashinai.hokkaido.jp","wakkanai.hokkaido.jp","wassamu.hokkaido.jp","yakumo.hokkaido.jp","yoichi.hokkaido.jp","aioi.hyogo.jp","akashi.hyogo.jp","ako.hyogo.jp","amagasaki.hyogo.jp","aogaki.hyogo.jp","asago.hyogo.jp","ashiya.hyogo.jp","awaji.hyogo.jp","fukusaki.hyogo.jp","goshiki.hyogo.jp","harima.hyogo.jp","himeji.hyogo.jp","ichikawa.hyogo.jp","inagawa.hyogo.jp","itami.hyogo.jp","kakogawa.hyogo.jp","kamigori.hyogo.jp","kamikawa.hyogo.jp","kasai.hyogo.jp","kasuga.hyogo.jp","kawanishi.hyogo.jp","miki.hyogo.jp","minamiawaji.hyogo.jp","nishinomiya.hyogo.jp","nishiwaki.hyogo.jp","ono.hyogo.jp","sanda.hyogo.jp","sannan.hyogo.jp","sasayama.hyogo.jp","sayo.hyogo.jp","shingu.hyogo.jp","shinonsen.hyogo.jp","shiso.hyogo.jp","sumoto.hyogo.jp","taishi.hyogo.jp","taka.hyogo.jp","takarazuka.hyogo.jp","takasago.hyogo.jp","takino.hyogo.jp","tamba.hyogo.jp","tatsuno.hyogo.jp","toyooka.hyogo.jp","yabu.hyogo.jp","yashiro.hyogo.jp","yoka.hyogo.jp","yokawa.hyogo.jp","ami.ibaraki.jp","asahi.ibaraki.jp","bando.ibaraki.jp","chikusei.ibaraki.jp","daigo.ibaraki.jp","fujishiro.ibaraki.jp","hitachi.ibaraki.jp","hitachinaka.ibaraki.jp","hitachiomiya.ibaraki.jp","hitachiota.ibaraki.jp","ibaraki.ibaraki.jp","ina.ibaraki.jp","inashiki.ibaraki.jp","itako.ibaraki.jp","iwama.ibaraki.jp","joso.ibaraki.jp","kamisu.ibaraki.jp","kasama.ibaraki.jp","kashima.ibaraki.jp","kasumigaura.ibaraki.jp","koga.ibaraki.jp","miho.ibaraki.jp","mito.ibaraki.jp","moriya.ibaraki.jp","naka.ibaraki.jp","namegata.ibaraki.jp","oarai.ibaraki.jp","ogawa.ibaraki.jp","omitama.ibaraki.jp","ryugasaki.ibaraki.jp","sakai.ibaraki.jp","sakuragawa.ibaraki.jp","shimodate.ibaraki.jp","shimotsuma.ibaraki.jp","shirosato.ibaraki.jp","sowa.ibaraki.jp","suifu.ibaraki.jp","takahagi.ibaraki.jp","tamatsukuri.ibaraki.jp","tokai.ibaraki.jp","tomobe.ibaraki.jp","tone.ibaraki.jp","toride.ibaraki.jp","tsuchiura.ibaraki.jp","tsukuba.ibaraki.jp","uchihara.ibaraki.jp","ushiku.ibaraki.jp","yachiyo.ibaraki.jp","yamagata.ibaraki.jp","yawara.ibaraki.jp","yuki.ibaraki.jp","anamizu.ishikawa.jp","hakui.ishikawa.jp","hakusan.ishikawa.jp","kaga.ishikawa.jp","kahoku.ishikawa.jp","kanazawa.ishikawa.jp","kawakita.ishikawa.jp","komatsu.ishikawa.jp","nakanoto.ishikawa.jp","nanao.ishikawa.jp","nomi.ishikawa.jp","nonoichi.ishikawa.jp","noto.ishikawa.jp","shika.ishikawa.jp","suzu.ishikawa.jp","tsubata.ishikawa.jp","tsurugi.ishikawa.jp","uchinada.ishikawa.jp","wajima.ishikawa.jp","fudai.iwate.jp","fujisawa.iwate.jp","hanamaki.iwate.jp","hiraizumi.iwate.jp","hirono.iwate.jp","ichinohe.iwate.jp","ichinoseki.iwate.jp","iwaizumi.iwate.jp","iwate.iwate.jp","joboji.iwate.jp","kamaishi.iwate.jp","kanegasaki.iwate.jp","karumai.iwate.jp","kawai.iwate.jp","kitakami.iwate.jp","kuji.iwate.jp","kunohe.iwate.jp","kuzumaki.iwate.jp","miyako.iwate.jp","mizusawa.iwate.jp","morioka.iwate.jp","ninohe.iwate.jp","noda.iwate.jp","ofunato.iwate.jp","oshu.iwate.jp","otsuchi.iwate.jp","rikuzentakata.iwate.jp","shiwa.iwate.jp","shizukuishi.iwate.jp","sumita.iwate.jp","tanohata.iwate.jp","tono.iwate.jp","yahaba.iwate.jp","yamada.iwate.jp","ayagawa.kagawa.jp","higashikagawa.kagawa.jp","kanonji.kagawa.jp","kotohira.kagawa.jp","manno.kagawa.jp","marugame.kagawa.jp","mitoyo.kagawa.jp","naoshima.kagawa.jp","sanuki.kagawa.jp","tadotsu.kagawa.jp","takamatsu.kagawa.jp","tonosho.kagawa.jp","uchinomi.kagawa.jp","utazu.kagawa.jp","zentsuji.kagawa.jp","akune.kagoshima.jp","amami.kagoshima.jp","hioki.kagoshima.jp","isa.kagoshima.jp","isen.kagoshima.jp","izumi.kagoshima.jp","kagoshima.kagoshima.jp","kanoya.kagoshima.jp","kawanabe.kagoshima.jp","kinko.kagoshima.jp","kouyama.kagoshima.jp","makurazaki.kagoshima.jp","matsumoto.kagoshima.jp","minamitane.kagoshima.jp","nakatane.kagoshima.jp","nishinoomote.kagoshima.jp","satsumasendai.kagoshima.jp","soo.kagoshima.jp","tarumizu.kagoshima.jp","yusui.kagoshima.jp","aikawa.kanagawa.jp","atsugi.kanagawa.jp","ayase.kanagawa.jp","chigasaki.kanagawa.jp","ebina.kanagawa.jp","fujisawa.kanagawa.jp","hadano.kanagawa.jp","hakone.kanagawa.jp","hiratsuka.kanagawa.jp","isehara.kanagawa.jp","kaisei.kanagawa.jp","kamakura.kanagawa.jp","kiyokawa.kanagawa.jp","matsuda.kanagawa.jp","minamiashigara.kanagawa.jp","miura.kanagawa.jp","nakai.kanagawa.jp","ninomiya.kanagawa.jp","odawara.kanagawa.jp","oi.kanagawa.jp","oiso.kanagawa.jp","sagamihara.kanagawa.jp","samukawa.kanagawa.jp","tsukui.kanagawa.jp","yamakita.kanagawa.jp","yamato.kanagawa.jp","yokosuka.kanagawa.jp","yugawara.kanagawa.jp","zama.kanagawa.jp","zushi.kanagawa.jp","aki.kochi.jp","geisei.kochi.jp","hidaka.kochi.jp","higashitsuno.kochi.jp","ino.kochi.jp","kagami.kochi.jp","kami.kochi.jp","kitagawa.kochi.jp","kochi.kochi.jp","mihara.kochi.jp","motoyama.kochi.jp","muroto.kochi.jp","nahari.kochi.jp","nakamura.kochi.jp","nankoku.kochi.jp","nishitosa.kochi.jp","niyodogawa.kochi.jp","ochi.kochi.jp","okawa.kochi.jp","otoyo.kochi.jp","otsuki.kochi.jp","sakawa.kochi.jp","sukumo.kochi.jp","susaki.kochi.jp","tosa.kochi.jp","tosashimizu.kochi.jp","toyo.kochi.jp","tsuno.kochi.jp","umaji.kochi.jp","yasuda.kochi.jp","yusuhara.kochi.jp","amakusa.kumamoto.jp","arao.kumamoto.jp","aso.kumamoto.jp","choyo.kumamoto.jp","gyokuto.kumamoto.jp","kamiamakusa.kumamoto.jp","kikuchi.kumamoto.jp","kumamoto.kumamoto.jp","mashiki.kumamoto.jp","mifune.kumamoto.jp","minamata.kumamoto.jp","minamioguni.kumamoto.jp","nagasu.kumamoto.jp","nishihara.kumamoto.jp","oguni.kumamoto.jp","ozu.kumamoto.jp","sumoto.kumamoto.jp","takamori.kumamoto.jp","uki.kumamoto.jp","uto.kumamoto.jp","yamaga.kumamoto.jp","yamato.kumamoto.jp","yatsushiro.kumamoto.jp","ayabe.kyoto.jp","fukuchiyama.kyoto.jp","higashiyama.kyoto.jp","ide.kyoto.jp","ine.kyoto.jp","joyo.kyoto.jp","kameoka.kyoto.jp","kamo.kyoto.jp","kita.kyoto.jp","kizu.kyoto.jp","kumiyama.kyoto.jp","kyotamba.kyoto.jp","kyotanabe.kyoto.jp","kyotango.kyoto.jp","maizuru.kyoto.jp","minami.kyoto.jp","minamiyamashiro.kyoto.jp","miyazu.kyoto.jp","muko.kyoto.jp","nagaokakyo.kyoto.jp","nakagyo.kyoto.jp","nantan.kyoto.jp","oyamazaki.kyoto.jp","sakyo.kyoto.jp","seika.kyoto.jp","tanabe.kyoto.jp","uji.kyoto.jp","ujitawara.kyoto.jp","wazuka.kyoto.jp","yamashina.kyoto.jp","yawata.kyoto.jp","asahi.mie.jp","inabe.mie.jp","ise.mie.jp","kameyama.mie.jp","kawagoe.mie.jp","kiho.mie.jp","kisosaki.mie.jp","kiwa.mie.jp","komono.mie.jp","kumano.mie.jp","kuwana.mie.jp","matsusaka.mie.jp","meiwa.mie.jp","mihama.mie.jp","minamiise.mie.jp","misugi.mie.jp","miyama.mie.jp","nabari.mie.jp","shima.mie.jp","suzuka.mie.jp","tado.mie.jp","taiki.mie.jp","taki.mie.jp","tamaki.mie.jp","toba.mie.jp","tsu.mie.jp","udono.mie.jp","ureshino.mie.jp","watarai.mie.jp","yokkaichi.mie.jp","furukawa.miyagi.jp","higashimatsushima.miyagi.jp","ishinomaki.miyagi.jp","iwanuma.miyagi.jp","kakuda.miyagi.jp","kami.miyagi.jp","kawasaki.miyagi.jp","marumori.miyagi.jp","matsushima.miyagi.jp","minamisanriku.miyagi.jp","misato.miyagi.jp","murata.miyagi.jp","natori.miyagi.jp","ogawara.miyagi.jp","ohira.miyagi.jp","onagawa.miyagi.jp","osaki.miyagi.jp","rifu.miyagi.jp","semine.miyagi.jp","shibata.miyagi.jp","shichikashuku.miyagi.jp","shikama.miyagi.jp","shiogama.miyagi.jp","shiroishi.miyagi.jp","tagajo.miyagi.jp","taiwa.miyagi.jp","tome.miyagi.jp","tomiya.miyagi.jp","wakuya.miyagi.jp","watari.miyagi.jp","yamamoto.miyagi.jp","zao.miyagi.jp","aya.miyazaki.jp","ebino.miyazaki.jp","gokase.miyazaki.jp","hyuga.miyazaki.jp","kadogawa.miyazaki.jp","kawaminami.miyazaki.jp","kijo.miyazaki.jp","kitagawa.miyazaki.jp","kitakata.miyazaki.jp","kitaura.miyazaki.jp","kobayashi.miyazaki.jp","kunitomi.miyazaki.jp","kushima.miyazaki.jp","mimata.miyazaki.jp","miyakonojo.miyazaki.jp","miyazaki.miyazaki.jp","morotsuka.miyazaki.jp","nichinan.miyazaki.jp","nishimera.miyazaki.jp","nobeoka.miyazaki.jp","saito.miyazaki.jp","shiiba.miyazaki.jp","shintomi.miyazaki.jp","takaharu.miyazaki.jp","takanabe.miyazaki.jp","takazaki.miyazaki.jp","tsuno.miyazaki.jp","achi.nagano.jp","agematsu.nagano.jp","anan.nagano.jp","aoki.nagano.jp","asahi.nagano.jp","azumino.nagano.jp","chikuhoku.nagano.jp","chikuma.nagano.jp","chino.nagano.jp","fujimi.nagano.jp","hakuba.nagano.jp","hara.nagano.jp","hiraya.nagano.jp","iida.nagano.jp","iijima.nagano.jp","iiyama.nagano.jp","iizuna.nagano.jp","ikeda.nagano.jp","ikusaka.nagano.jp","ina.nagano.jp","karuizawa.nagano.jp","kawakami.nagano.jp","kiso.nagano.jp","kisofukushima.nagano.jp","kitaaiki.nagano.jp","komagane.nagano.jp","komoro.nagano.jp","matsukawa.nagano.jp","matsumoto.nagano.jp","miasa.nagano.jp","minamiaiki.nagano.jp","minamimaki.nagano.jp","minamiminowa.nagano.jp","minowa.nagano.jp","miyada.nagano.jp","miyota.nagano.jp","mochizuki.nagano.jp","nagano.nagano.jp","nagawa.nagano.jp","nagiso.nagano.jp","nakagawa.nagano.jp","nakano.nagano.jp","nozawaonsen.nagano.jp","obuse.nagano.jp","ogawa.nagano.jp","okaya.nagano.jp","omachi.nagano.jp","omi.nagano.jp","ookuwa.nagano.jp","ooshika.nagano.jp","otaki.nagano.jp","otari.nagano.jp","sakae.nagano.jp","sakaki.nagano.jp","saku.nagano.jp","sakuho.nagano.jp","shimosuwa.nagano.jp","shinanomachi.nagano.jp","shiojiri.nagano.jp","suwa.nagano.jp","suzaka.nagano.jp","takagi.nagano.jp","takamori.nagano.jp","takayama.nagano.jp","tateshina.nagano.jp","tatsuno.nagano.jp","togakushi.nagano.jp","togura.nagano.jp","tomi.nagano.jp","ueda.nagano.jp","wada.nagano.jp","yamagata.nagano.jp","yamanouchi.nagano.jp","yasaka.nagano.jp","yasuoka.nagano.jp","chijiwa.nagasaki.jp","futsu.nagasaki.jp","goto.nagasaki.jp","hasami.nagasaki.jp","hirado.nagasaki.jp","iki.nagasaki.jp","isahaya.nagasaki.jp","kawatana.nagasaki.jp","kuchinotsu.nagasaki.jp","matsuura.nagasaki.jp","nagasaki.nagasaki.jp","obama.nagasaki.jp","omura.nagasaki.jp","oseto.nagasaki.jp","saikai.nagasaki.jp","sasebo.nagasaki.jp","seihi.nagasaki.jp","shimabara.nagasaki.jp","shinkamigoto.nagasaki.jp","togitsu.nagasaki.jp","tsushima.nagasaki.jp","unzen.nagasaki.jp","ando.nara.jp","gose.nara.jp","heguri.nara.jp","higashiyoshino.nara.jp","ikaruga.nara.jp","ikoma.nara.jp","kamikitayama.nara.jp","kanmaki.nara.jp","kashiba.nara.jp","kashihara.nara.jp","katsuragi.nara.jp","kawai.nara.jp","kawakami.nara.jp","kawanishi.nara.jp","koryo.nara.jp","kurotaki.nara.jp","mitsue.nara.jp","miyake.nara.jp","nara.nara.jp","nosegawa.nara.jp","oji.nara.jp","ouda.nara.jp","oyodo.nara.jp","sakurai.nara.jp","sango.nara.jp","shimoichi.nara.jp","shimokitayama.nara.jp","shinjo.nara.jp","soni.nara.jp","takatori.nara.jp","tawaramoto.nara.jp","tenkawa.nara.jp","tenri.nara.jp","uda.nara.jp","yamatokoriyama.nara.jp","yamatotakada.nara.jp","yamazoe.nara.jp","yoshino.nara.jp","aga.niigata.jp","agano.niigata.jp","gosen.niigata.jp","itoigawa.niigata.jp","izumozaki.niigata.jp","joetsu.niigata.jp","kamo.niigata.jp","kariwa.niigata.jp","kashiwazaki.niigata.jp","minamiuonuma.niigata.jp","mitsuke.niigata.jp","muika.niigata.jp","murakami.niigata.jp","myoko.niigata.jp","nagaoka.niigata.jp","niigata.niigata.jp","ojiya.niigata.jp","omi.niigata.jp","sado.niigata.jp","sanjo.niigata.jp","seiro.niigata.jp","seirou.niigata.jp","sekikawa.niigata.jp","shibata.niigata.jp","tagami.niigata.jp","tainai.niigata.jp","tochio.niigata.jp","tokamachi.niigata.jp","tsubame.niigata.jp","tsunan.niigata.jp","uonuma.niigata.jp","yahiko.niigata.jp","yoita.niigata.jp","yuzawa.niigata.jp","beppu.oita.jp","bungoono.oita.jp","bungotakada.oita.jp","hasama.oita.jp","hiji.oita.jp","himeshima.oita.jp","hita.oita.jp","kamitsue.oita.jp","kokonoe.oita.jp","kuju.oita.jp","kunisaki.oita.jp","kusu.oita.jp","oita.oita.jp","saiki.oita.jp","taketa.oita.jp","tsukumi.oita.jp","usa.oita.jp","usuki.oita.jp","yufu.oita.jp","akaiwa.okayama.jp","asakuchi.okayama.jp","bizen.okayama.jp","hayashima.okayama.jp","ibara.okayama.jp","kagamino.okayama.jp","kasaoka.okayama.jp","kibichuo.okayama.jp","kumenan.okayama.jp","kurashiki.okayama.jp","maniwa.okayama.jp","misaki.okayama.jp","nagi.okayama.jp","niimi.okayama.jp","nishiawakura.okayama.jp","okayama.okayama.jp","satosho.okayama.jp","setouchi.okayama.jp","shinjo.okayama.jp","shoo.okayama.jp","soja.okayama.jp","takahashi.okayama.jp","tamano.okayama.jp","tsuyama.okayama.jp","wake.okayama.jp","yakage.okayama.jp","aguni.okinawa.jp","ginowan.okinawa.jp","ginoza.okinawa.jp","gushikami.okinawa.jp","haebaru.okinawa.jp","higashi.okinawa.jp","hirara.okinawa.jp","iheya.okinawa.jp","ishigaki.okinawa.jp","ishikawa.okinawa.jp","itoman.okinawa.jp","izena.okinawa.jp","kadena.okinawa.jp","kin.okinawa.jp","kitadaito.okinawa.jp","kitanakagusuku.okinawa.jp","kumejima.okinawa.jp","kunigami.okinawa.jp","minamidaito.okinawa.jp","motobu.okinawa.jp","nago.okinawa.jp","naha.okinawa.jp","nakagusuku.okinawa.jp","nakijin.okinawa.jp","nanjo.okinawa.jp","nishihara.okinawa.jp","ogimi.okinawa.jp","okinawa.okinawa.jp","onna.okinawa.jp","shimoji.okinawa.jp","taketomi.okinawa.jp","tarama.okinawa.jp","tokashiki.okinawa.jp","tomigusuku.okinawa.jp","tonaki.okinawa.jp","urasoe.okinawa.jp","uruma.okinawa.jp","yaese.okinawa.jp","yomitan.okinawa.jp","yonabaru.okinawa.jp","yonaguni.okinawa.jp","zamami.okinawa.jp","abeno.osaka.jp","chihayaakasaka.osaka.jp","chuo.osaka.jp","daito.osaka.jp","fujiidera.osaka.jp","habikino.osaka.jp","hannan.osaka.jp","higashiosaka.osaka.jp","higashisumiyoshi.osaka.jp","higashiyodogawa.osaka.jp","hirakata.osaka.jp","ibaraki.osaka.jp","ikeda.osaka.jp","izumi.osaka.jp","izumiotsu.osaka.jp","izumisano.osaka.jp","kadoma.osaka.jp","kaizuka.osaka.jp","kanan.osaka.jp","kashiwara.osaka.jp","katano.osaka.jp","kawachinagano.osaka.jp","kishiwada.osaka.jp","kita.osaka.jp","kumatori.osaka.jp","matsubara.osaka.jp","minato.osaka.jp","minoh.osaka.jp","misaki.osaka.jp","moriguchi.osaka.jp","neyagawa.osaka.jp","nishi.osaka.jp","nose.osaka.jp","osakasayama.osaka.jp","sakai.osaka.jp","sayama.osaka.jp","sennan.osaka.jp","settsu.osaka.jp","shijonawate.osaka.jp","shimamoto.osaka.jp","suita.osaka.jp","tadaoka.osaka.jp","taishi.osaka.jp","tajiri.osaka.jp","takaishi.osaka.jp","takatsuki.osaka.jp","tondabayashi.osaka.jp","toyonaka.osaka.jp","toyono.osaka.jp","yao.osaka.jp","ariake.saga.jp","arita.saga.jp","fukudomi.saga.jp","genkai.saga.jp","hamatama.saga.jp","hizen.saga.jp","imari.saga.jp","kamimine.saga.jp","kanzaki.saga.jp","karatsu.saga.jp","kashima.saga.jp","kitagata.saga.jp","kitahata.saga.jp","kiyama.saga.jp","kouhoku.saga.jp","kyuragi.saga.jp","nishiarita.saga.jp","ogi.saga.jp","omachi.saga.jp","ouchi.saga.jp","saga.saga.jp","shiroishi.saga.jp","taku.saga.jp","tara.saga.jp","tosu.saga.jp","yoshinogari.saga.jp","arakawa.saitama.jp","asaka.saitama.jp","chichibu.saitama.jp","fujimi.saitama.jp","fujimino.saitama.jp","fukaya.saitama.jp","hanno.saitama.jp","hanyu.saitama.jp","hasuda.saitama.jp","hatogaya.saitama.jp","hatoyama.saitama.jp","hidaka.saitama.jp","higashichichibu.saitama.jp","higashimatsuyama.saitama.jp","honjo.saitama.jp","ina.saitama.jp","iruma.saitama.jp","iwatsuki.saitama.jp","kamiizumi.saitama.jp","kamikawa.saitama.jp","kamisato.saitama.jp","kasukabe.saitama.jp","kawagoe.saitama.jp","kawaguchi.saitama.jp","kawajima.saitama.jp","kazo.saitama.jp","kitamoto.saitama.jp","koshigaya.saitama.jp","kounosu.saitama.jp","kuki.saitama.jp","kumagaya.saitama.jp","matsubushi.saitama.jp","minano.saitama.jp","misato.saitama.jp","miyashiro.saitama.jp","miyoshi.saitama.jp","moroyama.saitama.jp","nagatoro.saitama.jp","namegawa.saitama.jp","niiza.saitama.jp","ogano.saitama.jp","ogawa.saitama.jp","ogose.saitama.jp","okegawa.saitama.jp","omiya.saitama.jp","otaki.saitama.jp","ranzan.saitama.jp","ryokami.saitama.jp","saitama.saitama.jp","sakado.saitama.jp","satte.saitama.jp","sayama.saitama.jp","shiki.saitama.jp","shiraoka.saitama.jp","soka.saitama.jp","sugito.saitama.jp","toda.saitama.jp","tokigawa.saitama.jp","tokorozawa.saitama.jp","tsurugashima.saitama.jp","urawa.saitama.jp","warabi.saitama.jp","yashio.saitama.jp","yokoze.saitama.jp","yono.saitama.jp","yorii.saitama.jp","yoshida.saitama.jp","yoshikawa.saitama.jp","yoshimi.saitama.jp","aisho.shiga.jp","gamo.shiga.jp","higashiomi.shiga.jp","hikone.shiga.jp","koka.shiga.jp","konan.shiga.jp","kosei.shiga.jp","koto.shiga.jp","kusatsu.shiga.jp","maibara.shiga.jp","moriyama.shiga.jp","nagahama.shiga.jp","nishiazai.shiga.jp","notogawa.shiga.jp","omihachiman.shiga.jp","otsu.shiga.jp","ritto.shiga.jp","ryuoh.shiga.jp","takashima.shiga.jp","takatsuki.shiga.jp","torahime.shiga.jp","toyosato.shiga.jp","yasu.shiga.jp","akagi.shimane.jp","ama.shimane.jp","gotsu.shimane.jp","hamada.shimane.jp","higashiizumo.shimane.jp","hikawa.shimane.jp","hikimi.shimane.jp","izumo.shimane.jp","kakinoki.shimane.jp","masuda.shimane.jp","matsue.shimane.jp","misato.shimane.jp","nishinoshima.shimane.jp","ohda.shimane.jp","okinoshima.shimane.jp","okuizumo.shimane.jp","shimane.shimane.jp","tamayu.shimane.jp","tsuwano.shimane.jp","unnan.shimane.jp","yakumo.shimane.jp","yasugi.shimane.jp","yatsuka.shimane.jp","arai.shizuoka.jp","atami.shizuoka.jp","fuji.shizuoka.jp","fujieda.shizuoka.jp","fujikawa.shizuoka.jp","fujinomiya.shizuoka.jp","fukuroi.shizuoka.jp","gotemba.shizuoka.jp","haibara.shizuoka.jp","hamamatsu.shizuoka.jp","higashiizu.shizuoka.jp","ito.shizuoka.jp","iwata.shizuoka.jp","izu.shizuoka.jp","izunokuni.shizuoka.jp","kakegawa.shizuoka.jp","kannami.shizuoka.jp","kawanehon.shizuoka.jp","kawazu.shizuoka.jp","kikugawa.shizuoka.jp","kosai.shizuoka.jp","makinohara.shizuoka.jp","matsuzaki.shizuoka.jp","minamiizu.shizuoka.jp","mishima.shizuoka.jp","morimachi.shizuoka.jp","nishiizu.shizuoka.jp","numazu.shizuoka.jp","omaezaki.shizuoka.jp","shimada.shizuoka.jp","shimizu.shizuoka.jp","shimoda.shizuoka.jp","shizuoka.shizuoka.jp","susono.shizuoka.jp","yaizu.shizuoka.jp","yoshida.shizuoka.jp","ashikaga.tochigi.jp","bato.tochigi.jp","haga.tochigi.jp","ichikai.tochigi.jp","iwafune.tochigi.jp","kaminokawa.tochigi.jp","kanuma.tochigi.jp","karasuyama.tochigi.jp","kuroiso.tochigi.jp","mashiko.tochigi.jp","mibu.tochigi.jp","moka.tochigi.jp","motegi.tochigi.jp","nasu.tochigi.jp","nasushiobara.tochigi.jp","nikko.tochigi.jp","nishikata.tochigi.jp","nogi.tochigi.jp","ohira.tochigi.jp","ohtawara.tochigi.jp","oyama.tochigi.jp","sakura.tochigi.jp","sano.tochigi.jp","shimotsuke.tochigi.jp","shioya.tochigi.jp","takanezawa.tochigi.jp","tochigi.tochigi.jp","tsuga.tochigi.jp","ujiie.tochigi.jp","utsunomiya.tochigi.jp","yaita.tochigi.jp","aizumi.tokushima.jp","anan.tokushima.jp","ichiba.tokushima.jp","itano.tokushima.jp","kainan.tokushima.jp","komatsushima.tokushima.jp","matsushige.tokushima.jp","mima.tokushima.jp","minami.tokushima.jp","miyoshi.tokushima.jp","mugi.tokushima.jp","nakagawa.tokushima.jp","naruto.tokushima.jp","sanagochi.tokushima.jp","shishikui.tokushima.jp","tokushima.tokushima.jp","wajiki.tokushima.jp","adachi.tokyo.jp","akiruno.tokyo.jp","akishima.tokyo.jp","aogashima.tokyo.jp","arakawa.tokyo.jp","bunkyo.tokyo.jp","chiyoda.tokyo.jp","chofu.tokyo.jp","chuo.tokyo.jp","edogawa.tokyo.jp","fuchu.tokyo.jp","fussa.tokyo.jp","hachijo.tokyo.jp","hachioji.tokyo.jp","hamura.tokyo.jp","higashikurume.tokyo.jp","higashimurayama.tokyo.jp","higashiyamato.tokyo.jp","hino.tokyo.jp","hinode.tokyo.jp","hinohara.tokyo.jp","inagi.tokyo.jp","itabashi.tokyo.jp","katsushika.tokyo.jp","kita.tokyo.jp","kiyose.tokyo.jp","kodaira.tokyo.jp","koganei.tokyo.jp","kokubunji.tokyo.jp","komae.tokyo.jp","koto.tokyo.jp","kouzushima.tokyo.jp","kunitachi.tokyo.jp","machida.tokyo.jp","meguro.tokyo.jp","minato.tokyo.jp","mitaka.tokyo.jp","mizuho.tokyo.jp","musashimurayama.tokyo.jp","musashino.tokyo.jp","nakano.tokyo.jp","nerima.tokyo.jp","ogasawara.tokyo.jp","okutama.tokyo.jp","ome.tokyo.jp","oshima.tokyo.jp","ota.tokyo.jp","setagaya.tokyo.jp","shibuya.tokyo.jp","shinagawa.tokyo.jp","shinjuku.tokyo.jp","suginami.tokyo.jp","sumida.tokyo.jp","tachikawa.tokyo.jp","taito.tokyo.jp","tama.tokyo.jp","toshima.tokyo.jp","chizu.tottori.jp","hino.tottori.jp","kawahara.tottori.jp","koge.tottori.jp","kotoura.tottori.jp","misasa.tottori.jp","nanbu.tottori.jp","nichinan.tottori.jp","sakaiminato.tottori.jp","tottori.tottori.jp","wakasa.tottori.jp","yazu.tottori.jp","yonago.tottori.jp","asahi.toyama.jp","fuchu.toyama.jp","fukumitsu.toyama.jp","funahashi.toyama.jp","himi.toyama.jp","imizu.toyama.jp","inami.toyama.jp","johana.toyama.jp","kamiichi.toyama.jp","kurobe.toyama.jp","nakaniikawa.toyama.jp","namerikawa.toyama.jp","nanto.toyama.jp","nyuzen.toyama.jp","oyabe.toyama.jp","taira.toyama.jp","takaoka.toyama.jp","tateyama.toyama.jp","toga.toyama.jp","tonami.toyama.jp","toyama.toyama.jp","unazuki.toyama.jp","uozu.toyama.jp","yamada.toyama.jp","arida.wakayama.jp","aridagawa.wakayama.jp","gobo.wakayama.jp","hashimoto.wakayama.jp","hidaka.wakayama.jp","hirogawa.wakayama.jp","inami.wakayama.jp","iwade.wakayama.jp","kainan.wakayama.jp","kamitonda.wakayama.jp","katsuragi.wakayama.jp","kimino.wakayama.jp","kinokawa.wakayama.jp","kitayama.wakayama.jp","koya.wakayama.jp","koza.wakayama.jp","kozagawa.wakayama.jp","kudoyama.wakayama.jp","kushimoto.wakayama.jp","mihama.wakayama.jp","misato.wakayama.jp","nachikatsuura.wakayama.jp","shingu.wakayama.jp","shirahama.wakayama.jp","taiji.wakayama.jp","tanabe.wakayama.jp","wakayama.wakayama.jp","yuasa.wakayama.jp","yura.wakayama.jp","asahi.yamagata.jp","funagata.yamagata.jp","higashine.yamagata.jp","iide.yamagata.jp","kahoku.yamagata.jp","kaminoyama.yamagata.jp","kaneyama.yamagata.jp","kawanishi.yamagata.jp","mamurogawa.yamagata.jp","mikawa.yamagata.jp","murayama.yamagata.jp","nagai.yamagata.jp","nakayama.yamagata.jp","nanyo.yamagata.jp","nishikawa.yamagata.jp","obanazawa.yamagata.jp","oe.yamagata.jp","oguni.yamagata.jp","ohkura.yamagata.jp","oishida.yamagata.jp","sagae.yamagata.jp","sakata.yamagata.jp","sakegawa.yamagata.jp","shinjo.yamagata.jp","shirataka.yamagata.jp","shonai.yamagata.jp","takahata.yamagata.jp","tendo.yamagata.jp","tozawa.yamagata.jp","tsuruoka.yamagata.jp","yamagata.yamagata.jp","yamanobe.yamagata.jp","yonezawa.yamagata.jp","yuza.yamagata.jp","abu.yamaguchi.jp","hagi.yamaguchi.jp","hikari.yamaguchi.jp","hofu.yamaguchi.jp","iwakuni.yamaguchi.jp","kudamatsu.yamaguchi.jp","mitou.yamaguchi.jp","nagato.yamaguchi.jp","oshima.yamaguchi.jp","shimonoseki.yamaguchi.jp","shunan.yamaguchi.jp","tabuse.yamaguchi.jp","tokuyama.yamaguchi.jp","toyota.yamaguchi.jp","ube.yamaguchi.jp","yuu.yamaguchi.jp","chuo.yamanashi.jp","doshi.yamanashi.jp","fuefuki.yamanashi.jp","fujikawa.yamanashi.jp","fujikawaguchiko.yamanashi.jp","fujiyoshida.yamanashi.jp","hayakawa.yamanashi.jp","hokuto.yamanashi.jp","ichikawamisato.yamanashi.jp","kai.yamanashi.jp","kofu.yamanashi.jp","koshu.yamanashi.jp","kosuge.yamanashi.jp","minami-alps.yamanashi.jp","minobu.yamanashi.jp","nakamichi.yamanashi.jp","nanbu.yamanashi.jp","narusawa.yamanashi.jp","nirasaki.yamanashi.jp","nishikatsura.yamanashi.jp","oshino.yamanashi.jp","otsuki.yamanashi.jp","showa.yamanashi.jp","tabayama.yamanashi.jp","tsuru.yamanashi.jp","uenohara.yamanashi.jp","yamanakako.yamanashi.jp","yamanashi.yamanashi.jp","ke","ac.ke","co.ke","go.ke","info.ke","me.ke","mobi.ke","ne.ke","or.ke","sc.ke","kg","org.kg","net.kg","com.kg","edu.kg","gov.kg","mil.kg","*.kh","ki","edu.ki","biz.ki","net.ki","org.ki","gov.ki","info.ki","com.ki","km","org.km","nom.km","gov.km","prd.km","tm.km","edu.km","mil.km","ass.km","com.km","coop.km","asso.km","presse.km","medecin.km","notaires.km","pharmaciens.km","veterinaire.km","gouv.km","kn","net.kn","org.kn","edu.kn","gov.kn","kp","com.kp","edu.kp","gov.kp","org.kp","rep.kp","tra.kp","kr","ac.kr","co.kr","es.kr","go.kr","hs.kr","kg.kr","mil.kr","ms.kr","ne.kr","or.kr","pe.kr","re.kr","sc.kr","busan.kr","chungbuk.kr","chungnam.kr","daegu.kr","daejeon.kr","gangwon.kr","gwangju.kr","gyeongbuk.kr","gyeonggi.kr","gyeongnam.kr","incheon.kr","jeju.kr","jeonbuk.kr","jeonnam.kr","seoul.kr","ulsan.kr","kw","com.kw","edu.kw","emb.kw","gov.kw","ind.kw","net.kw","org.kw","ky","com.ky","edu.ky","net.ky","org.ky","kz","org.kz","edu.kz","net.kz","gov.kz","mil.kz","com.kz","la","int.la","net.la","info.la","edu.la","gov.la","per.la","com.la","org.la","lb","com.lb","edu.lb","gov.lb","net.lb","org.lb","lc","com.lc","net.lc","co.lc","org.lc","edu.lc","gov.lc","li","lk","gov.lk","sch.lk","net.lk","int.lk","com.lk","org.lk","edu.lk","ngo.lk","soc.lk","web.lk","ltd.lk","assn.lk","grp.lk","hotel.lk","ac.lk","lr","com.lr","edu.lr","gov.lr","org.lr","net.lr","ls","ac.ls","biz.ls","co.ls","edu.ls","gov.ls","info.ls","net.ls","org.ls","sc.ls","lt","gov.lt","lu","lv","com.lv","edu.lv","gov.lv","org.lv","mil.lv","id.lv","net.lv","asn.lv","conf.lv","ly","com.ly","net.ly","gov.ly","plc.ly","edu.ly","sch.ly","med.ly","org.ly","id.ly","ma","co.ma","net.ma","gov.ma","org.ma","ac.ma","press.ma","mc","tm.mc","asso.mc","md","me","co.me","net.me","org.me","edu.me","ac.me","gov.me","its.me","priv.me","mg","co.mg","com.mg","edu.mg","gov.mg","mil.mg","nom.mg","org.mg","prd.mg","mh","mil","mk","com.mk","org.mk","net.mk","edu.mk","gov.mk","inf.mk","name.mk","ml","com.ml","edu.ml","gouv.ml","gov.ml","net.ml","org.ml","presse.ml","*.mm","mn","gov.mn","edu.mn","org.mn","mo","com.mo","net.mo","org.mo","edu.mo","gov.mo","mobi","mp","mq","mr","gov.mr","ms","com.ms","edu.ms","gov.ms","net.ms","org.ms","mt","com.mt","edu.mt","net.mt","org.mt","mu","com.mu","net.mu","org.mu","gov.mu","ac.mu","co.mu","or.mu","museum","mv","aero.mv","biz.mv","com.mv","coop.mv","edu.mv","gov.mv","info.mv","int.mv","mil.mv","museum.mv","name.mv","net.mv","org.mv","pro.mv","mw","ac.mw","biz.mw","co.mw","com.mw","coop.mw","edu.mw","gov.mw","int.mw","net.mw","org.mw","mx","com.mx","org.mx","gob.mx","edu.mx","net.mx","my","biz.my","com.my","edu.my","gov.my","mil.my","name.my","net.my","org.my","mz","ac.mz","adv.mz","co.mz","edu.mz","gov.mz","mil.mz","net.mz","org.mz","na","alt.na","co.na","com.na","gov.na","net.na","org.na","name","nc","asso.nc","nom.nc","ne","net","nf","com.nf","net.nf","per.nf","rec.nf","web.nf","arts.nf","firm.nf","info.nf","other.nf","store.nf","ng","com.ng","edu.ng","gov.ng","i.ng","mil.ng","mobi.ng","name.ng","net.ng","org.ng","sch.ng","ni","ac.ni","biz.ni","co.ni","com.ni","edu.ni","gob.ni","in.ni","info.ni","int.ni","mil.ni","net.ni","nom.ni","org.ni","web.ni","nl","no","fhs.no","vgs.no","fylkesbibl.no","folkebibl.no","museum.no","idrett.no","priv.no","mil.no","stat.no","dep.no","kommune.no","herad.no","aa.no","ah.no","bu.no","fm.no","hl.no","hm.no","jan-mayen.no","mr.no","nl.no","nt.no","of.no","ol.no","oslo.no","rl.no","sf.no","st.no","svalbard.no","tm.no","tr.no","va.no","vf.no","gs.aa.no","gs.ah.no","gs.bu.no","gs.fm.no","gs.hl.no","gs.hm.no","gs.jan-mayen.no","gs.mr.no","gs.nl.no","gs.nt.no","gs.of.no","gs.ol.no","gs.oslo.no","gs.rl.no","gs.sf.no","gs.st.no","gs.svalbard.no","gs.tm.no","gs.tr.no","gs.va.no","gs.vf.no","akrehamn.no","åkrehamn.no","algard.no","ålgård.no","arna.no","brumunddal.no","bryne.no","bronnoysund.no","brønnøysund.no","drobak.no","drøbak.no","egersund.no","fetsund.no","floro.no","florø.no","fredrikstad.no","hokksund.no","honefoss.no","hønefoss.no","jessheim.no","jorpeland.no","jørpeland.no","kirkenes.no","kopervik.no","krokstadelva.no","langevag.no","langevåg.no","leirvik.no","mjondalen.no","mjøndalen.no","mo-i-rana.no","mosjoen.no","mosjøen.no","nesoddtangen.no","orkanger.no","osoyro.no","osøyro.no","raholt.no","råholt.no","sandnessjoen.no","sandnessjøen.no","skedsmokorset.no","slattum.no","spjelkavik.no","stathelle.no","stavern.no","stjordalshalsen.no","stjørdalshalsen.no","tananger.no","tranby.no","vossevangen.no","afjord.no","åfjord.no","agdenes.no","al.no","ål.no","alesund.no","ålesund.no","alstahaug.no","alta.no","áltá.no","alaheadju.no","álaheadju.no","alvdal.no","amli.no","åmli.no","amot.no","åmot.no","andebu.no","andoy.no","andøy.no","andasuolo.no","ardal.no","årdal.no","aremark.no","arendal.no","ås.no","aseral.no","åseral.no","asker.no","askim.no","askvoll.no","askoy.no","askøy.no","asnes.no","åsnes.no","audnedaln.no","aukra.no","aure.no","aurland.no","aurskog-holand.no","aurskog-høland.no","austevoll.no","austrheim.no","averoy.no","averøy.no","balestrand.no","ballangen.no","balat.no","bálát.no","balsfjord.no","bahccavuotna.no","báhccavuotna.no","bamble.no","bardu.no","beardu.no","beiarn.no","bajddar.no","bájddar.no","baidar.no","báidár.no","berg.no","bergen.no","berlevag.no","berlevåg.no","bearalvahki.no","bearalváhki.no","bindal.no","birkenes.no","bjarkoy.no","bjarkøy.no","bjerkreim.no","bjugn.no","bodo.no","bodø.no","badaddja.no","bådåddjå.no","budejju.no","bokn.no","bremanger.no","bronnoy.no","brønnøy.no","bygland.no","bykle.no","barum.no","bærum.no","bo.telemark.no","bø.telemark.no","bo.nordland.no","bø.nordland.no","bievat.no","bievát.no","bomlo.no","bømlo.no","batsfjord.no","båtsfjord.no","bahcavuotna.no","báhcavuotna.no","dovre.no","drammen.no","drangedal.no","dyroy.no","dyrøy.no","donna.no","dønna.no","eid.no","eidfjord.no","eidsberg.no","eidskog.no","eidsvoll.no","eigersund.no","elverum.no","enebakk.no","engerdal.no","etne.no","etnedal.no","evenes.no","evenassi.no","evenášši.no","evje-og-hornnes.no","farsund.no","fauske.no","fuossko.no","fuoisku.no","fedje.no","fet.no","finnoy.no","finnøy.no","fitjar.no","fjaler.no","fjell.no","flakstad.no","flatanger.no","flekkefjord.no","flesberg.no","flora.no","fla.no","flå.no","folldal.no","forsand.no","fosnes.no","frei.no","frogn.no","froland.no","frosta.no","frana.no","fræna.no","froya.no","frøya.no","fusa.no","fyresdal.no","forde.no","førde.no","gamvik.no","gangaviika.no","gáŋgaviika.no","gaular.no","gausdal.no","gildeskal.no","gildeskål.no","giske.no","gjemnes.no","gjerdrum.no","gjerstad.no","gjesdal.no","gjovik.no","gjøvik.no","gloppen.no","gol.no","gran.no","grane.no","granvin.no","gratangen.no","grimstad.no","grong.no","kraanghke.no","kråanghke.no","grue.no","gulen.no","hadsel.no","halden.no","halsa.no","hamar.no","hamaroy.no","habmer.no","hábmer.no","hapmir.no","hápmir.no","hammerfest.no","hammarfeasta.no","hámmárfeasta.no","haram.no","hareid.no","harstad.no","hasvik.no","aknoluokta.no","ákŋoluokta.no","hattfjelldal.no","aarborte.no","haugesund.no","hemne.no","hemnes.no","hemsedal.no","heroy.more-og-romsdal.no","herøy.møre-og-romsdal.no","heroy.nordland.no","herøy.nordland.no","hitra.no","hjartdal.no","hjelmeland.no","hobol.no","hobøl.no","hof.no","hol.no","hole.no","holmestrand.no","holtalen.no","holtålen.no","hornindal.no","horten.no","hurdal.no","hurum.no","hvaler.no","hyllestad.no","hagebostad.no","hægebostad.no","hoyanger.no","høyanger.no","hoylandet.no","høylandet.no","ha.no","hå.no","ibestad.no","inderoy.no","inderøy.no","iveland.no","jevnaker.no","jondal.no","jolster.no","jølster.no","karasjok.no","karasjohka.no","kárášjohka.no","karlsoy.no","galsa.no","gálsá.no","karmoy.no","karmøy.no","kautokeino.no","guovdageaidnu.no","klepp.no","klabu.no","klæbu.no","kongsberg.no","kongsvinger.no","kragero.no","kragerø.no","kristiansand.no","kristiansund.no","krodsherad.no","krødsherad.no","kvalsund.no","rahkkeravju.no","ráhkkerávju.no","kvam.no","kvinesdal.no","kvinnherad.no","kviteseid.no","kvitsoy.no","kvitsøy.no","kvafjord.no","kvæfjord.no","giehtavuoatna.no","kvanangen.no","kvænangen.no","navuotna.no","návuotna.no","kafjord.no","kåfjord.no","gaivuotna.no","gáivuotna.no","larvik.no","lavangen.no","lavagis.no","loabat.no","loabát.no","lebesby.no","davvesiida.no","leikanger.no","leirfjord.no","leka.no","leksvik.no","lenvik.no","leangaviika.no","leaŋgaviika.no","lesja.no","levanger.no","lier.no","lierne.no","lillehammer.no","lillesand.no","lindesnes.no","lindas.no","lindås.no","lom.no","loppa.no","lahppi.no","láhppi.no","lund.no","lunner.no","luroy.no","lurøy.no","luster.no","lyngdal.no","lyngen.no","ivgu.no","lardal.no","lerdal.no","lærdal.no","lodingen.no","lødingen.no","lorenskog.no","lørenskog.no","loten.no","løten.no","malvik.no","masoy.no","måsøy.no","muosat.no","muosát.no","mandal.no","marker.no","marnardal.no","masfjorden.no","meland.no","meldal.no","melhus.no","meloy.no","meløy.no","meraker.no","meråker.no","moareke.no","moåreke.no","midsund.no","midtre-gauldal.no","modalen.no","modum.no","molde.no","moskenes.no","moss.no","mosvik.no","malselv.no","målselv.no","malatvuopmi.no","málatvuopmi.no","namdalseid.no","aejrie.no","namsos.no","namsskogan.no","naamesjevuemie.no","nååmesjevuemie.no","laakesvuemie.no","nannestad.no","narvik.no","narviika.no","naustdal.no","nedre-eiker.no","nes.akershus.no","nes.buskerud.no","nesna.no","nesodden.no","nesseby.no","unjarga.no","unjárga.no","nesset.no","nissedal.no","nittedal.no","nord-aurdal.no","nord-fron.no","nord-odal.no","norddal.no","nordkapp.no","davvenjarga.no","davvenjárga.no","nordre-land.no","nordreisa.no","raisa.no","ráisa.no","nore-og-uvdal.no","notodden.no","naroy.no","nærøy.no","notteroy.no","nøtterøy.no","odda.no","oksnes.no","øksnes.no","oppdal.no","oppegard.no","oppegård.no","orkdal.no","orland.no","ørland.no","orskog.no","ørskog.no","orsta.no","ørsta.no","os.hedmark.no","os.hordaland.no","osen.no","osteroy.no","osterøy.no","ostre-toten.no","østre-toten.no","overhalla.no","ovre-eiker.no","øvre-eiker.no","oyer.no","øyer.no","oygarden.no","øygarden.no","oystre-slidre.no","øystre-slidre.no","porsanger.no","porsangu.no","porsáŋgu.no","porsgrunn.no","radoy.no","radøy.no","rakkestad.no","rana.no","ruovat.no","randaberg.no","rauma.no","rendalen.no","rennebu.no","rennesoy.no","rennesøy.no","rindal.no","ringebu.no","ringerike.no","ringsaker.no","rissa.no","risor.no","risør.no","roan.no","rollag.no","rygge.no","ralingen.no","rælingen.no","rodoy.no","rødøy.no","romskog.no","rømskog.no","roros.no","røros.no","rost.no","røst.no","royken.no","røyken.no","royrvik.no","røyrvik.no","rade.no","råde.no","salangen.no","siellak.no","saltdal.no","salat.no","sálát.no","sálat.no","samnanger.no","sande.more-og-romsdal.no","sande.møre-og-romsdal.no","sande.vestfold.no","sandefjord.no","sandnes.no","sandoy.no","sandøy.no","sarpsborg.no","sauda.no","sauherad.no","sel.no","selbu.no","selje.no","seljord.no","sigdal.no","siljan.no","sirdal.no","skaun.no","skedsmo.no","ski.no","skien.no","skiptvet.no","skjervoy.no","skjervøy.no","skierva.no","skiervá.no","skjak.no","skjåk.no","skodje.no","skanland.no","skånland.no","skanit.no","skánit.no","smola.no","smøla.no","snillfjord.no","snasa.no","snåsa.no","snoasa.no","snaase.no","snåase.no","sogndal.no","sokndal.no","sola.no","solund.no","songdalen.no","sortland.no","spydeberg.no","stange.no","stavanger.no","steigen.no","steinkjer.no","stjordal.no","stjørdal.no","stokke.no","stor-elvdal.no","stord.no","stordal.no","storfjord.no","omasvuotna.no","strand.no","stranda.no","stryn.no","sula.no","suldal.no","sund.no","sunndal.no","surnadal.no","sveio.no","svelvik.no","sykkylven.no","sogne.no","søgne.no","somna.no","sømna.no","sondre-land.no","søndre-land.no","sor-aurdal.no","sør-aurdal.no","sor-fron.no","sør-fron.no","sor-odal.no","sør-odal.no","sor-varanger.no","sør-varanger.no","matta-varjjat.no","mátta-várjjat.no","sorfold.no","sørfold.no","sorreisa.no","sørreisa.no","sorum.no","sørum.no","tana.no","deatnu.no","time.no","tingvoll.no","tinn.no","tjeldsund.no","dielddanuorri.no","tjome.no","tjøme.no","tokke.no","tolga.no","torsken.no","tranoy.no","tranøy.no","tromso.no","tromsø.no","tromsa.no","romsa.no","trondheim.no","troandin.no","trysil.no","trana.no","træna.no","trogstad.no","trøgstad.no","tvedestrand.no","tydal.no","tynset.no","tysfjord.no","divtasvuodna.no","divttasvuotna.no","tysnes.no","tysvar.no","tysvær.no","tonsberg.no","tønsberg.no","ullensaker.no","ullensvang.no","ulvik.no","utsira.no","vadso.no","vadsø.no","cahcesuolo.no","čáhcesuolo.no","vaksdal.no","valle.no","vang.no","vanylven.no","vardo.no","vardø.no","varggat.no","várggát.no","vefsn.no","vaapste.no","vega.no","vegarshei.no","vegårshei.no","vennesla.no","verdal.no","verran.no","vestby.no","vestnes.no","vestre-slidre.no","vestre-toten.no","vestvagoy.no","vestvågøy.no","vevelstad.no","vik.no","vikna.no","vindafjord.no","volda.no","voss.no","varoy.no","værøy.no","vagan.no","vågan.no","voagat.no","vagsoy.no","vågsøy.no","vaga.no","vågå.no","valer.ostfold.no","våler.østfold.no","valer.hedmark.no","våler.hedmark.no","*.np","nr","biz.nr","info.nr","gov.nr","edu.nr","org.nr","net.nr","com.nr","nu","nz","ac.nz","co.nz","cri.nz","geek.nz","gen.nz","govt.nz","health.nz","iwi.nz","kiwi.nz","maori.nz","mil.nz","māori.nz","net.nz","org.nz","parliament.nz","school.nz","om","co.om","com.om","edu.om","gov.om","med.om","museum.om","net.om","org.om","pro.om","onion","org","pa","ac.pa","gob.pa","com.pa","org.pa","sld.pa","edu.pa","net.pa","ing.pa","abo.pa","med.pa","nom.pa","pe","edu.pe","gob.pe","nom.pe","mil.pe","org.pe","com.pe","net.pe","pf","com.pf","org.pf","edu.pf","*.pg","ph","com.ph","net.ph","org.ph","gov.ph","edu.ph","ngo.ph","mil.ph","i.ph","pk","ac.pk","biz.pk","com.pk","edu.pk","fam.pk","gkp.pk","gob.pk","gog.pk","gok.pk","gon.pk","gop.pk","gos.pk","gov.pk","net.pk","org.pk","web.pk","pl","com.pl","net.pl","org.pl","agro.pl","aid.pl","atm.pl","auto.pl","biz.pl","edu.pl","gmina.pl","gsm.pl","info.pl","mail.pl","media.pl","miasta.pl","mil.pl","nieruchomosci.pl","nom.pl","pc.pl","powiat.pl","priv.pl","realestate.pl","rel.pl","sex.pl","shop.pl","sklep.pl","sos.pl","szkola.pl","targi.pl","tm.pl","tourism.pl","travel.pl","turystyka.pl","gov.pl","ap.gov.pl","griw.gov.pl","ic.gov.pl","is.gov.pl","kmpsp.gov.pl","konsulat.gov.pl","kppsp.gov.pl","kwp.gov.pl","kwpsp.gov.pl","mup.gov.pl","mw.gov.pl","oia.gov.pl","oirm.gov.pl","oke.gov.pl","oow.gov.pl","oschr.gov.pl","oum.gov.pl","pa.gov.pl","pinb.gov.pl","piw.gov.pl","po.gov.pl","pr.gov.pl","psp.gov.pl","psse.gov.pl","pup.gov.pl","rzgw.gov.pl","sa.gov.pl","sdn.gov.pl","sko.gov.pl","so.gov.pl","sr.gov.pl","starostwo.gov.pl","ug.gov.pl","ugim.gov.pl","um.gov.pl","umig.gov.pl","upow.gov.pl","uppo.gov.pl","us.gov.pl","uw.gov.pl","uzs.gov.pl","wif.gov.pl","wiih.gov.pl","winb.gov.pl","wios.gov.pl","witd.gov.pl","wiw.gov.pl","wkz.gov.pl","wsa.gov.pl","wskr.gov.pl","wsse.gov.pl","wuoz.gov.pl","wzmiuw.gov.pl","zp.gov.pl","zpisdn.gov.pl","augustow.pl","babia-gora.pl","bedzin.pl","beskidy.pl","bialowieza.pl","bialystok.pl","bielawa.pl","bieszczady.pl","boleslawiec.pl","bydgoszcz.pl","bytom.pl","cieszyn.pl","czeladz.pl","czest.pl","dlugoleka.pl","elblag.pl","elk.pl","glogow.pl","gniezno.pl","gorlice.pl","grajewo.pl","ilawa.pl","jaworzno.pl","jelenia-gora.pl","jgora.pl","kalisz.pl","karpacz.pl","kartuzy.pl","kaszuby.pl","katowice.pl","kazimierz-dolny.pl","kepno.pl","ketrzyn.pl","klodzko.pl","kobierzyce.pl","kolobrzeg.pl","konin.pl","konskowola.pl","kutno.pl","lapy.pl","lebork.pl","legnica.pl","lezajsk.pl","limanowa.pl","lomza.pl","lowicz.pl","lubin.pl","lukow.pl","malbork.pl","malopolska.pl","mazowsze.pl","mazury.pl","mielec.pl","mielno.pl","mragowo.pl","naklo.pl","nowaruda.pl","nysa.pl","olawa.pl","olecko.pl","olkusz.pl","olsztyn.pl","opoczno.pl","opole.pl","ostroda.pl","ostroleka.pl","ostrowiec.pl","ostrowwlkp.pl","pila.pl","pisz.pl","podhale.pl","podlasie.pl","polkowice.pl","pomorskie.pl","pomorze.pl","prochowice.pl","pruszkow.pl","przeworsk.pl","pulawy.pl","radom.pl","rawa-maz.pl","rybnik.pl","rzeszow.pl","sanok.pl","sejny.pl","skoczow.pl","slask.pl","slupsk.pl","sosnowiec.pl","stalowa-wola.pl","starachowice.pl","stargard.pl","suwalki.pl","swidnica.pl","swiebodzin.pl","swinoujscie.pl","szczecin.pl","szczytno.pl","tarnobrzeg.pl","tgory.pl","turek.pl","tychy.pl","ustka.pl","walbrzych.pl","warmia.pl","warszawa.pl","waw.pl","wegrow.pl","wielun.pl","wlocl.pl","wloclawek.pl","wodzislaw.pl","wolomin.pl","wroclaw.pl","zachpomor.pl","zagan.pl","zarow.pl","zgora.pl","zgorzelec.pl","pm","pn","gov.pn","co.pn","org.pn","edu.pn","net.pn","post","pr","com.pr","net.pr","org.pr","gov.pr","edu.pr","isla.pr","pro.pr","biz.pr","info.pr","name.pr","est.pr","prof.pr","ac.pr","pro","aaa.pro","aca.pro","acct.pro","avocat.pro","bar.pro","cpa.pro","eng.pro","jur.pro","law.pro","med.pro","recht.pro","ps","edu.ps","gov.ps","sec.ps","plo.ps","com.ps","org.ps","net.ps","pt","net.pt","gov.pt","org.pt","edu.pt","int.pt","publ.pt","com.pt","nome.pt","pw","co.pw","or.pw","ed.pw","go.pw","belau.pw","py","com.py","coop.py","edu.py","gov.py","mil.py","net.py","org.py","qa","com.qa","edu.qa","gov.qa","mil.qa","name.qa","net.qa","org.qa","sch.qa","re","asso.re","com.re","ro","arts.ro","com.ro","firm.ro","info.ro","nom.ro","nt.ro","org.ro","rec.ro","store.ro","tm.ro","www.ro","rs","ac.rs","co.rs","edu.rs","gov.rs","in.rs","org.rs","ru","rw","ac.rw","co.rw","coop.rw","gov.rw","mil.rw","net.rw","org.rw","sa","com.sa","net.sa","org.sa","gov.sa","med.sa","pub.sa","edu.sa","sch.sa","sb","com.sb","edu.sb","gov.sb","net.sb","org.sb","sc","com.sc","gov.sc","net.sc","org.sc","edu.sc","sd","com.sd","net.sd","org.sd","edu.sd","med.sd","tv.sd","gov.sd","info.sd","se","a.se","ac.se","b.se","bd.se","brand.se","c.se","d.se","e.se","f.se","fh.se","fhsk.se","fhv.se","g.se","h.se","i.se","k.se","komforb.se","kommunalforbund.se","komvux.se","l.se","lanbib.se","m.se","n.se","naturbruksgymn.se","o.se","org.se","p.se","parti.se","pp.se","press.se","r.se","s.se","t.se","tm.se","u.se","w.se","x.se","y.se","z.se","sg","com.sg","net.sg","org.sg","gov.sg","edu.sg","sh","com.sh","net.sh","gov.sh","org.sh","mil.sh","si","sj","sk","sl","com.sl","net.sl","edu.sl","gov.sl","org.sl","sm","sn","art.sn","com.sn","edu.sn","gouv.sn","org.sn","perso.sn","univ.sn","so","com.so","edu.so","gov.so","me.so","net.so","org.so","sr","ss","biz.ss","co.ss","com.ss","edu.ss","gov.ss","me.ss","net.ss","org.ss","sch.ss","st","co.st","com.st","consulado.st","edu.st","embaixada.st","mil.st","net.st","org.st","principe.st","saotome.st","store.st","su","sv","com.sv","edu.sv","gob.sv","org.sv","red.sv","sx","gov.sx","sy","edu.sy","gov.sy","net.sy","mil.sy","com.sy","org.sy","sz","co.sz","ac.sz","org.sz","tc","td","tel","tf","tg","th","ac.th","co.th","go.th","in.th","mi.th","net.th","or.th","tj","ac.tj","biz.tj","co.tj","com.tj","edu.tj","go.tj","gov.tj","int.tj","mil.tj","name.tj","net.tj","nic.tj","org.tj","test.tj","web.tj","tk","tl","gov.tl","tm","co.tm","com.tm","edu.tm","gov.tm","mil.tm","net.tm","nom.tm","org.tm","tn","com.tn","ens.tn","fin.tn","gov.tn","ind.tn","info.tn","intl.tn","mincom.tn","nat.tn","net.tn","org.tn","perso.tn","tourism.tn","to","com.to","gov.to","net.to","org.to","edu.to","mil.to","tr","av.tr","bbs.tr","bel.tr","biz.tr","com.tr","dr.tr","edu.tr","gen.tr","gov.tr","info.tr","mil.tr","k12.tr","kep.tr","name.tr","net.tr","org.tr","pol.tr","tel.tr","tsk.tr","tv.tr","web.tr","nc.tr","gov.nc.tr","tt","biz.tt","co.tt","com.tt","edu.tt","gov.tt","info.tt","mil.tt","name.tt","net.tt","org.tt","pro.tt","tv","tw","edu.tw","gov.tw","mil.tw","com.tw","net.tw","org.tw","idv.tw","game.tw","ebiz.tw","club.tw","網路.tw","組織.tw","商業.tw","tz","ac.tz","co.tz","go.tz","hotel.tz","info.tz","me.tz","mil.tz","mobi.tz","ne.tz","or.tz","sc.tz","tv.tz","ua","com.ua","edu.ua","gov.ua","in.ua","net.ua","org.ua","cherkassy.ua","cherkasy.ua","chernigov.ua","chernihiv.ua","chernivtsi.ua","chernovtsy.ua","ck.ua","cn.ua","cr.ua","crimea.ua","cv.ua","dn.ua","dnepropetrovsk.ua","dnipropetrovsk.ua","donetsk.ua","dp.ua","if.ua","ivano-frankivsk.ua","kh.ua","kharkiv.ua","kharkov.ua","kherson.ua","khmelnitskiy.ua","khmelnytskyi.ua","kiev.ua","kirovograd.ua","km.ua","kr.ua","kropyvnytskyi.ua","krym.ua","ks.ua","kv.ua","kyiv.ua","lg.ua","lt.ua","lugansk.ua","luhansk.ua","lutsk.ua","lv.ua","lviv.ua","mk.ua","mykolaiv.ua","nikolaev.ua","od.ua","odesa.ua","odessa.ua","pl.ua","poltava.ua","rivne.ua","rovno.ua","rv.ua","sb.ua","sebastopol.ua","sevastopol.ua","sm.ua","sumy.ua","te.ua","ternopil.ua","uz.ua","uzhgorod.ua","uzhhorod.ua","vinnica.ua","vinnytsia.ua","vn.ua","volyn.ua","yalta.ua","zakarpattia.ua","zaporizhzhe.ua","zaporizhzhia.ua","zhitomir.ua","zhytomyr.ua","zp.ua","zt.ua","ug","co.ug","or.ug","ac.ug","sc.ug","go.ug","ne.ug","com.ug","org.ug","uk","ac.uk","co.uk","gov.uk","ltd.uk","me.uk","net.uk","nhs.uk","org.uk","plc.uk","police.uk","*.sch.uk","us","dni.us","fed.us","isa.us","kids.us","nsn.us","ak.us","al.us","ar.us","as.us","az.us","ca.us","co.us","ct.us","dc.us","de.us","fl.us","ga.us","gu.us","hi.us","ia.us","id.us","il.us","in.us","ks.us","ky.us","la.us","ma.us","md.us","me.us","mi.us","mn.us","mo.us","ms.us","mt.us","nc.us","nd.us","ne.us","nh.us","nj.us","nm.us","nv.us","ny.us","oh.us","ok.us","or.us","pa.us","pr.us","ri.us","sc.us","sd.us","tn.us","tx.us","ut.us","vi.us","vt.us","va.us","wa.us","wi.us","wv.us","wy.us","k12.ak.us","k12.al.us","k12.ar.us","k12.as.us","k12.az.us","k12.ca.us","k12.co.us","k12.ct.us","k12.dc.us","k12.fl.us","k12.ga.us","k12.gu.us","k12.ia.us","k12.id.us","k12.il.us","k12.in.us","k12.ks.us","k12.ky.us","k12.la.us","k12.ma.us","k12.md.us","k12.me.us","k12.mi.us","k12.mn.us","k12.mo.us","k12.ms.us","k12.mt.us","k12.nc.us","k12.ne.us","k12.nh.us","k12.nj.us","k12.nm.us","k12.nv.us","k12.ny.us","k12.oh.us","k12.ok.us","k12.or.us","k12.pa.us","k12.pr.us","k12.sc.us","k12.tn.us","k12.tx.us","k12.ut.us","k12.vi.us","k12.vt.us","k12.va.us","k12.wa.us","k12.wi.us","k12.wy.us","cc.ak.us","cc.al.us","cc.ar.us","cc.as.us","cc.az.us","cc.ca.us","cc.co.us","cc.ct.us","cc.dc.us","cc.de.us","cc.fl.us","cc.ga.us","cc.gu.us","cc.hi.us","cc.ia.us","cc.id.us","cc.il.us","cc.in.us","cc.ks.us","cc.ky.us","cc.la.us","cc.ma.us","cc.md.us","cc.me.us","cc.mi.us","cc.mn.us","cc.mo.us","cc.ms.us","cc.mt.us","cc.nc.us","cc.nd.us","cc.ne.us","cc.nh.us","cc.nj.us","cc.nm.us","cc.nv.us","cc.ny.us","cc.oh.us","cc.ok.us","cc.or.us","cc.pa.us","cc.pr.us","cc.ri.us","cc.sc.us","cc.sd.us","cc.tn.us","cc.tx.us","cc.ut.us","cc.vi.us","cc.vt.us","cc.va.us","cc.wa.us","cc.wi.us","cc.wv.us","cc.wy.us","lib.ak.us","lib.al.us","lib.ar.us","lib.as.us","lib.az.us","lib.ca.us","lib.co.us","lib.ct.us","lib.dc.us","lib.fl.us","lib.ga.us","lib.gu.us","lib.hi.us","lib.ia.us","lib.id.us","lib.il.us","lib.in.us","lib.ks.us","lib.ky.us","lib.la.us","lib.ma.us","lib.md.us","lib.me.us","lib.mi.us","lib.mn.us","lib.mo.us","lib.ms.us","lib.mt.us","lib.nc.us","lib.nd.us","lib.ne.us","lib.nh.us","lib.nj.us","lib.nm.us","lib.nv.us","lib.ny.us","lib.oh.us","lib.ok.us","lib.or.us","lib.pa.us","lib.pr.us","lib.ri.us","lib.sc.us","lib.sd.us","lib.tn.us","lib.tx.us","lib.ut.us","lib.vi.us","lib.vt.us","lib.va.us","lib.wa.us","lib.wi.us","lib.wy.us","pvt.k12.ma.us","chtr.k12.ma.us","paroch.k12.ma.us","ann-arbor.mi.us","cog.mi.us","dst.mi.us","eaton.mi.us","gen.mi.us","mus.mi.us","tec.mi.us","washtenaw.mi.us","uy","com.uy","edu.uy","gub.uy","mil.uy","net.uy","org.uy","uz","co.uz","com.uz","net.uz","org.uz","va","vc","com.vc","net.vc","org.vc","gov.vc","mil.vc","edu.vc","ve","arts.ve","bib.ve","co.ve","com.ve","e12.ve","edu.ve","firm.ve","gob.ve","gov.ve","info.ve","int.ve","mil.ve","net.ve","nom.ve","org.ve","rar.ve","rec.ve","store.ve","tec.ve","web.ve","vg","vi","co.vi","com.vi","k12.vi","net.vi","org.vi","vn","ac.vn","ai.vn","biz.vn","com.vn","edu.vn","gov.vn","health.vn","id.vn","info.vn","int.vn","io.vn","name.vn","net.vn","org.vn","pro.vn","angiang.vn","bacgiang.vn","backan.vn","baclieu.vn","bacninh.vn","baria-vungtau.vn","bentre.vn","binhdinh.vn","binhduong.vn","binhphuoc.vn","binhthuan.vn","camau.vn","cantho.vn","caobang.vn","daklak.vn","daknong.vn","danang.vn","dienbien.vn","dongnai.vn","dongthap.vn","gialai.vn","hagiang.vn","haiduong.vn","haiphong.vn","hanam.vn","hanoi.vn","hatinh.vn","haugiang.vn","hoabinh.vn","hungyen.vn","khanhhoa.vn","kiengiang.vn","kontum.vn","laichau.vn","lamdong.vn","langson.vn","laocai.vn","longan.vn","namdinh.vn","nghean.vn","ninhbinh.vn","ninhthuan.vn","phutho.vn","phuyen.vn","quangbinh.vn","quangnam.vn","quangngai.vn","quangninh.vn","quangtri.vn","soctrang.vn","sonla.vn","tayninh.vn","thaibinh.vn","thainguyen.vn","thanhhoa.vn","thanhphohochiminh.vn","thuathienhue.vn","tiengiang.vn","travinh.vn","tuyenquang.vn","vinhlong.vn","vinhphuc.vn","yenbai.vn","vu","com.vu","edu.vu","net.vu","org.vu","wf","ws","com.ws","net.ws","org.ws","gov.ws","edu.ws","yt","امارات","հայ","বাংলা","бг","البحرين","бел","中国","中國","الجزائر","مصر","ею","ευ","موريتانيا","გე","ελ","香港","公司.香港","教育.香港","政府.香港","個人.香港","網絡.香港","組織.香港","ಭಾರತ","ଭାରତ","ভাৰত","भारतम्","भारोत","ڀارت","ഭാരതം","भारत","بارت","بھارت","భారత్","ભારત","ਭਾਰਤ","ভারত","இந்தியா","ایران","ايران","عراق","الاردن","한국","қаз","ລາວ","ලංකා","இலங்கை","المغرب","мкд","мон","澳門","澳门","مليسيا","عمان","پاکستان","پاكستان","فلسطين","срб","пр.срб","орг.срб","обр.срб","од.срб","упр.срб","ак.срб","рф","قطر","السعودية","السعودیة","السعودیۃ","السعوديه","سودان","新加坡","சிங்கப்பூர்","سورية","سوريا","ไทย","ศึกษา.ไทย","ธุรกิจ.ไทย","รัฐบาล.ไทย","ทหาร.ไทย","เน็ต.ไทย","องค์กร.ไทย","تونس","台灣","台湾","臺灣","укр","اليمن","xxx","ye","com.ye","edu.ye","gov.ye","net.ye","mil.ye","org.ye","ac.za","agric.za","alt.za","co.za","edu.za","gov.za","grondar.za","law.za","mil.za","net.za","ngo.za","nic.za","nis.za","nom.za","org.za","school.za","tm.za","web.za","zm","ac.zm","biz.zm","co.zm","com.zm","edu.zm","gov.zm","info.zm","mil.zm","net.zm","org.zm","sch.zm","zw","ac.zw","co.zw","gov.zw","mil.zw","org.zw","aaa","aarp","abb","abbott","abbvie","abc","able","abogado","abudhabi","academy","accenture","accountant","accountants","aco","actor","ads","adult","aeg","aetna","afl","africa","agakhan","agency","aig","airbus","airforce","airtel","akdn","alibaba","alipay","allfinanz","allstate","ally","alsace","alstom","amazon","americanexpress","americanfamily","amex","amfam","amica","amsterdam","analytics","android","anquan","anz","aol","apartments","app","apple","aquarelle","arab","aramco","archi","army","art","arte","asda","associates","athleta","attorney","auction","audi","audible","audio","auspost","author","auto","autos","aws","axa","azure","baby","baidu","banamex","band","bank","bar","barcelona","barclaycard","barclays","barefoot","bargains","baseball","basketball","bauhaus","bayern","bbc","bbt","bbva","bcg","bcn","beats","beauty","beer","bentley","berlin","best","bestbuy","bet","bharti","bible","bid","bike","bing","bingo","bio","black","blackfriday","blockbuster","blog","bloomberg","blue","bms","bmw","bnpparibas","boats","boehringer","bofa","bom","bond","boo","book","booking","bosch","bostik","boston","bot","boutique","box","bradesco","bridgestone","broadway","broker","brother","brussels","build","builders","business","buy","buzz","bzh","cab","cafe","cal","call","calvinklein","cam","camera","camp","canon","capetown","capital","capitalone","car","caravan","cards","care","career","careers","cars","casa","case","cash","casino","catering","catholic","cba","cbn","cbre","center","ceo","cern","cfa","cfd","chanel","channel","charity","chase","chat","cheap","chintai","christmas","chrome","church","cipriani","circle","cisco","citadel","citi","citic","city","claims","cleaning","click","clinic","clinique","clothing","cloud","club","clubmed","coach","codes","coffee","college","cologne","commbank","community","company","compare","computer","comsec","condos","construction","consulting","contact","contractors","cooking","cool","corsica","country","coupon","coupons","courses","cpa","credit","creditcard","creditunion","cricket","crown","crs","cruise","cruises","cuisinella","cymru","cyou","dad","dance","data","date","dating","datsun","day","dclk","dds","deal","dealer","deals","degree","delivery","dell","deloitte","delta","democrat","dental","dentist","desi","design","dev","dhl","diamonds","diet","digital","direct","directory","discount","discover","dish","diy","dnp","docs","doctor","dog","domains","dot","download","drive","dtv","dubai","dunlop","dupont","durban","dvag","dvr","earth","eat","eco","edeka","education","email","emerck","energy","engineer","engineering","enterprises","epson","equipment","ericsson","erni","esq","estate","eurovision","eus","events","exchange","expert","exposed","express","extraspace","fage","fail","fairwinds","faith","family","fan","fans","farm","farmers","fashion","fast","fedex","feedback","ferrari","ferrero","fidelity","fido","film","final","finance","financial","fire","firestone","firmdale","fish","fishing","fit","fitness","flickr","flights","flir","florist","flowers","fly","foo","food","football","ford","forex","forsale","forum","foundation","fox","free","fresenius","frl","frogans","frontier","ftr","fujitsu","fun","fund","furniture","futbol","fyi","gal","gallery","gallo","gallup","game","games","gap","garden","gay","gbiz","gdn","gea","gent","genting","george","ggee","gift","gifts","gives","giving","glass","gle","global","globo","gmail","gmbh","gmo","gmx","godaddy","gold","goldpoint","golf","goo","goodyear","goog","google","gop","got","grainger","graphics","gratis","green","gripe","grocery","group","gucci","guge","guide","guitars","guru","hair","hamburg","hangout","haus","hbo","hdfc","hdfcbank","health","healthcare","help","helsinki","here","hermes","hiphop","hisamitsu","hitachi","hiv","hkt","hockey","holdings","holiday","homedepot","homegoods","homes","homesense","honda","horse","hospital","host","hosting","hot","hotels","hotmail","house","how","hsbc","hughes","hyatt","hyundai","ibm","icbc","ice","icu","ieee","ifm","ikano","imamat","imdb","immo","immobilien","inc","industries","infiniti","ing","ink","institute","insurance","insure","international","intuit","investments","ipiranga","irish","ismaili","ist","istanbul","itau","itv","jaguar","java","jcb","jeep","jetzt","jewelry","jio","jll","jmp","jnj","joburg","jot","joy","jpmorgan","jprs","juegos","juniper","kaufen","kddi","kerryhotels","kerrylogistics","kerryproperties","kfh","kia","kids","kim","kindle","kitchen","kiwi","koeln","komatsu","kosher","kpmg","kpn","krd","kred","kuokgroup","kyoto","lacaixa","lamborghini","lamer","lancaster","land","landrover","lanxess","lasalle","lat","latino","latrobe","law","lawyer","lds","lease","leclerc","lefrak","legal","lego","lexus","lgbt","lidl","life","lifeinsurance","lifestyle","lighting","like","lilly","limited","limo","lincoln","link","lipsy","live","living","llc","llp","loan","loans","locker","locus","lol","london","lotte","lotto","love","lpl","lplfinancial","ltd","ltda","lundbeck","luxe","luxury","madrid","maif","maison","makeup","man","management","mango","map","market","marketing","markets","marriott","marshalls","mattel","mba","mckinsey","med","media","meet","melbourne","meme","memorial","men","menu","merck","merckmsd","miami","microsoft","mini","mint","mit","mitsubishi","mlb","mls","mma","mobile","moda","moe","moi","mom","monash","money","monster","mormon","mortgage","moscow","moto","motorcycles","mov","movie","msd","mtn","mtr","music","nab","nagoya","navy","nba","nec","netbank","netflix","network","neustar","new","news","next","nextdirect","nexus","nfl","ngo","nhk","nico","nike","nikon","ninja","nissan","nissay","nokia","norton","now","nowruz","nowtv","nra","nrw","ntt","nyc","obi","observer","office","okinawa","olayan","olayangroup","ollo","omega","one","ong","onl","online","ooo","open","oracle","orange","organic","origins","osaka","otsuka","ott","ovh","page","panasonic","paris","pars","partners","parts","party","pay","pccw","pet","pfizer","pharmacy","phd","philips","phone","photo","photography","photos","physio","pics","pictet","pictures","pid","pin","ping","pink","pioneer","pizza","place","play","playstation","plumbing","plus","pnc","pohl","poker","politie","porn","pramerica","praxi","press","prime","prod","productions","prof","progressive","promo","properties","property","protection","pru","prudential","pub","pwc","qpon","quebec","quest","racing","radio","read","realestate","realtor","realty","recipes","red","redstone","redumbrella","rehab","reise","reisen","reit","reliance","ren","rent","rentals","repair","report","republican","rest","restaurant","review","reviews","rexroth","rich","richardli","ricoh","ril","rio","rip","rocks","rodeo","rogers","room","rsvp","rugby","ruhr","run","rwe","ryukyu","saarland","safe","safety","sakura","sale","salon","samsclub","samsung","sandvik","sandvikcoromant","sanofi","sap","sarl","sas","save","saxo","sbi","sbs","scb","schaeffler","schmidt","scholarships","school","schule","schwarz","science","scot","search","seat","secure","security","seek","select","sener","services","seven","sew","sex","sexy","sfr","shangrila","sharp","shell","shia","shiksha","shoes","shop","shopping","shouji","show","silk","sina","singles","site","ski","skin","sky","skype","sling","smart","smile","sncf","soccer","social","softbank","software","sohu","solar","solutions","song","sony","soy","spa","space","sport","spot","srl","stada","staples","star","statebank","statefarm","stc","stcgroup","stockholm","storage","store","stream","studio","study","style","sucks","supplies","supply","support","surf","surgery","suzuki","swatch","swiss","sydney","systems","tab","taipei","talk","taobao","target","tatamotors","tatar","tattoo","tax","taxi","tci","tdk","team","tech","technology","temasek","tennis","teva","thd","theater","theatre","tiaa","tickets","tienda","tips","tires","tirol","tjmaxx","tjx","tkmaxx","tmall","today","tokyo","tools","top","toray","toshiba","total","tours","town","toyota","toys","trade","trading","training","travel","travelers","travelersinsurance","trust","trv","tube","tui","tunes","tushu","tvs","ubank","ubs","unicom","university","uno","uol","ups","vacations","vana","vanguard","vegas","ventures","verisign","versicherung","vet","viajes","video","vig","viking","villas","vin","vip","virgin","visa","vision","viva","vivo","vlaanderen","vodka","volvo","vote","voting","voto","voyage","wales","walmart","walter","wang","wanggou","watch","watches","weather","weatherchannel","webcam","weber","website","wed","wedding","weibo","weir","whoswho","wien","wiki","williamhill","win","windows","wine","winners","wme","wolterskluwer","woodside","work","works","world","wow","wtc","wtf","xbox","xerox","xihuan","xin","कॉम","セール","佛山","慈善","集团","在线","点看","คอม","八卦","موقع","公益","公司","香格里拉","网站","移动","我爱你","москва","католик","онлайн","сайт","联通","קום","时尚","微博","淡马锡","ファッション","орг","नेट","ストア","アマゾン","삼성","商标","商店","商城","дети","ポイント","新闻","家電","كوم","中文网","中信","娱乐","谷歌","電訊盈科","购物","クラウド","通販","网店","संगठन","餐厅","网络","ком","亚马逊","食品","飞利浦","手机","ارامكو","العليان","بازار","ابوظبي","كاثوليك","همراه","닷컴","政府","شبكة","بيتك","عرب","机构","组织机构","健康","招聘","рус","大拿","みんな","グーグル","世界","書籍","网址","닷넷","コム","天主教","游戏","vermögensberater","vermögensberatung","企业","信息","嘉里大酒店","嘉里","广东","政务","xyz","yachts","yahoo","yamaxun","yandex","yodobashi","yoga","yokohama","you","youtube","yun","zappos","zara","zero","zip","zone","zuerich","co.krd","edu.krd","art.pl","gliwice.pl","krakow.pl","poznan.pl","wroc.pl","zakopane.pl","lib.de.us","12chars.dev","12chars.it","12chars.pro","cc.ua","inf.ua","ltd.ua","611.to","a2hosted.com","cpserver.com","aaa.vodka","*.on-acorn.io","activetrail.biz","adaptable.app","adobeaemcloud.com","*.dev.adobeaemcloud.com","aem.live","hlx.live","adobeaemcloud.net","aem.page","hlx.page","hlx3.page","adobeio-static.net","adobeioruntime.net","africa.com","beep.pl","airkitapps.com","airkitapps-au.com","airkitapps.eu","aivencloud.com","akadns.net","akamai.net","akamai-staging.net","akamaiedge.net","akamaiedge-staging.net","akamaihd.net","akamaihd-staging.net","akamaiorigin.net","akamaiorigin-staging.net","akamaized.net","akamaized-staging.net","edgekey.net","edgekey-staging.net","edgesuite.net","edgesuite-staging.net","barsy.ca","*.compute.estate","*.alces.network","kasserver.com","altervista.org","alwaysdata.net","myamaze.net","execute-api.cn-north-1.amazonaws.com.cn","execute-api.cn-northwest-1.amazonaws.com.cn","execute-api.af-south-1.amazonaws.com","execute-api.ap-east-1.amazonaws.com","execute-api.ap-northeast-1.amazonaws.com","execute-api.ap-northeast-2.amazonaws.com","execute-api.ap-northeast-3.amazonaws.com","execute-api.ap-south-1.amazonaws.com","execute-api.ap-south-2.amazonaws.com","execute-api.ap-southeast-1.amazonaws.com","execute-api.ap-southeast-2.amazonaws.com","execute-api.ap-southeast-3.amazonaws.com","execute-api.ap-southeast-4.amazonaws.com","execute-api.ap-southeast-5.amazonaws.com","execute-api.ca-central-1.amazonaws.com","execute-api.ca-west-1.amazonaws.com","execute-api.eu-central-1.amazonaws.com","execute-api.eu-central-2.amazonaws.com","execute-api.eu-north-1.amazonaws.com","execute-api.eu-south-1.amazonaws.com","execute-api.eu-south-2.amazonaws.com","execute-api.eu-west-1.amazonaws.com","execute-api.eu-west-2.amazonaws.com","execute-api.eu-west-3.amazonaws.com","execute-api.il-central-1.amazonaws.com","execute-api.me-central-1.amazonaws.com","execute-api.me-south-1.amazonaws.com","execute-api.sa-east-1.amazonaws.com","execute-api.us-east-1.amazonaws.com","execute-api.us-east-2.amazonaws.com","execute-api.us-gov-east-1.amazonaws.com","execute-api.us-gov-west-1.amazonaws.com","execute-api.us-west-1.amazonaws.com","execute-api.us-west-2.amazonaws.com","cloudfront.net","auth.af-south-1.amazoncognito.com","auth.ap-east-1.amazoncognito.com","auth.ap-northeast-1.amazoncognito.com","auth.ap-northeast-2.amazoncognito.com","auth.ap-northeast-3.amazoncognito.com","auth.ap-south-1.amazoncognito.com","auth.ap-south-2.amazoncognito.com","auth.ap-southeast-1.amazoncognito.com","auth.ap-southeast-2.amazoncognito.com","auth.ap-southeast-3.amazoncognito.com","auth.ap-southeast-4.amazoncognito.com","auth.ca-central-1.amazoncognito.com","auth.ca-west-1.amazoncognito.com","auth.eu-central-1.amazoncognito.com","auth.eu-central-2.amazoncognito.com","auth.eu-north-1.amazoncognito.com","auth.eu-south-1.amazoncognito.com","auth.eu-south-2.amazoncognito.com","auth.eu-west-1.amazoncognito.com","auth.eu-west-2.amazoncognito.com","auth.eu-west-3.amazoncognito.com","auth.il-central-1.amazoncognito.com","auth.me-central-1.amazoncognito.com","auth.me-south-1.amazoncognito.com","auth.sa-east-1.amazoncognito.com","auth.us-east-1.amazoncognito.com","auth-fips.us-east-1.amazoncognito.com","auth.us-east-2.amazoncognito.com","auth-fips.us-east-2.amazoncognito.com","auth-fips.us-gov-west-1.amazoncognito.com","auth.us-west-1.amazoncognito.com","auth-fips.us-west-1.amazoncognito.com","auth.us-west-2.amazoncognito.com","auth-fips.us-west-2.amazoncognito.com","*.compute.amazonaws.com.cn","*.compute.amazonaws.com","*.compute-1.amazonaws.com","us-east-1.amazonaws.com","emrappui-prod.cn-north-1.amazonaws.com.cn","emrnotebooks-prod.cn-north-1.amazonaws.com.cn","emrstudio-prod.cn-north-1.amazonaws.com.cn","emrappui-prod.cn-northwest-1.amazonaws.com.cn","emrnotebooks-prod.cn-northwest-1.amazonaws.com.cn","emrstudio-prod.cn-northwest-1.amazonaws.com.cn","emrappui-prod.af-south-1.amazonaws.com","emrnotebooks-prod.af-south-1.amazonaws.com","emrstudio-prod.af-south-1.amazonaws.com","emrappui-prod.ap-east-1.amazonaws.com","emrnotebooks-prod.ap-east-1.amazonaws.com","emrstudio-prod.ap-east-1.amazonaws.com","emrappui-prod.ap-northeast-1.amazonaws.com","emrnotebooks-prod.ap-northeast-1.amazonaws.com","emrstudio-prod.ap-northeast-1.amazonaws.com","emrappui-prod.ap-northeast-2.amazonaws.com","emrnotebooks-prod.ap-northeast-2.amazonaws.com","emrstudio-prod.ap-northeast-2.amazonaws.com","emrappui-prod.ap-northeast-3.amazonaws.com","emrnotebooks-prod.ap-northeast-3.amazonaws.com","emrstudio-prod.ap-northeast-3.amazonaws.com","emrappui-prod.ap-south-1.amazonaws.com","emrnotebooks-prod.ap-south-1.amazonaws.com","emrstudio-prod.ap-south-1.amazonaws.com","emrappui-prod.ap-south-2.amazonaws.com","emrnotebooks-prod.ap-south-2.amazonaws.com","emrstudio-prod.ap-south-2.amazonaws.com","emrappui-prod.ap-southeast-1.amazonaws.com","emrnotebooks-prod.ap-southeast-1.amazonaws.com","emrstudio-prod.ap-southeast-1.amazonaws.com","emrappui-prod.ap-southeast-2.amazonaws.com","emrnotebooks-prod.ap-southeast-2.amazonaws.com","emrstudio-prod.ap-southeast-2.amazonaws.com","emrappui-prod.ap-southeast-3.amazonaws.com","emrnotebooks-prod.ap-southeast-3.amazonaws.com","emrstudio-prod.ap-southeast-3.amazonaws.com","emrappui-prod.ap-southeast-4.amazonaws.com","emrnotebooks-prod.ap-southeast-4.amazonaws.com","emrstudio-prod.ap-southeast-4.amazonaws.com","emrappui-prod.ca-central-1.amazonaws.com","emrnotebooks-prod.ca-central-1.amazonaws.com","emrstudio-prod.ca-central-1.amazonaws.com","emrappui-prod.ca-west-1.amazonaws.com","emrnotebooks-prod.ca-west-1.amazonaws.com","emrstudio-prod.ca-west-1.amazonaws.com","emrappui-prod.eu-central-1.amazonaws.com","emrnotebooks-prod.eu-central-1.amazonaws.com","emrstudio-prod.eu-central-1.amazonaws.com","emrappui-prod.eu-central-2.amazonaws.com","emrnotebooks-prod.eu-central-2.amazonaws.com","emrstudio-prod.eu-central-2.amazonaws.com","emrappui-prod.eu-north-1.amazonaws.com","emrnotebooks-prod.eu-north-1.amazonaws.com","emrstudio-prod.eu-north-1.amazonaws.com","emrappui-prod.eu-south-1.amazonaws.com","emrnotebooks-prod.eu-south-1.amazonaws.com","emrstudio-prod.eu-south-1.amazonaws.com","emrappui-prod.eu-south-2.amazonaws.com","emrnotebooks-prod.eu-south-2.amazonaws.com","emrstudio-prod.eu-south-2.amazonaws.com","emrappui-prod.eu-west-1.amazonaws.com","emrnotebooks-prod.eu-west-1.amazonaws.com","emrstudio-prod.eu-west-1.amazonaws.com","emrappui-prod.eu-west-2.amazonaws.com","emrnotebooks-prod.eu-west-2.amazonaws.com","emrstudio-prod.eu-west-2.amazonaws.com","emrappui-prod.eu-west-3.amazonaws.com","emrnotebooks-prod.eu-west-3.amazonaws.com","emrstudio-prod.eu-west-3.amazonaws.com","emrappui-prod.il-central-1.amazonaws.com","emrnotebooks-prod.il-central-1.amazonaws.com","emrstudio-prod.il-central-1.amazonaws.com","emrappui-prod.me-central-1.amazonaws.com","emrnotebooks-prod.me-central-1.amazonaws.com","emrstudio-prod.me-central-1.amazonaws.com","emrappui-prod.me-south-1.amazonaws.com","emrnotebooks-prod.me-south-1.amazonaws.com","emrstudio-prod.me-south-1.amazonaws.com","emrappui-prod.sa-east-1.amazonaws.com","emrnotebooks-prod.sa-east-1.amazonaws.com","emrstudio-prod.sa-east-1.amazonaws.com","emrappui-prod.us-east-1.amazonaws.com","emrnotebooks-prod.us-east-1.amazonaws.com","emrstudio-prod.us-east-1.amazonaws.com","emrappui-prod.us-east-2.amazonaws.com","emrnotebooks-prod.us-east-2.amazonaws.com","emrstudio-prod.us-east-2.amazonaws.com","emrappui-prod.us-gov-east-1.amazonaws.com","emrnotebooks-prod.us-gov-east-1.amazonaws.com","emrstudio-prod.us-gov-east-1.amazonaws.com","emrappui-prod.us-gov-west-1.amazonaws.com","emrnotebooks-prod.us-gov-west-1.amazonaws.com","emrstudio-prod.us-gov-west-1.amazonaws.com","emrappui-prod.us-west-1.amazonaws.com","emrnotebooks-prod.us-west-1.amazonaws.com","emrstudio-prod.us-west-1.amazonaws.com","emrappui-prod.us-west-2.amazonaws.com","emrnotebooks-prod.us-west-2.amazonaws.com","emrstudio-prod.us-west-2.amazonaws.com","*.cn-north-1.airflow.amazonaws.com.cn","*.cn-northwest-1.airflow.amazonaws.com.cn","*.af-south-1.airflow.amazonaws.com","*.ap-east-1.airflow.amazonaws.com","*.ap-northeast-1.airflow.amazonaws.com","*.ap-northeast-2.airflow.amazonaws.com","*.ap-northeast-3.airflow.amazonaws.com","*.ap-south-1.airflow.amazonaws.com","*.ap-south-2.airflow.amazonaws.com","*.ap-southeast-1.airflow.amazonaws.com","*.ap-southeast-2.airflow.amazonaws.com","*.ap-southeast-3.airflow.amazonaws.com","*.ap-southeast-4.airflow.amazonaws.com","*.ca-central-1.airflow.amazonaws.com","*.ca-west-1.airflow.amazonaws.com","*.eu-central-1.airflow.amazonaws.com","*.eu-central-2.airflow.amazonaws.com","*.eu-north-1.airflow.amazonaws.com","*.eu-south-1.airflow.amazonaws.com","*.eu-south-2.airflow.amazonaws.com","*.eu-west-1.airflow.amazonaws.com","*.eu-west-2.airflow.amazonaws.com","*.eu-west-3.airflow.amazonaws.com","*.il-central-1.airflow.amazonaws.com","*.me-central-1.airflow.amazonaws.com","*.me-south-1.airflow.amazonaws.com","*.sa-east-1.airflow.amazonaws.com","*.us-east-1.airflow.amazonaws.com","*.us-east-2.airflow.amazonaws.com","*.us-west-1.airflow.amazonaws.com","*.us-west-2.airflow.amazonaws.com","s3.dualstack.cn-north-1.amazonaws.com.cn","s3-accesspoint.dualstack.cn-north-1.amazonaws.com.cn","s3-website.dualstack.cn-north-1.amazonaws.com.cn","s3.cn-north-1.amazonaws.com.cn","s3-accesspoint.cn-north-1.amazonaws.com.cn","s3-deprecated.cn-north-1.amazonaws.com.cn","s3-object-lambda.cn-north-1.amazonaws.com.cn","s3-website.cn-north-1.amazonaws.com.cn","s3.dualstack.cn-northwest-1.amazonaws.com.cn","s3-accesspoint.dualstack.cn-northwest-1.amazonaws.com.cn","s3.cn-northwest-1.amazonaws.com.cn","s3-accesspoint.cn-northwest-1.amazonaws.com.cn","s3-object-lambda.cn-northwest-1.amazonaws.com.cn","s3-website.cn-northwest-1.amazonaws.com.cn","s3.dualstack.af-south-1.amazonaws.com","s3-accesspoint.dualstack.af-south-1.amazonaws.com","s3-website.dualstack.af-south-1.amazonaws.com","s3.af-south-1.amazonaws.com","s3-accesspoint.af-south-1.amazonaws.com","s3-object-lambda.af-south-1.amazonaws.com","s3-website.af-south-1.amazonaws.com","s3.dualstack.ap-east-1.amazonaws.com","s3-accesspoint.dualstack.ap-east-1.amazonaws.com","s3.ap-east-1.amazonaws.com","s3-accesspoint.ap-east-1.amazonaws.com","s3-object-lambda.ap-east-1.amazonaws.com","s3-website.ap-east-1.amazonaws.com","s3.dualstack.ap-northeast-1.amazonaws.com","s3-accesspoint.dualstack.ap-northeast-1.amazonaws.com","s3-website.dualstack.ap-northeast-1.amazonaws.com","s3.ap-northeast-1.amazonaws.com","s3-accesspoint.ap-northeast-1.amazonaws.com","s3-object-lambda.ap-northeast-1.amazonaws.com","s3-website.ap-northeast-1.amazonaws.com","s3.dualstack.ap-northeast-2.amazonaws.com","s3-accesspoint.dualstack.ap-northeast-2.amazonaws.com","s3-website.dualstack.ap-northeast-2.amazonaws.com","s3.ap-northeast-2.amazonaws.com","s3-accesspoint.ap-northeast-2.amazonaws.com","s3-object-lambda.ap-northeast-2.amazonaws.com","s3-website.ap-northeast-2.amazonaws.com","s3.dualstack.ap-northeast-3.amazonaws.com","s3-accesspoint.dualstack.ap-northeast-3.amazonaws.com","s3-website.dualstack.ap-northeast-3.amazonaws.com","s3.ap-northeast-3.amazonaws.com","s3-accesspoint.ap-northeast-3.amazonaws.com","s3-object-lambda.ap-northeast-3.amazonaws.com","s3-website.ap-northeast-3.amazonaws.com","s3.dualstack.ap-south-1.amazonaws.com","s3-accesspoint.dualstack.ap-south-1.amazonaws.com","s3-website.dualstack.ap-south-1.amazonaws.com","s3.ap-south-1.amazonaws.com","s3-accesspoint.ap-south-1.amazonaws.com","s3-object-lambda.ap-south-1.amazonaws.com","s3-website.ap-south-1.amazonaws.com","s3.dualstack.ap-south-2.amazonaws.com","s3-accesspoint.dualstack.ap-south-2.amazonaws.com","s3-website.dualstack.ap-south-2.amazonaws.com","s3.ap-south-2.amazonaws.com","s3-accesspoint.ap-south-2.amazonaws.com","s3-object-lambda.ap-south-2.amazonaws.com","s3-website.ap-south-2.amazonaws.com","s3.dualstack.ap-southeast-1.amazonaws.com","s3-accesspoint.dualstack.ap-southeast-1.amazonaws.com","s3-website.dualstack.ap-southeast-1.amazonaws.com","s3.ap-southeast-1.amazonaws.com","s3-accesspoint.ap-southeast-1.amazonaws.com","s3-object-lambda.ap-southeast-1.amazonaws.com","s3-website.ap-southeast-1.amazonaws.com","s3.dualstack.ap-southeast-2.amazonaws.com","s3-accesspoint.dualstack.ap-southeast-2.amazonaws.com","s3-website.dualstack.ap-southeast-2.amazonaws.com","s3.ap-southeast-2.amazonaws.com","s3-accesspoint.ap-southeast-2.amazonaws.com","s3-object-lambda.ap-southeast-2.amazonaws.com","s3-website.ap-southeast-2.amazonaws.com","s3.dualstack.ap-southeast-3.amazonaws.com","s3-accesspoint.dualstack.ap-southeast-3.amazonaws.com","s3-website.dualstack.ap-southeast-3.amazonaws.com","s3.ap-southeast-3.amazonaws.com","s3-accesspoint.ap-southeast-3.amazonaws.com","s3-object-lambda.ap-southeast-3.amazonaws.com","s3-website.ap-southeast-3.amazonaws.com","s3.dualstack.ap-southeast-4.amazonaws.com","s3-accesspoint.dualstack.ap-southeast-4.amazonaws.com","s3-website.dualstack.ap-southeast-4.amazonaws.com","s3.ap-southeast-4.amazonaws.com","s3-accesspoint.ap-southeast-4.amazonaws.com","s3-object-lambda.ap-southeast-4.amazonaws.com","s3-website.ap-southeast-4.amazonaws.com","s3.dualstack.ap-southeast-5.amazonaws.com","s3-accesspoint.dualstack.ap-southeast-5.amazonaws.com","s3-website.dualstack.ap-southeast-5.amazonaws.com","s3.ap-southeast-5.amazonaws.com","s3-accesspoint.ap-southeast-5.amazonaws.com","s3-deprecated.ap-southeast-5.amazonaws.com","s3-object-lambda.ap-southeast-5.amazonaws.com","s3-website.ap-southeast-5.amazonaws.com","s3.dualstack.ca-central-1.amazonaws.com","s3-accesspoint.dualstack.ca-central-1.amazonaws.com","s3-accesspoint-fips.dualstack.ca-central-1.amazonaws.com","s3-fips.dualstack.ca-central-1.amazonaws.com","s3-website.dualstack.ca-central-1.amazonaws.com","s3.ca-central-1.amazonaws.com","s3-accesspoint.ca-central-1.amazonaws.com","s3-accesspoint-fips.ca-central-1.amazonaws.com","s3-fips.ca-central-1.amazonaws.com","s3-object-lambda.ca-central-1.amazonaws.com","s3-website.ca-central-1.amazonaws.com","s3.dualstack.ca-west-1.amazonaws.com","s3-accesspoint.dualstack.ca-west-1.amazonaws.com","s3-accesspoint-fips.dualstack.ca-west-1.amazonaws.com","s3-fips.dualstack.ca-west-1.amazonaws.com","s3-website.dualstack.ca-west-1.amazonaws.com","s3.ca-west-1.amazonaws.com","s3-accesspoint.ca-west-1.amazonaws.com","s3-accesspoint-fips.ca-west-1.amazonaws.com","s3-fips.ca-west-1.amazonaws.com","s3-object-lambda.ca-west-1.amazonaws.com","s3-website.ca-west-1.amazonaws.com","s3.dualstack.eu-central-1.amazonaws.com","s3-accesspoint.dualstack.eu-central-1.amazonaws.com","s3-website.dualstack.eu-central-1.amazonaws.com","s3.eu-central-1.amazonaws.com","s3-accesspoint.eu-central-1.amazonaws.com","s3-object-lambda.eu-central-1.amazonaws.com","s3-website.eu-central-1.amazonaws.com","s3.dualstack.eu-central-2.amazonaws.com","s3-accesspoint.dualstack.eu-central-2.amazonaws.com","s3-website.dualstack.eu-central-2.amazonaws.com","s3.eu-central-2.amazonaws.com","s3-accesspoint.eu-central-2.amazonaws.com","s3-object-lambda.eu-central-2.amazonaws.com","s3-website.eu-central-2.amazonaws.com","s3.dualstack.eu-north-1.amazonaws.com","s3-accesspoint.dualstack.eu-north-1.amazonaws.com","s3.eu-north-1.amazonaws.com","s3-accesspoint.eu-north-1.amazonaws.com","s3-object-lambda.eu-north-1.amazonaws.com","s3-website.eu-north-1.amazonaws.com","s3.dualstack.eu-south-1.amazonaws.com","s3-accesspoint.dualstack.eu-south-1.amazonaws.com","s3-website.dualstack.eu-south-1.amazonaws.com","s3.eu-south-1.amazonaws.com","s3-accesspoint.eu-south-1.amazonaws.com","s3-object-lambda.eu-south-1.amazonaws.com","s3-website.eu-south-1.amazonaws.com","s3.dualstack.eu-south-2.amazonaws.com","s3-accesspoint.dualstack.eu-south-2.amazonaws.com","s3-website.dualstack.eu-south-2.amazonaws.com","s3.eu-south-2.amazonaws.com","s3-accesspoint.eu-south-2.amazonaws.com","s3-object-lambda.eu-south-2.amazonaws.com","s3-website.eu-south-2.amazonaws.com","s3.dualstack.eu-west-1.amazonaws.com","s3-accesspoint.dualstack.eu-west-1.amazonaws.com","s3-website.dualstack.eu-west-1.amazonaws.com","s3.eu-west-1.amazonaws.com","s3-accesspoint.eu-west-1.amazonaws.com","s3-deprecated.eu-west-1.amazonaws.com","s3-object-lambda.eu-west-1.amazonaws.com","s3-website.eu-west-1.amazonaws.com","s3.dualstack.eu-west-2.amazonaws.com","s3-accesspoint.dualstack.eu-west-2.amazonaws.com","s3.eu-west-2.amazonaws.com","s3-accesspoint.eu-west-2.amazonaws.com","s3-object-lambda.eu-west-2.amazonaws.com","s3-website.eu-west-2.amazonaws.com","s3.dualstack.eu-west-3.amazonaws.com","s3-accesspoint.dualstack.eu-west-3.amazonaws.com","s3-website.dualstack.eu-west-3.amazonaws.com","s3.eu-west-3.amazonaws.com","s3-accesspoint.eu-west-3.amazonaws.com","s3-object-lambda.eu-west-3.amazonaws.com","s3-website.eu-west-3.amazonaws.com","s3.dualstack.il-central-1.amazonaws.com","s3-accesspoint.dualstack.il-central-1.amazonaws.com","s3-website.dualstack.il-central-1.amazonaws.com","s3.il-central-1.amazonaws.com","s3-accesspoint.il-central-1.amazonaws.com","s3-object-lambda.il-central-1.amazonaws.com","s3-website.il-central-1.amazonaws.com","s3.dualstack.me-central-1.amazonaws.com","s3-accesspoint.dualstack.me-central-1.amazonaws.com","s3-website.dualstack.me-central-1.amazonaws.com","s3.me-central-1.amazonaws.com","s3-accesspoint.me-central-1.amazonaws.com","s3-object-lambda.me-central-1.amazonaws.com","s3-website.me-central-1.amazonaws.com","s3.dualstack.me-south-1.amazonaws.com","s3-accesspoint.dualstack.me-south-1.amazonaws.com","s3.me-south-1.amazonaws.com","s3-accesspoint.me-south-1.amazonaws.com","s3-object-lambda.me-south-1.amazonaws.com","s3-website.me-south-1.amazonaws.com","s3.amazonaws.com","s3-1.amazonaws.com","s3-ap-east-1.amazonaws.com","s3-ap-northeast-1.amazonaws.com","s3-ap-northeast-2.amazonaws.com","s3-ap-northeast-3.amazonaws.com","s3-ap-south-1.amazonaws.com","s3-ap-southeast-1.amazonaws.com","s3-ap-southeast-2.amazonaws.com","s3-ca-central-1.amazonaws.com","s3-eu-central-1.amazonaws.com","s3-eu-north-1.amazonaws.com","s3-eu-west-1.amazonaws.com","s3-eu-west-2.amazonaws.com","s3-eu-west-3.amazonaws.com","s3-external-1.amazonaws.com","s3-fips-us-gov-east-1.amazonaws.com","s3-fips-us-gov-west-1.amazonaws.com","mrap.accesspoint.s3-global.amazonaws.com","s3-me-south-1.amazonaws.com","s3-sa-east-1.amazonaws.com","s3-us-east-2.amazonaws.com","s3-us-gov-east-1.amazonaws.com","s3-us-gov-west-1.amazonaws.com","s3-us-west-1.amazonaws.com","s3-us-west-2.amazonaws.com","s3-website-ap-northeast-1.amazonaws.com","s3-website-ap-southeast-1.amazonaws.com","s3-website-ap-southeast-2.amazonaws.com","s3-website-eu-west-1.amazonaws.com","s3-website-sa-east-1.amazonaws.com","s3-website-us-east-1.amazonaws.com","s3-website-us-gov-west-1.amazonaws.com","s3-website-us-west-1.amazonaws.com","s3-website-us-west-2.amazonaws.com","s3.dualstack.sa-east-1.amazonaws.com","s3-accesspoint.dualstack.sa-east-1.amazonaws.com","s3-website.dualstack.sa-east-1.amazonaws.com","s3.sa-east-1.amazonaws.com","s3-accesspoint.sa-east-1.amazonaws.com","s3-object-lambda.sa-east-1.amazonaws.com","s3-website.sa-east-1.amazonaws.com","s3.dualstack.us-east-1.amazonaws.com","s3-accesspoint.dualstack.us-east-1.amazonaws.com","s3-accesspoint-fips.dualstack.us-east-1.amazonaws.com","s3-fips.dualstack.us-east-1.amazonaws.com","s3-website.dualstack.us-east-1.amazonaws.com","s3.us-east-1.amazonaws.com","s3-accesspoint.us-east-1.amazonaws.com","s3-accesspoint-fips.us-east-1.amazonaws.com","s3-deprecated.us-east-1.amazonaws.com","s3-fips.us-east-1.amazonaws.com","s3-object-lambda.us-east-1.amazonaws.com","s3-website.us-east-1.amazonaws.com","s3.dualstack.us-east-2.amazonaws.com","s3-accesspoint.dualstack.us-east-2.amazonaws.com","s3-accesspoint-fips.dualstack.us-east-2.amazonaws.com","s3-fips.dualstack.us-east-2.amazonaws.com","s3-website.dualstack.us-east-2.amazonaws.com","s3.us-east-2.amazonaws.com","s3-accesspoint.us-east-2.amazonaws.com","s3-accesspoint-fips.us-east-2.amazonaws.com","s3-deprecated.us-east-2.amazonaws.com","s3-fips.us-east-2.amazonaws.com","s3-object-lambda.us-east-2.amazonaws.com","s3-website.us-east-2.amazonaws.com","s3.dualstack.us-gov-east-1.amazonaws.com","s3-accesspoint.dualstack.us-gov-east-1.amazonaws.com","s3-accesspoint-fips.dualstack.us-gov-east-1.amazonaws.com","s3-fips.dualstack.us-gov-east-1.amazonaws.com","s3.us-gov-east-1.amazonaws.com","s3-accesspoint.us-gov-east-1.amazonaws.com","s3-accesspoint-fips.us-gov-east-1.amazonaws.com","s3-fips.us-gov-east-1.amazonaws.com","s3-object-lambda.us-gov-east-1.amazonaws.com","s3-website.us-gov-east-1.amazonaws.com","s3.dualstack.us-gov-west-1.amazonaws.com","s3-accesspoint.dualstack.us-gov-west-1.amazonaws.com","s3-accesspoint-fips.dualstack.us-gov-west-1.amazonaws.com","s3-fips.dualstack.us-gov-west-1.amazonaws.com","s3.us-gov-west-1.amazonaws.com","s3-accesspoint.us-gov-west-1.amazonaws.com","s3-accesspoint-fips.us-gov-west-1.amazonaws.com","s3-fips.us-gov-west-1.amazonaws.com","s3-object-lambda.us-gov-west-1.amazonaws.com","s3-website.us-gov-west-1.amazonaws.com","s3.dualstack.us-west-1.amazonaws.com","s3-accesspoint.dualstack.us-west-1.amazonaws.com","s3-accesspoint-fips.dualstack.us-west-1.amazonaws.com","s3-fips.dualstack.us-west-1.amazonaws.com","s3-website.dualstack.us-west-1.amazonaws.com","s3.us-west-1.amazonaws.com","s3-accesspoint.us-west-1.amazonaws.com","s3-accesspoint-fips.us-west-1.amazonaws.com","s3-fips.us-west-1.amazonaws.com","s3-object-lambda.us-west-1.amazonaws.com","s3-website.us-west-1.amazonaws.com","s3.dualstack.us-west-2.amazonaws.com","s3-accesspoint.dualstack.us-west-2.amazonaws.com","s3-accesspoint-fips.dualstack.us-west-2.amazonaws.com","s3-fips.dualstack.us-west-2.amazonaws.com","s3-website.dualstack.us-west-2.amazonaws.com","s3.us-west-2.amazonaws.com","s3-accesspoint.us-west-2.amazonaws.com","s3-accesspoint-fips.us-west-2.amazonaws.com","s3-deprecated.us-west-2.amazonaws.com","s3-fips.us-west-2.amazonaws.com","s3-object-lambda.us-west-2.amazonaws.com","s3-website.us-west-2.amazonaws.com","labeling.ap-northeast-1.sagemaker.aws","labeling.ap-northeast-2.sagemaker.aws","labeling.ap-south-1.sagemaker.aws","labeling.ap-southeast-1.sagemaker.aws","labeling.ap-southeast-2.sagemaker.aws","labeling.ca-central-1.sagemaker.aws","labeling.eu-central-1.sagemaker.aws","labeling.eu-west-1.sagemaker.aws","labeling.eu-west-2.sagemaker.aws","labeling.us-east-1.sagemaker.aws","labeling.us-east-2.sagemaker.aws","labeling.us-west-2.sagemaker.aws","notebook.af-south-1.sagemaker.aws","notebook.ap-east-1.sagemaker.aws","notebook.ap-northeast-1.sagemaker.aws","notebook.ap-northeast-2.sagemaker.aws","notebook.ap-northeast-3.sagemaker.aws","notebook.ap-south-1.sagemaker.aws","notebook.ap-south-2.sagemaker.aws","notebook.ap-southeast-1.sagemaker.aws","notebook.ap-southeast-2.sagemaker.aws","notebook.ap-southeast-3.sagemaker.aws","notebook.ap-southeast-4.sagemaker.aws","notebook.ca-central-1.sagemaker.aws","notebook-fips.ca-central-1.sagemaker.aws","notebook.ca-west-1.sagemaker.aws","notebook-fips.ca-west-1.sagemaker.aws","notebook.eu-central-1.sagemaker.aws","notebook.eu-central-2.sagemaker.aws","notebook.eu-north-1.sagemaker.aws","notebook.eu-south-1.sagemaker.aws","notebook.eu-south-2.sagemaker.aws","notebook.eu-west-1.sagemaker.aws","notebook.eu-west-2.sagemaker.aws","notebook.eu-west-3.sagemaker.aws","notebook.il-central-1.sagemaker.aws","notebook.me-central-1.sagemaker.aws","notebook.me-south-1.sagemaker.aws","notebook.sa-east-1.sagemaker.aws","notebook.us-east-1.sagemaker.aws","notebook-fips.us-east-1.sagemaker.aws","notebook.us-east-2.sagemaker.aws","notebook-fips.us-east-2.sagemaker.aws","notebook.us-gov-east-1.sagemaker.aws","notebook-fips.us-gov-east-1.sagemaker.aws","notebook.us-gov-west-1.sagemaker.aws","notebook-fips.us-gov-west-1.sagemaker.aws","notebook.us-west-1.sagemaker.aws","notebook-fips.us-west-1.sagemaker.aws","notebook.us-west-2.sagemaker.aws","notebook-fips.us-west-2.sagemaker.aws","notebook.cn-north-1.sagemaker.com.cn","notebook.cn-northwest-1.sagemaker.com.cn","studio.af-south-1.sagemaker.aws","studio.ap-east-1.sagemaker.aws","studio.ap-northeast-1.sagemaker.aws","studio.ap-northeast-2.sagemaker.aws","studio.ap-northeast-3.sagemaker.aws","studio.ap-south-1.sagemaker.aws","studio.ap-southeast-1.sagemaker.aws","studio.ap-southeast-2.sagemaker.aws","studio.ap-southeast-3.sagemaker.aws","studio.ca-central-1.sagemaker.aws","studio.eu-central-1.sagemaker.aws","studio.eu-north-1.sagemaker.aws","studio.eu-south-1.sagemaker.aws","studio.eu-south-2.sagemaker.aws","studio.eu-west-1.sagemaker.aws","studio.eu-west-2.sagemaker.aws","studio.eu-west-3.sagemaker.aws","studio.il-central-1.sagemaker.aws","studio.me-central-1.sagemaker.aws","studio.me-south-1.sagemaker.aws","studio.sa-east-1.sagemaker.aws","studio.us-east-1.sagemaker.aws","studio.us-east-2.sagemaker.aws","studio.us-gov-east-1.sagemaker.aws","studio-fips.us-gov-east-1.sagemaker.aws","studio.us-gov-west-1.sagemaker.aws","studio-fips.us-gov-west-1.sagemaker.aws","studio.us-west-1.sagemaker.aws","studio.us-west-2.sagemaker.aws","studio.cn-north-1.sagemaker.com.cn","studio.cn-northwest-1.sagemaker.com.cn","*.experiments.sagemaker.aws","analytics-gateway.ap-northeast-1.amazonaws.com","analytics-gateway.ap-northeast-2.amazonaws.com","analytics-gateway.ap-south-1.amazonaws.com","analytics-gateway.ap-southeast-1.amazonaws.com","analytics-gateway.ap-southeast-2.amazonaws.com","analytics-gateway.eu-central-1.amazonaws.com","analytics-gateway.eu-west-1.amazonaws.com","analytics-gateway.us-east-1.amazonaws.com","analytics-gateway.us-east-2.amazonaws.com","analytics-gateway.us-west-2.amazonaws.com","amplifyapp.com","*.awsapprunner.com","webview-assets.aws-cloud9.af-south-1.amazonaws.com","vfs.cloud9.af-south-1.amazonaws.com","webview-assets.cloud9.af-south-1.amazonaws.com","webview-assets.aws-cloud9.ap-east-1.amazonaws.com","vfs.cloud9.ap-east-1.amazonaws.com","webview-assets.cloud9.ap-east-1.amazonaws.com","webview-assets.aws-cloud9.ap-northeast-1.amazonaws.com","vfs.cloud9.ap-northeast-1.amazonaws.com","webview-assets.cloud9.ap-northeast-1.amazonaws.com","webview-assets.aws-cloud9.ap-northeast-2.amazonaws.com","vfs.cloud9.ap-northeast-2.amazonaws.com","webview-assets.cloud9.ap-northeast-2.amazonaws.com","webview-assets.aws-cloud9.ap-northeast-3.amazonaws.com","vfs.cloud9.ap-northeast-3.amazonaws.com","webview-assets.cloud9.ap-northeast-3.amazonaws.com","webview-assets.aws-cloud9.ap-south-1.amazonaws.com","vfs.cloud9.ap-south-1.amazonaws.com","webview-assets.cloud9.ap-south-1.amazonaws.com","webview-assets.aws-cloud9.ap-southeast-1.amazonaws.com","vfs.cloud9.ap-southeast-1.amazonaws.com","webview-assets.cloud9.ap-southeast-1.amazonaws.com","webview-assets.aws-cloud9.ap-southeast-2.amazonaws.com","vfs.cloud9.ap-southeast-2.amazonaws.com","webview-assets.cloud9.ap-southeast-2.amazonaws.com","webview-assets.aws-cloud9.ca-central-1.amazonaws.com","vfs.cloud9.ca-central-1.amazonaws.com","webview-assets.cloud9.ca-central-1.amazonaws.com","webview-assets.aws-cloud9.eu-central-1.amazonaws.com","vfs.cloud9.eu-central-1.amazonaws.com","webview-assets.cloud9.eu-central-1.amazonaws.com","webview-assets.aws-cloud9.eu-north-1.amazonaws.com","vfs.cloud9.eu-north-1.amazonaws.com","webview-assets.cloud9.eu-north-1.amazonaws.com","webview-assets.aws-cloud9.eu-south-1.amazonaws.com","vfs.cloud9.eu-south-1.amazonaws.com","webview-assets.cloud9.eu-south-1.amazonaws.com","webview-assets.aws-cloud9.eu-west-1.amazonaws.com","vfs.cloud9.eu-west-1.amazonaws.com","webview-assets.cloud9.eu-west-1.amazonaws.com","webview-assets.aws-cloud9.eu-west-2.amazonaws.com","vfs.cloud9.eu-west-2.amazonaws.com","webview-assets.cloud9.eu-west-2.amazonaws.com","webview-assets.aws-cloud9.eu-west-3.amazonaws.com","vfs.cloud9.eu-west-3.amazonaws.com","webview-assets.cloud9.eu-west-3.amazonaws.com","webview-assets.aws-cloud9.il-central-1.amazonaws.com","vfs.cloud9.il-central-1.amazonaws.com","webview-assets.aws-cloud9.me-south-1.amazonaws.com","vfs.cloud9.me-south-1.amazonaws.com","webview-assets.cloud9.me-south-1.amazonaws.com","webview-assets.aws-cloud9.sa-east-1.amazonaws.com","vfs.cloud9.sa-east-1.amazonaws.com","webview-assets.cloud9.sa-east-1.amazonaws.com","webview-assets.aws-cloud9.us-east-1.amazonaws.com","vfs.cloud9.us-east-1.amazonaws.com","webview-assets.cloud9.us-east-1.amazonaws.com","webview-assets.aws-cloud9.us-east-2.amazonaws.com","vfs.cloud9.us-east-2.amazonaws.com","webview-assets.cloud9.us-east-2.amazonaws.com","webview-assets.aws-cloud9.us-west-1.amazonaws.com","vfs.cloud9.us-west-1.amazonaws.com","webview-assets.cloud9.us-west-1.amazonaws.com","webview-assets.aws-cloud9.us-west-2.amazonaws.com","vfs.cloud9.us-west-2.amazonaws.com","webview-assets.cloud9.us-west-2.amazonaws.com","awsapps.com","cn-north-1.eb.amazonaws.com.cn","cn-northwest-1.eb.amazonaws.com.cn","elasticbeanstalk.com","af-south-1.elasticbeanstalk.com","ap-east-1.elasticbeanstalk.com","ap-northeast-1.elasticbeanstalk.com","ap-northeast-2.elasticbeanstalk.com","ap-northeast-3.elasticbeanstalk.com","ap-south-1.elasticbeanstalk.com","ap-southeast-1.elasticbeanstalk.com","ap-southeast-2.elasticbeanstalk.com","ap-southeast-3.elasticbeanstalk.com","ca-central-1.elasticbeanstalk.com","eu-central-1.elasticbeanstalk.com","eu-north-1.elasticbeanstalk.com","eu-south-1.elasticbeanstalk.com","eu-west-1.elasticbeanstalk.com","eu-west-2.elasticbeanstalk.com","eu-west-3.elasticbeanstalk.com","il-central-1.elasticbeanstalk.com","me-south-1.elasticbeanstalk.com","sa-east-1.elasticbeanstalk.com","us-east-1.elasticbeanstalk.com","us-east-2.elasticbeanstalk.com","us-gov-east-1.elasticbeanstalk.com","us-gov-west-1.elasticbeanstalk.com","us-west-1.elasticbeanstalk.com","us-west-2.elasticbeanstalk.com","*.elb.amazonaws.com.cn","*.elb.amazonaws.com","awsglobalaccelerator.com","*.private.repost.aws","eero.online","eero-stage.online","apigee.io","panel.dev","siiites.com","appspacehosted.com","appspaceusercontent.com","appudo.net","on-aptible.com","f5.si","arvanedge.ir","user.aseinet.ne.jp","gv.vc","d.gv.vc","user.party.eus","pimienta.org","poivron.org","potager.org","sweetpepper.org","myasustor.com","cdn.prod.atlassian-dev.net","translated.page","myfritz.link","myfritz.net","onavstack.net","*.awdev.ca","*.advisor.ws","ecommerce-shop.pl","b-data.io","balena-devices.com","base.ec","official.ec","buyshop.jp","fashionstore.jp","handcrafted.jp","kawaiishop.jp","supersale.jp","theshop.jp","shopselect.net","base.shop","beagleboard.io","*.beget.app","pages.gay","bnr.la","bitbucket.io","blackbaudcdn.net","of.je","bluebite.io","boomla.net","boutir.com","boxfuse.io","square7.ch","bplaced.com","bplaced.de","square7.de","bplaced.net","square7.net","*.s.brave.io","shop.brendly.hr","shop.brendly.rs","browsersafetymark.io","radio.am","radio.fm","uk0.bigv.io","dh.bytemark.co.uk","vm.bytemark.co.uk","cafjs.com","canva-apps.cn","*.my.canvasite.cn","canva-apps.com","*.my.canva.site","drr.ac","uwu.ai","carrd.co","crd.co","ju.mp","api.gov.uk","cdn77-storage.com","rsc.contentproxy9.cz","r.cdn77.net","cdn77-ssl.net","c.cdn77.org","rsc.cdn77.org","ssl.origin.cdn77-secure.org","za.bz","br.com","cn.com","de.com","eu.com","jpn.com","mex.com","ru.com","sa.com","uk.com","us.com","za.com","com.de","gb.net","hu.net","jp.net","se.net","uk.net","ae.org","com.se","cx.ua","discourse.group","discourse.team","clerk.app","clerkstage.app","*.lcl.dev","*.lclstage.dev","*.stg.dev","*.stgstage.dev","cleverapps.cc","*.services.clever-cloud.com","cleverapps.io","cleverapps.tech","clickrising.net","cloudns.asia","cloudns.be","cloud-ip.biz","cloudns.biz","cloudns.cc","cloudns.ch","cloudns.cl","cloudns.club","dnsabr.com","ip-ddns.com","cloudns.cx","cloudns.eu","cloudns.in","cloudns.info","ddns-ip.net","dns-cloud.net","dns-dynamic.net","cloudns.nz","cloudns.org","ip-dynamic.org","cloudns.ph","cloudns.pro","cloudns.pw","cloudns.us","c66.me","cloud66.ws","cloud66.zone","jdevcloud.com","wpdevcloud.com","cloudaccess.host","freesite.host","cloudaccess.net","*.cloudera.site","cf-ipfs.com","cloudflare-ipfs.com","trycloudflare.com","pages.dev","r2.dev","workers.dev","cloudflare.net","cdn.cloudflare.net","cdn.cloudflareanycast.net","cdn.cloudflarecn.net","cdn.cloudflareglobal.net","cust.cloudscale.ch","objects.lpg.cloudscale.ch","objects.rma.cloudscale.ch","wnext.app","cnpy.gdn","*.otap.co","co.ca","co.com","codeberg.page","csb.app","preview.csb.app","co.nl","co.no","webhosting.be","hosting-cluster.nl","ctfcloud.net","convex.site","ac.ru","edu.ru","gov.ru","int.ru","mil.ru","test.ru","dyn.cosidns.de","dnsupdater.de","dynamisches-dns.de","internet-dns.de","l-o-g-i-n.de","dynamic-dns.info","feste-ip.net","knx-server.net","static-access.net","craft.me","realm.cz","on.crisp.email","*.cryptonomic.net","curv.dev","cfolks.pl","cyon.link","cyon.site","platform0.app","fnwk.site","folionetwork.site","biz.dk","co.dk","firm.dk","reg.dk","store.dk","dyndns.dappnode.io","builtwithdark.com","darklang.io","demo.datadetect.com","instance.datadetect.com","edgestack.me","dattolocal.com","dattorelay.com","dattoweb.com","mydatto.com","dattolocal.net","mydatto.net","ddnss.de","dyn.ddnss.de","dyndns.ddnss.de","dyn-ip24.de","dyndns1.de","home-webserver.de","dyn.home-webserver.de","myhome-server.de","ddnss.org","debian.net","definima.io","definima.net","deno.dev","deno-staging.dev","dedyn.io","deta.app","deta.dev","dfirma.pl","dkonto.pl","you2.pl","ondigitalocean.app","*.digitaloceanspaces.com","us.kg","rss.my.id","diher.solutions","discordsays.com","discordsez.com","jozi.biz","dnshome.de","online.th","shop.th","drayddns.com","shoparena.pl","dreamhosters.com","durumis.com","mydrobo.com","drud.io","drud.us","duckdns.org","dy.fi","tunk.org","dyndns.biz","for-better.biz","for-more.biz","for-some.biz","for-the.biz","selfip.biz","webhop.biz","ftpaccess.cc","game-server.cc","myphotos.cc","scrapping.cc","blogdns.com","cechire.com","dnsalias.com","dnsdojo.com","doesntexist.com","dontexist.com","doomdns.com","dyn-o-saur.com","dynalias.com","dyndns-at-home.com","dyndns-at-work.com","dyndns-blog.com","dyndns-free.com","dyndns-home.com","dyndns-ip.com","dyndns-mail.com","dyndns-office.com","dyndns-pics.com","dyndns-remote.com","dyndns-server.com","dyndns-web.com","dyndns-wiki.com","dyndns-work.com","est-a-la-maison.com","est-a-la-masion.com","est-le-patron.com","est-mon-blogueur.com","from-ak.com","from-al.com","from-ar.com","from-ca.com","from-ct.com","from-dc.com","from-de.com","from-fl.com","from-ga.com","from-hi.com","from-ia.com","from-id.com","from-il.com","from-in.com","from-ks.com","from-ky.com","from-ma.com","from-md.com","from-mi.com","from-mn.com","from-mo.com","from-ms.com","from-mt.com","from-nc.com","from-nd.com","from-ne.com","from-nh.com","from-nj.com","from-nm.com","from-nv.com","from-oh.com","from-ok.com","from-or.com","from-pa.com","from-pr.com","from-ri.com","from-sc.com","from-sd.com","from-tn.com","from-tx.com","from-ut.com","from-va.com","from-vt.com","from-wa.com","from-wi.com","from-wv.com","from-wy.com","getmyip.com","gotdns.com","hobby-site.com","homelinux.com","homeunix.com","iamallama.com","is-a-anarchist.com","is-a-blogger.com","is-a-bookkeeper.com","is-a-bulls-fan.com","is-a-caterer.com","is-a-chef.com","is-a-conservative.com","is-a-cpa.com","is-a-cubicle-slave.com","is-a-democrat.com","is-a-designer.com","is-a-doctor.com","is-a-financialadvisor.com","is-a-geek.com","is-a-green.com","is-a-guru.com","is-a-hard-worker.com","is-a-hunter.com","is-a-landscaper.com","is-a-lawyer.com","is-a-liberal.com","is-a-libertarian.com","is-a-llama.com","is-a-musician.com","is-a-nascarfan.com","is-a-nurse.com","is-a-painter.com","is-a-personaltrainer.com","is-a-photographer.com","is-a-player.com","is-a-republican.com","is-a-rockstar.com","is-a-socialist.com","is-a-student.com","is-a-teacher.com","is-a-techie.com","is-a-therapist.com","is-an-accountant.com","is-an-actor.com","is-an-actress.com","is-an-anarchist.com","is-an-artist.com","is-an-engineer.com","is-an-entertainer.com","is-certified.com","is-gone.com","is-into-anime.com","is-into-cars.com","is-into-cartoons.com","is-into-games.com","is-leet.com","is-not-certified.com","is-slick.com","is-uberleet.com","is-with-theband.com","isa-geek.com","isa-hockeynut.com","issmarterthanyou.com","likes-pie.com","likescandy.com","neat-url.com","saves-the-whales.com","selfip.com","sells-for-less.com","sells-for-u.com","servebbs.com","simple-url.com","space-to-rent.com","teaches-yoga.com","writesthisblog.com","ath.cx","fuettertdasnetz.de","isteingeek.de","istmein.de","lebtimnetz.de","leitungsen.de","traeumtgerade.de","barrel-of-knowledge.info","barrell-of-knowledge.info","dyndns.info","for-our.info","groks-the.info","groks-this.info","here-for-more.info","knowsitall.info","selfip.info","webhop.info","forgot.her.name","forgot.his.name","at-band-camp.net","blogdns.net","broke-it.net","buyshouses.net","dnsalias.net","dnsdojo.net","does-it.net","dontexist.net","dynalias.net","dynathome.net","endofinternet.net","from-az.net","from-co.net","from-la.net","from-ny.net","gets-it.net","ham-radio-op.net","homeftp.net","homeip.net","homelinux.net","homeunix.net","in-the-band.net","is-a-chef.net","is-a-geek.net","isa-geek.net","kicks-ass.net","office-on-the.net","podzone.net","scrapper-site.net","selfip.net","sells-it.net","servebbs.net","serveftp.net","thruhere.net","webhop.net","merseine.nu","mine.nu","shacknet.nu","blogdns.org","blogsite.org","boldlygoingnowhere.org","dnsalias.org","dnsdojo.org","doesntexist.org","dontexist.org","doomdns.org","dvrdns.org","dynalias.org","dyndns.org","go.dyndns.org","home.dyndns.org","endofinternet.org","endoftheinternet.org","from-me.org","game-host.org","gotdns.org","hobby-site.org","homedns.org","homeftp.org","homelinux.org","homeunix.org","is-a-bruinsfan.org","is-a-candidate.org","is-a-celticsfan.org","is-a-chef.org","is-a-geek.org","is-a-knight.org","is-a-linux-user.org","is-a-patsfan.org","is-a-soxfan.org","is-found.org","is-lost.org","is-saved.org","is-very-bad.org","is-very-evil.org","is-very-good.org","is-very-nice.org","is-very-sweet.org","isa-geek.org","kicks-ass.org","misconfused.org","podzone.org","readmyblog.org","selfip.org","sellsyourhome.org","servebbs.org","serveftp.org","servegame.org","stuff-4-sale.org","webhop.org","better-than.tv","dyndns.tv","on-the-web.tv","worse-than.tv","is-by.us","land-4-sale.us","stuff-4-sale.us","dyndns.ws","mypets.ws","ddnsfree.com","ddnsgeek.com","giize.com","gleeze.com","kozow.com","loseyourip.com","ooguy.com","theworkpc.com","casacam.net","dynu.net","accesscam.org","camdvr.org","freeddns.org","mywire.org","webredirect.org","myddns.rocks","dynv6.net","e4.cz","easypanel.app","easypanel.host","*.ewp.live","twmail.cc","twmail.net","twmail.org","mymailer.com.tw","url.tw","at.emf.camp","rt.ht","elementor.cloud","elementor.cool","en-root.fr","mytuleap.com","tuleap-partners.com","encr.app","encoreapi.com","eu.encoway.cloud","eu.org","al.eu.org","asso.eu.org","at.eu.org","au.eu.org","be.eu.org","bg.eu.org","ca.eu.org","cd.eu.org","ch.eu.org","cn.eu.org","cy.eu.org","cz.eu.org","de.eu.org","dk.eu.org","edu.eu.org","ee.eu.org","es.eu.org","fi.eu.org","fr.eu.org","gr.eu.org","hr.eu.org","hu.eu.org","ie.eu.org","il.eu.org","in.eu.org","int.eu.org","is.eu.org","it.eu.org","jp.eu.org","kr.eu.org","lt.eu.org","lu.eu.org","lv.eu.org","me.eu.org","mk.eu.org","mt.eu.org","my.eu.org","net.eu.org","ng.eu.org","nl.eu.org","no.eu.org","nz.eu.org","pl.eu.org","pt.eu.org","ro.eu.org","ru.eu.org","se.eu.org","si.eu.org","sk.eu.org","tr.eu.org","uk.eu.org","us.eu.org","eurodir.ru","eu-1.evennode.com","eu-2.evennode.com","eu-3.evennode.com","eu-4.evennode.com","us-1.evennode.com","us-2.evennode.com","us-3.evennode.com","us-4.evennode.com","relay.evervault.app","relay.evervault.dev","expo.app","staging.expo.app","onfabrica.com","ru.net","adygeya.ru","bashkiria.ru","bir.ru","cbg.ru","com.ru","dagestan.ru","grozny.ru","kalmykia.ru","kustanai.ru","marine.ru","mordovia.ru","msk.ru","mytis.ru","nalchik.ru","nov.ru","pyatigorsk.ru","spb.ru","vladikavkaz.ru","vladimir.ru","abkhazia.su","adygeya.su","aktyubinsk.su","arkhangelsk.su","armenia.su","ashgabad.su","azerbaijan.su","balashov.su","bashkiria.su","bryansk.su","bukhara.su","chimkent.su","dagestan.su","east-kazakhstan.su","exnet.su","georgia.su","grozny.su","ivanovo.su","jambyl.su","kalmykia.su","kaluga.su","karacol.su","karaganda.su","karelia.su","khakassia.su","krasnodar.su","kurgan.su","kustanai.su","lenug.su","mangyshlak.su","mordovia.su","msk.su","murmansk.su","nalchik.su","navoi.su","north-kazakhstan.su","nov.su","obninsk.su","penza.su","pokrovsk.su","sochi.su","spb.su","tashkent.su","termez.su","togliatti.su","troitsk.su","tselinograd.su","tula.su","tuva.su","vladikavkaz.su","vladimir.su","vologda.su","channelsdvr.net","u.channelsdvr.net","edgecompute.app","fastly-edge.com","fastly-terrarium.com","freetls.fastly.net","map.fastly.net","a.prod.fastly.net","global.prod.fastly.net","a.ssl.fastly.net","b.ssl.fastly.net","global.ssl.fastly.net","fastlylb.net","map.fastlylb.net","*.user.fm","fastvps-server.com","fastvps.host","myfast.host","fastvps.site","myfast.space","conn.uk","copro.uk","hosp.uk","fedorainfracloud.org","fedorapeople.org","cloud.fedoraproject.org","app.os.fedoraproject.org","app.os.stg.fedoraproject.org","mydobiss.com","fh-muenster.io","filegear.me","firebaseapp.com","fldrv.com","flutterflow.app","fly.dev","shw.io","edgeapp.net","forgeblocks.com","id.forgerock.io","framer.ai","framer.app","framercanvas.com","framer.media","framer.photos","framer.website","framer.wiki","0e.vc","freebox-os.com","freeboxos.com","fbx-os.fr","fbxos.fr","freebox-os.fr","freeboxos.fr","freedesktop.org","freemyip.com","*.frusky.de","wien.funkfeuer.at","daemon.asia","dix.asia","mydns.bz","0am.jp","0g0.jp","0j0.jp","0t0.jp","mydns.jp","pgw.jp","wjg.jp","keyword-on.net","live-on.net","server-on.net","mydns.tw","mydns.vc","*.futurecms.at","*.ex.futurecms.at","*.in.futurecms.at","futurehosting.at","futuremailing.at","*.ex.ortsinfo.at","*.kunden.ortsinfo.at","*.statics.cloud","aliases121.com","campaign.gov.uk","service.gov.uk","independent-commission.uk","independent-inquest.uk","independent-inquiry.uk","independent-panel.uk","independent-review.uk","public-inquiry.uk","royal-commission.uk","gehirn.ne.jp","usercontent.jp","gentapps.com","gentlentapis.com","lab.ms","cdn-edges.net","localcert.net","localhostcert.net","gsj.bz","githubusercontent.com","githubpreview.dev","github.io","gitlab.io","gitapp.si","gitpage.si","glitch.me","nog.community","co.ro","shop.ro","lolipop.io","angry.jp","babyblue.jp","babymilk.jp","backdrop.jp","bambina.jp","bitter.jp","blush.jp","boo.jp","boy.jp","boyfriend.jp","but.jp","candypop.jp","capoo.jp","catfood.jp","cheap.jp","chicappa.jp","chillout.jp","chips.jp","chowder.jp","chu.jp","ciao.jp","cocotte.jp","coolblog.jp","cranky.jp","cutegirl.jp","daa.jp","deca.jp","deci.jp","digick.jp","egoism.jp","fakefur.jp","fem.jp","flier.jp","floppy.jp","fool.jp","frenchkiss.jp","girlfriend.jp","girly.jp","gloomy.jp","gonna.jp","greater.jp","hacca.jp","heavy.jp","her.jp","hiho.jp","hippy.jp","holy.jp","hungry.jp","icurus.jp","itigo.jp","jellybean.jp","kikirara.jp","kill.jp","kilo.jp","kuron.jp","littlestar.jp","lolipopmc.jp","lolitapunk.jp","lomo.jp","lovepop.jp","lovesick.jp","main.jp","mods.jp","mond.jp","mongolian.jp","moo.jp","namaste.jp","nikita.jp","nobushi.jp","noor.jp","oops.jp","parallel.jp","parasite.jp","pecori.jp","peewee.jp","penne.jp","pepper.jp","perma.jp","pigboat.jp","pinoko.jp","punyu.jp","pupu.jp","pussycat.jp","pya.jp","raindrop.jp","readymade.jp","sadist.jp","schoolbus.jp","secret.jp","staba.jp","stripper.jp","sub.jp","sunnyday.jp","thick.jp","tonkotsu.jp","under.jp","upper.jp","velvet.jp","verse.jp","versus.jp","vivian.jp","watson.jp","weblike.jp","whitesnow.jp","zombie.jp","heteml.net","graphic.design","goip.de","blogspot.ae","blogspot.al","blogspot.am","*.hosted.app","*.run.app","web.app","blogspot.com.ar","blogspot.co.at","blogspot.com.au","blogspot.ba","blogspot.be","blogspot.bg","blogspot.bj","blogspot.com.br","blogspot.com.by","blogspot.ca","blogspot.cf","blogspot.ch","blogspot.cl","blogspot.com.co","*.0emm.com","appspot.com","*.r.appspot.com","blogspot.com","codespot.com","googleapis.com","googlecode.com","pagespeedmobilizer.com","withgoogle.com","withyoutube.com","blogspot.cv","blogspot.com.cy","blogspot.cz","blogspot.de","*.gateway.dev","blogspot.dk","blogspot.com.ee","blogspot.com.eg","blogspot.com.es","blogspot.fi","blogspot.fr","cloud.goog","translate.goog","*.usercontent.goog","blogspot.gr","blogspot.hk","blogspot.hr","blogspot.hu","blogspot.co.id","blogspot.ie","blogspot.co.il","blogspot.in","blogspot.is","blogspot.it","blogspot.jp","blogspot.co.ke","blogspot.kr","blogspot.li","blogspot.lt","blogspot.lu","blogspot.md","blogspot.mk","blogspot.com.mt","blogspot.mx","blogspot.my","cloudfunctions.net","blogspot.com.ng","blogspot.nl","blogspot.no","blogspot.co.nz","blogspot.pe","blogspot.pt","blogspot.qa","blogspot.re","blogspot.ro","blogspot.rs","blogspot.ru","blogspot.se","blogspot.sg","blogspot.si","blogspot.sk","blogspot.sn","blogspot.td","blogspot.com.tr","blogspot.tw","blogspot.ug","blogspot.co.uk","blogspot.com.uy","blogspot.vn","blogspot.co.za","goupile.fr","pymnt.uk","cloudapps.digital","london.cloudapps.digital","gov.nl","grafana-dev.net","grayjayleagues.com","günstigbestellen.de","günstigliefern.de","fin.ci","free.hr","caa.li","ua.rs","conf.se","häkkinen.fi","hrsn.dev","hashbang.sh","hasura.app","hasura-app.io","hatenablog.com","hatenadiary.com","hateblo.jp","hatenablog.jp","hatenadiary.jp","hatenadiary.org","pages.it.hs-heilbronn.de","pages-research.it.hs-heilbronn.de","heiyu.space","helioho.st","heliohost.us","hepforge.org","herokuapp.com","herokussl.com","heyflow.page","heyflow.site","ravendb.cloud","ravendb.community","development.run","ravendb.run","homesklep.pl","*.kin.one","*.id.pub","*.kin.pub","secaas.hk","hoplix.shop","orx.biz","biz.gl","biz.ng","co.biz.ng","dl.biz.ng","go.biz.ng","lg.biz.ng","on.biz.ng","col.ng","firm.ng","gen.ng","ltd.ng","ngo.ng","plc.ng","ie.ua","hostyhosting.io","hf.space","static.hf.space","hypernode.io","iobb.net","co.cz","*.moonscale.io","moonscale.net","gr.com","iki.fi","ibxos.it","iliadboxos.it","smushcdn.com","wphostedmail.com","wpmucdn.com","tempurl.host","wpmudev.host","dyn-berlin.de","in-berlin.de","in-brb.de","in-butter.de","in-dsl.de","in-vpn.de","in-dsl.net","in-vpn.net","in-dsl.org","in-vpn.org","biz.at","info.at","info.cx","ac.leg.br","al.leg.br","am.leg.br","ap.leg.br","ba.leg.br","ce.leg.br","df.leg.br","es.leg.br","go.leg.br","ma.leg.br","mg.leg.br","ms.leg.br","mt.leg.br","pa.leg.br","pb.leg.br","pe.leg.br","pi.leg.br","pr.leg.br","rj.leg.br","rn.leg.br","ro.leg.br","rr.leg.br","rs.leg.br","sc.leg.br","se.leg.br","sp.leg.br","to.leg.br","pixolino.com","na4u.ru","apps-1and1.com","live-website.com","apps-1and1.net","websitebuilder.online","app-ionos.space","iopsys.se","*.dweb.link","ipifony.net","ir.md","is-a-good.dev","is-a.dev","iservschule.de","mein-iserv.de","schulplattform.de","schulserver.de","test-iserv.de","iserv.dev","mel.cloudlets.com.au","cloud.interhostsolutions.be","alp1.ae.flow.ch","appengine.flow.ch","es-1.axarnet.cloud","diadem.cloud","vip.jelastic.cloud","jele.cloud","it1.eur.aruba.jenv-aruba.cloud","it1.jenv-aruba.cloud","keliweb.cloud","cs.keliweb.cloud","oxa.cloud","tn.oxa.cloud","uk.oxa.cloud","primetel.cloud","uk.primetel.cloud","ca.reclaim.cloud","uk.reclaim.cloud","us.reclaim.cloud","ch.trendhosting.cloud","de.trendhosting.cloud","jele.club","dopaas.com","paas.hosted-by-previder.com","rag-cloud.hosteur.com","rag-cloud-ch.hosteur.com","jcloud.ik-server.com","jcloud-ver-jpc.ik-server.com","demo.jelastic.com","paas.massivegrid.com","jed.wafaicloud.com","ryd.wafaicloud.com","j.scaleforce.com.cy","jelastic.dogado.eu","fi.cloudplatform.fi","demo.datacenter.fi","paas.datacenter.fi","jele.host","mircloud.host","paas.beebyte.io","sekd1.beebyteapp.io","jele.io","jc.neen.it","jcloud.kz","cloudjiffy.net","fra1-de.cloudjiffy.net","west1-us.cloudjiffy.net","jls-sto1.elastx.net","jls-sto2.elastx.net","jls-sto3.elastx.net","fr-1.paas.massivegrid.net","lon-1.paas.massivegrid.net","lon-2.paas.massivegrid.net","ny-1.paas.massivegrid.net","ny-2.paas.massivegrid.net","sg-1.paas.massivegrid.net","jelastic.saveincloud.net","nordeste-idc.saveincloud.net","j.scaleforce.net","sdscloud.pl","unicloud.pl","mircloud.ru","enscaled.sg","jele.site","jelastic.team","orangecloud.tn","j.layershift.co.uk","phx.enscaled.us","mircloud.us","myjino.ru","*.hosting.myjino.ru","*.landing.myjino.ru","*.spectrum.myjino.ru","*.vps.myjino.ru","jotelulu.cloud","webadorsite.com","jouwweb.site","*.cns.joyent.com","*.triton.zone","js.org","kaas.gg","khplay.nl","kapsi.fi","ezproxy.kuleuven.be","kuleuven.cloud","keymachine.de","kinghost.net","uni5.net","knightpoint.systems","koobin.events","webthings.io","krellian.net","oya.to","git-repos.de","lcube-server.de","svn-repos.de","leadpages.co","lpages.co","lpusercontent.com","lelux.site","libp2p.direct","runcontainers.dev","co.business","co.education","co.events","co.financial","co.network","co.place","co.technology","linkyard-cloud.ch","linkyard.cloud","members.linode.com","*.nodebalancer.linode.com","*.linodeobjects.com","ip.linodeusercontent.com","we.bs","filegear-sg.me","ggff.net","*.user.localcert.dev","lodz.pl","pabianice.pl","plock.pl","sieradz.pl","skierniewice.pl","zgierz.pl","loginline.app","loginline.dev","loginline.io","loginline.services","loginline.site","lohmus.me","servers.run","krasnik.pl","leczna.pl","lubartow.pl","lublin.pl","poniatowa.pl","swidnik.pl","glug.org.uk","lug.org.uk","lugs.org.uk","barsy.bg","barsy.club","barsycenter.com","barsyonline.com","barsy.de","barsy.dev","barsy.eu","barsy.gr","barsy.in","barsy.info","barsy.io","barsy.me","barsy.menu","barsyonline.menu","barsy.mobi","barsy.net","barsy.online","barsy.org","barsy.pro","barsy.pub","barsy.ro","barsy.rs","barsy.shop","barsyonline.shop","barsy.site","barsy.store","barsy.support","barsy.uk","barsy.co.uk","barsyonline.co.uk","*.magentosite.cloud","hb.cldmail.ru","matlab.cloud","modelscape.com","mwcloudnonprod.com","polyspace.com","mayfirst.info","mayfirst.org","mazeplay.com","mcdir.me","mcdir.ru","vps.mcdir.ru","mcpre.ru","mcpe.me","mediatech.by","mediatech.dev","hra.health","medusajs.app","miniserver.com","memset.net","messerli.app","atmeta.com","apps.fbsbx.com","*.cloud.metacentrum.cz","custom.metacentrum.cz","flt.cloud.muni.cz","usr.cloud.muni.cz","meteorapp.com","eu.meteorapp.com","co.pl","*.azurecontainer.io","azure-api.net","azure-mobile.net","azureedge.net","azurefd.net","azurestaticapps.net","1.azurestaticapps.net","2.azurestaticapps.net","3.azurestaticapps.net","4.azurestaticapps.net","5.azurestaticapps.net","6.azurestaticapps.net","7.azurestaticapps.net","centralus.azurestaticapps.net","eastasia.azurestaticapps.net","eastus2.azurestaticapps.net","westeurope.azurestaticapps.net","westus2.azurestaticapps.net","azurewebsites.net","cloudapp.net","trafficmanager.net","blob.core.windows.net","servicebus.windows.net","routingthecloud.com","sn.mynetname.net","routingthecloud.net","routingthecloud.org","csx.cc","mydbserver.com","webspaceconfig.de","mittwald.info","mittwaldserver.info","typo3server.info","project.space","modx.dev","bmoattachments.org","net.ru","org.ru","pp.ru","hostedpi.com","caracal.mythic-beasts.com","customer.mythic-beasts.com","fentiger.mythic-beasts.com","lynx.mythic-beasts.com","ocelot.mythic-beasts.com","oncilla.mythic-beasts.com","onza.mythic-beasts.com","sphinx.mythic-beasts.com","vs.mythic-beasts.com","x.mythic-beasts.com","yali.mythic-beasts.com","cust.retrosnub.co.uk","ui.nabu.casa","cloud.nospamproxy.com","netfy.app","netlify.app","4u.com","nfshost.com","ipfs.nftstorage.link","ngo.us","ngrok.app","ngrok-free.app","ngrok.dev","ngrok-free.dev","ngrok.io","ap.ngrok.io","au.ngrok.io","eu.ngrok.io","in.ngrok.io","jp.ngrok.io","sa.ngrok.io","us.ngrok.io","ngrok.pizza","ngrok.pro","torun.pl","nh-serv.co.uk","nimsite.uk","mmafan.biz","myftp.biz","no-ip.biz","no-ip.ca","fantasyleague.cc","gotdns.ch","3utilities.com","blogsyte.com","ciscofreak.com","damnserver.com","ddnsking.com","ditchyourip.com","dnsiskinky.com","dynns.com","geekgalaxy.com","health-carereform.com","homesecuritymac.com","homesecuritypc.com","myactivedirectory.com","mysecuritycamera.com","myvnc.com","net-freaks.com","onthewifi.com","point2this.com","quicksytes.com","securitytactics.com","servebeer.com","servecounterstrike.com","serveexchange.com","serveftp.com","servegame.com","servehalflife.com","servehttp.com","servehumour.com","serveirc.com","servemp3.com","servep2p.com","servepics.com","servequake.com","servesarcasm.com","stufftoread.com","unusualperson.com","workisboring.com","dvrcam.info","ilovecollege.info","no-ip.info","brasilia.me","ddns.me","dnsfor.me","hopto.me","loginto.me","noip.me","webhop.me","bounceme.net","ddns.net","eating-organic.net","mydissent.net","myeffect.net","mymediapc.net","mypsx.net","mysecuritycamera.net","nhlfan.net","no-ip.net","pgafan.net","privatizehealthinsurance.net","redirectme.net","serveblog.net","serveminecraft.net","sytes.net","cable-modem.org","collegefan.org","couchpotatofries.org","hopto.org","mlbfan.org","myftp.org","mysecuritycamera.org","nflfan.org","no-ip.org","read-books.org","ufcfan.org","zapto.org","no-ip.co.uk","golffan.us","noip.us","pointto.us","stage.nodeart.io","*.developer.app","noop.app","*.northflank.app","*.build.run","*.code.run","*.database.run","*.migration.run","noticeable.news","notion.site","dnsking.ch","mypi.co","n4t.co","001www.com","myiphost.com","forumz.info","soundcast.me","tcp4.me","dnsup.net","hicam.net","now-dns.net","ownip.net","vpndns.net","dynserv.org","now-dns.org","x443.pw","now-dns.top","ntdll.top","freeddns.us","nsupdate.info","nerdpol.ovh","nyc.mn","prvcy.page","obl.ong","observablehq.cloud","static.observableusercontent.com","omg.lol","cloudycluster.net","omniwe.site","123webseite.at","123website.be","simplesite.com.br","123website.ch","simplesite.com","123webseite.de","123hjemmeside.dk","123miweb.es","123kotisivu.fi","123siteweb.fr","simplesite.gr","123homepage.it","123website.lu","123website.nl","123hjemmeside.no","service.one","simplesite.pl","123paginaweb.pt","123minsida.se","is-a-fullstack.dev","is-cool.dev","is-not-a.dev","localplayer.dev","is-local.org","opensocial.site","opencraft.hosting","16-b.it","32-b.it","64-b.it","orsites.com","operaunite.com","*.customer-oci.com","*.oci.customer-oci.com","*.ocp.customer-oci.com","*.ocs.customer-oci.com","*.oraclecloudapps.com","*.oraclegovcloudapps.com","*.oraclegovcloudapps.uk","tech.orange","can.re","authgear-staging.com","authgearapps.com","skygearapp.com","outsystemscloud.com","*.hosting.ovh.net","*.webpaas.ovh.net","ownprovider.com","own.pm","*.owo.codes","ox.rs","oy.lc","pgfog.com","pagexl.com","gotpantheon.com","pantheonsite.io","*.paywhirl.com","*.xmit.co","xmit.dev","madethis.site","srv.us","gh.srv.us","gl.srv.us","lk3.ru","mypep.link","perspecta.cloud","on-web.fr","*.upsun.app","upsunapp.com","ent.platform.sh","eu.platform.sh","us.platform.sh","*.platformsh.site","*.tst.site","platter-app.com","platter-app.dev","platterp.us","pley.games","onporter.run","co.bn","postman-echo.com","pstmn.io","mock.pstmn.io","httpbin.org","prequalifyme.today","xen.prgmr.com","priv.at","protonet.io","chirurgiens-dentistes-en-france.fr","byen.site","pubtls.org","pythonanywhere.com","eu.pythonanywhere.com","qa2.com","qcx.io","*.sys.qcx.io","myqnapcloud.cn","alpha-myqnapcloud.com","dev-myqnapcloud.com","mycloudnas.com","mynascloud.com","myqnapcloud.com","qoto.io","qualifioapp.com","ladesk.com","qbuser.com","*.quipelements.com","vapor.cloud","vaporcloud.io","rackmaze.com","rackmaze.net","cloudsite.builders","myradweb.net","servername.us","web.in","in.net","myrdbx.io","site.rb-hosting.io","*.on-rancher.cloud","*.on-k3s.io","*.on-rio.io","ravpage.co.il","readthedocs-hosted.com","readthedocs.io","rhcloud.com","instances.spawn.cc","onrender.com","app.render.com","replit.app","id.replit.app","firewalledreplit.co","id.firewalledreplit.co","repl.co","id.repl.co","replit.dev","archer.replit.dev","bones.replit.dev","canary.replit.dev","global.replit.dev","hacker.replit.dev","id.replit.dev","janeway.replit.dev","kim.replit.dev","kira.replit.dev","kirk.replit.dev","odo.replit.dev","paris.replit.dev","picard.replit.dev","pike.replit.dev","prerelease.replit.dev","reed.replit.dev","riker.replit.dev","sisko.replit.dev","spock.replit.dev","staging.replit.dev","sulu.replit.dev","tarpit.replit.dev","teams.replit.dev","tucker.replit.dev","wesley.replit.dev","worf.replit.dev","repl.run","resindevice.io","devices.resinstaging.io","hzc.io","adimo.co.uk","itcouldbewor.se","aus.basketball","nz.basketball","git-pages.rit.edu","rocky.page","биз.рус","ком.рус","крым.рус","мир.рус","мск.рус","орг.рус","самара.рус","сочи.рус","спб.рус","я.рус","ras.ru","nyat.app","180r.com","dojin.com","sakuratan.com","sakuraweb.com","x0.com","2-d.jp","bona.jp","crap.jp","daynight.jp","eek.jp","flop.jp","halfmoon.jp","jeez.jp","matrix.jp","mimoza.jp","ivory.ne.jp","mail-box.ne.jp","mints.ne.jp","mokuren.ne.jp","opal.ne.jp","sakura.ne.jp","sumomo.ne.jp","topaz.ne.jp","netgamers.jp","nyanta.jp","o0o0.jp","rdy.jp","rgr.jp","rulez.jp","s3.isk01.sakurastorage.jp","s3.isk02.sakurastorage.jp","saloon.jp","sblo.jp","skr.jp","tank.jp","uh-oh.jp","undo.jp","rs.webaccel.jp","user.webaccel.jp","websozai.jp","xii.jp","squares.net","jpn.org","kirara.st","x0.to","from.tv","sakura.tv","*.builder.code.com","*.dev-builder.code.com","*.stg-builder.code.com","*.001.test.code-builder-stg.platform.salesforce.com","*.d.crm.dev","*.w.crm.dev","*.wa.crm.dev","*.wb.crm.dev","*.wc.crm.dev","*.wd.crm.dev","*.we.crm.dev","*.wf.crm.dev","sandcats.io","logoip.com","logoip.de","fr-par-1.baremetal.scw.cloud","fr-par-2.baremetal.scw.cloud","nl-ams-1.baremetal.scw.cloud","cockpit.fr-par.scw.cloud","fnc.fr-par.scw.cloud","functions.fnc.fr-par.scw.cloud","k8s.fr-par.scw.cloud","nodes.k8s.fr-par.scw.cloud","s3.fr-par.scw.cloud","s3-website.fr-par.scw.cloud","whm.fr-par.scw.cloud","priv.instances.scw.cloud","pub.instances.scw.cloud","k8s.scw.cloud","cockpit.nl-ams.scw.cloud","k8s.nl-ams.scw.cloud","nodes.k8s.nl-ams.scw.cloud","s3.nl-ams.scw.cloud","s3-website.nl-ams.scw.cloud","whm.nl-ams.scw.cloud","cockpit.pl-waw.scw.cloud","k8s.pl-waw.scw.cloud","nodes.k8s.pl-waw.scw.cloud","s3.pl-waw.scw.cloud","s3-website.pl-waw.scw.cloud","scalebook.scw.cloud","smartlabeling.scw.cloud","dedibox.fr","schokokeks.net","gov.scot","service.gov.scot","scrysec.com","client.scrypted.io","firewall-gateway.com","firewall-gateway.de","my-gateway.de","my-router.de","spdns.de","spdns.eu","firewall-gateway.net","my-firewall.org","myfirewall.org","spdns.org","seidat.net","sellfy.store","minisite.ms","senseering.net","servebolt.cloud","biz.ua","co.ua","pp.ua","as.sh.cn","sheezy.games","shiftedit.io","myshopblocks.com","myshopify.com","shopitsite.com","shopware.shop","shopware.store","mo-siemens.io","1kapp.com","appchizi.com","applinzi.com","sinaapp.com","vipsinaapp.com","siteleaf.net","small-web.org","aeroport.fr","avocat.fr","chambagri.fr","chirurgiens-dentistes.fr","experts-comptables.fr","medecin.fr","notaires.fr","pharmacien.fr","port.fr","veterinaire.fr","vp4.me","*.snowflake.app","*.privatelink.snowflake.app","streamlit.app","streamlitapp.com","try-snowplow.com","mafelo.net","playstation-cloud.com","srht.site","apps.lair.io","*.stolos.io","spacekit.io","ind.mom","customer.speedpartner.de","myspreadshop.at","myspreadshop.com.au","myspreadshop.be","myspreadshop.ca","myspreadshop.ch","myspreadshop.com","myspreadshop.de","myspreadshop.dk","myspreadshop.es","myspreadshop.fi","myspreadshop.fr","myspreadshop.ie","myspreadshop.it","myspreadshop.net","myspreadshop.nl","myspreadshop.no","myspreadshop.pl","myspreadshop.se","myspreadshop.co.uk","w-corp-staticblitz.com","w-credentialless-staticblitz.com","w-staticblitz.com","stackhero-network.com","runs.onstackit.cloud","stackit.gg","stackit.rocks","stackit.run","stackit.zone","musician.io","novecore.site","api.stdlib.com","feedback.ac","forms.ac","assessments.cx","calculators.cx","funnels.cx","paynow.cx","quizzes.cx","researched.cx","tests.cx","surveys.so","storebase.store","storipress.app","storj.farm","strapiapp.com","media.strapiapp.com","vps-host.net","atl.jelastic.vps-host.net","njs.jelastic.vps-host.net","ric.jelastic.vps-host.net","streak-link.com","streaklinks.com","streakusercontent.com","soc.srcf.net","user.srcf.net","utwente.io","temp-dns.com","supabase.co","supabase.in","supabase.net","syncloud.it","dscloud.biz","direct.quickconnect.cn","dsmynas.com","familyds.com","diskstation.me","dscloud.me","i234.me","myds.me","synology.me","dscloud.mobi","dsmynas.net","familyds.net","dsmynas.org","familyds.org","direct.quickconnect.to","vpnplus.to","mytabit.com","mytabit.co.il","tabitorder.co.il","taifun-dns.de","ts.net","*.c.ts.net","gda.pl","gdansk.pl","gdynia.pl","med.pl","sopot.pl","taveusercontent.com","p.tawk.email","p.tawkto.email","site.tb-hosting.com","edugit.io","s3.teckids.org","telebit.app","telebit.io","*.telebit.xyz","*.firenet.ch","*.svc.firenet.ch","reservd.com","thingdustdata.com","cust.dev.thingdust.io","reservd.dev.thingdust.io","cust.disrec.thingdust.io","reservd.disrec.thingdust.io","cust.prod.thingdust.io","cust.testing.thingdust.io","reservd.testing.thingdust.io","tickets.io","arvo.network","azimuth.network","tlon.network","torproject.net","pages.torproject.net","townnews-staging.com","12hp.at","2ix.at","4lima.at","lima-city.at","12hp.ch","2ix.ch","4lima.ch","lima-city.ch","trafficplex.cloud","de.cool","12hp.de","2ix.de","4lima.de","lima-city.de","1337.pictures","clan.rip","lima-city.rocks","webspace.rocks","lima.zone","*.transurl.be","*.transurl.eu","site.transip.me","*.transurl.nl","tuxfamily.org","dd-dns.de","dray-dns.de","draydns.de","dyn-vpn.de","dynvpn.de","mein-vigor.de","my-vigor.de","my-wan.de","syno-ds.de","synology-diskstation.de","synology-ds.de","diskstation.eu","diskstation.org","typedream.app","pro.typeform.com","*.uberspace.de","uber.space","hk.com","inc.hk","ltd.hk","hk.org","it.com","unison-services.cloud","virtual-user.de","virtualuser.de","name.pm","sch.tf","biz.wf","sch.wf","org.yt","rs.ba","bielsko.pl","upli.io","urown.cloud","dnsupdate.info","us.org","v.ua","express.val.run","web.val.run","vercel.app","v0.build","vercel.dev","vusercontent.net","now.sh","2038.io","router.management","v-info.info","voorloper.cloud","*.vultrobjects.com","wafflecell.com","webflow.io","webflowtest.io","*.webhare.dev","bookonline.app","hotelwithflight.com","reserve-online.com","reserve-online.net","cprapid.com","pleskns.com","wp2.host","pdns.page","plesk.page","wpsquared.site","*.wadl.top","remotewd.com","box.ca","pages.wiardweb.com","toolforge.org","wmcloud.org","wmflabs.org","wdh.app","panel.gg","daemon.panel.gg","wixsite.com","wixstudio.com","editorx.io","wixstudio.io","wix.run","messwithdns.com","woltlab-demo.com","myforum.community","community-pro.de","diskussionsbereich.de","community-pro.net","meinforum.net","affinitylottery.org.uk","raffleentry.org.uk","weeklylottery.org.uk","wpenginepowered.com","js.wpenginepowered.com","half.host","xnbay.com","u2.xnbay.com","u2-local.xnbay.com","cistron.nl","demon.nl","xs4all.space","yandexcloud.net","storage.yandexcloud.net","website.yandexcloud.net","official.academy","yolasite.com","yombo.me","ynh.fr","nohost.me","noho.st","za.net","za.org","zap.cloud","zeabur.app","bss.design","basicserver.io","virtualserver.io","enterprisecloud.nu"];var d={};d.rules=Z.map(function(a){return {rule:a,suffix:a.replace(/^(\*\.|\!)/,""),punySuffix:-1,wildcard:a.charAt(0)==="*",exception:a.charAt(0)==="!"}});d.endsWith=function(a,s){return a.indexOf(s,a.length-s.length)!==-1};d.findRule=function(a){var s=v.toASCII(a);return d.rules.reduce(function(e,o){return o.punySuffix===-1&&(o.punySuffix=v.toASCII(o.suffix)),!d.endsWith(s,"."+o.punySuffix)&&s!==o.punySuffix?e:o},null)};const B={DOMAIN_TOO_SHORT:"Domain name too short.",DOMAIN_TOO_LONG:"Domain name too long. It should be no more than 255 chars.",LABEL_STARTS_WITH_DASH:"Domain name label can not start with a dash.",LABEL_ENDS_WITH_DASH:"Domain name label can not end with a dash.",LABEL_TOO_LONG:"Domain name label should be at most 63 chars long.",LABEL_TOO_SHORT:"Domain name label should be at least 1 character long.",LABEL_INVALID_CHARS:"Domain name label can only contain alphanumeric characters or dashes."};d.validate=function(a){var s=v.toASCII(a);if(s.length<1)return "DOMAIN_TOO_SHORT";if(s.length>255)return "DOMAIN_TOO_LONG";for(var e=s.split("."),o,i=0;i<e.length;++i){if(o=e[i],!o.length)return "LABEL_TOO_SHORT";if(o.length>63)return "LABEL_TOO_LONG";if(o.charAt(0)==="-")return "LABEL_STARTS_WITH_DASH";if(o.charAt(o.length-1)==="-")return "LABEL_ENDS_WITH_DASH";if(!/^[a-z0-9\-]+$/.test(o))return "LABEL_INVALID_CHARS"}};const f=function(a){if(typeof a!="string")throw new TypeError("Domain name must be a string.");var s=a.slice(0).toLowerCase();s.charAt(s.length-1)==="."&&(s=s.slice(0,s.length-1));var e=d.validate(s);if(e)return {input:a,error:{message:B[e],code:e}};var o={input:a,tld:null,sld:null,domain:null,subdomain:null,listed:!1},i=s.split(".");if(i[i.length-1]==="local")return o;var n=function(){return /xn--/.test(s)&&(o.domain&&(o.domain=v.toASCII(o.domain)),o.subdomain&&(o.subdomain=v.toASCII(o.subdomain))),o},r=d.findRule(s);if(!r)return i.length<2?o:(o.tld=i.pop(),o.sld=i.pop(),o.domain=[o.sld,o.tld].join("."),i.length&&(o.subdomain=i.pop()),n());o.listed=!0;var t=r.suffix.split("."),m=i.slice(0,i.length-t.length);return r.exception&&m.push(t.shift()),o.tld=t.join("."),!m.length||(r.wildcard&&(t.unshift(m.pop()),o.tld=t.join(".")),!m.length)||(o.sld=m.pop(),o.domain=[o.sld,o.tld].join("."),m.length&&(o.subdomain=m.join("."))),n()},M=function(a){return a&&f(a).domain||null},F=function(a){var s=f(a);return !!(s.domain&&s.listed)},aa={parse:f,get:M,isValid:F};exports.default=aa;exports.errorCodes=B;exports.get=M;exports.isValid=F;exports.parse=f; 
	} (psl));
	return psl;
}

/*!
 * Copyright (c) 2018, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

var hasRequiredPubsuffixPsl;

function requirePubsuffixPsl () {
	if (hasRequiredPubsuffixPsl) return pubsuffixPsl;
	hasRequiredPubsuffixPsl = 1;
	var psl = requirePsl();

	function getPublicSuffix(domain) {
	  return psl.get(domain);
	}

	pubsuffixPsl.getPublicSuffix = getPublicSuffix;
	return pubsuffixPsl;
}

var store = {};

/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

var hasRequiredStore;

function requireStore () {
	if (hasRequiredStore) return store;
	hasRequiredStore = 1;
	/*jshint unused:false */

	function Store() {
	}
	store.Store = Store;

	// Stores may be synchronous, but are still required to use a
	// Continuation-Passing Style API.  The CookieJar itself will expose a "*Sync"
	// API that converts from synchronous-callbacks to imperative style.
	Store.prototype.synchronous = false;

	Store.prototype.findCookie = function(domain, path, key, cb) {
	  throw new Error('findCookie is not implemented');
	};

	Store.prototype.findCookies = function(domain, path, cb) {
	  throw new Error('findCookies is not implemented');
	};

	Store.prototype.putCookie = function(cookie, cb) {
	  throw new Error('putCookie is not implemented');
	};

	Store.prototype.updateCookie = function(oldCookie, newCookie, cb) {
	  // recommended default implementation:
	  // return this.putCookie(newCookie, cb);
	  throw new Error('updateCookie is not implemented');
	};

	Store.prototype.removeCookie = function(domain, path, key, cb) {
	  throw new Error('removeCookie is not implemented');
	};

	Store.prototype.removeCookies = function(domain, path, cb) {
	  throw new Error('removeCookies is not implemented');
	};

	Store.prototype.removeAllCookies = function(cb) {
	  throw new Error('removeAllCookies is not implemented');
	};

	Store.prototype.getAllCookies = function(cb) {
	  throw new Error('getAllCookies is not implemented (therefore jar cannot be serialized)');
	};
	return store;
}

var memstore = {};

var permuteDomain = {};

/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

var hasRequiredPermuteDomain;

function requirePermuteDomain () {
	if (hasRequiredPermuteDomain) return permuteDomain;
	hasRequiredPermuteDomain = 1;
	var pubsuffix = requirePubsuffixPsl();

	// Gives the permutation of all possible domainMatch()es of a given domain. The
	// array is in shortest-to-longest order.  Handy for indexing.
	function permuteDomain$1 (domain) {
	  var pubSuf = pubsuffix.getPublicSuffix(domain);
	  if (!pubSuf) {
	    return null;
	  }
	  if (pubSuf == domain) {
	    return [domain];
	  }

	  var prefix = domain.slice(0, -(pubSuf.length + 1)); // ".example.com"
	  var parts = prefix.split('.').reverse();
	  var cur = pubSuf;
	  var permutations = [cur];
	  while (parts.length) {
	    cur = parts.shift() + '.' + cur;
	    permutations.push(cur);
	  }
	  return permutations;
	}

	permuteDomain.permuteDomain = permuteDomain$1;
	return permuteDomain;
}

var pathMatch = {};

/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

var hasRequiredPathMatch;

function requirePathMatch () {
	if (hasRequiredPathMatch) return pathMatch;
	hasRequiredPathMatch = 1;
	/*
	 * "A request-path path-matches a given cookie-path if at least one of the
	 * following conditions holds:"
	 */
	function pathMatch$1 (reqPath, cookiePath) {
	  // "o  The cookie-path and the request-path are identical."
	  if (cookiePath === reqPath) {
	    return true;
	  }

	  var idx = reqPath.indexOf(cookiePath);
	  if (idx === 0) {
	    // "o  The cookie-path is a prefix of the request-path, and the last
	    // character of the cookie-path is %x2F ("/")."
	    if (cookiePath.substr(-1) === "/") {
	      return true;
	    }

	    // " o  The cookie-path is a prefix of the request-path, and the first
	    // character of the request-path that is not included in the cookie- path
	    // is a %x2F ("/") character."
	    if (reqPath.substr(cookiePath.length, 1) === "/") {
	      return true;
	    }
	  }

	  return false;
	}

	pathMatch.pathMatch = pathMatch$1;
	return pathMatch;
}

/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

var hasRequiredMemstore;

function requireMemstore () {
	if (hasRequiredMemstore) return memstore;
	hasRequiredMemstore = 1;
	var Store = requireStore().Store;
	var permuteDomain = requirePermuteDomain().permuteDomain;
	var pathMatch = requirePathMatch().pathMatch;
	var util = require$$1$2;

	function MemoryCookieStore() {
	  Store.call(this);
	  this.idx = {};
	}
	util.inherits(MemoryCookieStore, Store);
	memstore.MemoryCookieStore = MemoryCookieStore;
	MemoryCookieStore.prototype.idx = null;

	// Since it's just a struct in RAM, this Store is synchronous
	MemoryCookieStore.prototype.synchronous = true;

	// force a default depth:
	MemoryCookieStore.prototype.inspect = function() {
	  return "{ idx: "+util.inspect(this.idx, false, 2)+' }';
	};

	// Use the new custom inspection symbol to add the custom inspect function if
	// available.
	if (util.inspect.custom) {
	  MemoryCookieStore.prototype[util.inspect.custom] = MemoryCookieStore.prototype.inspect;
	}

	MemoryCookieStore.prototype.findCookie = function(domain, path, key, cb) {
	  if (!this.idx[domain]) {
	    return cb(null,undefined);
	  }
	  if (!this.idx[domain][path]) {
	    return cb(null,undefined);
	  }
	  return cb(null,this.idx[domain][path][key]||null);
	};

	MemoryCookieStore.prototype.findCookies = function(domain, path, cb) {
	  var results = [];
	  if (!domain) {
	    return cb(null,[]);
	  }

	  var pathMatcher;
	  if (!path) {
	    // null means "all paths"
	    pathMatcher = function matchAll(domainIndex) {
	      for (var curPath in domainIndex) {
	        var pathIndex = domainIndex[curPath];
	        for (var key in pathIndex) {
	          results.push(pathIndex[key]);
	        }
	      }
	    };

	  } else {
	    pathMatcher = function matchRFC(domainIndex) {
	       //NOTE: we should use path-match algorithm from S5.1.4 here
	       //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)
	       Object.keys(domainIndex).forEach(function (cookiePath) {
	         if (pathMatch(path, cookiePath)) {
	           var pathIndex = domainIndex[cookiePath];

	           for (var key in pathIndex) {
	             results.push(pathIndex[key]);
	           }
	         }
	       });
	     };
	  }

	  var domains = permuteDomain(domain) || [domain];
	  var idx = this.idx;
	  domains.forEach(function(curDomain) {
	    var domainIndex = idx[curDomain];
	    if (!domainIndex) {
	      return;
	    }
	    pathMatcher(domainIndex);
	  });

	  cb(null,results);
	};

	MemoryCookieStore.prototype.putCookie = function(cookie, cb) {
	  if (!this.idx[cookie.domain]) {
	    this.idx[cookie.domain] = {};
	  }
	  if (!this.idx[cookie.domain][cookie.path]) {
	    this.idx[cookie.domain][cookie.path] = {};
	  }
	  this.idx[cookie.domain][cookie.path][cookie.key] = cookie;
	  cb(null);
	};

	MemoryCookieStore.prototype.updateCookie = function(oldCookie, newCookie, cb) {
	  // updateCookie() may avoid updating cookies that are identical.  For example,
	  // lastAccessed may not be important to some stores and an equality
	  // comparison could exclude that field.
	  this.putCookie(newCookie,cb);
	};

	MemoryCookieStore.prototype.removeCookie = function(domain, path, key, cb) {
	  if (this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key]) {
	    delete this.idx[domain][path][key];
	  }
	  cb(null);
	};

	MemoryCookieStore.prototype.removeCookies = function(domain, path, cb) {
	  if (this.idx[domain]) {
	    if (path) {
	      delete this.idx[domain][path];
	    } else {
	      delete this.idx[domain];
	    }
	  }
	  return cb(null);
	};

	MemoryCookieStore.prototype.removeAllCookies = function(cb) {
	  this.idx = {};
	  return cb(null);
	};

	MemoryCookieStore.prototype.getAllCookies = function(cb) {
	  var cookies = [];
	  var idx = this.idx;

	  var domains = Object.keys(idx);
	  domains.forEach(function(domain) {
	    var paths = Object.keys(idx[domain]);
	    paths.forEach(function(path) {
	      var keys = Object.keys(idx[domain][path]);
	      keys.forEach(function(key) {
	        if (key !== null) {
	          cookies.push(idx[domain][path][key]);
	        }
	      });
	    });
	  });

	  // Sort by creationIndex so deserializing retains the creation order.
	  // When implementing your own store, this SHOULD retain the order too
	  cookies.sort(function(a,b) {
	    return (a.creationIndex||0) - (b.creationIndex||0);
	  });

	  cb(null, cookies);
	};
	return memstore;
}

var version$2;
var hasRequiredVersion;

function requireVersion () {
	if (hasRequiredVersion) return version$2;
	hasRequiredVersion = 1;
	// generated by genversion
	version$2 = '2.5.0';
	return version$2;
}

/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

var hasRequiredCookie;

function requireCookie () {
	if (hasRequiredCookie) return cookie;
	hasRequiredCookie = 1;
	var net = require$$0$3;
	var urlParse = require$$0$2.parse;
	var util = require$$1$2;
	var pubsuffix = requirePubsuffixPsl();
	var Store = requireStore().Store;
	var MemoryCookieStore = requireMemstore().MemoryCookieStore;
	var pathMatch = requirePathMatch().pathMatch;
	var VERSION = requireVersion();

	var punycode;
	try {
	  punycode = require('punycode');
	} catch(e) {
	  console.warn("tough-cookie: can't load punycode; won't use punycode for domain normalization");
	}

	// From RFC6265 S4.1.1
	// note that it excludes \x3B ";"
	var COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;

	var CONTROL_CHARS = /[\x00-\x1F]/;

	// From Chromium // '\r', '\n' and '\0' should be treated as a terminator in
	// the "relaxed" mode, see:
	// https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/parsed_cookie.cc#L60
	var TERMINATORS = ['\n', '\r', '\0'];

	// RFC6265 S4.1.1 defines path value as 'any CHAR except CTLs or ";"'
	// Note ';' is \x3B
	var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;

	// date-time parsing constants (RFC6265 S5.1.1)

	var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;

	var MONTH_TO_NUM = {
	  jan:0, feb:1, mar:2, apr:3, may:4, jun:5,
	  jul:6, aug:7, sep:8, oct:9, nov:10, dec:11
	};
	var NUM_TO_MONTH = [
	  'Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'
	];
	var NUM_TO_DAY = [
	  'Sun','Mon','Tue','Wed','Thu','Fri','Sat'
	];

	var MAX_TIME = 2147483647000; // 31-bit max
	var MIN_TIME = 0; // 31-bit min

	/*
	 * Parses a Natural number (i.e., non-negative integer) with either the
	 *    <min>*<max>DIGIT ( non-digit *OCTET )
	 * or
	 *    <min>*<max>DIGIT
	 * grammar (RFC6265 S5.1.1).
	 *
	 * The "trailingOK" boolean controls if the grammar accepts a
	 * "( non-digit *OCTET )" trailer.
	 */
	function parseDigits(token, minDigits, maxDigits, trailingOK) {
	  var count = 0;
	  while (count < token.length) {
	    var c = token.charCodeAt(count);
	    // "non-digit = %x00-2F / %x3A-FF"
	    if (c <= 0x2F || c >= 0x3A) {
	      break;
	    }
	    count++;
	  }

	  // constrain to a minimum and maximum number of digits.
	  if (count < minDigits || count > maxDigits) {
	    return null;
	  }

	  if (!trailingOK && count != token.length) {
	    return null;
	  }

	  return parseInt(token.substr(0,count), 10);
	}

	function parseTime(token) {
	  var parts = token.split(':');
	  var result = [0,0,0];

	  /* RF6256 S5.1.1:
	   *      time            = hms-time ( non-digit *OCTET )
	   *      hms-time        = time-field ":" time-field ":" time-field
	   *      time-field      = 1*2DIGIT
	   */

	  if (parts.length !== 3) {
	    return null;
	  }

	  for (var i = 0; i < 3; i++) {
	    // "time-field" must be strictly "1*2DIGIT", HOWEVER, "hms-time" can be
	    // followed by "( non-digit *OCTET )" so therefore the last time-field can
	    // have a trailer
	    var trailingOK = (i == 2);
	    var num = parseDigits(parts[i], 1, 2, trailingOK);
	    if (num === null) {
	      return null;
	    }
	    result[i] = num;
	  }

	  return result;
	}

	function parseMonth(token) {
	  token = String(token).substr(0,3).toLowerCase();
	  var num = MONTH_TO_NUM[token];
	  return num >= 0 ? num : null;
	}

	/*
	 * RFC6265 S5.1.1 date parser (see RFC for full grammar)
	 */
	function parseDate(str) {
	  if (!str) {
	    return;
	  }

	  /* RFC6265 S5.1.1:
	   * 2. Process each date-token sequentially in the order the date-tokens
	   * appear in the cookie-date
	   */
	  var tokens = str.split(DATE_DELIM);
	  if (!tokens) {
	    return;
	  }

	  var hour = null;
	  var minute = null;
	  var second = null;
	  var dayOfMonth = null;
	  var month = null;
	  var year = null;

	  for (var i=0; i<tokens.length; i++) {
	    var token = tokens[i].trim();
	    if (!token.length) {
	      continue;
	    }

	    var result;

	    /* 2.1. If the found-time flag is not set and the token matches the time
	     * production, set the found-time flag and set the hour- value,
	     * minute-value, and second-value to the numbers denoted by the digits in
	     * the date-token, respectively.  Skip the remaining sub-steps and continue
	     * to the next date-token.
	     */
	    if (second === null) {
	      result = parseTime(token);
	      if (result) {
	        hour = result[0];
	        minute = result[1];
	        second = result[2];
	        continue;
	      }
	    }

	    /* 2.2. If the found-day-of-month flag is not set and the date-token matches
	     * the day-of-month production, set the found-day-of- month flag and set
	     * the day-of-month-value to the number denoted by the date-token.  Skip
	     * the remaining sub-steps and continue to the next date-token.
	     */
	    if (dayOfMonth === null) {
	      // "day-of-month = 1*2DIGIT ( non-digit *OCTET )"
	      result = parseDigits(token, 1, 2, true);
	      if (result !== null) {
	        dayOfMonth = result;
	        continue;
	      }
	    }

	    /* 2.3. If the found-month flag is not set and the date-token matches the
	     * month production, set the found-month flag and set the month-value to
	     * the month denoted by the date-token.  Skip the remaining sub-steps and
	     * continue to the next date-token.
	     */
	    if (month === null) {
	      result = parseMonth(token);
	      if (result !== null) {
	        month = result;
	        continue;
	      }
	    }

	    /* 2.4. If the found-year flag is not set and the date-token matches the
	     * year production, set the found-year flag and set the year-value to the
	     * number denoted by the date-token.  Skip the remaining sub-steps and
	     * continue to the next date-token.
	     */
	    if (year === null) {
	      // "year = 2*4DIGIT ( non-digit *OCTET )"
	      result = parseDigits(token, 2, 4, true);
	      if (result !== null) {
	        year = result;
	        /* From S5.1.1:
	         * 3.  If the year-value is greater than or equal to 70 and less
	         * than or equal to 99, increment the year-value by 1900.
	         * 4.  If the year-value is greater than or equal to 0 and less
	         * than or equal to 69, increment the year-value by 2000.
	         */
	        if (year >= 70 && year <= 99) {
	          year += 1900;
	        } else if (year >= 0 && year <= 69) {
	          year += 2000;
	        }
	      }
	    }
	  }

	  /* RFC 6265 S5.1.1
	   * "5. Abort these steps and fail to parse the cookie-date if:
	   *     *  at least one of the found-day-of-month, found-month, found-
	   *        year, or found-time flags is not set,
	   *     *  the day-of-month-value is less than 1 or greater than 31,
	   *     *  the year-value is less than 1601,
	   *     *  the hour-value is greater than 23,
	   *     *  the minute-value is greater than 59, or
	   *     *  the second-value is greater than 59.
	   *     (Note that leap seconds cannot be represented in this syntax.)"
	   *
	   * So, in order as above:
	   */
	  if (
	    dayOfMonth === null || month === null || year === null || second === null ||
	    dayOfMonth < 1 || dayOfMonth > 31 ||
	    year < 1601 ||
	    hour > 23 ||
	    minute > 59 ||
	    second > 59
	  ) {
	    return;
	  }

	  return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
	}

	function formatDate(date) {
	  var d = date.getUTCDate(); d = d >= 10 ? d : '0'+d;
	  var h = date.getUTCHours(); h = h >= 10 ? h : '0'+h;
	  var m = date.getUTCMinutes(); m = m >= 10 ? m : '0'+m;
	  var s = date.getUTCSeconds(); s = s >= 10 ? s : '0'+s;
	  return NUM_TO_DAY[date.getUTCDay()] + ', ' +
	    d+' '+ NUM_TO_MONTH[date.getUTCMonth()] +' '+ date.getUTCFullYear() +' '+
	    h+':'+m+':'+s+' GMT';
	}

	// S5.1.2 Canonicalized Host Names
	function canonicalDomain(str) {
	  if (str == null) {
	    return null;
	  }
	  str = str.trim().replace(/^\./,''); // S4.1.2.3 & S5.2.3: ignore leading .

	  // convert to IDN if any non-ASCII characters
	  if (punycode && /[^\u0001-\u007f]/.test(str)) {
	    str = punycode.toASCII(str);
	  }

	  return str.toLowerCase();
	}

	// S5.1.3 Domain Matching
	function domainMatch(str, domStr, canonicalize) {
	  if (str == null || domStr == null) {
	    return null;
	  }
	  if (canonicalize !== false) {
	    str = canonicalDomain(str);
	    domStr = canonicalDomain(domStr);
	  }

	  /*
	   * "The domain string and the string are identical. (Note that both the
	   * domain string and the string will have been canonicalized to lower case at
	   * this point)"
	   */
	  if (str == domStr) {
	    return true;
	  }

	  /* "All of the following [three] conditions hold:" (order adjusted from the RFC) */

	  /* "* The string is a host name (i.e., not an IP address)." */
	  if (net.isIP(str)) {
	    return false;
	  }

	  /* "* The domain string is a suffix of the string" */
	  var idx = str.indexOf(domStr);
	  if (idx <= 0) {
	    return false; // it's a non-match (-1) or prefix (0)
	  }

	  // e.g "a.b.c".indexOf("b.c") === 2
	  // 5 === 3+2
	  if (str.length !== domStr.length + idx) { // it's not a suffix
	    return false;
	  }

	  /* "* The last character of the string that is not included in the domain
	  * string is a %x2E (".") character." */
	  if (str.substr(idx-1,1) !== '.') {
	    return false;
	  }

	  return true;
	}


	// RFC6265 S5.1.4 Paths and Path-Match

	/*
	 * "The user agent MUST use an algorithm equivalent to the following algorithm
	 * to compute the default-path of a cookie:"
	 *
	 * Assumption: the path (and not query part or absolute uri) is passed in.
	 */
	function defaultPath(path) {
	  // "2. If the uri-path is empty or if the first character of the uri-path is not
	  // a %x2F ("/") character, output %x2F ("/") and skip the remaining steps.
	  if (!path || path.substr(0,1) !== "/") {
	    return "/";
	  }

	  // "3. If the uri-path contains no more than one %x2F ("/") character, output
	  // %x2F ("/") and skip the remaining step."
	  if (path === "/") {
	    return path;
	  }

	  var rightSlash = path.lastIndexOf("/");
	  if (rightSlash === 0) {
	    return "/";
	  }

	  // "4. Output the characters of the uri-path from the first character up to,
	  // but not including, the right-most %x2F ("/")."
	  return path.slice(0, rightSlash);
	}

	function trimTerminator(str) {
	  for (var t = 0; t < TERMINATORS.length; t++) {
	    var terminatorIdx = str.indexOf(TERMINATORS[t]);
	    if (terminatorIdx !== -1) {
	      str = str.substr(0,terminatorIdx);
	    }
	  }

	  return str;
	}

	function parseCookiePair(cookiePair, looseMode) {
	  cookiePair = trimTerminator(cookiePair);

	  var firstEq = cookiePair.indexOf('=');
	  if (looseMode) {
	    if (firstEq === 0) { // '=' is immediately at start
	      cookiePair = cookiePair.substr(1);
	      firstEq = cookiePair.indexOf('='); // might still need to split on '='
	    }
	  } else { // non-loose mode
	    if (firstEq <= 0) { // no '=' or is at start
	      return; // needs to have non-empty "cookie-name"
	    }
	  }

	  var cookieName, cookieValue;
	  if (firstEq <= 0) {
	    cookieName = "";
	    cookieValue = cookiePair.trim();
	  } else {
	    cookieName = cookiePair.substr(0, firstEq).trim();
	    cookieValue = cookiePair.substr(firstEq+1).trim();
	  }

	  if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
	    return;
	  }

	  var c = new Cookie();
	  c.key = cookieName;
	  c.value = cookieValue;
	  return c;
	}

	function parse(str, options) {
	  if (!options || typeof options !== 'object') {
	    options = {};
	  }
	  str = str.trim();

	  // We use a regex to parse the "name-value-pair" part of S5.2
	  var firstSemi = str.indexOf(';'); // S5.2 step 1
	  var cookiePair = (firstSemi === -1) ? str : str.substr(0, firstSemi);
	  var c = parseCookiePair(cookiePair, !!options.loose);
	  if (!c) {
	    return;
	  }

	  if (firstSemi === -1) {
	    return c;
	  }

	  // S5.2.3 "unparsed-attributes consist of the remainder of the set-cookie-string
	  // (including the %x3B (";") in question)." plus later on in the same section
	  // "discard the first ";" and trim".
	  var unparsed = str.slice(firstSemi + 1).trim();

	  // "If the unparsed-attributes string is empty, skip the rest of these
	  // steps."
	  if (unparsed.length === 0) {
	    return c;
	  }

	  /*
	   * S5.2 says that when looping over the items "[p]rocess the attribute-name
	   * and attribute-value according to the requirements in the following
	   * subsections" for every item.  Plus, for many of the individual attributes
	   * in S5.3 it says to use the "attribute-value of the last attribute in the
	   * cookie-attribute-list".  Therefore, in this implementation, we overwrite
	   * the previous value.
	   */
	  var cookie_avs = unparsed.split(';');
	  while (cookie_avs.length) {
	    var av = cookie_avs.shift().trim();
	    if (av.length === 0) { // happens if ";;" appears
	      continue;
	    }
	    var av_sep = av.indexOf('=');
	    var av_key, av_value;

	    if (av_sep === -1) {
	      av_key = av;
	      av_value = null;
	    } else {
	      av_key = av.substr(0,av_sep);
	      av_value = av.substr(av_sep+1);
	    }

	    av_key = av_key.trim().toLowerCase();

	    if (av_value) {
	      av_value = av_value.trim();
	    }

	    switch(av_key) {
	    case 'expires': // S5.2.1
	      if (av_value) {
	        var exp = parseDate(av_value);
	        // "If the attribute-value failed to parse as a cookie date, ignore the
	        // cookie-av."
	        if (exp) {
	          // over and underflow not realistically a concern: V8's getTime() seems to
	          // store something larger than a 32-bit time_t (even with 32-bit node)
	          c.expires = exp;
	        }
	      }
	      break;

	    case 'max-age': // S5.2.2
	      if (av_value) {
	        // "If the first character of the attribute-value is not a DIGIT or a "-"
	        // character ...[or]... If the remainder of attribute-value contains a
	        // non-DIGIT character, ignore the cookie-av."
	        if (/^-?[0-9]+$/.test(av_value)) {
	          var delta = parseInt(av_value, 10);
	          // "If delta-seconds is less than or equal to zero (0), let expiry-time
	          // be the earliest representable date and time."
	          c.setMaxAge(delta);
	        }
	      }
	      break;

	    case 'domain': // S5.2.3
	      // "If the attribute-value is empty, the behavior is undefined.  However,
	      // the user agent SHOULD ignore the cookie-av entirely."
	      if (av_value) {
	        // S5.2.3 "Let cookie-domain be the attribute-value without the leading %x2E
	        // (".") character."
	        var domain = av_value.trim().replace(/^\./, '');
	        if (domain) {
	          // "Convert the cookie-domain to lower case."
	          c.domain = domain.toLowerCase();
	        }
	      }
	      break;

	    case 'path': // S5.2.4
	      /*
	       * "If the attribute-value is empty or if the first character of the
	       * attribute-value is not %x2F ("/"):
	       *   Let cookie-path be the default-path.
	       * Otherwise:
	       *   Let cookie-path be the attribute-value."
	       *
	       * We'll represent the default-path as null since it depends on the
	       * context of the parsing.
	       */
	      c.path = av_value && av_value[0] === "/" ? av_value : null;
	      break;

	    case 'secure': // S5.2.5
	      /*
	       * "If the attribute-name case-insensitively matches the string "Secure",
	       * the user agent MUST append an attribute to the cookie-attribute-list
	       * with an attribute-name of Secure and an empty attribute-value."
	       */
	      c.secure = true;
	      break;

	    case 'httponly': // S5.2.6 -- effectively the same as 'secure'
	      c.httpOnly = true;
	      break;

	    default:
	      c.extensions = c.extensions || [];
	      c.extensions.push(av);
	      break;
	    }
	  }

	  return c;
	}

	// avoid the V8 deoptimization monster!
	function jsonParse(str) {
	  var obj;
	  try {
	    obj = JSON.parse(str);
	  } catch (e) {
	    return e;
	  }
	  return obj;
	}

	function fromJSON(str) {
	  if (!str) {
	    return null;
	  }

	  var obj;
	  if (typeof str === 'string') {
	    obj = jsonParse(str);
	    if (obj instanceof Error) {
	      return null;
	    }
	  } else {
	    // assume it's an Object
	    obj = str;
	  }

	  var c = new Cookie();
	  for (var i=0; i<Cookie.serializableProperties.length; i++) {
	    var prop = Cookie.serializableProperties[i];
	    if (obj[prop] === undefined ||
	        obj[prop] === Cookie.prototype[prop])
	    {
	      continue; // leave as prototype default
	    }

	    if (prop === 'expires' ||
	        prop === 'creation' ||
	        prop === 'lastAccessed')
	    {
	      if (obj[prop] === null) {
	        c[prop] = null;
	      } else {
	        c[prop] = obj[prop] == "Infinity" ?
	          "Infinity" : new Date(obj[prop]);
	      }
	    } else {
	      c[prop] = obj[prop];
	    }
	  }

	  return c;
	}

	/* Section 5.4 part 2:
	 * "*  Cookies with longer paths are listed before cookies with
	 *     shorter paths.
	 *
	 *  *  Among cookies that have equal-length path fields, cookies with
	 *     earlier creation-times are listed before cookies with later
	 *     creation-times."
	 */

	function cookieCompare(a,b) {
	  var cmp = 0;

	  // descending for length: b CMP a
	  var aPathLen = a.path ? a.path.length : 0;
	  var bPathLen = b.path ? b.path.length : 0;
	  cmp = bPathLen - aPathLen;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  // ascending for time: a CMP b
	  var aTime = a.creation ? a.creation.getTime() : MAX_TIME;
	  var bTime = b.creation ? b.creation.getTime() : MAX_TIME;
	  cmp = aTime - bTime;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  // break ties for the same millisecond (precision of JavaScript's clock)
	  cmp = a.creationIndex - b.creationIndex;

	  return cmp;
	}

	// Gives the permutation of all possible pathMatch()es of a given path. The
	// array is in longest-to-shortest order.  Handy for indexing.
	function permutePath(path) {
	  if (path === '/') {
	    return ['/'];
	  }
	  if (path.lastIndexOf('/') === path.length-1) {
	    path = path.substr(0,path.length-1);
	  }
	  var permutations = [path];
	  while (path.length > 1) {
	    var lindex = path.lastIndexOf('/');
	    if (lindex === 0) {
	      break;
	    }
	    path = path.substr(0,lindex);
	    permutations.push(path);
	  }
	  permutations.push('/');
	  return permutations;
	}

	function getCookieContext(url) {
	  if (url instanceof Object) {
	    return url;
	  }
	  // NOTE: decodeURI will throw on malformed URIs (see GH-32).
	  // Therefore, we will just skip decoding for such URIs.
	  try {
	    url = decodeURI(url);
	  }
	  catch(err) {
	    // Silently swallow error
	  }

	  return urlParse(url);
	}

	function Cookie(options) {
	  options = options || {};

	  Object.keys(options).forEach(function(prop) {
	    if (Cookie.prototype.hasOwnProperty(prop) &&
	        Cookie.prototype[prop] !== options[prop] &&
	        prop.substr(0,1) !== '_')
	    {
	      this[prop] = options[prop];
	    }
	  }, this);

	  this.creation = this.creation || new Date();

	  // used to break creation ties in cookieCompare():
	  Object.defineProperty(this, 'creationIndex', {
	    configurable: false,
	    enumerable: false, // important for assert.deepEqual checks
	    writable: true,
	    value: ++Cookie.cookiesCreated
	  });
	}

	Cookie.cookiesCreated = 0; // incremented each time a cookie is created

	Cookie.parse = parse;
	Cookie.fromJSON = fromJSON;

	Cookie.prototype.key = "";
	Cookie.prototype.value = "";

	// the order in which the RFC has them:
	Cookie.prototype.expires = "Infinity"; // coerces to literal Infinity
	Cookie.prototype.maxAge = null; // takes precedence over expires for TTL
	Cookie.prototype.domain = null;
	Cookie.prototype.path = null;
	Cookie.prototype.secure = false;
	Cookie.prototype.httpOnly = false;
	Cookie.prototype.extensions = null;

	// set by the CookieJar:
	Cookie.prototype.hostOnly = null; // boolean when set
	Cookie.prototype.pathIsDefault = null; // boolean when set
	Cookie.prototype.creation = null; // Date when set; defaulted by Cookie.parse
	Cookie.prototype.lastAccessed = null; // Date when set
	Object.defineProperty(Cookie.prototype, 'creationIndex', {
	  configurable: true,
	  enumerable: false,
	  writable: true,
	  value: 0
	});

	Cookie.serializableProperties = Object.keys(Cookie.prototype)
	  .filter(function(prop) {
	    return !(
	      Cookie.prototype[prop] instanceof Function ||
	      prop === 'creationIndex' ||
	      prop.substr(0,1) === '_'
	    );
	  });

	Cookie.prototype.inspect = function inspect() {
	  var now = Date.now();
	  return 'Cookie="'+this.toString() +
	    '; hostOnly='+(this.hostOnly != null ? this.hostOnly : '?') +
	    '; aAge='+(this.lastAccessed ? (now-this.lastAccessed.getTime())+'ms' : '?') +
	    '; cAge='+(this.creation ? (now-this.creation.getTime())+'ms' : '?') +
	    '"';
	};

	// Use the new custom inspection symbol to add the custom inspect function if
	// available.
	if (util.inspect.custom) {
	  Cookie.prototype[util.inspect.custom] = Cookie.prototype.inspect;
	}

	Cookie.prototype.toJSON = function() {
	  var obj = {};

	  var props = Cookie.serializableProperties;
	  for (var i=0; i<props.length; i++) {
	    var prop = props[i];
	    if (this[prop] === Cookie.prototype[prop]) {
	      continue; // leave as prototype default
	    }

	    if (prop === 'expires' ||
	        prop === 'creation' ||
	        prop === 'lastAccessed')
	    {
	      if (this[prop] === null) {
	        obj[prop] = null;
	      } else {
	        obj[prop] = this[prop] == "Infinity" ? // intentionally not ===
	          "Infinity" : this[prop].toISOString();
	      }
	    } else if (prop === 'maxAge') {
	      if (this[prop] !== null) {
	        // again, intentionally not ===
	        obj[prop] = (this[prop] == Infinity || this[prop] == -Infinity) ?
	          this[prop].toString() : this[prop];
	      }
	    } else {
	      if (this[prop] !== Cookie.prototype[prop]) {
	        obj[prop] = this[prop];
	      }
	    }
	  }

	  return obj;
	};

	Cookie.prototype.clone = function() {
	  return fromJSON(this.toJSON());
	};

	Cookie.prototype.validate = function validate() {
	  if (!COOKIE_OCTETS.test(this.value)) {
	    return false;
	  }
	  if (this.expires != Infinity && !(this.expires instanceof Date) && !parseDate(this.expires)) {
	    return false;
	  }
	  if (this.maxAge != null && this.maxAge <= 0) {
	    return false; // "Max-Age=" non-zero-digit *DIGIT
	  }
	  if (this.path != null && !PATH_VALUE.test(this.path)) {
	    return false;
	  }

	  var cdomain = this.cdomain();
	  if (cdomain) {
	    if (cdomain.match(/\.$/)) {
	      return false; // S4.1.2.3 suggests that this is bad. domainMatch() tests confirm this
	    }
	    var suffix = pubsuffix.getPublicSuffix(cdomain);
	    if (suffix == null) { // it's a public suffix
	      return false;
	    }
	  }
	  return true;
	};

	Cookie.prototype.setExpires = function setExpires(exp) {
	  if (exp instanceof Date) {
	    this.expires = exp;
	  } else {
	    this.expires = parseDate(exp) || "Infinity";
	  }
	};

	Cookie.prototype.setMaxAge = function setMaxAge(age) {
	  if (age === Infinity || age === -Infinity) {
	    this.maxAge = age.toString(); // so JSON.stringify() works
	  } else {
	    this.maxAge = age;
	  }
	};

	// gives Cookie header format
	Cookie.prototype.cookieString = function cookieString() {
	  var val = this.value;
	  if (val == null) {
	    val = '';
	  }
	  if (this.key === '') {
	    return val;
	  }
	  return this.key+'='+val;
	};

	// gives Set-Cookie header format
	Cookie.prototype.toString = function toString() {
	  var str = this.cookieString();

	  if (this.expires != Infinity) {
	    if (this.expires instanceof Date) {
	      str += '; Expires='+formatDate(this.expires);
	    } else {
	      str += '; Expires='+this.expires;
	    }
	  }

	  if (this.maxAge != null && this.maxAge != Infinity) {
	    str += '; Max-Age='+this.maxAge;
	  }

	  if (this.domain && !this.hostOnly) {
	    str += '; Domain='+this.domain;
	  }
	  if (this.path) {
	    str += '; Path='+this.path;
	  }

	  if (this.secure) {
	    str += '; Secure';
	  }
	  if (this.httpOnly) {
	    str += '; HttpOnly';
	  }
	  if (this.extensions) {
	    this.extensions.forEach(function(ext) {
	      str += '; '+ext;
	    });
	  }

	  return str;
	};

	// TTL() partially replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
	// elsewhere)
	// S5.3 says to give the "latest representable date" for which we use Infinity
	// For "expired" we use 0
	Cookie.prototype.TTL = function TTL(now) {
	  /* RFC6265 S4.1.2.2 If a cookie has both the Max-Age and the Expires
	   * attribute, the Max-Age attribute has precedence and controls the
	   * expiration date of the cookie.
	   * (Concurs with S5.3 step 3)
	   */
	  if (this.maxAge != null) {
	    return this.maxAge<=0 ? 0 : this.maxAge*1000;
	  }

	  var expires = this.expires;
	  if (expires != Infinity) {
	    if (!(expires instanceof Date)) {
	      expires = parseDate(expires) || Infinity;
	    }

	    if (expires == Infinity) {
	      return Infinity;
	    }

	    return expires.getTime() - (now || Date.now());
	  }

	  return Infinity;
	};

	// expiryTime() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
	// elsewhere)
	Cookie.prototype.expiryTime = function expiryTime(now) {
	  if (this.maxAge != null) {
	    var relativeTo = now || this.creation || new Date();
	    var age = (this.maxAge <= 0) ? -Infinity : this.maxAge*1000;
	    return relativeTo.getTime() + age;
	  }

	  if (this.expires == Infinity) {
	    return Infinity;
	  }
	  return this.expires.getTime();
	};

	// expiryDate() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
	// elsewhere), except it returns a Date
	Cookie.prototype.expiryDate = function expiryDate(now) {
	  var millisec = this.expiryTime(now);
	  if (millisec == Infinity) {
	    return new Date(MAX_TIME);
	  } else if (millisec == -Infinity) {
	    return new Date(MIN_TIME);
	  } else {
	    return new Date(millisec);
	  }
	};

	// This replaces the "persistent-flag" parts of S5.3 step 3
	Cookie.prototype.isPersistent = function isPersistent() {
	  return (this.maxAge != null || this.expires != Infinity);
	};

	// Mostly S5.1.2 and S5.2.3:
	Cookie.prototype.cdomain =
	Cookie.prototype.canonicalizedDomain = function canonicalizedDomain() {
	  if (this.domain == null) {
	    return null;
	  }
	  return canonicalDomain(this.domain);
	};

	function CookieJar(store, options) {
	  if (typeof options === "boolean") {
	    options = {rejectPublicSuffixes: options};
	  } else if (options == null) {
	    options = {};
	  }
	  if (options.rejectPublicSuffixes != null) {
	    this.rejectPublicSuffixes = options.rejectPublicSuffixes;
	  }
	  if (options.looseMode != null) {
	    this.enableLooseMode = options.looseMode;
	  }

	  if (!store) {
	    store = new MemoryCookieStore();
	  }
	  this.store = store;
	}
	CookieJar.prototype.store = null;
	CookieJar.prototype.rejectPublicSuffixes = true;
	CookieJar.prototype.enableLooseMode = false;
	var CAN_BE_SYNC = [];

	CAN_BE_SYNC.push('setCookie');
	CookieJar.prototype.setCookie = function(cookie, url, options, cb) {
	  var err;
	  var context = getCookieContext(url);
	  if (options instanceof Function) {
	    cb = options;
	    options = {};
	  }

	  var host = canonicalDomain(context.hostname);
	  var loose = this.enableLooseMode;
	  if (options.loose != null) {
	    loose = options.loose;
	  }

	  // S5.3 step 1
	  if (!(cookie instanceof Cookie)) {
	    cookie = Cookie.parse(cookie, { loose: loose });
	  }
	  if (!cookie) {
	    err = new Error("Cookie failed to parse");
	    return cb(options.ignoreError ? null : err);
	  }

	  // S5.3 step 2
	  var now = options.now || new Date(); // will assign later to save effort in the face of errors

	  // S5.3 step 3: NOOP; persistent-flag and expiry-time is handled by getCookie()

	  // S5.3 step 4: NOOP; domain is null by default

	  // S5.3 step 5: public suffixes
	  if (this.rejectPublicSuffixes && cookie.domain) {
	    var suffix = pubsuffix.getPublicSuffix(cookie.cdomain());
	    if (suffix == null) { // e.g. "com"
	      err = new Error("Cookie has domain set to a public suffix");
	      return cb(options.ignoreError ? null : err);
	    }
	  }

	  // S5.3 step 6:
	  if (cookie.domain) {
	    if (!domainMatch(host, cookie.cdomain(), false)) {
	      err = new Error("Cookie not in this host's domain. Cookie:"+cookie.cdomain()+" Request:"+host);
	      return cb(options.ignoreError ? null : err);
	    }

	    if (cookie.hostOnly == null) { // don't reset if already set
	      cookie.hostOnly = false;
	    }

	  } else {
	    cookie.hostOnly = true;
	    cookie.domain = host;
	  }

	  //S5.2.4 If the attribute-value is empty or if the first character of the
	  //attribute-value is not %x2F ("/"):
	  //Let cookie-path be the default-path.
	  if (!cookie.path || cookie.path[0] !== '/') {
	    cookie.path = defaultPath(context.pathname);
	    cookie.pathIsDefault = true;
	  }

	  // S5.3 step 8: NOOP; secure attribute
	  // S5.3 step 9: NOOP; httpOnly attribute

	  // S5.3 step 10
	  if (options.http === false && cookie.httpOnly) {
	    err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
	    return cb(options.ignoreError ? null : err);
	  }

	  var store = this.store;

	  if (!store.updateCookie) {
	    store.updateCookie = function(oldCookie, newCookie, cb) {
	      this.putCookie(newCookie, cb);
	    };
	  }

	  function withCookie(err, oldCookie) {
	    if (err) {
	      return cb(err);
	    }

	    var next = function(err) {
	      if (err) {
	        return cb(err);
	      } else {
	        cb(null, cookie);
	      }
	    };

	    if (oldCookie) {
	      // S5.3 step 11 - "If the cookie store contains a cookie with the same name,
	      // domain, and path as the newly created cookie:"
	      if (options.http === false && oldCookie.httpOnly) { // step 11.2
	        err = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
	        return cb(options.ignoreError ? null : err);
	      }
	      cookie.creation = oldCookie.creation; // step 11.3
	      cookie.creationIndex = oldCookie.creationIndex; // preserve tie-breaker
	      cookie.lastAccessed = now;
	      // Step 11.4 (delete cookie) is implied by just setting the new one:
	      store.updateCookie(oldCookie, cookie, next); // step 12

	    } else {
	      cookie.creation = cookie.lastAccessed = now;
	      store.putCookie(cookie, next); // step 12
	    }
	  }

	  store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
	};

	// RFC6365 S5.4
	CAN_BE_SYNC.push('getCookies');
	CookieJar.prototype.getCookies = function(url, options, cb) {
	  var context = getCookieContext(url);
	  if (options instanceof Function) {
	    cb = options;
	    options = {};
	  }

	  var host = canonicalDomain(context.hostname);
	  var path = context.pathname || '/';

	  var secure = options.secure;
	  if (secure == null && context.protocol &&
	      (context.protocol == 'https:' || context.protocol == 'wss:'))
	  {
	    secure = true;
	  }

	  var http = options.http;
	  if (http == null) {
	    http = true;
	  }

	  var now = options.now || Date.now();
	  var expireCheck = options.expire !== false;
	  var allPaths = !!options.allPaths;
	  var store = this.store;

	  function matchingCookie(c) {
	    // "Either:
	    //   The cookie's host-only-flag is true and the canonicalized
	    //   request-host is identical to the cookie's domain.
	    // Or:
	    //   The cookie's host-only-flag is false and the canonicalized
	    //   request-host domain-matches the cookie's domain."
	    if (c.hostOnly) {
	      if (c.domain != host) {
	        return false;
	      }
	    } else {
	      if (!domainMatch(host, c.domain, false)) {
	        return false;
	      }
	    }

	    // "The request-uri's path path-matches the cookie's path."
	    if (!allPaths && !pathMatch(path, c.path)) {
	      return false;
	    }

	    // "If the cookie's secure-only-flag is true, then the request-uri's
	    // scheme must denote a "secure" protocol"
	    if (c.secure && !secure) {
	      return false;
	    }

	    // "If the cookie's http-only-flag is true, then exclude the cookie if the
	    // cookie-string is being generated for a "non-HTTP" API"
	    if (c.httpOnly && !http) {
	      return false;
	    }

	    // deferred from S5.3
	    // non-RFC: allow retention of expired cookies by choice
	    if (expireCheck && c.expiryTime() <= now) {
	      store.removeCookie(c.domain, c.path, c.key, function(){}); // result ignored
	      return false;
	    }

	    return true;
	  }

	  store.findCookies(host, allPaths ? null : path, function(err,cookies) {
	    if (err) {
	      return cb(err);
	    }

	    cookies = cookies.filter(matchingCookie);

	    // sorting of S5.4 part 2
	    if (options.sort !== false) {
	      cookies = cookies.sort(cookieCompare);
	    }

	    // S5.4 part 3
	    var now = new Date();
	    cookies.forEach(function(c) {
	      c.lastAccessed = now;
	    });
	    // TODO persist lastAccessed

	    cb(null,cookies);
	  });
	};

	CAN_BE_SYNC.push('getCookieString');
	CookieJar.prototype.getCookieString = function(/*..., cb*/) {
	  var args = Array.prototype.slice.call(arguments,0);
	  var cb = args.pop();
	  var next = function(err,cookies) {
	    if (err) {
	      cb(err);
	    } else {
	      cb(null, cookies
	        .sort(cookieCompare)
	        .map(function(c){
	          return c.cookieString();
	        })
	        .join('; '));
	    }
	  };
	  args.push(next);
	  this.getCookies.apply(this,args);
	};

	CAN_BE_SYNC.push('getSetCookieStrings');
	CookieJar.prototype.getSetCookieStrings = function(/*..., cb*/) {
	  var args = Array.prototype.slice.call(arguments,0);
	  var cb = args.pop();
	  var next = function(err,cookies) {
	    if (err) {
	      cb(err);
	    } else {
	      cb(null, cookies.map(function(c){
	        return c.toString();
	      }));
	    }
	  };
	  args.push(next);
	  this.getCookies.apply(this,args);
	};

	CAN_BE_SYNC.push('serialize');
	CookieJar.prototype.serialize = function(cb) {
	  var type = this.store.constructor.name;
	  if (type === 'Object') {
	    type = null;
	  }

	  // update README.md "Serialization Format" if you change this, please!
	  var serialized = {
	    // The version of tough-cookie that serialized this jar. Generally a good
	    // practice since future versions can make data import decisions based on
	    // known past behavior. When/if this matters, use `semver`.
	    version: 'tough-cookie@'+VERSION,

	    // add the store type, to make humans happy:
	    storeType: type,

	    // CookieJar configuration:
	    rejectPublicSuffixes: !!this.rejectPublicSuffixes,

	    // this gets filled from getAllCookies:
	    cookies: []
	  };

	  if (!(this.store.getAllCookies &&
	        typeof this.store.getAllCookies === 'function'))
	  {
	    return cb(new Error('store does not support getAllCookies and cannot be serialized'));
	  }

	  this.store.getAllCookies(function(err,cookies) {
	    if (err) {
	      return cb(err);
	    }

	    serialized.cookies = cookies.map(function(cookie) {
	      // convert to serialized 'raw' cookies
	      cookie = (cookie instanceof Cookie) ? cookie.toJSON() : cookie;

	      // Remove the index so new ones get assigned during deserialization
	      delete cookie.creationIndex;

	      return cookie;
	    });

	    return cb(null, serialized);
	  });
	};

	// well-known name that JSON.stringify calls
	CookieJar.prototype.toJSON = function() {
	  return this.serializeSync();
	};

	// use the class method CookieJar.deserialize instead of calling this directly
	CAN_BE_SYNC.push('_importCookies');
	CookieJar.prototype._importCookies = function(serialized, cb) {
	  var jar = this;
	  var cookies = serialized.cookies;
	  if (!cookies || !Array.isArray(cookies)) {
	    return cb(new Error('serialized jar has no cookies array'));
	  }
	  cookies = cookies.slice(); // do not modify the original

	  function putNext(err) {
	    if (err) {
	      return cb(err);
	    }

	    if (!cookies.length) {
	      return cb(err, jar);
	    }

	    var cookie;
	    try {
	      cookie = fromJSON(cookies.shift());
	    } catch (e) {
	      return cb(e);
	    }

	    if (cookie === null) {
	      return putNext(null); // skip this cookie
	    }

	    jar.store.putCookie(cookie, putNext);
	  }

	  putNext();
	};

	CookieJar.deserialize = function(strOrObj, store, cb) {
	  if (arguments.length !== 3) {
	    // store is optional
	    cb = store;
	    store = null;
	  }

	  var serialized;
	  if (typeof strOrObj === 'string') {
	    serialized = jsonParse(strOrObj);
	    if (serialized instanceof Error) {
	      return cb(serialized);
	    }
	  } else {
	    serialized = strOrObj;
	  }

	  var jar = new CookieJar(store, serialized.rejectPublicSuffixes);
	  jar._importCookies(serialized, function(err) {
	    if (err) {
	      return cb(err);
	    }
	    cb(null, jar);
	  });
	};

	CookieJar.deserializeSync = function(strOrObj, store) {
	  var serialized = typeof strOrObj === 'string' ?
	    JSON.parse(strOrObj) : strOrObj;
	  var jar = new CookieJar(store, serialized.rejectPublicSuffixes);

	  // catch this mistake early:
	  if (!jar.store.synchronous) {
	    throw new Error('CookieJar store is not synchronous; use async API instead.');
	  }

	  jar._importCookiesSync(serialized);
	  return jar;
	};
	CookieJar.fromJSON = CookieJar.deserializeSync;

	CookieJar.prototype.clone = function(newStore, cb) {
	  if (arguments.length === 1) {
	    cb = newStore;
	    newStore = null;
	  }

	  this.serialize(function(err,serialized) {
	    if (err) {
	      return cb(err);
	    }
	    CookieJar.deserialize(serialized, newStore, cb);
	  });
	};

	CAN_BE_SYNC.push('removeAllCookies');
	CookieJar.prototype.removeAllCookies = function(cb) {
	  var store = this.store;

	  // Check that the store implements its own removeAllCookies(). The default
	  // implementation in Store will immediately call the callback with a "not
	  // implemented" Error.
	  if (store.removeAllCookies instanceof Function &&
	      store.removeAllCookies !== Store.prototype.removeAllCookies)
	  {
	    return store.removeAllCookies(cb);
	  }

	  store.getAllCookies(function(err, cookies) {
	    if (err) {
	      return cb(err);
	    }

	    if (cookies.length === 0) {
	      return cb(null);
	    }

	    var completedCount = 0;
	    var removeErrors = [];

	    function removeCookieCb(removeErr) {
	      if (removeErr) {
	        removeErrors.push(removeErr);
	      }

	      completedCount++;

	      if (completedCount === cookies.length) {
	        return cb(removeErrors.length ? removeErrors[0] : null);
	      }
	    }

	    cookies.forEach(function(cookie) {
	      store.removeCookie(cookie.domain, cookie.path, cookie.key, removeCookieCb);
	    });
	  });
	};

	CookieJar.prototype._cloneSync = syncWrap('clone');
	CookieJar.prototype.cloneSync = function(newStore) {
	  if (!newStore.synchronous) {
	    throw new Error('CookieJar clone destination store is not synchronous; use async API instead.');
	  }
	  return this._cloneSync(newStore);
	};

	// Use a closure to provide a true imperative API for synchronous stores.
	function syncWrap(method) {
	  return function() {
	    if (!this.store.synchronous) {
	      throw new Error('CookieJar store is not synchronous; use async API instead.');
	    }

	    var args = Array.prototype.slice.call(arguments);
	    var syncErr, syncResult;
	    args.push(function syncCb(err, result) {
	      syncErr = err;
	      syncResult = result;
	    });
	    this[method].apply(this, args);

	    if (syncErr) {
	      throw syncErr;
	    }
	    return syncResult;
	  };
	}

	// wrap all declared CAN_BE_SYNC methods in the sync wrapper
	CAN_BE_SYNC.forEach(function(method) {
	  CookieJar.prototype[method+'Sync'] = syncWrap(method);
	});

	cookie.version = VERSION;
	cookie.CookieJar = CookieJar;
	cookie.Cookie = Cookie;
	cookie.Store = Store;
	cookie.MemoryCookieStore = MemoryCookieStore;
	cookie.parseDate = parseDate;
	cookie.formatDate = formatDate;
	cookie.parse = parse;
	cookie.fromJSON = fromJSON;
	cookie.domainMatch = domainMatch;
	cookie.defaultPath = defaultPath;
	cookie.pathMatch = pathMatch;
	cookie.getPublicSuffix = pubsuffix.getPublicSuffix;
	cookie.cookieCompare = cookieCompare;
	cookie.permuteDomain = requirePermuteDomain().permuteDomain;
	cookie.permutePath = permutePath;
	cookie.canonicalDomain = canonicalDomain;
	return cookie;
}

var hasRequiredCookies;

function requireCookies () {
	if (hasRequiredCookies) return cookies;
	hasRequiredCookies = 1;

	var tough = requireCookie();

	var Cookie = tough.Cookie;
	var CookieJar = tough.CookieJar;

	cookies.parse = function (str) {
	  if (str && str.uri) {
	    str = str.uri;
	  }
	  if (typeof str !== 'string') {
	    throw new Error('The cookie function only accepts STRING as param')
	  }
	  return Cookie.parse(str, {loose: true})
	};

	// Adapt the sometimes-Async api of tough.CookieJar to our requirements
	function RequestJar (store) {
	  var self = this;
	  self._jar = new CookieJar(store, {looseMode: true});
	}
	RequestJar.prototype.setCookie = function (cookieOrStr, uri, options) {
	  var self = this;
	  return self._jar.setCookieSync(cookieOrStr, uri, options || {})
	};
	RequestJar.prototype.getCookieString = function (uri) {
	  var self = this;
	  return self._jar.getCookieStringSync(uri)
	};
	RequestJar.prototype.getCookies = function (uri) {
	  var self = this;
	  return self._jar.getCookiesSync(uri)
	};

	cookies.jar = function (store) {
	  return new RequestJar(store)
	};
	return cookies;
}

var helpers = {};

var stringify = {exports: {}};

var hasRequiredStringify$1;

function requireStringify$1 () {
	if (hasRequiredStringify$1) return stringify.exports;
	hasRequiredStringify$1 = 1;
	(function (module, exports) {
		exports = module.exports = stringify;
		exports.getSerialize = serializer;

		function stringify(obj, replacer, spaces, cycleReplacer) {
		  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)
		}

		function serializer(replacer, cycleReplacer) {
		  var stack = [], keys = [];

		  if (cycleReplacer == null) cycleReplacer = function(key, value) {
		    if (stack[0] === value) return "[Circular ~]"
		    return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]"
		  };

		  return function(key, value) {
		    if (stack.length > 0) {
		      var thisPos = stack.indexOf(this);
		      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
		      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
		      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value);
		    }
		    else stack.push(value);

		    return replacer == null ? value : replacer.call(this, key, value)
		  }
		} 
	} (stringify, stringify.exports));
	return stringify.exports;
}

var safeBuffer$1 = {exports: {}};

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

var hasRequiredSafeBuffer$1;

function requireSafeBuffer$1 () {
	if (hasRequiredSafeBuffer$1) return safeBuffer$1.exports;
	hasRequiredSafeBuffer$1 = 1;
	(function (module, exports) {
		/* eslint-disable node/no-deprecated-api */
		var buffer = require$$0$4;
		var Buffer = buffer.Buffer;

		// alternative to using Object.keys for old browsers
		function copyProps (src, dst) {
		  for (var key in src) {
		    dst[key] = src[key];
		  }
		}
		if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
		  module.exports = buffer;
		} else {
		  // Copy properties from require('buffer')
		  copyProps(buffer, exports);
		  exports.Buffer = SafeBuffer;
		}

		function SafeBuffer (arg, encodingOrOffset, length) {
		  return Buffer(arg, encodingOrOffset, length)
		}

		SafeBuffer.prototype = Object.create(Buffer.prototype);

		// Copy static methods from Buffer
		copyProps(Buffer, SafeBuffer);

		SafeBuffer.from = function (arg, encodingOrOffset, length) {
		  if (typeof arg === 'number') {
		    throw new TypeError('Argument must not be a number')
		  }
		  return Buffer(arg, encodingOrOffset, length)
		};

		SafeBuffer.alloc = function (size, fill, encoding) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  var buf = Buffer(size);
		  if (fill !== undefined) {
		    if (typeof encoding === 'string') {
		      buf.fill(fill, encoding);
		    } else {
		      buf.fill(fill);
		    }
		  } else {
		    buf.fill(0);
		  }
		  return buf
		};

		SafeBuffer.allocUnsafe = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return Buffer(size)
		};

		SafeBuffer.allocUnsafeSlow = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return buffer.SlowBuffer(size)
		}; 
	} (safeBuffer$1, safeBuffer$1.exports));
	return safeBuffer$1.exports;
}

var hasRequiredHelpers;

function requireHelpers () {
	if (hasRequiredHelpers) return helpers;
	hasRequiredHelpers = 1;

	var jsonSafeStringify = requireStringify$1();
	var crypto = require$$0$5;
	var Buffer = requireSafeBuffer$1().Buffer;

	var defer = typeof setImmediate === 'undefined'
	  ? process.nextTick
	  : setImmediate;

	function paramsHaveRequestBody (params) {
	  return (
	    params.body ||
	    params.requestBodyStream ||
	    (params.json && typeof params.json !== 'boolean') ||
	    params.multipart
	  )
	}

	function safeStringify (obj, replacer) {
	  var ret;
	  try {
	    ret = JSON.stringify(obj, replacer);
	  } catch (e) {
	    ret = jsonSafeStringify(obj, replacer);
	  }
	  return ret
	}

	function md5 (str) {
	  return crypto.createHash('md5').update(str).digest('hex')
	}

	function isReadStream (rs) {
	  return rs.readable && rs.path && rs.mode
	}

	function toBase64 (str) {
	  return Buffer.from(str || '', 'utf8').toString('base64')
	}

	function copy (obj) {
	  var o = {};
	  Object.keys(obj).forEach(function (i) {
	    o[i] = obj[i];
	  });
	  return o
	}

	function version () {
	  var numbers = process.version.replace('v', '').split('.');
	  return {
	    major: parseInt(numbers[0], 10),
	    minor: parseInt(numbers[1], 10),
	    patch: parseInt(numbers[2], 10)
	  }
	}

	helpers.paramsHaveRequestBody = paramsHaveRequestBody;
	helpers.safeStringify = safeStringify;
	helpers.md5 = md5;
	helpers.isReadStream = isReadStream;
	helpers.toBase64 = toBase64;
	helpers.copy = copy;
	helpers.version = version;
	helpers.defer = defer;
	return helpers;
}

var awsSign2 = {exports: {}};

var hasRequiredAwsSign2;

function requireAwsSign2 () {
	if (hasRequiredAwsSign2) return awsSign2.exports;
	hasRequiredAwsSign2 = 1;
	/*!
	 *  Copyright 2010 LearnBoost <dev@learnboost.com>
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	/**
	 * Module dependencies.
	 */

	var crypto = require$$0$5
	  , parse = require$$0$2.parse
	  ;

	/**
	 * Valid keys.
	 */

	var keys = 
	  [ 'acl'
	  , 'location'
	  , 'logging'
	  , 'notification'
	  , 'partNumber'
	  , 'policy'
	  , 'requestPayment'
	  , 'torrent'
	  , 'uploadId'
	  , 'uploads'
	  , 'versionId'
	  , 'versioning'
	  , 'versions'
	  , 'website'
	  ];

	/**
	 * Return an "Authorization" header value with the given `options`
	 * in the form of "AWS <key>:<signature>"
	 *
	 * @param {Object} options
	 * @return {String}
	 * @api private
	 */

	function authorization (options) {
	  return 'AWS ' + options.key + ':' + sign(options)
	}

	awsSign2.exports = authorization;
	awsSign2.exports.authorization = authorization;

	/**
	 * Simple HMAC-SHA1 Wrapper
	 *
	 * @param {Object} options
	 * @return {String}
	 * @api private
	 */ 

	function hmacSha1 (options) {
	  return crypto.createHmac('sha1', options.secret).update(options.message).digest('base64')
	}

	awsSign2.exports.hmacSha1 = hmacSha1;

	/**
	 * Create a base64 sha1 HMAC for `options`. 
	 * 
	 * @param {Object} options
	 * @return {String}
	 * @api private
	 */

	function sign (options) {
	  options.message = stringToSign(options);
	  return hmacSha1(options)
	}
	awsSign2.exports.sign = sign;

	/**
	 * Create a base64 sha1 HMAC for `options`. 
	 *
	 * Specifically to be used with S3 presigned URLs
	 * 
	 * @param {Object} options
	 * @return {String}
	 * @api private
	 */

	function signQuery (options) {
	  options.message = queryStringToSign(options);
	  return hmacSha1(options)
	}
	awsSign2.exports.signQuery= signQuery;

	/**
	 * Return a string for sign() with the given `options`.
	 *
	 * Spec:
	 * 
	 *    <verb>\n
	 *    <md5>\n
	 *    <content-type>\n
	 *    <date>\n
	 *    [headers\n]
	 *    <resource>
	 *
	 * @param {Object} options
	 * @return {String}
	 * @api private
	 */

	function stringToSign (options) {
	  var headers = options.amazonHeaders || '';
	  if (headers) headers += '\n';
	  var r = 
	    [ options.verb
	    , options.md5
	    , options.contentType
	    , options.date ? options.date.toUTCString() : ''
	    , headers + options.resource
	    ];
	  return r.join('\n')
	}
	awsSign2.exports.stringToSign = stringToSign;

	/**
	 * Return a string for sign() with the given `options`, but is meant exclusively
	 * for S3 presigned URLs
	 *
	 * Spec:
	 * 
	 *    <date>\n
	 *    <resource>
	 *
	 * @param {Object} options
	 * @return {String}
	 * @api private
	 */

	function queryStringToSign (options){
	  return 'GET\n\n\n' + options.date + '\n' + options.resource
	}
	awsSign2.exports.queryStringToSign = queryStringToSign;

	/**
	 * Perform the following:
	 *
	 *  - ignore non-amazon headers
	 *  - lowercase fields
	 *  - sort lexicographically
	 *  - trim whitespace between ":"
	 *  - join with newline
	 *
	 * @param {Object} headers
	 * @return {String}
	 * @api private
	 */

	function canonicalizeHeaders (headers) {
	  var buf = []
	    , fields = Object.keys(headers)
	    ;
	  for (var i = 0, len = fields.length; i < len; ++i) {
	    var field = fields[i]
	      , val = headers[field]
	      , field = field.toLowerCase()
	      ;
	    if (0 !== field.indexOf('x-amz')) continue
	    buf.push(field + ':' + val);
	  }
	  return buf.sort().join('\n')
	}
	awsSign2.exports.canonicalizeHeaders = canonicalizeHeaders;

	/**
	 * Perform the following:
	 *
	 *  - ignore non sub-resources
	 *  - sort lexicographically
	 *
	 * @param {String} resource
	 * @return {String}
	 * @api private
	 */

	function canonicalizeResource (resource) {
	  var url = parse(resource, true)
	    , path = url.pathname
	    , buf = []
	    ;

	  Object.keys(url.query).forEach(function(key){
	    if (!~keys.indexOf(key)) return
	    var val = '' == url.query[key] ? '' : '=' + encodeURIComponent(url.query[key]);
	    buf.push(key + val);
	  });

	  return path + (buf.length ? '?' + buf.sort().join('&') : '')
	}
	awsSign2.exports.canonicalizeResource = canonicalizeResource;
	return awsSign2.exports;
}

var aws4 = {};

var lru;
var hasRequiredLru;

function requireLru () {
	if (hasRequiredLru) return lru;
	hasRequiredLru = 1;
	lru = function(size) {
	  return new LruCache(size)
	};

	function LruCache(size) {
	  this.capacity = size | 0;
	  this.map = Object.create(null);
	  this.list = new DoublyLinkedList();
	}

	LruCache.prototype.get = function(key) {
	  var node = this.map[key];
	  if (node == null) return undefined
	  this.used(node);
	  return node.val
	};

	LruCache.prototype.set = function(key, val) {
	  var node = this.map[key];
	  if (node != null) {
	    node.val = val;
	  } else {
	    if (!this.capacity) this.prune();
	    if (!this.capacity) return false
	    node = new DoublyLinkedNode(key, val);
	    this.map[key] = node;
	    this.capacity--;
	  }
	  this.used(node);
	  return true
	};

	LruCache.prototype.used = function(node) {
	  this.list.moveToFront(node);
	};

	LruCache.prototype.prune = function() {
	  var node = this.list.pop();
	  if (node != null) {
	    delete this.map[node.key];
	    this.capacity++;
	  }
	};


	function DoublyLinkedList() {
	  this.firstNode = null;
	  this.lastNode = null;
	}

	DoublyLinkedList.prototype.moveToFront = function(node) {
	  if (this.firstNode == node) return

	  this.remove(node);

	  if (this.firstNode == null) {
	    this.firstNode = node;
	    this.lastNode = node;
	    node.prev = null;
	    node.next = null;
	  } else {
	    node.prev = null;
	    node.next = this.firstNode;
	    node.next.prev = node;
	    this.firstNode = node;
	  }
	};

	DoublyLinkedList.prototype.pop = function() {
	  var lastNode = this.lastNode;
	  if (lastNode != null) {
	    this.remove(lastNode);
	  }
	  return lastNode
	};

	DoublyLinkedList.prototype.remove = function(node) {
	  if (this.firstNode == node) {
	    this.firstNode = node.next;
	  } else if (node.prev != null) {
	    node.prev.next = node.next;
	  }
	  if (this.lastNode == node) {
	    this.lastNode = node.prev;
	  } else if (node.next != null) {
	    node.next.prev = node.prev;
	  }
	};


	function DoublyLinkedNode(key, val) {
	  this.key = key;
	  this.val = val;
	  this.prev = null;
	  this.next = null;
	}
	return lru;
}

var hasRequiredAws4;

function requireAws4 () {
	if (hasRequiredAws4) return aws4;
	hasRequiredAws4 = 1;
	(function (exports) {
		var aws4 = exports,
		    url = require$$0$2,
		    querystring = require$$1$3,
		    crypto = require$$0$5,
		    lru = requireLru(),
		    credentialsCache = lru(1000);

		// http://docs.amazonwebservices.com/general/latest/gr/signature-version-4.html

		function hmac(key, string, encoding) {
		  return crypto.createHmac('sha256', key).update(string, 'utf8').digest(encoding)
		}

		function hash(string, encoding) {
		  return crypto.createHash('sha256').update(string, 'utf8').digest(encoding)
		}

		// This function assumes the string has already been percent encoded
		function encodeRfc3986(urlEncodedString) {
		  return urlEncodedString.replace(/[!'()*]/g, function(c) {
		    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
		  })
		}

		function encodeRfc3986Full(str) {
		  return encodeRfc3986(encodeURIComponent(str))
		}

		// A bit of a combination of:
		// https://github.com/aws/aws-sdk-java-v2/blob/dc695de6ab49ad03934e1b02e7263abbd2354be0/core/auth/src/main/java/software/amazon/awssdk/auth/signer/internal/AbstractAws4Signer.java#L59
		// https://github.com/aws/aws-sdk-js/blob/18cb7e5b463b46239f9fdd4a65e2ff8c81831e8f/lib/signers/v4.js#L191-L199
		// https://github.com/mhart/aws4fetch/blob/b3aed16b6f17384cf36ea33bcba3c1e9f3bdfefd/src/main.js#L25-L34
		var HEADERS_TO_IGNORE = {
		  'authorization': true,
		  'connection': true,
		  'x-amzn-trace-id': true,
		  'user-agent': true,
		  'expect': true,
		  'presigned-expires': true,
		  'range': true,
		};

		// request: { path | body, [host], [method], [headers], [service], [region] }
		// credentials: { accessKeyId, secretAccessKey, [sessionToken] }
		function RequestSigner(request, credentials) {

		  if (typeof request === 'string') request = url.parse(request);

		  var headers = request.headers = Object.assign({}, (request.headers || {})),
		      hostParts = (!this.service || !this.region) && this.matchHost(request.hostname || request.host || headers.Host || headers.host);

		  this.request = request;
		  this.credentials = credentials || this.defaultCredentials();

		  this.service = request.service || hostParts[0] || '';
		  this.region = request.region || hostParts[1] || 'us-east-1';

		  // SES uses a different domain from the service name
		  if (this.service === 'email') this.service = 'ses';

		  if (!request.method && request.body)
		    request.method = 'POST';

		  if (!headers.Host && !headers.host) {
		    headers.Host = request.hostname || request.host || this.createHost();

		    // If a port is specified explicitly, use it as is
		    if (request.port)
		      headers.Host += ':' + request.port;
		  }
		  if (!request.hostname && !request.host)
		    request.hostname = headers.Host || headers.host;

		  this.isCodeCommitGit = this.service === 'codecommit' && request.method === 'GIT';

		  this.extraHeadersToIgnore = request.extraHeadersToIgnore || Object.create(null);
		  this.extraHeadersToInclude = request.extraHeadersToInclude || Object.create(null);
		}

		RequestSigner.prototype.matchHost = function(host) {
		  var match = (host || '').match(/([^\.]{1,63})\.(?:([^\.]{0,63})\.)?amazonaws\.com(\.cn)?$/);
		  var hostParts = (match || []).slice(1, 3);

		  // ES's hostParts are sometimes the other way round, if the value that is expected
		  // to be region equals ‘es’ switch them back
		  // e.g. search-cluster-name-aaaa00aaaa0aaa0aaaaaaa0aaa.us-east-1.es.amazonaws.com
		  if (hostParts[1] === 'es' || hostParts[1] === 'aoss')
		    hostParts = hostParts.reverse();

		  if (hostParts[1] == 's3') {
		    hostParts[0] = 's3';
		    hostParts[1] = 'us-east-1';
		  } else {
		    for (var i = 0; i < 2; i++) {
		      if (/^s3-/.test(hostParts[i])) {
		        hostParts[1] = hostParts[i].slice(3);
		        hostParts[0] = 's3';
		        break
		      }
		    }
		  }

		  return hostParts
		};

		// http://docs.aws.amazon.com/general/latest/gr/rande.html
		RequestSigner.prototype.isSingleRegion = function() {
		  // Special case for S3 and SimpleDB in us-east-1
		  if (['s3', 'sdb'].indexOf(this.service) >= 0 && this.region === 'us-east-1') return true

		  return ['cloudfront', 'ls', 'route53', 'iam', 'importexport', 'sts']
		    .indexOf(this.service) >= 0
		};

		RequestSigner.prototype.createHost = function() {
		  var region = this.isSingleRegion() ? '' : '.' + this.region,
		      subdomain = this.service === 'ses' ? 'email' : this.service;
		  return subdomain + region + '.amazonaws.com'
		};

		RequestSigner.prototype.prepareRequest = function() {
		  this.parsePath();

		  var request = this.request, headers = request.headers, query;

		  if (request.signQuery) {

		    this.parsedPath.query = query = this.parsedPath.query || {};

		    if (this.credentials.sessionToken)
		      query['X-Amz-Security-Token'] = this.credentials.sessionToken;

		    if (this.service === 's3' && !query['X-Amz-Expires'])
		      query['X-Amz-Expires'] = 86400;

		    if (query['X-Amz-Date'])
		      this.datetime = query['X-Amz-Date'];
		    else
		      query['X-Amz-Date'] = this.getDateTime();

		    query['X-Amz-Algorithm'] = 'AWS4-HMAC-SHA256';
		    query['X-Amz-Credential'] = this.credentials.accessKeyId + '/' + this.credentialString();
		    query['X-Amz-SignedHeaders'] = this.signedHeaders();

		  } else {

		    if (!request.doNotModifyHeaders && !this.isCodeCommitGit) {
		      if (request.body && !headers['Content-Type'] && !headers['content-type'])
		        headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=utf-8';

		      if (request.body && !headers['Content-Length'] && !headers['content-length'])
		        headers['Content-Length'] = Buffer.byteLength(request.body);

		      if (this.credentials.sessionToken && !headers['X-Amz-Security-Token'] && !headers['x-amz-security-token'])
		        headers['X-Amz-Security-Token'] = this.credentials.sessionToken;

		      if (this.service === 's3' && !headers['X-Amz-Content-Sha256'] && !headers['x-amz-content-sha256'])
		        headers['X-Amz-Content-Sha256'] = hash(this.request.body || '', 'hex');

		      if (headers['X-Amz-Date'] || headers['x-amz-date'])
		        this.datetime = headers['X-Amz-Date'] || headers['x-amz-date'];
		      else
		        headers['X-Amz-Date'] = this.getDateTime();
		    }

		    delete headers.Authorization;
		    delete headers.authorization;
		  }
		};

		RequestSigner.prototype.sign = function() {
		  if (!this.parsedPath) this.prepareRequest();

		  if (this.request.signQuery) {
		    this.parsedPath.query['X-Amz-Signature'] = this.signature();
		  } else {
		    this.request.headers.Authorization = this.authHeader();
		  }

		  this.request.path = this.formatPath();

		  return this.request
		};

		RequestSigner.prototype.getDateTime = function() {
		  if (!this.datetime) {
		    var headers = this.request.headers,
		      date = new Date(headers.Date || headers.date || new Date);

		    this.datetime = date.toISOString().replace(/[:\-]|\.\d{3}/g, '');

		    // Remove the trailing 'Z' on the timestamp string for CodeCommit git access
		    if (this.isCodeCommitGit) this.datetime = this.datetime.slice(0, -1);
		  }
		  return this.datetime
		};

		RequestSigner.prototype.getDate = function() {
		  return this.getDateTime().substr(0, 8)
		};

		RequestSigner.prototype.authHeader = function() {
		  return [
		    'AWS4-HMAC-SHA256 Credential=' + this.credentials.accessKeyId + '/' + this.credentialString(),
		    'SignedHeaders=' + this.signedHeaders(),
		    'Signature=' + this.signature(),
		  ].join(', ')
		};

		RequestSigner.prototype.signature = function() {
		  var date = this.getDate(),
		      cacheKey = [this.credentials.secretAccessKey, date, this.region, this.service].join(),
		      kDate, kRegion, kService, kCredentials = credentialsCache.get(cacheKey);
		  if (!kCredentials) {
		    kDate = hmac('AWS4' + this.credentials.secretAccessKey, date);
		    kRegion = hmac(kDate, this.region);
		    kService = hmac(kRegion, this.service);
		    kCredentials = hmac(kService, 'aws4_request');
		    credentialsCache.set(cacheKey, kCredentials);
		  }
		  return hmac(kCredentials, this.stringToSign(), 'hex')
		};

		RequestSigner.prototype.stringToSign = function() {
		  return [
		    'AWS4-HMAC-SHA256',
		    this.getDateTime(),
		    this.credentialString(),
		    hash(this.canonicalString(), 'hex'),
		  ].join('\n')
		};

		RequestSigner.prototype.canonicalString = function() {
		  if (!this.parsedPath) this.prepareRequest();

		  var pathStr = this.parsedPath.path,
		      query = this.parsedPath.query,
		      headers = this.request.headers,
		      queryStr = '',
		      normalizePath = this.service !== 's3',
		      decodePath = this.service === 's3' || this.request.doNotEncodePath,
		      decodeSlashesInPath = this.service === 's3',
		      firstValOnly = this.service === 's3',
		      bodyHash;

		  if (this.service === 's3' && this.request.signQuery) {
		    bodyHash = 'UNSIGNED-PAYLOAD';
		  } else if (this.isCodeCommitGit) {
		    bodyHash = '';
		  } else {
		    bodyHash = headers['X-Amz-Content-Sha256'] || headers['x-amz-content-sha256'] ||
		      hash(this.request.body || '', 'hex');
		  }

		  if (query) {
		    var reducedQuery = Object.keys(query).reduce(function(obj, key) {
		      if (!key) return obj
		      obj[encodeRfc3986Full(key)] = !Array.isArray(query[key]) ? query[key] :
		        (firstValOnly ? query[key][0] : query[key]);
		      return obj
		    }, {});
		    var encodedQueryPieces = [];
		    Object.keys(reducedQuery).sort().forEach(function(key) {
		      if (!Array.isArray(reducedQuery[key])) {
		        encodedQueryPieces.push(key + '=' + encodeRfc3986Full(reducedQuery[key]));
		      } else {
		        reducedQuery[key].map(encodeRfc3986Full).sort()
		          .forEach(function(val) { encodedQueryPieces.push(key + '=' + val); });
		      }
		    });
		    queryStr = encodedQueryPieces.join('&');
		  }
		  if (pathStr !== '/') {
		    if (normalizePath) pathStr = pathStr.replace(/\/{2,}/g, '/');
		    pathStr = pathStr.split('/').reduce(function(path, piece) {
		      if (normalizePath && piece === '..') {
		        path.pop();
		      } else if (!normalizePath || piece !== '.') {
		        if (decodePath) piece = decodeURIComponent(piece.replace(/\+/g, ' '));
		        path.push(encodeRfc3986Full(piece));
		      }
		      return path
		    }, []).join('/');
		    if (pathStr[0] !== '/') pathStr = '/' + pathStr;
		    if (decodeSlashesInPath) pathStr = pathStr.replace(/%2F/g, '/');
		  }

		  return [
		    this.request.method || 'GET',
		    pathStr,
		    queryStr,
		    this.canonicalHeaders() + '\n',
		    this.signedHeaders(),
		    bodyHash,
		  ].join('\n')
		};

		RequestSigner.prototype.filterHeaders = function() {
		  var headers = this.request.headers,
		      extraHeadersToInclude = this.extraHeadersToInclude,
		      extraHeadersToIgnore = this.extraHeadersToIgnore;
		  this.filteredHeaders = Object.keys(headers)
		    .map(function(key) { return [key.toLowerCase(), headers[key]] })
		    .filter(function(entry) {
		      return extraHeadersToInclude[entry[0]] ||
		        (HEADERS_TO_IGNORE[entry[0]] == null && !extraHeadersToIgnore[entry[0]])
		    })
		    .sort(function(a, b) { return a[0] < b[0] ? -1 : 1 });
		};

		RequestSigner.prototype.canonicalHeaders = function() {
		  if (!this.filteredHeaders) this.filterHeaders();

		  return this.filteredHeaders.map(function(entry) {
		    return entry[0] + ':' + entry[1].toString().trim().replace(/\s+/g, ' ')
		  }).join('\n')
		};

		RequestSigner.prototype.signedHeaders = function() {
		  if (!this.filteredHeaders) this.filterHeaders();

		  return this.filteredHeaders.map(function(entry) { return entry[0] }).join(';')
		};

		RequestSigner.prototype.credentialString = function() {
		  return [
		    this.getDate(),
		    this.region,
		    this.service,
		    'aws4_request',
		  ].join('/')
		};

		RequestSigner.prototype.defaultCredentials = function() {
		  var env = process.env;
		  return {
		    accessKeyId: env.AWS_ACCESS_KEY_ID || env.AWS_ACCESS_KEY,
		    secretAccessKey: env.AWS_SECRET_ACCESS_KEY || env.AWS_SECRET_KEY,
		    sessionToken: env.AWS_SESSION_TOKEN,
		  }
		};

		RequestSigner.prototype.parsePath = function() {
		  var path = this.request.path || '/';

		  // S3 doesn't always encode characters > 127 correctly and
		  // all services don't encode characters > 255 correctly
		  // So if there are non-reserved chars (and it's not already all % encoded), just encode them all
		  if (/[^0-9A-Za-z;,/?:@&=+$\-_.!~*'()#%]/.test(path)) {
		    path = encodeURI(decodeURI(path));
		  }

		  var queryIx = path.indexOf('?'),
		      query = null;

		  if (queryIx >= 0) {
		    query = querystring.parse(path.slice(queryIx + 1));
		    path = path.slice(0, queryIx);
		  }

		  this.parsedPath = {
		    path: path,
		    query: query,
		  };
		};

		RequestSigner.prototype.formatPath = function() {
		  var path = this.parsedPath.path,
		      query = this.parsedPath.query;

		  if (!query) return path

		  // Services don't support empty query string keys
		  if (query[''] != null) delete query[''];

		  return path + '?' + encodeRfc3986(querystring.stringify(query))
		};

		aws4.RequestSigner = RequestSigner;

		aws4.sign = function(request, credentials) {
		  return new RequestSigner(request, credentials).sign()
		}; 
	} (aws4));
	return aws4;
}

var assert_1;
var hasRequiredAssert;

function requireAssert () {
	if (hasRequiredAssert) return assert_1;
	hasRequiredAssert = 1;
	// Copyright (c) 2012, Mark Cavage. All rights reserved.
	// Copyright 2015 Joyent, Inc.

	var assert = require$$0$7;
	var Stream = require$$0$6.Stream;
	var util = require$$1$2;


	///--- Globals

	/* JSSTYLED */
	var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;


	///--- Internal

	function _capitalize(str) {
	    return (str.charAt(0).toUpperCase() + str.slice(1));
	}

	function _toss(name, expected, oper, arg, actual) {
	    throw new assert.AssertionError({
	        message: util.format('%s (%s) is required', name, expected),
	        actual: (actual === undefined) ? typeof (arg) : actual(arg),
	        expected: expected,
	        operator: oper || '===',
	        stackStartFunction: _toss.caller
	    });
	}

	function _getClass(arg) {
	    return (Object.prototype.toString.call(arg).slice(8, -1));
	}

	function noop() {
	    // Why even bother with asserts?
	}


	///--- Exports

	var types = {
	    bool: {
	        check: function (arg) { return typeof (arg) === 'boolean'; }
	    },
	    func: {
	        check: function (arg) { return typeof (arg) === 'function'; }
	    },
	    string: {
	        check: function (arg) { return typeof (arg) === 'string'; }
	    },
	    object: {
	        check: function (arg) {
	            return typeof (arg) === 'object' && arg !== null;
	        }
	    },
	    number: {
	        check: function (arg) {
	            return typeof (arg) === 'number' && !isNaN(arg);
	        }
	    },
	    finite: {
	        check: function (arg) {
	            return typeof (arg) === 'number' && !isNaN(arg) && isFinite(arg);
	        }
	    },
	    buffer: {
	        check: function (arg) { return Buffer.isBuffer(arg); },
	        operator: 'Buffer.isBuffer'
	    },
	    array: {
	        check: function (arg) { return Array.isArray(arg); },
	        operator: 'Array.isArray'
	    },
	    stream: {
	        check: function (arg) { return arg instanceof Stream; },
	        operator: 'instanceof',
	        actual: _getClass
	    },
	    date: {
	        check: function (arg) { return arg instanceof Date; },
	        operator: 'instanceof',
	        actual: _getClass
	    },
	    regexp: {
	        check: function (arg) { return arg instanceof RegExp; },
	        operator: 'instanceof',
	        actual: _getClass
	    },
	    uuid: {
	        check: function (arg) {
	            return typeof (arg) === 'string' && UUID_REGEXP.test(arg);
	        },
	        operator: 'isUUID'
	    }
	};

	function _setExports(ndebug) {
	    var keys = Object.keys(types);
	    var out;

	    /* re-export standard assert */
	    if (process.env.NODE_NDEBUG) {
	        out = noop;
	    } else {
	        out = function (arg, msg) {
	            if (!arg) {
	                _toss(msg, 'true', arg);
	            }
	        };
	    }

	    /* standard checks */
	    keys.forEach(function (k) {
	        if (ndebug) {
	            out[k] = noop;
	            return;
	        }
	        var type = types[k];
	        out[k] = function (arg, msg) {
	            if (!type.check(arg)) {
	                _toss(msg, k, type.operator, arg, type.actual);
	            }
	        };
	    });

	    /* optional checks */
	    keys.forEach(function (k) {
	        var name = 'optional' + _capitalize(k);
	        if (ndebug) {
	            out[name] = noop;
	            return;
	        }
	        var type = types[k];
	        out[name] = function (arg, msg) {
	            if (arg === undefined || arg === null) {
	                return;
	            }
	            if (!type.check(arg)) {
	                _toss(msg, k, type.operator, arg, type.actual);
	            }
	        };
	    });

	    /* arrayOf checks */
	    keys.forEach(function (k) {
	        var name = 'arrayOf' + _capitalize(k);
	        if (ndebug) {
	            out[name] = noop;
	            return;
	        }
	        var type = types[k];
	        var expected = '[' + k + ']';
	        out[name] = function (arg, msg) {
	            if (!Array.isArray(arg)) {
	                _toss(msg, expected, type.operator, arg, type.actual);
	            }
	            var i;
	            for (i = 0; i < arg.length; i++) {
	                if (!type.check(arg[i])) {
	                    _toss(msg, expected, type.operator, arg, type.actual);
	                }
	            }
	        };
	    });

	    /* optionalArrayOf checks */
	    keys.forEach(function (k) {
	        var name = 'optionalArrayOf' + _capitalize(k);
	        if (ndebug) {
	            out[name] = noop;
	            return;
	        }
	        var type = types[k];
	        var expected = '[' + k + ']';
	        out[name] = function (arg, msg) {
	            if (arg === undefined || arg === null) {
	                return;
	            }
	            if (!Array.isArray(arg)) {
	                _toss(msg, expected, type.operator, arg, type.actual);
	            }
	            var i;
	            for (i = 0; i < arg.length; i++) {
	                if (!type.check(arg[i])) {
	                    _toss(msg, expected, type.operator, arg, type.actual);
	                }
	            }
	        };
	    });

	    /* re-export built-in assertions */
	    Object.keys(assert).forEach(function (k) {
	        if (k === 'AssertionError') {
	            out[k] = assert[k];
	            return;
	        }
	        if (ndebug) {
	            out[k] = noop;
	            return;
	        }
	        out[k] = assert[k];
	    });

	    /* export ourselves (for unit tests _only_) */
	    out._setExports = _setExports;

	    return out;
	}

	assert_1 = _setExports(process.env.NODE_NDEBUG);
	return assert_1;
}

/* eslint-disable node/no-deprecated-api */

var safer_1;
var hasRequiredSafer;

function requireSafer () {
	if (hasRequiredSafer) return safer_1;
	hasRequiredSafer = 1;

	var buffer = require$$0$4;
	var Buffer = buffer.Buffer;

	var safer = {};

	var key;

	for (key in buffer) {
	  if (!buffer.hasOwnProperty(key)) continue
	  if (key === 'SlowBuffer' || key === 'Buffer') continue
	  safer[key] = buffer[key];
	}

	var Safer = safer.Buffer = {};
	for (key in Buffer) {
	  if (!Buffer.hasOwnProperty(key)) continue
	  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
	  Safer[key] = Buffer[key];
	}

	safer.Buffer.prototype = Buffer.prototype;

	if (!Safer.from || Safer.from === Uint8Array.from) {
	  Safer.from = function (value, encodingOrOffset, length) {
	    if (typeof value === 'number') {
	      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
	    }
	    if (value && typeof value.length === 'undefined') {
	      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
	    }
	    return Buffer(value, encodingOrOffset, length)
	  };
	}

	if (!Safer.alloc) {
	  Safer.alloc = function (size, fill, encoding) {
	    if (typeof size !== 'number') {
	      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
	    }
	    if (size < 0 || size >= 2 * (1 << 30)) {
	      throw new RangeError('The value "' + size + '" is invalid for option "size"')
	    }
	    var buf = Buffer(size);
	    if (!fill || fill.length === 0) {
	      buf.fill(0);
	    } else if (typeof encoding === 'string') {
	      buf.fill(fill, encoding);
	    } else {
	      buf.fill(fill);
	    }
	    return buf
	  };
	}

	if (!safer.kStringMaxLength) {
	  try {
	    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;
	  } catch (e) {
	    // we can't determine kStringMaxLength in environments where process.binding
	    // is unsupported, so let's not set it
	  }
	}

	if (!safer.constants) {
	  safer.constants = {
	    MAX_LENGTH: safer.kMaxLength
	  };
	  if (safer.kStringMaxLength) {
	    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
	  }
	}

	safer_1 = safer;
	return safer_1;
}

var algs;
var hasRequiredAlgs;

function requireAlgs () {
	if (hasRequiredAlgs) return algs;
	hasRequiredAlgs = 1;
	// Copyright 2015 Joyent, Inc.

	var Buffer = requireSafer().Buffer;

	var algInfo = {
		'dsa': {
			parts: ['p', 'q', 'g', 'y'],
			sizePart: 'p'
		},
		'rsa': {
			parts: ['e', 'n'],
			sizePart: 'n'
		},
		'ecdsa': {
			parts: ['curve', 'Q'],
			sizePart: 'Q'
		},
		'ed25519': {
			parts: ['A'],
			sizePart: 'A'
		}
	};
	algInfo['curve25519'] = algInfo['ed25519'];

	var algPrivInfo = {
		'dsa': {
			parts: ['p', 'q', 'g', 'y', 'x']
		},
		'rsa': {
			parts: ['n', 'e', 'd', 'iqmp', 'p', 'q']
		},
		'ecdsa': {
			parts: ['curve', 'Q', 'd']
		},
		'ed25519': {
			parts: ['A', 'k']
		}
	};
	algPrivInfo['curve25519'] = algPrivInfo['ed25519'];

	var hashAlgs = {
		'md5': true,
		'sha1': true,
		'sha256': true,
		'sha384': true,
		'sha512': true
	};

	/*
	 * Taken from
	 * http://csrc.nist.gov/groups/ST/toolkit/documents/dss/NISTReCur.pdf
	 */
	var curves = {
		'nistp256': {
			size: 256,
			pkcs8oid: '1.2.840.10045.3.1.7',
			p: Buffer.from(('00' +
			    'ffffffff 00000001 00000000 00000000' +
			    '00000000 ffffffff ffffffff ffffffff').
			    replace(/ /g, ''), 'hex'),
			a: Buffer.from(('00' +
			    'FFFFFFFF 00000001 00000000 00000000' +
			    '00000000 FFFFFFFF FFFFFFFF FFFFFFFC').
			    replace(/ /g, ''), 'hex'),
			b: Buffer.from((
			    '5ac635d8 aa3a93e7 b3ebbd55 769886bc' +
			    '651d06b0 cc53b0f6 3bce3c3e 27d2604b').
			    replace(/ /g, ''), 'hex'),
			s: Buffer.from(('00' +
			    'c49d3608 86e70493 6a6678e1 139d26b7' +
			    '819f7e90').
			    replace(/ /g, ''), 'hex'),
			n: Buffer.from(('00' +
			    'ffffffff 00000000 ffffffff ffffffff' +
			    'bce6faad a7179e84 f3b9cac2 fc632551').
			    replace(/ /g, ''), 'hex'),
			G: Buffer.from(('04' +
			    '6b17d1f2 e12c4247 f8bce6e5 63a440f2' +
			    '77037d81 2deb33a0 f4a13945 d898c296' +
			    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16' +
			    '2bce3357 6b315ece cbb64068 37bf51f5').
			    replace(/ /g, ''), 'hex')
		},
		'nistp384': {
			size: 384,
			pkcs8oid: '1.3.132.0.34',
			p: Buffer.from(('00' +
			    'ffffffff ffffffff ffffffff ffffffff' +
			    'ffffffff ffffffff ffffffff fffffffe' +
			    'ffffffff 00000000 00000000 ffffffff').
			    replace(/ /g, ''), 'hex'),
			a: Buffer.from(('00' +
			    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +
			    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE' +
			    'FFFFFFFF 00000000 00000000 FFFFFFFC').
			    replace(/ /g, ''), 'hex'),
			b: Buffer.from((
			    'b3312fa7 e23ee7e4 988e056b e3f82d19' +
			    '181d9c6e fe814112 0314088f 5013875a' +
			    'c656398d 8a2ed19d 2a85c8ed d3ec2aef').
			    replace(/ /g, ''), 'hex'),
			s: Buffer.from(('00' +
			    'a335926a a319a27a 1d00896a 6773a482' +
			    '7acdac73').
			    replace(/ /g, ''), 'hex'),
			n: Buffer.from(('00' +
			    'ffffffff ffffffff ffffffff ffffffff' +
			    'ffffffff ffffffff c7634d81 f4372ddf' +
			    '581a0db2 48b0a77a ecec196a ccc52973').
			    replace(/ /g, ''), 'hex'),
			G: Buffer.from(('04' +
			    'aa87ca22 be8b0537 8eb1c71e f320ad74' +
			    '6e1d3b62 8ba79b98 59f741e0 82542a38' +
			    '5502f25d bf55296c 3a545e38 72760ab7' +
			    '3617de4a 96262c6f 5d9e98bf 9292dc29' +
			    'f8f41dbd 289a147c e9da3113 b5f0b8c0' +
			    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f').
			    replace(/ /g, ''), 'hex')
		},
		'nistp521': {
			size: 521,
			pkcs8oid: '1.3.132.0.35',
			p: Buffer.from((
			    '01ffffff ffffffff ffffffff ffffffff' +
			    'ffffffff ffffffff ffffffff ffffffff' +
			    'ffffffff ffffffff ffffffff ffffffff' +
			    'ffffffff ffffffff ffffffff ffffffff' +
			    'ffff').replace(/ /g, ''), 'hex'),
			a: Buffer.from(('01FF' +
			    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +
			    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +
			    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +
			    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFC').
			    replace(/ /g, ''), 'hex'),
			b: Buffer.from(('51' +
			    '953eb961 8e1c9a1f 929a21a0 b68540ee' +
			    'a2da725b 99b315f3 b8b48991 8ef109e1' +
			    '56193951 ec7e937b 1652c0bd 3bb1bf07' +
			    '3573df88 3d2c34f1 ef451fd4 6b503f00').
			    replace(/ /g, ''), 'hex'),
			s: Buffer.from(('00' +
			    'd09e8800 291cb853 96cc6717 393284aa' +
			    'a0da64ba').replace(/ /g, ''), 'hex'),
			n: Buffer.from(('01ff' +
			    'ffffffff ffffffff ffffffff ffffffff' +
			    'ffffffff ffffffff ffffffff fffffffa' +
			    '51868783 bf2f966b 7fcc0148 f709a5d0' +
			    '3bb5c9b8 899c47ae bb6fb71e 91386409').
			    replace(/ /g, ''), 'hex'),
			G: Buffer.from(('04' +
			    '00c6 858e06b7 0404e9cd 9e3ecb66 2395b442' +
			         '9c648139 053fb521 f828af60 6b4d3dba' +
			         'a14b5e77 efe75928 fe1dc127 a2ffa8de' +
			         '3348b3c1 856a429b f97e7e31 c2e5bd66' +
			    '0118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9' +
			         '98f54449 579b4468 17afbd17 273e662c' +
			         '97ee7299 5ef42640 c550b901 3fad0761' +
			         '353c7086 a272c240 88be9476 9fd16650').
			    replace(/ /g, ''), 'hex')
		}
	};

	algs = {
		info: algInfo,
		privInfo: algPrivInfo,
		hashAlgs: hashAlgs,
		curves: curves
	};
	return algs;
}

var errors$1;
var hasRequiredErrors$1;

function requireErrors$1 () {
	if (hasRequiredErrors$1) return errors$1;
	hasRequiredErrors$1 = 1;
	// Copyright 2015 Joyent, Inc.

	requireAssert();
	var util = require$$1$2;

	function FingerprintFormatError(fp, format) {
		if (Error.captureStackTrace)
			Error.captureStackTrace(this, FingerprintFormatError);
		this.name = 'FingerprintFormatError';
		this.fingerprint = fp;
		this.format = format;
		this.message = 'Fingerprint format is not supported, or is invalid: ';
		if (fp !== undefined)
			this.message += ' fingerprint = ' + fp;
		if (format !== undefined)
			this.message += ' format = ' + format;
	}
	util.inherits(FingerprintFormatError, Error);

	function InvalidAlgorithmError(alg) {
		if (Error.captureStackTrace)
			Error.captureStackTrace(this, InvalidAlgorithmError);
		this.name = 'InvalidAlgorithmError';
		this.algorithm = alg;
		this.message = 'Algorithm "' + alg + '" is not supported';
	}
	util.inherits(InvalidAlgorithmError, Error);

	function KeyParseError(name, format, innerErr) {
		if (Error.captureStackTrace)
			Error.captureStackTrace(this, KeyParseError);
		this.name = 'KeyParseError';
		this.format = format;
		this.keyName = name;
		this.innerErr = innerErr;
		this.message = 'Failed to parse ' + name + ' as a valid ' + format +
		    ' format key: ' + innerErr.message;
	}
	util.inherits(KeyParseError, Error);

	function SignatureParseError(type, format, innerErr) {
		if (Error.captureStackTrace)
			Error.captureStackTrace(this, SignatureParseError);
		this.name = 'SignatureParseError';
		this.type = type;
		this.format = format;
		this.innerErr = innerErr;
		this.message = 'Failed to parse the given data as a ' + type +
		    ' signature in ' + format + ' format: ' + innerErr.message;
	}
	util.inherits(SignatureParseError, Error);

	function CertificateParseError(name, format, innerErr) {
		if (Error.captureStackTrace)
			Error.captureStackTrace(this, CertificateParseError);
		this.name = 'CertificateParseError';
		this.format = format;
		this.certName = name;
		this.innerErr = innerErr;
		this.message = 'Failed to parse ' + name + ' as a valid ' + format +
		    ' format certificate: ' + innerErr.message;
	}
	util.inherits(CertificateParseError, Error);

	function KeyEncryptedError(name, format) {
		if (Error.captureStackTrace)
			Error.captureStackTrace(this, KeyEncryptedError);
		this.name = 'KeyEncryptedError';
		this.format = format;
		this.keyName = name;
		this.message = 'The ' + format + ' format key ' + name + ' is ' +
		    'encrypted (password-protected), and no passphrase was ' +
		    'provided in `options`';
	}
	util.inherits(KeyEncryptedError, Error);

	errors$1 = {
		FingerprintFormatError: FingerprintFormatError,
		InvalidAlgorithmError: InvalidAlgorithmError,
		KeyParseError: KeyParseError,
		SignatureParseError: SignatureParseError,
		KeyEncryptedError: KeyEncryptedError,
		CertificateParseError: CertificateParseError
	};
	return errors$1;
}

var ber = {exports: {}};

var errors;
var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;
	// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.


	errors = {

	  newInvalidAsn1Error: function (msg) {
	    var e = new Error();
	    e.name = 'InvalidAsn1Error';
	    e.message = msg || '';
	    return e;
	  }

	};
	return errors;
}

var types;
var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types;
	hasRequiredTypes = 1;
	// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.


	types = {
	  EOC: 0,
	  Boolean: 1,
	  Integer: 2,
	  BitString: 3,
	  OctetString: 4,
	  Null: 5,
	  OID: 6,
	  ObjectDescriptor: 7,
	  External: 8,
	  Real: 9, // float
	  Enumeration: 10,
	  PDV: 11,
	  Utf8String: 12,
	  RelativeOID: 13,
	  Sequence: 16,
	  Set: 17,
	  NumericString: 18,
	  PrintableString: 19,
	  T61String: 20,
	  VideotexString: 21,
	  IA5String: 22,
	  UTCTime: 23,
	  GeneralizedTime: 24,
	  GraphicString: 25,
	  VisibleString: 26,
	  GeneralString: 28,
	  UniversalString: 29,
	  CharacterString: 30,
	  BMPString: 31,
	  Constructor: 32,
	  Context: 128
	};
	return types;
}

var reader;
var hasRequiredReader;

function requireReader () {
	if (hasRequiredReader) return reader;
	hasRequiredReader = 1;
	// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

	var assert = require$$0$7;
	var Buffer = requireSafer().Buffer;

	var ASN1 = requireTypes();
	var errors = requireErrors();


	// --- Globals

	var newInvalidAsn1Error = errors.newInvalidAsn1Error;



	// --- API

	function Reader(data) {
	  if (!data || !Buffer.isBuffer(data))
	    throw new TypeError('data must be a node Buffer');

	  this._buf = data;
	  this._size = data.length;

	  // These hold the "current" state
	  this._len = 0;
	  this._offset = 0;
	}

	Object.defineProperty(Reader.prototype, 'length', {
	  enumerable: true,
	  get: function () { return (this._len); }
	});

	Object.defineProperty(Reader.prototype, 'offset', {
	  enumerable: true,
	  get: function () { return (this._offset); }
	});

	Object.defineProperty(Reader.prototype, 'remain', {
	  get: function () { return (this._size - this._offset); }
	});

	Object.defineProperty(Reader.prototype, 'buffer', {
	  get: function () { return (this._buf.slice(this._offset)); }
	});


	/**
	 * Reads a single byte and advances offset; you can pass in `true` to make this
	 * a "peek" operation (i.e., get the byte, but don't advance the offset).
	 *
	 * @param {Boolean} peek true means don't move offset.
	 * @return {Number} the next byte, null if not enough data.
	 */
	Reader.prototype.readByte = function (peek) {
	  if (this._size - this._offset < 1)
	    return null;

	  var b = this._buf[this._offset] & 0xff;

	  if (!peek)
	    this._offset += 1;

	  return b;
	};


	Reader.prototype.peek = function () {
	  return this.readByte(true);
	};


	/**
	 * Reads a (potentially) variable length off the BER buffer.  This call is
	 * not really meant to be called directly, as callers have to manipulate
	 * the internal buffer afterwards.
	 *
	 * As a result of this call, you can call `Reader.length`, until the
	 * next thing called that does a readLength.
	 *
	 * @return {Number} the amount of offset to advance the buffer.
	 * @throws {InvalidAsn1Error} on bad ASN.1
	 */
	Reader.prototype.readLength = function (offset) {
	  if (offset === undefined)
	    offset = this._offset;

	  if (offset >= this._size)
	    return null;

	  var lenB = this._buf[offset++] & 0xff;
	  if (lenB === null)
	    return null;

	  if ((lenB & 0x80) === 0x80) {
	    lenB &= 0x7f;

	    if (lenB === 0)
	      throw newInvalidAsn1Error('Indefinite length not supported');

	    if (lenB > 4)
	      throw newInvalidAsn1Error('encoding too long');

	    if (this._size - offset < lenB)
	      return null;

	    this._len = 0;
	    for (var i = 0; i < lenB; i++)
	      this._len = (this._len << 8) + (this._buf[offset++] & 0xff);

	  } else {
	    // Wasn't a variable length
	    this._len = lenB;
	  }

	  return offset;
	};


	/**
	 * Parses the next sequence in this BER buffer.
	 *
	 * To get the length of the sequence, call `Reader.length`.
	 *
	 * @return {Number} the sequence's tag.
	 */
	Reader.prototype.readSequence = function (tag) {
	  var seq = this.peek();
	  if (seq === null)
	    return null;
	  if (tag !== undefined && tag !== seq)
	    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
	                              ': got 0x' + seq.toString(16));

	  var o = this.readLength(this._offset + 1); // stored in `length`
	  if (o === null)
	    return null;

	  this._offset = o;
	  return seq;
	};


	Reader.prototype.readInt = function () {
	  return this._readTag(ASN1.Integer);
	};


	Reader.prototype.readBoolean = function () {
	  return (this._readTag(ASN1.Boolean) === 0 ? false : true);
	};


	Reader.prototype.readEnumeration = function () {
	  return this._readTag(ASN1.Enumeration);
	};


	Reader.prototype.readString = function (tag, retbuf) {
	  if (!tag)
	    tag = ASN1.OctetString;

	  var b = this.peek();
	  if (b === null)
	    return null;

	  if (b !== tag)
	    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
	                              ': got 0x' + b.toString(16));

	  var o = this.readLength(this._offset + 1); // stored in `length`

	  if (o === null)
	    return null;

	  if (this.length > this._size - o)
	    return null;

	  this._offset = o;

	  if (this.length === 0)
	    return retbuf ? Buffer.alloc(0) : '';

	  var str = this._buf.slice(this._offset, this._offset + this.length);
	  this._offset += this.length;

	  return retbuf ? str : str.toString('utf8');
	};

	Reader.prototype.readOID = function (tag) {
	  if (!tag)
	    tag = ASN1.OID;

	  var b = this.readString(tag, true);
	  if (b === null)
	    return null;

	  var values = [];
	  var value = 0;

	  for (var i = 0; i < b.length; i++) {
	    var byte = b[i] & 0xff;

	    value <<= 7;
	    value += byte & 0x7f;
	    if ((byte & 0x80) === 0) {
	      values.push(value);
	      value = 0;
	    }
	  }

	  value = values.shift();
	  values.unshift(value % 40);
	  values.unshift((value / 40) >> 0);

	  return values.join('.');
	};


	Reader.prototype._readTag = function (tag) {
	  assert.ok(tag !== undefined);

	  var b = this.peek();

	  if (b === null)
	    return null;

	  if (b !== tag)
	    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
	                              ': got 0x' + b.toString(16));

	  var o = this.readLength(this._offset + 1); // stored in `length`
	  if (o === null)
	    return null;

	  if (this.length > 4)
	    throw newInvalidAsn1Error('Integer too long: ' + this.length);

	  if (this.length > this._size - o)
	    return null;
	  this._offset = o;

	  var fb = this._buf[this._offset];
	  var value = 0;

	  for (var i = 0; i < this.length; i++) {
	    value <<= 8;
	    value |= (this._buf[this._offset++] & 0xff);
	  }

	  if ((fb & 0x80) === 0x80 && i !== 4)
	    value -= (1 << (i * 8));

	  return value >> 0;
	};



	// --- Exported API

	reader = Reader;
	return reader;
}

var writer;
var hasRequiredWriter;

function requireWriter () {
	if (hasRequiredWriter) return writer;
	hasRequiredWriter = 1;
	// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

	var assert = require$$0$7;
	var Buffer = requireSafer().Buffer;
	var ASN1 = requireTypes();
	var errors = requireErrors();


	// --- Globals

	var newInvalidAsn1Error = errors.newInvalidAsn1Error;

	var DEFAULT_OPTS = {
	  size: 1024,
	  growthFactor: 8
	};


	// --- Helpers

	function merge(from, to) {
	  assert.ok(from);
	  assert.equal(typeof (from), 'object');
	  assert.ok(to);
	  assert.equal(typeof (to), 'object');

	  var keys = Object.getOwnPropertyNames(from);
	  keys.forEach(function (key) {
	    if (to[key])
	      return;

	    var value = Object.getOwnPropertyDescriptor(from, key);
	    Object.defineProperty(to, key, value);
	  });

	  return to;
	}



	// --- API

	function Writer(options) {
	  options = merge(DEFAULT_OPTS, options || {});

	  this._buf = Buffer.alloc(options.size || 1024);
	  this._size = this._buf.length;
	  this._offset = 0;
	  this._options = options;

	  // A list of offsets in the buffer where we need to insert
	  // sequence tag/len pairs.
	  this._seq = [];
	}

	Object.defineProperty(Writer.prototype, 'buffer', {
	  get: function () {
	    if (this._seq.length)
	      throw newInvalidAsn1Error(this._seq.length + ' unended sequence(s)');

	    return (this._buf.slice(0, this._offset));
	  }
	});

	Writer.prototype.writeByte = function (b) {
	  if (typeof (b) !== 'number')
	    throw new TypeError('argument must be a Number');

	  this._ensure(1);
	  this._buf[this._offset++] = b;
	};


	Writer.prototype.writeInt = function (i, tag) {
	  if (typeof (i) !== 'number')
	    throw new TypeError('argument must be a Number');
	  if (typeof (tag) !== 'number')
	    tag = ASN1.Integer;

	  var sz = 4;

	  while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000 >> 0)) &&
	        (sz > 1)) {
	    sz--;
	    i <<= 8;
	  }

	  if (sz > 4)
	    throw newInvalidAsn1Error('BER ints cannot be > 0xffffffff');

	  this._ensure(2 + sz);
	  this._buf[this._offset++] = tag;
	  this._buf[this._offset++] = sz;

	  while (sz-- > 0) {
	    this._buf[this._offset++] = ((i & 0xff000000) >>> 24);
	    i <<= 8;
	  }

	};


	Writer.prototype.writeNull = function () {
	  this.writeByte(ASN1.Null);
	  this.writeByte(0x00);
	};


	Writer.prototype.writeEnumeration = function (i, tag) {
	  if (typeof (i) !== 'number')
	    throw new TypeError('argument must be a Number');
	  if (typeof (tag) !== 'number')
	    tag = ASN1.Enumeration;

	  return this.writeInt(i, tag);
	};


	Writer.prototype.writeBoolean = function (b, tag) {
	  if (typeof (b) !== 'boolean')
	    throw new TypeError('argument must be a Boolean');
	  if (typeof (tag) !== 'number')
	    tag = ASN1.Boolean;

	  this._ensure(3);
	  this._buf[this._offset++] = tag;
	  this._buf[this._offset++] = 0x01;
	  this._buf[this._offset++] = b ? 0xff : 0x00;
	};


	Writer.prototype.writeString = function (s, tag) {
	  if (typeof (s) !== 'string')
	    throw new TypeError('argument must be a string (was: ' + typeof (s) + ')');
	  if (typeof (tag) !== 'number')
	    tag = ASN1.OctetString;

	  var len = Buffer.byteLength(s);
	  this.writeByte(tag);
	  this.writeLength(len);
	  if (len) {
	    this._ensure(len);
	    this._buf.write(s, this._offset);
	    this._offset += len;
	  }
	};


	Writer.prototype.writeBuffer = function (buf, tag) {
	  if (typeof (tag) !== 'number')
	    throw new TypeError('tag must be a number');
	  if (!Buffer.isBuffer(buf))
	    throw new TypeError('argument must be a buffer');

	  this.writeByte(tag);
	  this.writeLength(buf.length);
	  this._ensure(buf.length);
	  buf.copy(this._buf, this._offset, 0, buf.length);
	  this._offset += buf.length;
	};


	Writer.prototype.writeStringArray = function (strings) {
	  if ((!strings instanceof Array))
	    throw new TypeError('argument must be an Array[String]');

	  var self = this;
	  strings.forEach(function (s) {
	    self.writeString(s);
	  });
	};

	// This is really to solve DER cases, but whatever for now
	Writer.prototype.writeOID = function (s, tag) {
	  if (typeof (s) !== 'string')
	    throw new TypeError('argument must be a string');
	  if (typeof (tag) !== 'number')
	    tag = ASN1.OID;

	  if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
	    throw new Error('argument is not a valid OID string');

	  function encodeOctet(bytes, octet) {
	    if (octet < 128) {
	        bytes.push(octet);
	    } else if (octet < 16384) {
	        bytes.push((octet >>> 7) | 0x80);
	        bytes.push(octet & 0x7F);
	    } else if (octet < 2097152) {
	      bytes.push((octet >>> 14) | 0x80);
	      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
	      bytes.push(octet & 0x7F);
	    } else if (octet < 268435456) {
	      bytes.push((octet >>> 21) | 0x80);
	      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
	      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
	      bytes.push(octet & 0x7F);
	    } else {
	      bytes.push(((octet >>> 28) | 0x80) & 0xFF);
	      bytes.push(((octet >>> 21) | 0x80) & 0xFF);
	      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
	      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
	      bytes.push(octet & 0x7F);
	    }
	  }

	  var tmp = s.split('.');
	  var bytes = [];
	  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
	  tmp.slice(2).forEach(function (b) {
	    encodeOctet(bytes, parseInt(b, 10));
	  });

	  var self = this;
	  this._ensure(2 + bytes.length);
	  this.writeByte(tag);
	  this.writeLength(bytes.length);
	  bytes.forEach(function (b) {
	    self.writeByte(b);
	  });
	};


	Writer.prototype.writeLength = function (len) {
	  if (typeof (len) !== 'number')
	    throw new TypeError('argument must be a Number');

	  this._ensure(4);

	  if (len <= 0x7f) {
	    this._buf[this._offset++] = len;
	  } else if (len <= 0xff) {
	    this._buf[this._offset++] = 0x81;
	    this._buf[this._offset++] = len;
	  } else if (len <= 0xffff) {
	    this._buf[this._offset++] = 0x82;
	    this._buf[this._offset++] = len >> 8;
	    this._buf[this._offset++] = len;
	  } else if (len <= 0xffffff) {
	    this._buf[this._offset++] = 0x83;
	    this._buf[this._offset++] = len >> 16;
	    this._buf[this._offset++] = len >> 8;
	    this._buf[this._offset++] = len;
	  } else {
	    throw newInvalidAsn1Error('Length too long (> 4 bytes)');
	  }
	};

	Writer.prototype.startSequence = function (tag) {
	  if (typeof (tag) !== 'number')
	    tag = ASN1.Sequence | ASN1.Constructor;

	  this.writeByte(tag);
	  this._seq.push(this._offset);
	  this._ensure(3);
	  this._offset += 3;
	};


	Writer.prototype.endSequence = function () {
	  var seq = this._seq.pop();
	  var start = seq + 3;
	  var len = this._offset - start;

	  if (len <= 0x7f) {
	    this._shift(start, len, -2);
	    this._buf[seq] = len;
	  } else if (len <= 0xff) {
	    this._shift(start, len, -1);
	    this._buf[seq] = 0x81;
	    this._buf[seq + 1] = len;
	  } else if (len <= 0xffff) {
	    this._buf[seq] = 0x82;
	    this._buf[seq + 1] = len >> 8;
	    this._buf[seq + 2] = len;
	  } else if (len <= 0xffffff) {
	    this._shift(start, len, 1);
	    this._buf[seq] = 0x83;
	    this._buf[seq + 1] = len >> 16;
	    this._buf[seq + 2] = len >> 8;
	    this._buf[seq + 3] = len;
	  } else {
	    throw newInvalidAsn1Error('Sequence too long');
	  }
	};


	Writer.prototype._shift = function (start, len, shift) {
	  assert.ok(start !== undefined);
	  assert.ok(len !== undefined);
	  assert.ok(shift);

	  this._buf.copy(this._buf, start + shift, start, start + len);
	  this._offset += shift;
	};

	Writer.prototype._ensure = function (len) {
	  assert.ok(len);

	  if (this._size - this._offset < len) {
	    var sz = this._size * this._options.growthFactor;
	    if (sz - this._offset < len)
	      sz += len;

	    var buf = Buffer.alloc(sz);

	    this._buf.copy(buf, 0, 0, this._offset);
	    this._buf = buf;
	    this._size = sz;
	  }
	};



	// --- Exported API

	writer = Writer;
	return writer;
}

var hasRequiredBer;

function requireBer () {
	if (hasRequiredBer) return ber.exports;
	hasRequiredBer = 1;
	(function (module) {
		// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

		var errors = requireErrors();
		var types = requireTypes();

		var Reader = requireReader();
		var Writer = requireWriter();


		// --- Exports

		module.exports = {

		  Reader: Reader,

		  Writer: Writer

		};

		for (var t in types) {
		  if (types.hasOwnProperty(t))
		    module.exports[t] = types[t];
		}
		for (var e in errors) {
		  if (errors.hasOwnProperty(e))
		    module.exports[e] = errors[e];
		} 
	} (ber));
	return ber.exports;
}

var lib$9;
var hasRequiredLib$9;

function requireLib$9 () {
	if (hasRequiredLib$9) return lib$9;
	hasRequiredLib$9 = 1;
	// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

	// If you have no idea what ASN.1 or BER is, see this:
	// ftp://ftp.rsa.com/pub/pkcs/ascii/layman.asc

	var Ber = requireBer();



	// --- Exported API

	lib$9 = {

	  Ber: Ber,

	  BerReader: Ber.Reader,

	  BerWriter: Ber.Writer

	};
	return lib$9;
}

var jsbn$1 = {exports: {}};

var jsbn = jsbn$1.exports;

var hasRequiredJsbn;

function requireJsbn () {
	if (hasRequiredJsbn) return jsbn$1.exports;
	hasRequiredJsbn = 1;
	(function (module, exports) {
		(function(){

		    // Copyright (c) 2005  Tom Wu
		    // All Rights Reserved.
		    // See "LICENSE" for details.

		    // Basic JavaScript BN library - subset useful for RSA encryption.

		    // Bits per digit
		    var dbits;

		    // JavaScript engine analysis
		    var canary = 0xdeadbeefcafe;
		    var j_lm = ((canary&0xffffff)==0xefcafe);

		    // (public) Constructor
		    function BigInteger(a,b,c) {
		      if(a != null)
		        if("number" == typeof a) this.fromNumber(a,b,c);
		        else if(b == null && "string" != typeof a) this.fromString(a,256);
		        else this.fromString(a,b);
		    }

		    // return new, unset BigInteger
		    function nbi() { return new BigInteger(null); }

		    // am: Compute w_j += (x*this_i), propagate carries,
		    // c is initial carry, returns final carry.
		    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
		    // We need to select the fastest one that works in this environment.

		    // am1: use a single mult and divide to get the high bits,
		    // max digit bits should be 26 because
		    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
		    function am1(i,x,w,j,c,n) {
		      while(--n >= 0) {
		        var v = x*this[i++]+w[j]+c;
		        c = Math.floor(v/0x4000000);
		        w[j++] = v&0x3ffffff;
		      }
		      return c;
		    }
		    // am2 avoids a big mult-and-extract completely.
		    // Max digit bits should be <= 30 because we do bitwise ops
		    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
		    function am2(i,x,w,j,c,n) {
		      var xl = x&0x7fff, xh = x>>15;
		      while(--n >= 0) {
		        var l = this[i]&0x7fff;
		        var h = this[i++]>>15;
		        var m = xh*l+h*xl;
		        l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
		        c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
		        w[j++] = l&0x3fffffff;
		      }
		      return c;
		    }
		    // Alternately, set max digit bits to 28 since some
		    // browsers slow down when dealing with 32-bit numbers.
		    function am3(i,x,w,j,c,n) {
		      var xl = x&0x3fff, xh = x>>14;
		      while(--n >= 0) {
		        var l = this[i]&0x3fff;
		        var h = this[i++]>>14;
		        var m = xh*l+h*xl;
		        l = xl*l+((m&0x3fff)<<14)+w[j]+c;
		        c = (l>>28)+(m>>14)+xh*h;
		        w[j++] = l&0xfffffff;
		      }
		      return c;
		    }
		    var inBrowser = typeof navigator !== "undefined";
		    if(inBrowser && j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
		      BigInteger.prototype.am = am2;
		      dbits = 30;
		    }
		    else if(inBrowser && j_lm && (navigator.appName != "Netscape")) {
		      BigInteger.prototype.am = am1;
		      dbits = 26;
		    }
		    else { // Mozilla/Netscape seems to prefer am3
		      BigInteger.prototype.am = am3;
		      dbits = 28;
		    }

		    BigInteger.prototype.DB = dbits;
		    BigInteger.prototype.DM = ((1<<dbits)-1);
		    BigInteger.prototype.DV = (1<<dbits);

		    var BI_FP = 52;
		    BigInteger.prototype.FV = Math.pow(2,BI_FP);
		    BigInteger.prototype.F1 = BI_FP-dbits;
		    BigInteger.prototype.F2 = 2*dbits-BI_FP;

		    // Digit conversions
		    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
		    var BI_RC = new Array();
		    var rr,vv;
		    rr = "0".charCodeAt(0);
		    for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
		    rr = "a".charCodeAt(0);
		    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
		    rr = "A".charCodeAt(0);
		    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

		    function int2char(n) { return BI_RM.charAt(n); }
		    function intAt(s,i) {
		      var c = BI_RC[s.charCodeAt(i)];
		      return (c==null)?-1:c;
		    }

		    // (protected) copy this to r
		    function bnpCopyTo(r) {
		      for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
		      r.t = this.t;
		      r.s = this.s;
		    }

		    // (protected) set from integer value x, -DV <= x < DV
		    function bnpFromInt(x) {
		      this.t = 1;
		      this.s = (x<0)?-1:0;
		      if(x > 0) this[0] = x;
		      else if(x < -1) this[0] = x+this.DV;
		      else this.t = 0;
		    }

		    // return bigint initialized to value
		    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

		    // (protected) set from string and radix
		    function bnpFromString(s,b) {
		      var k;
		      if(b == 16) k = 4;
		      else if(b == 8) k = 3;
		      else if(b == 256) k = 8; // byte array
		      else if(b == 2) k = 1;
		      else if(b == 32) k = 5;
		      else if(b == 4) k = 2;
		      else { this.fromRadix(s,b); return; }
		      this.t = 0;
		      this.s = 0;
		      var i = s.length, mi = false, sh = 0;
		      while(--i >= 0) {
		        var x = (k==8)?s[i]&0xff:intAt(s,i);
		        if(x < 0) {
		          if(s.charAt(i) == "-") mi = true;
		          continue;
		        }
		        mi = false;
		        if(sh == 0)
		          this[this.t++] = x;
		        else if(sh+k > this.DB) {
		          this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
		          this[this.t++] = (x>>(this.DB-sh));
		        }
		        else
		          this[this.t-1] |= x<<sh;
		        sh += k;
		        if(sh >= this.DB) sh -= this.DB;
		      }
		      if(k == 8 && (s[0]&0x80) != 0) {
		        this.s = -1;
		        if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
		      }
		      this.clamp();
		      if(mi) BigInteger.ZERO.subTo(this,this);
		    }

		    // (protected) clamp off excess high words
		    function bnpClamp() {
		      var c = this.s&this.DM;
		      while(this.t > 0 && this[this.t-1] == c) --this.t;
		    }

		    // (public) return string representation in given radix
		    function bnToString(b) {
		      if(this.s < 0) return "-"+this.negate().toString(b);
		      var k;
		      if(b == 16) k = 4;
		      else if(b == 8) k = 3;
		      else if(b == 2) k = 1;
		      else if(b == 32) k = 5;
		      else if(b == 4) k = 2;
		      else return this.toRadix(b);
		      var km = (1<<k)-1, d, m = false, r = "", i = this.t;
		      var p = this.DB-(i*this.DB)%k;
		      if(i-- > 0) {
		        if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }
		        while(i >= 0) {
		          if(p < k) {
		            d = (this[i]&((1<<p)-1))<<(k-p);
		            d |= this[--i]>>(p+=this.DB-k);
		          }
		          else {
		            d = (this[i]>>(p-=k))&km;
		            if(p <= 0) { p += this.DB; --i; }
		          }
		          if(d > 0) m = true;
		          if(m) r += int2char(d);
		        }
		      }
		      return m?r:"0";
		    }

		    // (public) -this
		    function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

		    // (public) |this|
		    function bnAbs() { return (this.s<0)?this.negate():this; }

		    // (public) return + if this > a, - if this < a, 0 if equal
		    function bnCompareTo(a) {
		      var r = this.s-a.s;
		      if(r != 0) return r;
		      var i = this.t;
		      r = i-a.t;
		      if(r != 0) return (this.s<0)?-r:r;
		      while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
		      return 0;
		    }

		    // returns bit length of the integer x
		    function nbits(x) {
		      var r = 1, t;
		      if((t=x>>>16) != 0) { x = t; r += 16; }
		      if((t=x>>8) != 0) { x = t; r += 8; }
		      if((t=x>>4) != 0) { x = t; r += 4; }
		      if((t=x>>2) != 0) { x = t; r += 2; }
		      if((t=x>>1) != 0) { x = t; r += 1; }
		      return r;
		    }

		    // (public) return the number of bits in "this"
		    function bnBitLength() {
		      if(this.t <= 0) return 0;
		      return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
		    }

		    // (protected) r = this << n*DB
		    function bnpDLShiftTo(n,r) {
		      var i;
		      for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
		      for(i = n-1; i >= 0; --i) r[i] = 0;
		      r.t = this.t+n;
		      r.s = this.s;
		    }

		    // (protected) r = this >> n*DB
		    function bnpDRShiftTo(n,r) {
		      for(var i = n; i < this.t; ++i) r[i-n] = this[i];
		      r.t = Math.max(this.t-n,0);
		      r.s = this.s;
		    }

		    // (protected) r = this << n
		    function bnpLShiftTo(n,r) {
		      var bs = n%this.DB;
		      var cbs = this.DB-bs;
		      var bm = (1<<cbs)-1;
		      var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
		      for(i = this.t-1; i >= 0; --i) {
		        r[i+ds+1] = (this[i]>>cbs)|c;
		        c = (this[i]&bm)<<bs;
		      }
		      for(i = ds-1; i >= 0; --i) r[i] = 0;
		      r[ds] = c;
		      r.t = this.t+ds+1;
		      r.s = this.s;
		      r.clamp();
		    }

		    // (protected) r = this >> n
		    function bnpRShiftTo(n,r) {
		      r.s = this.s;
		      var ds = Math.floor(n/this.DB);
		      if(ds >= this.t) { r.t = 0; return; }
		      var bs = n%this.DB;
		      var cbs = this.DB-bs;
		      var bm = (1<<bs)-1;
		      r[0] = this[ds]>>bs;
		      for(var i = ds+1; i < this.t; ++i) {
		        r[i-ds-1] |= (this[i]&bm)<<cbs;
		        r[i-ds] = this[i]>>bs;
		      }
		      if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;
		      r.t = this.t-ds;
		      r.clamp();
		    }

		    // (protected) r = this - a
		    function bnpSubTo(a,r) {
		      var i = 0, c = 0, m = Math.min(a.t,this.t);
		      while(i < m) {
		        c += this[i]-a[i];
		        r[i++] = c&this.DM;
		        c >>= this.DB;
		      }
		      if(a.t < this.t) {
		        c -= a.s;
		        while(i < this.t) {
		          c += this[i];
		          r[i++] = c&this.DM;
		          c >>= this.DB;
		        }
		        c += this.s;
		      }
		      else {
		        c += this.s;
		        while(i < a.t) {
		          c -= a[i];
		          r[i++] = c&this.DM;
		          c >>= this.DB;
		        }
		        c -= a.s;
		      }
		      r.s = (c<0)?-1:0;
		      if(c < -1) r[i++] = this.DV+c;
		      else if(c > 0) r[i++] = c;
		      r.t = i;
		      r.clamp();
		    }

		    // (protected) r = this * a, r != this,a (HAC 14.12)
		    // "this" should be the larger one if appropriate.
		    function bnpMultiplyTo(a,r) {
		      var x = this.abs(), y = a.abs();
		      var i = x.t;
		      r.t = i+y.t;
		      while(--i >= 0) r[i] = 0;
		      for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
		      r.s = 0;
		      r.clamp();
		      if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
		    }

		    // (protected) r = this^2, r != this (HAC 14.16)
		    function bnpSquareTo(r) {
		      var x = this.abs();
		      var i = r.t = 2*x.t;
		      while(--i >= 0) r[i] = 0;
		      for(i = 0; i < x.t-1; ++i) {
		        var c = x.am(i,x[i],r,2*i,0,1);
		        if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
		          r[i+x.t] -= x.DV;
		          r[i+x.t+1] = 1;
		        }
		      }
		      if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
		      r.s = 0;
		      r.clamp();
		    }

		    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
		    // r != q, this != m.  q or r may be null.
		    function bnpDivRemTo(m,q,r) {
		      var pm = m.abs();
		      if(pm.t <= 0) return;
		      var pt = this.abs();
		      if(pt.t < pm.t) {
		        if(q != null) q.fromInt(0);
		        if(r != null) this.copyTo(r);
		        return;
		      }
		      if(r == null) r = nbi();
		      var y = nbi(), ts = this.s, ms = m.s;
		      var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus
		      if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
		      else { pm.copyTo(y); pt.copyTo(r); }
		      var ys = y.t;
		      var y0 = y[ys-1];
		      if(y0 == 0) return;
		      var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
		      var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
		      var i = r.t, j = i-ys, t = (q==null)?nbi():q;
		      y.dlShiftTo(j,t);
		      if(r.compareTo(t) >= 0) {
		        r[r.t++] = 1;
		        r.subTo(t,r);
		      }
		      BigInteger.ONE.dlShiftTo(ys,t);
		      t.subTo(y,y);  // "negative" y so we can replace sub with am later
		      while(y.t < ys) y[y.t++] = 0;
		      while(--j >= 0) {
		        // Estimate quotient digit
		        var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
		        if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out
		          y.dlShiftTo(j,t);
		          r.subTo(t,r);
		          while(r[i] < --qd) r.subTo(t,r);
		        }
		      }
		      if(q != null) {
		        r.drShiftTo(ys,q);
		        if(ts != ms) BigInteger.ZERO.subTo(q,q);
		      }
		      r.t = ys;
		      r.clamp();
		      if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder
		      if(ts < 0) BigInteger.ZERO.subTo(r,r);
		    }

		    // (public) this mod a
		    function bnMod(a) {
		      var r = nbi();
		      this.abs().divRemTo(a,null,r);
		      if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
		      return r;
		    }

		    // Modular reduction using "classic" algorithm
		    function Classic(m) { this.m = m; }
		    function cConvert(x) {
		      if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
		      else return x;
		    }
		    function cRevert(x) { return x; }
		    function cReduce(x) { x.divRemTo(this.m,null,x); }
		    function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
		    function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

		    Classic.prototype.convert = cConvert;
		    Classic.prototype.revert = cRevert;
		    Classic.prototype.reduce = cReduce;
		    Classic.prototype.mulTo = cMulTo;
		    Classic.prototype.sqrTo = cSqrTo;

		    // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
		    // justification:
		    //         xy == 1 (mod m)
		    //         xy =  1+km
		    //   xy(2-xy) = (1+km)(1-km)
		    // x[y(2-xy)] = 1-k^2m^2
		    // x[y(2-xy)] == 1 (mod m^2)
		    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
		    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
		    // JS multiply "overflows" differently from C/C++, so care is needed here.
		    function bnpInvDigit() {
		      if(this.t < 1) return 0;
		      var x = this[0];
		      if((x&1) == 0) return 0;
		      var y = x&3;       // y == 1/x mod 2^2
		      y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4
		      y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8
		      y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16
		      // last step - calculate inverse mod DV directly;
		      // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
		      y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits
		      // we really want the negative inverse, and -DV < y < DV
		      return (y>0)?this.DV-y:-y;
		    }

		    // Montgomery reduction
		    function Montgomery(m) {
		      this.m = m;
		      this.mp = m.invDigit();
		      this.mpl = this.mp&0x7fff;
		      this.mph = this.mp>>15;
		      this.um = (1<<(m.DB-15))-1;
		      this.mt2 = 2*m.t;
		    }

		    // xR mod m
		    function montConvert(x) {
		      var r = nbi();
		      x.abs().dlShiftTo(this.m.t,r);
		      r.divRemTo(this.m,null,r);
		      if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
		      return r;
		    }

		    // x/R mod m
		    function montRevert(x) {
		      var r = nbi();
		      x.copyTo(r);
		      this.reduce(r);
		      return r;
		    }

		    // x = x/R mod m (HAC 14.32)
		    function montReduce(x) {
		      while(x.t <= this.mt2) // pad x so am has enough room later
		        x[x.t++] = 0;
		      for(var i = 0; i < this.m.t; ++i) {
		        // faster way of calculating u0 = x[i]*mp mod DV
		        var j = x[i]&0x7fff;
		        var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
		        // use am to combine the multiply-shift-add into one call
		        j = i+this.m.t;
		        x[j] += this.m.am(0,u0,x,i,0,this.m.t);
		        // propagate carry
		        while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
		      }
		      x.clamp();
		      x.drShiftTo(this.m.t,x);
		      if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
		    }

		    // r = "x^2/R mod m"; x != r
		    function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

		    // r = "xy/R mod m"; x,y != r
		    function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

		    Montgomery.prototype.convert = montConvert;
		    Montgomery.prototype.revert = montRevert;
		    Montgomery.prototype.reduce = montReduce;
		    Montgomery.prototype.mulTo = montMulTo;
		    Montgomery.prototype.sqrTo = montSqrTo;

		    // (protected) true iff this is even
		    function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }

		    // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
		    function bnpExp(e,z) {
		      if(e > 0xffffffff || e < 1) return BigInteger.ONE;
		      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
		      g.copyTo(r);
		      while(--i >= 0) {
		        z.sqrTo(r,r2);
		        if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
		        else { var t = r; r = r2; r2 = t; }
		      }
		      return z.revert(r);
		    }

		    // (public) this^e % m, 0 <= e < 2^32
		    function bnModPowInt(e,m) {
		      var z;
		      if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
		      return this.exp(e,z);
		    }

		    // protected
		    BigInteger.prototype.copyTo = bnpCopyTo;
		    BigInteger.prototype.fromInt = bnpFromInt;
		    BigInteger.prototype.fromString = bnpFromString;
		    BigInteger.prototype.clamp = bnpClamp;
		    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
		    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
		    BigInteger.prototype.lShiftTo = bnpLShiftTo;
		    BigInteger.prototype.rShiftTo = bnpRShiftTo;
		    BigInteger.prototype.subTo = bnpSubTo;
		    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
		    BigInteger.prototype.squareTo = bnpSquareTo;
		    BigInteger.prototype.divRemTo = bnpDivRemTo;
		    BigInteger.prototype.invDigit = bnpInvDigit;
		    BigInteger.prototype.isEven = bnpIsEven;
		    BigInteger.prototype.exp = bnpExp;

		    // public
		    BigInteger.prototype.toString = bnToString;
		    BigInteger.prototype.negate = bnNegate;
		    BigInteger.prototype.abs = bnAbs;
		    BigInteger.prototype.compareTo = bnCompareTo;
		    BigInteger.prototype.bitLength = bnBitLength;
		    BigInteger.prototype.mod = bnMod;
		    BigInteger.prototype.modPowInt = bnModPowInt;

		    // "constants"
		    BigInteger.ZERO = nbv(0);
		    BigInteger.ONE = nbv(1);

		    // Copyright (c) 2005-2009  Tom Wu
		    // All Rights Reserved.
		    // See "LICENSE" for details.

		    // Extended JavaScript BN functions, required for RSA private ops.

		    // Version 1.1: new BigInteger("0", 10) returns "proper" zero
		    // Version 1.2: square() API, isProbablePrime fix

		    // (public)
		    function bnClone() { var r = nbi(); this.copyTo(r); return r; }

		    // (public) return value as integer
		    function bnIntValue() {
		      if(this.s < 0) {
		        if(this.t == 1) return this[0]-this.DV;
		        else if(this.t == 0) return -1;
		      }
		      else if(this.t == 1) return this[0];
		      else if(this.t == 0) return 0;
		      // assumes 16 < DB < 32
		      return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];
		    }

		    // (public) return value as byte
		    function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }

		    // (public) return value as short (assumes DB>=16)
		    function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }

		    // (protected) return x s.t. r^x < DV
		    function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }

		    // (public) 0 if this == 0, 1 if this > 0
		    function bnSigNum() {
		      if(this.s < 0) return -1;
		      else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
		      else return 1;
		    }

		    // (protected) convert to radix string
		    function bnpToRadix(b) {
		      if(b == null) b = 10;
		      if(this.signum() == 0 || b < 2 || b > 36) return "0";
		      var cs = this.chunkSize(b);
		      var a = Math.pow(b,cs);
		      var d = nbv(a), y = nbi(), z = nbi(), r = "";
		      this.divRemTo(d,y,z);
		      while(y.signum() > 0) {
		        r = (a+z.intValue()).toString(b).substr(1) + r;
		        y.divRemTo(d,y,z);
		      }
		      return z.intValue().toString(b) + r;
		    }

		    // (protected) convert from radix string
		    function bnpFromRadix(s,b) {
		      this.fromInt(0);
		      if(b == null) b = 10;
		      var cs = this.chunkSize(b);
		      var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
		      for(var i = 0; i < s.length; ++i) {
		        var x = intAt(s,i);
		        if(x < 0) {
		          if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
		          continue;
		        }
		        w = b*w+x;
		        if(++j >= cs) {
		          this.dMultiply(d);
		          this.dAddOffset(w,0);
		          j = 0;
		          w = 0;
		        }
		      }
		      if(j > 0) {
		        this.dMultiply(Math.pow(b,j));
		        this.dAddOffset(w,0);
		      }
		      if(mi) BigInteger.ZERO.subTo(this,this);
		    }

		    // (protected) alternate constructor
		    function bnpFromNumber(a,b,c) {
		      if("number" == typeof b) {
		        // new BigInteger(int,int,RNG)
		        if(a < 2) this.fromInt(1);
		        else {
		          this.fromNumber(a,c);
		          if(!this.testBit(a-1))	// force MSB set
		            this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
		          if(this.isEven()) this.dAddOffset(1,0); // force odd
		          while(!this.isProbablePrime(b)) {
		            this.dAddOffset(2,0);
		            if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
		          }
		        }
		      }
		      else {
		        // new BigInteger(int,RNG)
		        var x = new Array(), t = a&7;
		        x.length = (a>>3)+1;
		        b.nextBytes(x);
		        if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;
		        this.fromString(x,256);
		      }
		    }

		    // (public) convert to bigendian byte array
		    function bnToByteArray() {
		      var i = this.t, r = new Array();
		      r[0] = this.s;
		      var p = this.DB-(i*this.DB)%8, d, k = 0;
		      if(i-- > 0) {
		        if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)
		          r[k++] = d|(this.s<<(this.DB-p));
		        while(i >= 0) {
		          if(p < 8) {
		            d = (this[i]&((1<<p)-1))<<(8-p);
		            d |= this[--i]>>(p+=this.DB-8);
		          }
		          else {
		            d = (this[i]>>(p-=8))&0xff;
		            if(p <= 0) { p += this.DB; --i; }
		          }
		          if((d&0x80) != 0) d |= -256;
		          if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;
		          if(k > 0 || d != this.s) r[k++] = d;
		        }
		      }
		      return r;
		    }

		    function bnEquals(a) { return(this.compareTo(a)==0); }
		    function bnMin(a) { return (this.compareTo(a)<0)?this:a; }
		    function bnMax(a) { return (this.compareTo(a)>0)?this:a; }

		    // (protected) r = this op a (bitwise)
		    function bnpBitwiseTo(a,op,r) {
		      var i, f, m = Math.min(a.t,this.t);
		      for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);
		      if(a.t < this.t) {
		        f = a.s&this.DM;
		        for(i = m; i < this.t; ++i) r[i] = op(this[i],f);
		        r.t = this.t;
		      }
		      else {
		        f = this.s&this.DM;
		        for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);
		        r.t = a.t;
		      }
		      r.s = op(this.s,a.s);
		      r.clamp();
		    }

		    // (public) this & a
		    function op_and(x,y) { return x&y; }
		    function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }

		    // (public) this | a
		    function op_or(x,y) { return x|y; }
		    function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }

		    // (public) this ^ a
		    function op_xor(x,y) { return x^y; }
		    function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }

		    // (public) this & ~a
		    function op_andnot(x,y) { return x&~y; }
		    function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }

		    // (public) ~this
		    function bnNot() {
		      var r = nbi();
		      for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];
		      r.t = this.t;
		      r.s = ~this.s;
		      return r;
		    }

		    // (public) this << n
		    function bnShiftLeft(n) {
		      var r = nbi();
		      if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
		      return r;
		    }

		    // (public) this >> n
		    function bnShiftRight(n) {
		      var r = nbi();
		      if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
		      return r;
		    }

		    // return index of lowest 1-bit in x, x < 2^31
		    function lbit(x) {
		      if(x == 0) return -1;
		      var r = 0;
		      if((x&0xffff) == 0) { x >>= 16; r += 16; }
		      if((x&0xff) == 0) { x >>= 8; r += 8; }
		      if((x&0xf) == 0) { x >>= 4; r += 4; }
		      if((x&3) == 0) { x >>= 2; r += 2; }
		      if((x&1) == 0) ++r;
		      return r;
		    }

		    // (public) returns index of lowest 1-bit (or -1 if none)
		    function bnGetLowestSetBit() {
		      for(var i = 0; i < this.t; ++i)
		        if(this[i] != 0) return i*this.DB+lbit(this[i]);
		      if(this.s < 0) return this.t*this.DB;
		      return -1;
		    }

		    // return number of 1 bits in x
		    function cbit(x) {
		      var r = 0;
		      while(x != 0) { x &= x-1; ++r; }
		      return r;
		    }

		    // (public) return number of set bits
		    function bnBitCount() {
		      var r = 0, x = this.s&this.DM;
		      for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);
		      return r;
		    }

		    // (public) true iff nth bit is set
		    function bnTestBit(n) {
		      var j = Math.floor(n/this.DB);
		      if(j >= this.t) return(this.s!=0);
		      return((this[j]&(1<<(n%this.DB)))!=0);
		    }

		    // (protected) this op (1<<n)
		    function bnpChangeBit(n,op) {
		      var r = BigInteger.ONE.shiftLeft(n);
		      this.bitwiseTo(r,op,r);
		      return r;
		    }

		    // (public) this | (1<<n)
		    function bnSetBit(n) { return this.changeBit(n,op_or); }

		    // (public) this & ~(1<<n)
		    function bnClearBit(n) { return this.changeBit(n,op_andnot); }

		    // (public) this ^ (1<<n)
		    function bnFlipBit(n) { return this.changeBit(n,op_xor); }

		    // (protected) r = this + a
		    function bnpAddTo(a,r) {
		      var i = 0, c = 0, m = Math.min(a.t,this.t);
		      while(i < m) {
		        c += this[i]+a[i];
		        r[i++] = c&this.DM;
		        c >>= this.DB;
		      }
		      if(a.t < this.t) {
		        c += a.s;
		        while(i < this.t) {
		          c += this[i];
		          r[i++] = c&this.DM;
		          c >>= this.DB;
		        }
		        c += this.s;
		      }
		      else {
		        c += this.s;
		        while(i < a.t) {
		          c += a[i];
		          r[i++] = c&this.DM;
		          c >>= this.DB;
		        }
		        c += a.s;
		      }
		      r.s = (c<0)?-1:0;
		      if(c > 0) r[i++] = c;
		      else if(c < -1) r[i++] = this.DV+c;
		      r.t = i;
		      r.clamp();
		    }

		    // (public) this + a
		    function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }

		    // (public) this - a
		    function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }

		    // (public) this * a
		    function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }

		    // (public) this^2
		    function bnSquare() { var r = nbi(); this.squareTo(r); return r; }

		    // (public) this / a
		    function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }

		    // (public) this % a
		    function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }

		    // (public) [this/a,this%a]
		    function bnDivideAndRemainder(a) {
		      var q = nbi(), r = nbi();
		      this.divRemTo(a,q,r);
		      return new Array(q,r);
		    }

		    // (protected) this *= n, this >= 0, 1 < n < DV
		    function bnpDMultiply(n) {
		      this[this.t] = this.am(0,n-1,this,0,0,this.t);
		      ++this.t;
		      this.clamp();
		    }

		    // (protected) this += n << w words, this >= 0
		    function bnpDAddOffset(n,w) {
		      if(n == 0) return;
		      while(this.t <= w) this[this.t++] = 0;
		      this[w] += n;
		      while(this[w] >= this.DV) {
		        this[w] -= this.DV;
		        if(++w >= this.t) this[this.t++] = 0;
		        ++this[w];
		      }
		    }

		    // A "null" reducer
		    function NullExp() {}
		    function nNop(x) { return x; }
		    function nMulTo(x,y,r) { x.multiplyTo(y,r); }
		    function nSqrTo(x,r) { x.squareTo(r); }

		    NullExp.prototype.convert = nNop;
		    NullExp.prototype.revert = nNop;
		    NullExp.prototype.mulTo = nMulTo;
		    NullExp.prototype.sqrTo = nSqrTo;

		    // (public) this^e
		    function bnPow(e) { return this.exp(e,new NullExp()); }

		    // (protected) r = lower n words of "this * a", a.t <= n
		    // "this" should be the larger one if appropriate.
		    function bnpMultiplyLowerTo(a,n,r) {
		      var i = Math.min(this.t+a.t,n);
		      r.s = 0; // assumes a,this >= 0
		      r.t = i;
		      while(i > 0) r[--i] = 0;
		      var j;
		      for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);
		      for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);
		      r.clamp();
		    }

		    // (protected) r = "this * a" without lower n words, n > 0
		    // "this" should be the larger one if appropriate.
		    function bnpMultiplyUpperTo(a,n,r) {
		      --n;
		      var i = r.t = this.t+a.t-n;
		      r.s = 0; // assumes a,this >= 0
		      while(--i >= 0) r[i] = 0;
		      for(i = Math.max(n-this.t,0); i < a.t; ++i)
		        r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);
		      r.clamp();
		      r.drShiftTo(1,r);
		    }

		    // Barrett modular reduction
		    function Barrett(m) {
		      // setup Barrett
		      this.r2 = nbi();
		      this.q3 = nbi();
		      BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
		      this.mu = this.r2.divide(m);
		      this.m = m;
		    }

		    function barrettConvert(x) {
		      if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);
		      else if(x.compareTo(this.m) < 0) return x;
		      else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
		    }

		    function barrettRevert(x) { return x; }

		    // x = x mod m (HAC 14.42)
		    function barrettReduce(x) {
		      x.drShiftTo(this.m.t-1,this.r2);
		      if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
		      this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);
		      this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);
		      while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);
		      x.subTo(this.r2,x);
		      while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
		    }

		    // r = x^2 mod m; x != r
		    function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

		    // r = x*y mod m; x,y != r
		    function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

		    Barrett.prototype.convert = barrettConvert;
		    Barrett.prototype.revert = barrettRevert;
		    Barrett.prototype.reduce = barrettReduce;
		    Barrett.prototype.mulTo = barrettMulTo;
		    Barrett.prototype.sqrTo = barrettSqrTo;

		    // (public) this^e % m (HAC 14.85)
		    function bnModPow(e,m) {
		      var i = e.bitLength(), k, r = nbv(1), z;
		      if(i <= 0) return r;
		      else if(i < 18) k = 1;
		      else if(i < 48) k = 3;
		      else if(i < 144) k = 4;
		      else if(i < 768) k = 5;
		      else k = 6;
		      if(i < 8)
		        z = new Classic(m);
		      else if(m.isEven())
		        z = new Barrett(m);
		      else
		        z = new Montgomery(m);

		      // precomputation
		      var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;
		      g[1] = z.convert(this);
		      if(k > 1) {
		        var g2 = nbi();
		        z.sqrTo(g[1],g2);
		        while(n <= km) {
		          g[n] = nbi();
		          z.mulTo(g2,g[n-2],g[n]);
		          n += 2;
		        }
		      }

		      var j = e.t-1, w, is1 = true, r2 = nbi(), t;
		      i = nbits(e[j])-1;
		      while(j >= 0) {
		        if(i >= k1) w = (e[j]>>(i-k1))&km;
		        else {
		          w = (e[j]&((1<<(i+1))-1))<<(k1-i);
		          if(j > 0) w |= e[j-1]>>(this.DB+i-k1);
		        }

		        n = k;
		        while((w&1) == 0) { w >>= 1; --n; }
		        if((i -= n) < 0) { i += this.DB; --j; }
		        if(is1) {	// ret == 1, don't bother squaring or multiplying it
		          g[w].copyTo(r);
		          is1 = false;
		        }
		        else {
		          while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
		          if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
		          z.mulTo(r2,g[w],r);
		        }

		        while(j >= 0 && (e[j]&(1<<i)) == 0) {
		          z.sqrTo(r,r2); t = r; r = r2; r2 = t;
		          if(--i < 0) { i = this.DB-1; --j; }
		        }
		      }
		      return z.revert(r);
		    }

		    // (public) gcd(this,a) (HAC 14.54)
		    function bnGCD(a) {
		      var x = (this.s<0)?this.negate():this.clone();
		      var y = (a.s<0)?a.negate():a.clone();
		      if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }
		      var i = x.getLowestSetBit(), g = y.getLowestSetBit();
		      if(g < 0) return x;
		      if(i < g) g = i;
		      if(g > 0) {
		        x.rShiftTo(g,x);
		        y.rShiftTo(g,y);
		      }
		      while(x.signum() > 0) {
		        if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);
		        if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);
		        if(x.compareTo(y) >= 0) {
		          x.subTo(y,x);
		          x.rShiftTo(1,x);
		        }
		        else {
		          y.subTo(x,y);
		          y.rShiftTo(1,y);
		        }
		      }
		      if(g > 0) y.lShiftTo(g,y);
		      return y;
		    }

		    // (protected) this % n, n < 2^26
		    function bnpModInt(n) {
		      if(n <= 0) return 0;
		      var d = this.DV%n, r = (this.s<0)?n-1:0;
		      if(this.t > 0)
		        if(d == 0) r = this[0]%n;
		        else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;
		      return r;
		    }

		    // (public) 1/this % m (HAC 14.61)
		    function bnModInverse(m) {
		      var ac = m.isEven();
		      if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
		      var u = m.clone(), v = this.clone();
		      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
		      while(u.signum() != 0) {
		        while(u.isEven()) {
		          u.rShiftTo(1,u);
		          if(ac) {
		            if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
		            a.rShiftTo(1,a);
		          }
		          else if(!b.isEven()) b.subTo(m,b);
		          b.rShiftTo(1,b);
		        }
		        while(v.isEven()) {
		          v.rShiftTo(1,v);
		          if(ac) {
		            if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
		            c.rShiftTo(1,c);
		          }
		          else if(!d.isEven()) d.subTo(m,d);
		          d.rShiftTo(1,d);
		        }
		        if(u.compareTo(v) >= 0) {
		          u.subTo(v,u);
		          if(ac) a.subTo(c,a);
		          b.subTo(d,b);
		        }
		        else {
		          v.subTo(u,v);
		          if(ac) c.subTo(a,c);
		          d.subTo(b,d);
		        }
		      }
		      if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
		      if(d.compareTo(m) >= 0) return d.subtract(m);
		      if(d.signum() < 0) d.addTo(m,d); else return d;
		      if(d.signum() < 0) return d.add(m); else return d;
		    }

		    var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];
		    var lplim = (1<<26)/lowprimes[lowprimes.length-1];

		    // (public) test primality with certainty >= 1-.5^t
		    function bnIsProbablePrime(t) {
		      var i, x = this.abs();
		      if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {
		        for(i = 0; i < lowprimes.length; ++i)
		          if(x[0] == lowprimes[i]) return true;
		        return false;
		      }
		      if(x.isEven()) return false;
		      i = 1;
		      while(i < lowprimes.length) {
		        var m = lowprimes[i], j = i+1;
		        while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];
		        m = x.modInt(m);
		        while(i < j) if(m%lowprimes[i++] == 0) return false;
		      }
		      return x.millerRabin(t);
		    }

		    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
		    function bnpMillerRabin(t) {
		      var n1 = this.subtract(BigInteger.ONE);
		      var k = n1.getLowestSetBit();
		      if(k <= 0) return false;
		      var r = n1.shiftRight(k);
		      t = (t+1)>>1;
		      if(t > lowprimes.length) t = lowprimes.length;
		      var a = nbi();
		      for(var i = 0; i < t; ++i) {
		        //Pick bases at random, instead of starting at 2
		        a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);
		        var y = a.modPow(r,this);
		        if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
		          var j = 1;
		          while(j++ < k && y.compareTo(n1) != 0) {
		            y = y.modPowInt(2,this);
		            if(y.compareTo(BigInteger.ONE) == 0) return false;
		          }
		          if(y.compareTo(n1) != 0) return false;
		        }
		      }
		      return true;
		    }

		    // protected
		    BigInteger.prototype.chunkSize = bnpChunkSize;
		    BigInteger.prototype.toRadix = bnpToRadix;
		    BigInteger.prototype.fromRadix = bnpFromRadix;
		    BigInteger.prototype.fromNumber = bnpFromNumber;
		    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
		    BigInteger.prototype.changeBit = bnpChangeBit;
		    BigInteger.prototype.addTo = bnpAddTo;
		    BigInteger.prototype.dMultiply = bnpDMultiply;
		    BigInteger.prototype.dAddOffset = bnpDAddOffset;
		    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
		    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
		    BigInteger.prototype.modInt = bnpModInt;
		    BigInteger.prototype.millerRabin = bnpMillerRabin;

		    // public
		    BigInteger.prototype.clone = bnClone;
		    BigInteger.prototype.intValue = bnIntValue;
		    BigInteger.prototype.byteValue = bnByteValue;
		    BigInteger.prototype.shortValue = bnShortValue;
		    BigInteger.prototype.signum = bnSigNum;
		    BigInteger.prototype.toByteArray = bnToByteArray;
		    BigInteger.prototype.equals = bnEquals;
		    BigInteger.prototype.min = bnMin;
		    BigInteger.prototype.max = bnMax;
		    BigInteger.prototype.and = bnAnd;
		    BigInteger.prototype.or = bnOr;
		    BigInteger.prototype.xor = bnXor;
		    BigInteger.prototype.andNot = bnAndNot;
		    BigInteger.prototype.not = bnNot;
		    BigInteger.prototype.shiftLeft = bnShiftLeft;
		    BigInteger.prototype.shiftRight = bnShiftRight;
		    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
		    BigInteger.prototype.bitCount = bnBitCount;
		    BigInteger.prototype.testBit = bnTestBit;
		    BigInteger.prototype.setBit = bnSetBit;
		    BigInteger.prototype.clearBit = bnClearBit;
		    BigInteger.prototype.flipBit = bnFlipBit;
		    BigInteger.prototype.add = bnAdd;
		    BigInteger.prototype.subtract = bnSubtract;
		    BigInteger.prototype.multiply = bnMultiply;
		    BigInteger.prototype.divide = bnDivide;
		    BigInteger.prototype.remainder = bnRemainder;
		    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
		    BigInteger.prototype.modPow = bnModPow;
		    BigInteger.prototype.modInverse = bnModInverse;
		    BigInteger.prototype.pow = bnPow;
		    BigInteger.prototype.gcd = bnGCD;
		    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;

		    // JSBN-specific extension
		    BigInteger.prototype.square = bnSquare;

		    // Expose the Barrett function
		    BigInteger.prototype.Barrett = Barrett;

		    // BigInteger interfaces not implemented in jsbn:

		    // BigInteger(int signum, byte[] magnitude)
		    // double doubleValue()
		    // float floatValue()
		    // int hashCode()
		    // long longValue()
		    // static BigInteger valueOf(long val)

			// Random number generator - requires a PRNG backend, e.g. prng4.js

			// For best results, put code like
			// <body onClick='rng_seed_time();' onKeyPress='rng_seed_time();'>
			// in your main HTML document.

			var rng_state;
			var rng_pool;
			var rng_pptr;

			// Mix in a 32-bit integer into the pool
			function rng_seed_int(x) {
			  rng_pool[rng_pptr++] ^= x & 255;
			  rng_pool[rng_pptr++] ^= (x >> 8) & 255;
			  rng_pool[rng_pptr++] ^= (x >> 16) & 255;
			  rng_pool[rng_pptr++] ^= (x >> 24) & 255;
			  if(rng_pptr >= rng_psize) rng_pptr -= rng_psize;
			}

			// Mix in the current time (w/milliseconds) into the pool
			function rng_seed_time() {
			  rng_seed_int(new Date().getTime());
			}

			// Initialize the pool with junk if needed.
			if(rng_pool == null) {
			  rng_pool = new Array();
			  rng_pptr = 0;
			  var t;
			  if(typeof window !== "undefined" && window.crypto) {
				if (window.crypto.getRandomValues) {
				  // Use webcrypto if available
				  var ua = new Uint8Array(32);
				  window.crypto.getRandomValues(ua);
				  for(t = 0; t < 32; ++t)
					rng_pool[rng_pptr++] = ua[t];
				}
				else if(navigator.appName == "Netscape" && navigator.appVersion < "5") {
				  // Extract entropy (256 bits) from NS4 RNG if available
				  var z = window.crypto.random(32);
				  for(t = 0; t < z.length; ++t)
					rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
				}
			  }
			  while(rng_pptr < rng_psize) {  // extract some randomness from Math.random()
				t = Math.floor(65536 * Math.random());
				rng_pool[rng_pptr++] = t >>> 8;
				rng_pool[rng_pptr++] = t & 255;
			  }
			  rng_pptr = 0;
			  rng_seed_time();
			  //rng_seed_int(window.screenX);
			  //rng_seed_int(window.screenY);
			}

			function rng_get_byte() {
			  if(rng_state == null) {
				rng_seed_time();
				rng_state = prng_newstate();
				rng_state.init(rng_pool);
				for(rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
				  rng_pool[rng_pptr] = 0;
				rng_pptr = 0;
				//rng_pool = null;
			  }
			  // TODO: allow reseeding after first request
			  return rng_state.next();
			}

			function rng_get_bytes(ba) {
			  var i;
			  for(i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
			}

			function SecureRandom() {}

			SecureRandom.prototype.nextBytes = rng_get_bytes;

			// prng4.js - uses Arcfour as a PRNG

			function Arcfour() {
			  this.i = 0;
			  this.j = 0;
			  this.S = new Array();
			}

			// Initialize arcfour context from key, an array of ints, each from [0..255]
			function ARC4init(key) {
			  var i, j, t;
			  for(i = 0; i < 256; ++i)
				this.S[i] = i;
			  j = 0;
			  for(i = 0; i < 256; ++i) {
				j = (j + this.S[i] + key[i % key.length]) & 255;
				t = this.S[i];
				this.S[i] = this.S[j];
				this.S[j] = t;
			  }
			  this.i = 0;
			  this.j = 0;
			}

			function ARC4next() {
			  var t;
			  this.i = (this.i + 1) & 255;
			  this.j = (this.j + this.S[this.i]) & 255;
			  t = this.S[this.i];
			  this.S[this.i] = this.S[this.j];
			  this.S[this.j] = t;
			  return this.S[(t + this.S[this.i]) & 255];
			}

			Arcfour.prototype.init = ARC4init;
			Arcfour.prototype.next = ARC4next;

			// Plug in your RNG constructor here
			function prng_newstate() {
			  return new Arcfour();
			}

			// Pool size must be a multiple of 4 and greater than 32.
			// An array of bytes the size of the pool will be passed to init()
			var rng_psize = 256;

		  BigInteger.SecureRandom = SecureRandom;
		  BigInteger.BigInteger = BigInteger;
		  {
		    module.exports = BigInteger;
		  }

		}).call(jsbn); 
	} (jsbn$1));
	return jsbn$1.exports;
}

var ec;
var hasRequiredEc;

function requireEc () {
	if (hasRequiredEc) return ec;
	hasRequiredEc = 1;
	// Basic Javascript Elliptic Curve implementation
	// Ported loosely from BouncyCastle's Java EC code
	// Only Fp curves implemented for now

	// Requires jsbn.js and jsbn2.js
	var BigInteger = requireJsbn().BigInteger;
	var Barrett = BigInteger.prototype.Barrett;

	// ----------------
	// ECFieldElementFp

	// constructor
	function ECFieldElementFp(q,x) {
	    this.x = x;
	    // TODO if(x.compareTo(q) >= 0) error
	    this.q = q;
	}

	function feFpEquals(other) {
	    if(other == this) return true;
	    return (this.q.equals(other.q) && this.x.equals(other.x));
	}

	function feFpToBigInteger() {
	    return this.x;
	}

	function feFpNegate() {
	    return new ECFieldElementFp(this.q, this.x.negate().mod(this.q));
	}

	function feFpAdd(b) {
	    return new ECFieldElementFp(this.q, this.x.add(b.toBigInteger()).mod(this.q));
	}

	function feFpSubtract(b) {
	    return new ECFieldElementFp(this.q, this.x.subtract(b.toBigInteger()).mod(this.q));
	}

	function feFpMultiply(b) {
	    return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger()).mod(this.q));
	}

	function feFpSquare() {
	    return new ECFieldElementFp(this.q, this.x.square().mod(this.q));
	}

	function feFpDivide(b) {
	    return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q));
	}

	ECFieldElementFp.prototype.equals = feFpEquals;
	ECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;
	ECFieldElementFp.prototype.negate = feFpNegate;
	ECFieldElementFp.prototype.add = feFpAdd;
	ECFieldElementFp.prototype.subtract = feFpSubtract;
	ECFieldElementFp.prototype.multiply = feFpMultiply;
	ECFieldElementFp.prototype.square = feFpSquare;
	ECFieldElementFp.prototype.divide = feFpDivide;

	// ----------------
	// ECPointFp

	// constructor
	function ECPointFp(curve,x,y,z) {
	    this.curve = curve;
	    this.x = x;
	    this.y = y;
	    // Projective coordinates: either zinv == null or z * zinv == 1
	    // z and zinv are just BigIntegers, not fieldElements
	    if(z == null) {
	      this.z = BigInteger.ONE;
	    }
	    else {
	      this.z = z;
	    }
	    this.zinv = null;
	    //TODO: compression flag
	}

	function pointFpGetX() {
	    if(this.zinv == null) {
	      this.zinv = this.z.modInverse(this.curve.q);
	    }
	    var r = this.x.toBigInteger().multiply(this.zinv);
	    this.curve.reduce(r);
	    return this.curve.fromBigInteger(r);
	}

	function pointFpGetY() {
	    if(this.zinv == null) {
	      this.zinv = this.z.modInverse(this.curve.q);
	    }
	    var r = this.y.toBigInteger().multiply(this.zinv);
	    this.curve.reduce(r);
	    return this.curve.fromBigInteger(r);
	}

	function pointFpEquals(other) {
	    if(other == this) return true;
	    if(this.isInfinity()) return other.isInfinity();
	    if(other.isInfinity()) return this.isInfinity();
	    var u, v;
	    // u = Y2 * Z1 - Y1 * Z2
	    u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);
	    if(!u.equals(BigInteger.ZERO)) return false;
	    // v = X2 * Z1 - X1 * Z2
	    v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);
	    return v.equals(BigInteger.ZERO);
	}

	function pointFpIsInfinity() {
	    if((this.x == null) && (this.y == null)) return true;
	    return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);
	}

	function pointFpNegate() {
	    return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);
	}

	function pointFpAdd(b) {
	    if(this.isInfinity()) return b;
	    if(b.isInfinity()) return this;

	    // u = Y2 * Z1 - Y1 * Z2
	    var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);
	    // v = X2 * Z1 - X1 * Z2
	    var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);

	    if(BigInteger.ZERO.equals(v)) {
	        if(BigInteger.ZERO.equals(u)) {
	            return this.twice(); // this == b, so double
	        }
		return this.curve.getInfinity(); // this = -b, so infinity
	    }

	    var THREE = new BigInteger("3");
	    var x1 = this.x.toBigInteger();
	    var y1 = this.y.toBigInteger();
	    b.x.toBigInteger();
	    b.y.toBigInteger();

	    var v2 = v.square();
	    var v3 = v2.multiply(v);
	    var x1v2 = x1.multiply(v2);
	    var zu2 = u.square().multiply(this.z);

	    // x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)
	    var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);
	    // y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3
	    var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);
	    // z3 = v^3 * z1 * z2
	    var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.q);

	    return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
	}

	function pointFpTwice() {
	    if(this.isInfinity()) return this;
	    if(this.y.toBigInteger().signum() == 0) return this.curve.getInfinity();

	    // TODO: optimized handling of constants
	    var THREE = new BigInteger("3");
	    var x1 = this.x.toBigInteger();
	    var y1 = this.y.toBigInteger();

	    var y1z1 = y1.multiply(this.z);
	    var y1sqz1 = y1z1.multiply(y1).mod(this.curve.q);
	    var a = this.curve.a.toBigInteger();

	    // w = 3 * x1^2 + a * z1^2
	    var w = x1.square().multiply(THREE);
	    if(!BigInteger.ZERO.equals(a)) {
	      w = w.add(this.z.square().multiply(a));
	    }
	    w = w.mod(this.curve.q);
	    //this.curve.reduce(w);
	    // x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)
	    var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);
	    // y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3
	    var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);
	    // z3 = 8 * (y1 * z1)^3
	    var z3 = y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);

	    return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
	}

	// Simple NAF (Non-Adjacent Form) multiplication algorithm
	// TODO: modularize the multiplication algorithm
	function pointFpMultiply(k) {
	    if(this.isInfinity()) return this;
	    if(k.signum() == 0) return this.curve.getInfinity();

	    var e = k;
	    var h = e.multiply(new BigInteger("3"));

	    var neg = this.negate();
	    var R = this;

	    var i;
	    for(i = h.bitLength() - 2; i > 0; --i) {
		R = R.twice();

		var hBit = h.testBit(i);
		var eBit = e.testBit(i);

		if (hBit != eBit) {
		    R = R.add(hBit ? this : neg);
		}
	    }

	    return R;
	}

	// Compute this*j + x*k (simultaneous multiplication)
	function pointFpMultiplyTwo(j,x,k) {
	  var i;
	  if(j.bitLength() > k.bitLength())
	    i = j.bitLength() - 1;
	  else
	    i = k.bitLength() - 1;

	  var R = this.curve.getInfinity();
	  var both = this.add(x);
	  while(i >= 0) {
	    R = R.twice();
	    if(j.testBit(i)) {
	      if(k.testBit(i)) {
	        R = R.add(both);
	      }
	      else {
	        R = R.add(this);
	      }
	    }
	    else {
	      if(k.testBit(i)) {
	        R = R.add(x);
	      }
	    }
	    --i;
	  }

	  return R;
	}

	ECPointFp.prototype.getX = pointFpGetX;
	ECPointFp.prototype.getY = pointFpGetY;
	ECPointFp.prototype.equals = pointFpEquals;
	ECPointFp.prototype.isInfinity = pointFpIsInfinity;
	ECPointFp.prototype.negate = pointFpNegate;
	ECPointFp.prototype.add = pointFpAdd;
	ECPointFp.prototype.twice = pointFpTwice;
	ECPointFp.prototype.multiply = pointFpMultiply;
	ECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;

	// ----------------
	// ECCurveFp

	// constructor
	function ECCurveFp(q,a,b) {
	    this.q = q;
	    this.a = this.fromBigInteger(a);
	    this.b = this.fromBigInteger(b);
	    this.infinity = new ECPointFp(this, null, null);
	    this.reducer = new Barrett(this.q);
	}

	function curveFpGetQ() {
	    return this.q;
	}

	function curveFpGetA() {
	    return this.a;
	}

	function curveFpGetB() {
	    return this.b;
	}

	function curveFpEquals(other) {
	    if(other == this) return true;
	    return(this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b));
	}

	function curveFpGetInfinity() {
	    return this.infinity;
	}

	function curveFpFromBigInteger(x) {
	    return new ECFieldElementFp(this.q, x);
	}

	function curveReduce(x) {
	    this.reducer.reduce(x);
	}

	function curveFpEncodePointHex(p) {
		if (p.isInfinity()) return "00";
		var xHex = p.getX().toBigInteger().toString(16);
		var yHex = p.getY().toBigInteger().toString(16);
		var oLen = this.getQ().toString(16).length;
		if ((oLen % 2) != 0) oLen++;
		while (xHex.length < oLen) {
			xHex = "0" + xHex;
		}
		while (yHex.length < oLen) {
			yHex = "0" + yHex;
		}
		return "04" + xHex + yHex;
	}

	ECCurveFp.prototype.getQ = curveFpGetQ;
	ECCurveFp.prototype.getA = curveFpGetA;
	ECCurveFp.prototype.getB = curveFpGetB;
	ECCurveFp.prototype.equals = curveFpEquals;
	ECCurveFp.prototype.getInfinity = curveFpGetInfinity;
	ECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;
	ECCurveFp.prototype.reduce = curveReduce;
	//ECCurveFp.prototype.decodePointHex = curveFpDecodePointHex;
	ECCurveFp.prototype.encodePointHex = curveFpEncodePointHex;

	// from: https://github.com/kaielvin/jsbn-ec-point-compression
	ECCurveFp.prototype.decodePointHex = function(s)
	{
		var yIsEven;
	    switch(parseInt(s.substr(0,2), 16)) { // first byte
	    case 0:
		return this.infinity;
	    case 2:
		yIsEven = false;
	    case 3:
		if(yIsEven == undefined) yIsEven = true;
		var len = s.length - 2;
		var xHex = s.substr(2, len);
		var x = this.fromBigInteger(new BigInteger(xHex,16));
		var alpha = x.multiply(x.square().add(this.getA())).add(this.getB());
		var beta = alpha.sqrt();

	    if (beta == null) throw "Invalid point compression";

	    var betaValue = beta.toBigInteger();
	    if (betaValue.testBit(0) != yIsEven)
	    {
	        // Use the other root
	        beta = this.fromBigInteger(this.getQ().subtract(betaValue));
	    }
	    return new ECPointFp(this,x,beta);
	    case 4:
	    case 6:
	    case 7:
		var len = (s.length - 2) / 2;
		var xHex = s.substr(2, len);
		var yHex = s.substr(len+2, len);

		return new ECPointFp(this,
				     this.fromBigInteger(new BigInteger(xHex, 16)),
				     this.fromBigInteger(new BigInteger(yHex, 16)));

	    default: // unsupported
		return null;
	    }
	};
	ECCurveFp.prototype.encodeCompressedPointHex = function(p)
	{
		if (p.isInfinity()) return "00";
		var xHex = p.getX().toBigInteger().toString(16);
		var oLen = this.getQ().toString(16).length;
		if ((oLen % 2) != 0) oLen++;
		while (xHex.length < oLen)
			xHex = "0" + xHex;
		var yPrefix;
		if(p.getY().toBigInteger().isEven()) yPrefix = "02";
		else                                 yPrefix = "03";

		return yPrefix + xHex;
	};


	ECFieldElementFp.prototype.getR = function()
	{
		if(this.r != undefined) return this.r;

	    this.r = null;
	    var bitLength = this.q.bitLength();
	    if (bitLength > 128)
	    {
	        var firstWord = this.q.shiftRight(bitLength - 64);
	        if (firstWord.intValue() == -1)
	        {
	            this.r = BigInteger.ONE.shiftLeft(bitLength).subtract(this.q);
	        }
	    }
	    return this.r;
	};
	ECFieldElementFp.prototype.modMult = function(x1,x2)
	{
	    return this.modReduce(x1.multiply(x2));
	};
	ECFieldElementFp.prototype.modReduce = function(x)
	{
	    if (this.getR() != null)
	    {
	        var qLen = q.bitLength();
	        while (x.bitLength() > (qLen + 1))
	        {
	            var u = x.shiftRight(qLen);
	            var v = x.subtract(u.shiftLeft(qLen));
	            if (!this.getR().equals(BigInteger.ONE))
	            {
	                u = u.multiply(this.getR());
	            }
	            x = u.add(v); 
	        }
	        while (x.compareTo(q) >= 0)
	        {
	            x = x.subtract(q);
	        }
	    }
	    else
	    {
	        x = x.mod(q);
	    }
	    return x;
	};
	ECFieldElementFp.prototype.sqrt = function()
	{
	    if (!this.q.testBit(0)) throw "unsupported";

	    // p mod 4 == 3
	    if (this.q.testBit(1))
	    {
	    	var z = new ECFieldElementFp(this.q,this.x.modPow(this.q.shiftRight(2).add(BigInteger.ONE),this.q));
	    	return z.square().equals(this) ? z : null;
	    }

	    // p mod 4 == 1
	    var qMinusOne = this.q.subtract(BigInteger.ONE);

	    var legendreExponent = qMinusOne.shiftRight(1);
	    if (!(this.x.modPow(legendreExponent, this.q).equals(BigInteger.ONE)))
	    {
	        return null;
	    }

	    var u = qMinusOne.shiftRight(2);
	    var k = u.shiftLeft(1).add(BigInteger.ONE);

	    var Q = this.x;
	    var fourQ = modDouble(modDouble(Q));

	    var U, V;
	    do
	    {
	        var P;
	        do
	        {
	            P = new BigInteger(this.q.bitLength(), new SecureRandom());
	        }
	        while (P.compareTo(this.q) >= 0
	            || !(P.multiply(P).subtract(fourQ).modPow(legendreExponent, this.q).equals(qMinusOne)));

	        var result = this.lucasSequence(P, Q, k);
	        U = result[0];
	        V = result[1];

	        if (this.modMult(V, V).equals(fourQ))
	        {
	            // Integer division by 2, mod q
	            if (V.testBit(0))
	            {
	                V = V.add(q);
	            }

	            V = V.shiftRight(1);

	            return new ECFieldElementFp(q,V);
	        }
	    }
	    while (U.equals(BigInteger.ONE) || U.equals(qMinusOne));

	    return null;
	};
	ECFieldElementFp.prototype.lucasSequence = function(P,Q,k)
	{
	    var n = k.bitLength();
	    var s = k.getLowestSetBit();

	    var Uh = BigInteger.ONE;
	    var Vl = BigInteger.TWO;
	    var Vh = P;
	    var Ql = BigInteger.ONE;
	    var Qh = BigInteger.ONE;

	    for (var j = n - 1; j >= s + 1; --j)
	    {
	        Ql = this.modMult(Ql, Qh);

	        if (k.testBit(j))
	        {
	            Qh = this.modMult(Ql, Q);
	            Uh = this.modMult(Uh, Vh);
	            Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
	            Vh = this.modReduce(Vh.multiply(Vh).subtract(Qh.shiftLeft(1)));
	        }
	        else
	        {
	            Qh = Ql;
	            Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
	            Vh = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
	            Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
	        }
	    }

	    Ql = this.modMult(Ql, Qh);
	    Qh = this.modMult(Ql, Q);
	    Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
	    Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
	    Ql = this.modMult(Ql, Qh);

	    for (var j = 1; j <= s; ++j)
	    {
	        Uh = this.modMult(Uh, Vl);
	        Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
	        Ql = this.modMult(Ql, Ql);
	    }

	    return [ Uh, Vl ];
	};

	var exports = {
	  ECCurveFp: ECCurveFp,
	  ECPointFp: ECPointFp,
	  ECFieldElementFp: ECFieldElementFp
	};

	ec = exports;
	return ec;
}

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var naclFast = {exports: {}};

var hasRequiredNaclFast;

function requireNaclFast () {
	if (hasRequiredNaclFast) return naclFast.exports;
	hasRequiredNaclFast = 1;
	(function (module) {
		(function(nacl) {

		// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
		// Public domain.
		//
		// Implementation derived from TweetNaCl version 20140427.
		// See for details: http://tweetnacl.cr.yp.to/

		var gf = function(init) {
		  var i, r = new Float64Array(16);
		  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
		  return r;
		};

		//  Pluggable, initialized in high-level API below.
		var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

		var _0 = new Uint8Array(16);
		var _9 = new Uint8Array(32); _9[0] = 9;

		var gf0 = gf(),
		    gf1 = gf([1]),
		    _121665 = gf([0xdb41, 1]),
		    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
		    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
		    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
		    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
		    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

		function ts64(x, i, h, l) {
		  x[i]   = (h >> 24) & 0xff;
		  x[i+1] = (h >> 16) & 0xff;
		  x[i+2] = (h >>  8) & 0xff;
		  x[i+3] = h & 0xff;
		  x[i+4] = (l >> 24)  & 0xff;
		  x[i+5] = (l >> 16)  & 0xff;
		  x[i+6] = (l >>  8)  & 0xff;
		  x[i+7] = l & 0xff;
		}

		function vn(x, xi, y, yi, n) {
		  var i,d = 0;
		  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
		  return (1 & ((d - 1) >>> 8)) - 1;
		}

		function crypto_verify_16(x, xi, y, yi) {
		  return vn(x,xi,y,yi,16);
		}

		function crypto_verify_32(x, xi, y, yi) {
		  return vn(x,xi,y,yi,32);
		}

		function core_salsa20(o, p, k, c) {
		  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
		      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
		      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
		      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
		      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
		      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
		      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
		      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
		      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
		      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
		      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
		      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
		      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
		      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
		      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
		      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

		  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
		      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
		      x15 = j15, u;

		  for (var i = 0; i < 20; i += 2) {
		    u = x0 + x12 | 0;
		    x4 ^= u<<7 | u>>>(32-7);
		    u = x4 + x0 | 0;
		    x8 ^= u<<9 | u>>>(32-9);
		    u = x8 + x4 | 0;
		    x12 ^= u<<13 | u>>>(32-13);
		    u = x12 + x8 | 0;
		    x0 ^= u<<18 | u>>>(32-18);

		    u = x5 + x1 | 0;
		    x9 ^= u<<7 | u>>>(32-7);
		    u = x9 + x5 | 0;
		    x13 ^= u<<9 | u>>>(32-9);
		    u = x13 + x9 | 0;
		    x1 ^= u<<13 | u>>>(32-13);
		    u = x1 + x13 | 0;
		    x5 ^= u<<18 | u>>>(32-18);

		    u = x10 + x6 | 0;
		    x14 ^= u<<7 | u>>>(32-7);
		    u = x14 + x10 | 0;
		    x2 ^= u<<9 | u>>>(32-9);
		    u = x2 + x14 | 0;
		    x6 ^= u<<13 | u>>>(32-13);
		    u = x6 + x2 | 0;
		    x10 ^= u<<18 | u>>>(32-18);

		    u = x15 + x11 | 0;
		    x3 ^= u<<7 | u>>>(32-7);
		    u = x3 + x15 | 0;
		    x7 ^= u<<9 | u>>>(32-9);
		    u = x7 + x3 | 0;
		    x11 ^= u<<13 | u>>>(32-13);
		    u = x11 + x7 | 0;
		    x15 ^= u<<18 | u>>>(32-18);

		    u = x0 + x3 | 0;
		    x1 ^= u<<7 | u>>>(32-7);
		    u = x1 + x0 | 0;
		    x2 ^= u<<9 | u>>>(32-9);
		    u = x2 + x1 | 0;
		    x3 ^= u<<13 | u>>>(32-13);
		    u = x3 + x2 | 0;
		    x0 ^= u<<18 | u>>>(32-18);

		    u = x5 + x4 | 0;
		    x6 ^= u<<7 | u>>>(32-7);
		    u = x6 + x5 | 0;
		    x7 ^= u<<9 | u>>>(32-9);
		    u = x7 + x6 | 0;
		    x4 ^= u<<13 | u>>>(32-13);
		    u = x4 + x7 | 0;
		    x5 ^= u<<18 | u>>>(32-18);

		    u = x10 + x9 | 0;
		    x11 ^= u<<7 | u>>>(32-7);
		    u = x11 + x10 | 0;
		    x8 ^= u<<9 | u>>>(32-9);
		    u = x8 + x11 | 0;
		    x9 ^= u<<13 | u>>>(32-13);
		    u = x9 + x8 | 0;
		    x10 ^= u<<18 | u>>>(32-18);

		    u = x15 + x14 | 0;
		    x12 ^= u<<7 | u>>>(32-7);
		    u = x12 + x15 | 0;
		    x13 ^= u<<9 | u>>>(32-9);
		    u = x13 + x12 | 0;
		    x14 ^= u<<13 | u>>>(32-13);
		    u = x14 + x13 | 0;
		    x15 ^= u<<18 | u>>>(32-18);
		  }
		   x0 =  x0 +  j0 | 0;
		   x1 =  x1 +  j1 | 0;
		   x2 =  x2 +  j2 | 0;
		   x3 =  x3 +  j3 | 0;
		   x4 =  x4 +  j4 | 0;
		   x5 =  x5 +  j5 | 0;
		   x6 =  x6 +  j6 | 0;
		   x7 =  x7 +  j7 | 0;
		   x8 =  x8 +  j8 | 0;
		   x9 =  x9 +  j9 | 0;
		  x10 = x10 + j10 | 0;
		  x11 = x11 + j11 | 0;
		  x12 = x12 + j12 | 0;
		  x13 = x13 + j13 | 0;
		  x14 = x14 + j14 | 0;
		  x15 = x15 + j15 | 0;

		  o[ 0] = x0 >>>  0 & 0xff;
		  o[ 1] = x0 >>>  8 & 0xff;
		  o[ 2] = x0 >>> 16 & 0xff;
		  o[ 3] = x0 >>> 24 & 0xff;

		  o[ 4] = x1 >>>  0 & 0xff;
		  o[ 5] = x1 >>>  8 & 0xff;
		  o[ 6] = x1 >>> 16 & 0xff;
		  o[ 7] = x1 >>> 24 & 0xff;

		  o[ 8] = x2 >>>  0 & 0xff;
		  o[ 9] = x2 >>>  8 & 0xff;
		  o[10] = x2 >>> 16 & 0xff;
		  o[11] = x2 >>> 24 & 0xff;

		  o[12] = x3 >>>  0 & 0xff;
		  o[13] = x3 >>>  8 & 0xff;
		  o[14] = x3 >>> 16 & 0xff;
		  o[15] = x3 >>> 24 & 0xff;

		  o[16] = x4 >>>  0 & 0xff;
		  o[17] = x4 >>>  8 & 0xff;
		  o[18] = x4 >>> 16 & 0xff;
		  o[19] = x4 >>> 24 & 0xff;

		  o[20] = x5 >>>  0 & 0xff;
		  o[21] = x5 >>>  8 & 0xff;
		  o[22] = x5 >>> 16 & 0xff;
		  o[23] = x5 >>> 24 & 0xff;

		  o[24] = x6 >>>  0 & 0xff;
		  o[25] = x6 >>>  8 & 0xff;
		  o[26] = x6 >>> 16 & 0xff;
		  o[27] = x6 >>> 24 & 0xff;

		  o[28] = x7 >>>  0 & 0xff;
		  o[29] = x7 >>>  8 & 0xff;
		  o[30] = x7 >>> 16 & 0xff;
		  o[31] = x7 >>> 24 & 0xff;

		  o[32] = x8 >>>  0 & 0xff;
		  o[33] = x8 >>>  8 & 0xff;
		  o[34] = x8 >>> 16 & 0xff;
		  o[35] = x8 >>> 24 & 0xff;

		  o[36] = x9 >>>  0 & 0xff;
		  o[37] = x9 >>>  8 & 0xff;
		  o[38] = x9 >>> 16 & 0xff;
		  o[39] = x9 >>> 24 & 0xff;

		  o[40] = x10 >>>  0 & 0xff;
		  o[41] = x10 >>>  8 & 0xff;
		  o[42] = x10 >>> 16 & 0xff;
		  o[43] = x10 >>> 24 & 0xff;

		  o[44] = x11 >>>  0 & 0xff;
		  o[45] = x11 >>>  8 & 0xff;
		  o[46] = x11 >>> 16 & 0xff;
		  o[47] = x11 >>> 24 & 0xff;

		  o[48] = x12 >>>  0 & 0xff;
		  o[49] = x12 >>>  8 & 0xff;
		  o[50] = x12 >>> 16 & 0xff;
		  o[51] = x12 >>> 24 & 0xff;

		  o[52] = x13 >>>  0 & 0xff;
		  o[53] = x13 >>>  8 & 0xff;
		  o[54] = x13 >>> 16 & 0xff;
		  o[55] = x13 >>> 24 & 0xff;

		  o[56] = x14 >>>  0 & 0xff;
		  o[57] = x14 >>>  8 & 0xff;
		  o[58] = x14 >>> 16 & 0xff;
		  o[59] = x14 >>> 24 & 0xff;

		  o[60] = x15 >>>  0 & 0xff;
		  o[61] = x15 >>>  8 & 0xff;
		  o[62] = x15 >>> 16 & 0xff;
		  o[63] = x15 >>> 24 & 0xff;
		}

		function core_hsalsa20(o,p,k,c) {
		  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
		      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
		      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
		      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
		      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
		      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
		      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
		      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
		      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
		      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
		      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
		      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
		      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
		      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
		      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
		      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

		  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
		      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
		      x15 = j15, u;

		  for (var i = 0; i < 20; i += 2) {
		    u = x0 + x12 | 0;
		    x4 ^= u<<7 | u>>>(32-7);
		    u = x4 + x0 | 0;
		    x8 ^= u<<9 | u>>>(32-9);
		    u = x8 + x4 | 0;
		    x12 ^= u<<13 | u>>>(32-13);
		    u = x12 + x8 | 0;
		    x0 ^= u<<18 | u>>>(32-18);

		    u = x5 + x1 | 0;
		    x9 ^= u<<7 | u>>>(32-7);
		    u = x9 + x5 | 0;
		    x13 ^= u<<9 | u>>>(32-9);
		    u = x13 + x9 | 0;
		    x1 ^= u<<13 | u>>>(32-13);
		    u = x1 + x13 | 0;
		    x5 ^= u<<18 | u>>>(32-18);

		    u = x10 + x6 | 0;
		    x14 ^= u<<7 | u>>>(32-7);
		    u = x14 + x10 | 0;
		    x2 ^= u<<9 | u>>>(32-9);
		    u = x2 + x14 | 0;
		    x6 ^= u<<13 | u>>>(32-13);
		    u = x6 + x2 | 0;
		    x10 ^= u<<18 | u>>>(32-18);

		    u = x15 + x11 | 0;
		    x3 ^= u<<7 | u>>>(32-7);
		    u = x3 + x15 | 0;
		    x7 ^= u<<9 | u>>>(32-9);
		    u = x7 + x3 | 0;
		    x11 ^= u<<13 | u>>>(32-13);
		    u = x11 + x7 | 0;
		    x15 ^= u<<18 | u>>>(32-18);

		    u = x0 + x3 | 0;
		    x1 ^= u<<7 | u>>>(32-7);
		    u = x1 + x0 | 0;
		    x2 ^= u<<9 | u>>>(32-9);
		    u = x2 + x1 | 0;
		    x3 ^= u<<13 | u>>>(32-13);
		    u = x3 + x2 | 0;
		    x0 ^= u<<18 | u>>>(32-18);

		    u = x5 + x4 | 0;
		    x6 ^= u<<7 | u>>>(32-7);
		    u = x6 + x5 | 0;
		    x7 ^= u<<9 | u>>>(32-9);
		    u = x7 + x6 | 0;
		    x4 ^= u<<13 | u>>>(32-13);
		    u = x4 + x7 | 0;
		    x5 ^= u<<18 | u>>>(32-18);

		    u = x10 + x9 | 0;
		    x11 ^= u<<7 | u>>>(32-7);
		    u = x11 + x10 | 0;
		    x8 ^= u<<9 | u>>>(32-9);
		    u = x8 + x11 | 0;
		    x9 ^= u<<13 | u>>>(32-13);
		    u = x9 + x8 | 0;
		    x10 ^= u<<18 | u>>>(32-18);

		    u = x15 + x14 | 0;
		    x12 ^= u<<7 | u>>>(32-7);
		    u = x12 + x15 | 0;
		    x13 ^= u<<9 | u>>>(32-9);
		    u = x13 + x12 | 0;
		    x14 ^= u<<13 | u>>>(32-13);
		    u = x14 + x13 | 0;
		    x15 ^= u<<18 | u>>>(32-18);
		  }

		  o[ 0] = x0 >>>  0 & 0xff;
		  o[ 1] = x0 >>>  8 & 0xff;
		  o[ 2] = x0 >>> 16 & 0xff;
		  o[ 3] = x0 >>> 24 & 0xff;

		  o[ 4] = x5 >>>  0 & 0xff;
		  o[ 5] = x5 >>>  8 & 0xff;
		  o[ 6] = x5 >>> 16 & 0xff;
		  o[ 7] = x5 >>> 24 & 0xff;

		  o[ 8] = x10 >>>  0 & 0xff;
		  o[ 9] = x10 >>>  8 & 0xff;
		  o[10] = x10 >>> 16 & 0xff;
		  o[11] = x10 >>> 24 & 0xff;

		  o[12] = x15 >>>  0 & 0xff;
		  o[13] = x15 >>>  8 & 0xff;
		  o[14] = x15 >>> 16 & 0xff;
		  o[15] = x15 >>> 24 & 0xff;

		  o[16] = x6 >>>  0 & 0xff;
		  o[17] = x6 >>>  8 & 0xff;
		  o[18] = x6 >>> 16 & 0xff;
		  o[19] = x6 >>> 24 & 0xff;

		  o[20] = x7 >>>  0 & 0xff;
		  o[21] = x7 >>>  8 & 0xff;
		  o[22] = x7 >>> 16 & 0xff;
		  o[23] = x7 >>> 24 & 0xff;

		  o[24] = x8 >>>  0 & 0xff;
		  o[25] = x8 >>>  8 & 0xff;
		  o[26] = x8 >>> 16 & 0xff;
		  o[27] = x8 >>> 24 & 0xff;

		  o[28] = x9 >>>  0 & 0xff;
		  o[29] = x9 >>>  8 & 0xff;
		  o[30] = x9 >>> 16 & 0xff;
		  o[31] = x9 >>> 24 & 0xff;
		}

		function crypto_core_salsa20(out,inp,k,c) {
		  core_salsa20(out,inp,k,c);
		}

		function crypto_core_hsalsa20(out,inp,k,c) {
		  core_hsalsa20(out,inp,k,c);
		}

		var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
		            // "expand 32-byte k"

		function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
		  var z = new Uint8Array(16), x = new Uint8Array(64);
		  var u, i;
		  for (i = 0; i < 16; i++) z[i] = 0;
		  for (i = 0; i < 8; i++) z[i] = n[i];
		  while (b >= 64) {
		    crypto_core_salsa20(x,z,k,sigma);
		    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
		    u = 1;
		    for (i = 8; i < 16; i++) {
		      u = u + (z[i] & 0xff) | 0;
		      z[i] = u & 0xff;
		      u >>>= 8;
		    }
		    b -= 64;
		    cpos += 64;
		    mpos += 64;
		  }
		  if (b > 0) {
		    crypto_core_salsa20(x,z,k,sigma);
		    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
		  }
		  return 0;
		}

		function crypto_stream_salsa20(c,cpos,b,n,k) {
		  var z = new Uint8Array(16), x = new Uint8Array(64);
		  var u, i;
		  for (i = 0; i < 16; i++) z[i] = 0;
		  for (i = 0; i < 8; i++) z[i] = n[i];
		  while (b >= 64) {
		    crypto_core_salsa20(x,z,k,sigma);
		    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
		    u = 1;
		    for (i = 8; i < 16; i++) {
		      u = u + (z[i] & 0xff) | 0;
		      z[i] = u & 0xff;
		      u >>>= 8;
		    }
		    b -= 64;
		    cpos += 64;
		  }
		  if (b > 0) {
		    crypto_core_salsa20(x,z,k,sigma);
		    for (i = 0; i < b; i++) c[cpos+i] = x[i];
		  }
		  return 0;
		}

		function crypto_stream(c,cpos,d,n,k) {
		  var s = new Uint8Array(32);
		  crypto_core_hsalsa20(s,n,k,sigma);
		  var sn = new Uint8Array(8);
		  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
		  return crypto_stream_salsa20(c,cpos,d,sn,s);
		}

		function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
		  var s = new Uint8Array(32);
		  crypto_core_hsalsa20(s,n,k,sigma);
		  var sn = new Uint8Array(8);
		  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
		  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
		}

		/*
		* Port of Andrew Moon's Poly1305-donna-16. Public domain.
		* https://github.com/floodyberry/poly1305-donna
		*/

		var poly1305 = function(key) {
		  this.buffer = new Uint8Array(16);
		  this.r = new Uint16Array(10);
		  this.h = new Uint16Array(10);
		  this.pad = new Uint16Array(8);
		  this.leftover = 0;
		  this.fin = 0;

		  var t0, t1, t2, t3, t4, t5, t6, t7;

		  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
		  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
		  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
		  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
		  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
		  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
		  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
		  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
		  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
		  this.r[9] = ((t7 >>>  5)) & 0x007f;

		  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
		  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
		  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
		  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
		  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
		  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
		  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
		  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
		};

		poly1305.prototype.blocks = function(m, mpos, bytes) {
		  var hibit = this.fin ? 0 : (1 << 11);
		  var t0, t1, t2, t3, t4, t5, t6, t7, c;
		  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

		  var h0 = this.h[0],
		      h1 = this.h[1],
		      h2 = this.h[2],
		      h3 = this.h[3],
		      h4 = this.h[4],
		      h5 = this.h[5],
		      h6 = this.h[6],
		      h7 = this.h[7],
		      h8 = this.h[8],
		      h9 = this.h[9];

		  var r0 = this.r[0],
		      r1 = this.r[1],
		      r2 = this.r[2],
		      r3 = this.r[3],
		      r4 = this.r[4],
		      r5 = this.r[5],
		      r6 = this.r[6],
		      r7 = this.r[7],
		      r8 = this.r[8],
		      r9 = this.r[9];

		  while (bytes >= 16) {
		    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
		    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
		    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
		    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
		    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
		    h5 += ((t4 >>>  1)) & 0x1fff;
		    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
		    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
		    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
		    h9 += ((t7 >>> 5)) | hibit;

		    c = 0;

		    d0 = c;
		    d0 += h0 * r0;
		    d0 += h1 * (5 * r9);
		    d0 += h2 * (5 * r8);
		    d0 += h3 * (5 * r7);
		    d0 += h4 * (5 * r6);
		    c = (d0 >>> 13); d0 &= 0x1fff;
		    d0 += h5 * (5 * r5);
		    d0 += h6 * (5 * r4);
		    d0 += h7 * (5 * r3);
		    d0 += h8 * (5 * r2);
		    d0 += h9 * (5 * r1);
		    c += (d0 >>> 13); d0 &= 0x1fff;

		    d1 = c;
		    d1 += h0 * r1;
		    d1 += h1 * r0;
		    d1 += h2 * (5 * r9);
		    d1 += h3 * (5 * r8);
		    d1 += h4 * (5 * r7);
		    c = (d1 >>> 13); d1 &= 0x1fff;
		    d1 += h5 * (5 * r6);
		    d1 += h6 * (5 * r5);
		    d1 += h7 * (5 * r4);
		    d1 += h8 * (5 * r3);
		    d1 += h9 * (5 * r2);
		    c += (d1 >>> 13); d1 &= 0x1fff;

		    d2 = c;
		    d2 += h0 * r2;
		    d2 += h1 * r1;
		    d2 += h2 * r0;
		    d2 += h3 * (5 * r9);
		    d2 += h4 * (5 * r8);
		    c = (d2 >>> 13); d2 &= 0x1fff;
		    d2 += h5 * (5 * r7);
		    d2 += h6 * (5 * r6);
		    d2 += h7 * (5 * r5);
		    d2 += h8 * (5 * r4);
		    d2 += h9 * (5 * r3);
		    c += (d2 >>> 13); d2 &= 0x1fff;

		    d3 = c;
		    d3 += h0 * r3;
		    d3 += h1 * r2;
		    d3 += h2 * r1;
		    d3 += h3 * r0;
		    d3 += h4 * (5 * r9);
		    c = (d3 >>> 13); d3 &= 0x1fff;
		    d3 += h5 * (5 * r8);
		    d3 += h6 * (5 * r7);
		    d3 += h7 * (5 * r6);
		    d3 += h8 * (5 * r5);
		    d3 += h9 * (5 * r4);
		    c += (d3 >>> 13); d3 &= 0x1fff;

		    d4 = c;
		    d4 += h0 * r4;
		    d4 += h1 * r3;
		    d4 += h2 * r2;
		    d4 += h3 * r1;
		    d4 += h4 * r0;
		    c = (d4 >>> 13); d4 &= 0x1fff;
		    d4 += h5 * (5 * r9);
		    d4 += h6 * (5 * r8);
		    d4 += h7 * (5 * r7);
		    d4 += h8 * (5 * r6);
		    d4 += h9 * (5 * r5);
		    c += (d4 >>> 13); d4 &= 0x1fff;

		    d5 = c;
		    d5 += h0 * r5;
		    d5 += h1 * r4;
		    d5 += h2 * r3;
		    d5 += h3 * r2;
		    d5 += h4 * r1;
		    c = (d5 >>> 13); d5 &= 0x1fff;
		    d5 += h5 * r0;
		    d5 += h6 * (5 * r9);
		    d5 += h7 * (5 * r8);
		    d5 += h8 * (5 * r7);
		    d5 += h9 * (5 * r6);
		    c += (d5 >>> 13); d5 &= 0x1fff;

		    d6 = c;
		    d6 += h0 * r6;
		    d6 += h1 * r5;
		    d6 += h2 * r4;
		    d6 += h3 * r3;
		    d6 += h4 * r2;
		    c = (d6 >>> 13); d6 &= 0x1fff;
		    d6 += h5 * r1;
		    d6 += h6 * r0;
		    d6 += h7 * (5 * r9);
		    d6 += h8 * (5 * r8);
		    d6 += h9 * (5 * r7);
		    c += (d6 >>> 13); d6 &= 0x1fff;

		    d7 = c;
		    d7 += h0 * r7;
		    d7 += h1 * r6;
		    d7 += h2 * r5;
		    d7 += h3 * r4;
		    d7 += h4 * r3;
		    c = (d7 >>> 13); d7 &= 0x1fff;
		    d7 += h5 * r2;
		    d7 += h6 * r1;
		    d7 += h7 * r0;
		    d7 += h8 * (5 * r9);
		    d7 += h9 * (5 * r8);
		    c += (d7 >>> 13); d7 &= 0x1fff;

		    d8 = c;
		    d8 += h0 * r8;
		    d8 += h1 * r7;
		    d8 += h2 * r6;
		    d8 += h3 * r5;
		    d8 += h4 * r4;
		    c = (d8 >>> 13); d8 &= 0x1fff;
		    d8 += h5 * r3;
		    d8 += h6 * r2;
		    d8 += h7 * r1;
		    d8 += h8 * r0;
		    d8 += h9 * (5 * r9);
		    c += (d8 >>> 13); d8 &= 0x1fff;

		    d9 = c;
		    d9 += h0 * r9;
		    d9 += h1 * r8;
		    d9 += h2 * r7;
		    d9 += h3 * r6;
		    d9 += h4 * r5;
		    c = (d9 >>> 13); d9 &= 0x1fff;
		    d9 += h5 * r4;
		    d9 += h6 * r3;
		    d9 += h7 * r2;
		    d9 += h8 * r1;
		    d9 += h9 * r0;
		    c += (d9 >>> 13); d9 &= 0x1fff;

		    c = (((c << 2) + c)) | 0;
		    c = (c + d0) | 0;
		    d0 = c & 0x1fff;
		    c = (c >>> 13);
		    d1 += c;

		    h0 = d0;
		    h1 = d1;
		    h2 = d2;
		    h3 = d3;
		    h4 = d4;
		    h5 = d5;
		    h6 = d6;
		    h7 = d7;
		    h8 = d8;
		    h9 = d9;

		    mpos += 16;
		    bytes -= 16;
		  }
		  this.h[0] = h0;
		  this.h[1] = h1;
		  this.h[2] = h2;
		  this.h[3] = h3;
		  this.h[4] = h4;
		  this.h[5] = h5;
		  this.h[6] = h6;
		  this.h[7] = h7;
		  this.h[8] = h8;
		  this.h[9] = h9;
		};

		poly1305.prototype.finish = function(mac, macpos) {
		  var g = new Uint16Array(10);
		  var c, mask, f, i;

		  if (this.leftover) {
		    i = this.leftover;
		    this.buffer[i++] = 1;
		    for (; i < 16; i++) this.buffer[i] = 0;
		    this.fin = 1;
		    this.blocks(this.buffer, 0, 16);
		  }

		  c = this.h[1] >>> 13;
		  this.h[1] &= 0x1fff;
		  for (i = 2; i < 10; i++) {
		    this.h[i] += c;
		    c = this.h[i] >>> 13;
		    this.h[i] &= 0x1fff;
		  }
		  this.h[0] += (c * 5);
		  c = this.h[0] >>> 13;
		  this.h[0] &= 0x1fff;
		  this.h[1] += c;
		  c = this.h[1] >>> 13;
		  this.h[1] &= 0x1fff;
		  this.h[2] += c;

		  g[0] = this.h[0] + 5;
		  c = g[0] >>> 13;
		  g[0] &= 0x1fff;
		  for (i = 1; i < 10; i++) {
		    g[i] = this.h[i] + c;
		    c = g[i] >>> 13;
		    g[i] &= 0x1fff;
		  }
		  g[9] -= (1 << 13);

		  mask = (c ^ 1) - 1;
		  for (i = 0; i < 10; i++) g[i] &= mask;
		  mask = ~mask;
		  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

		  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
		  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
		  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
		  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
		  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
		  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
		  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
		  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

		  f = this.h[0] + this.pad[0];
		  this.h[0] = f & 0xffff;
		  for (i = 1; i < 8; i++) {
		    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
		    this.h[i] = f & 0xffff;
		  }

		  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
		  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
		  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
		  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
		  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
		  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
		  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
		  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
		  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
		  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
		  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
		  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
		  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
		  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
		  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
		  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
		};

		poly1305.prototype.update = function(m, mpos, bytes) {
		  var i, want;

		  if (this.leftover) {
		    want = (16 - this.leftover);
		    if (want > bytes)
		      want = bytes;
		    for (i = 0; i < want; i++)
		      this.buffer[this.leftover + i] = m[mpos+i];
		    bytes -= want;
		    mpos += want;
		    this.leftover += want;
		    if (this.leftover < 16)
		      return;
		    this.blocks(this.buffer, 0, 16);
		    this.leftover = 0;
		  }

		  if (bytes >= 16) {
		    want = bytes - (bytes % 16);
		    this.blocks(m, mpos, want);
		    mpos += want;
		    bytes -= want;
		  }

		  if (bytes) {
		    for (i = 0; i < bytes; i++)
		      this.buffer[this.leftover + i] = m[mpos+i];
		    this.leftover += bytes;
		  }
		};

		function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
		  var s = new poly1305(k);
		  s.update(m, mpos, n);
		  s.finish(out, outpos);
		  return 0;
		}

		function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
		  var x = new Uint8Array(16);
		  crypto_onetimeauth(x,0,m,mpos,n,k);
		  return crypto_verify_16(h,hpos,x,0);
		}

		function crypto_secretbox(c,m,d,n,k) {
		  var i;
		  if (d < 32) return -1;
		  crypto_stream_xor(c,0,m,0,d,n,k);
		  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
		  for (i = 0; i < 16; i++) c[i] = 0;
		  return 0;
		}

		function crypto_secretbox_open(m,c,d,n,k) {
		  var i;
		  var x = new Uint8Array(32);
		  if (d < 32) return -1;
		  crypto_stream(x,0,32,n,k);
		  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
		  crypto_stream_xor(m,0,c,0,d,n,k);
		  for (i = 0; i < 32; i++) m[i] = 0;
		  return 0;
		}

		function set25519(r, a) {
		  var i;
		  for (i = 0; i < 16; i++) r[i] = a[i]|0;
		}

		function car25519(o) {
		  var i, v, c = 1;
		  for (i = 0; i < 16; i++) {
		    v = o[i] + c + 65535;
		    c = Math.floor(v / 65536);
		    o[i] = v - c * 65536;
		  }
		  o[0] += c-1 + 37 * (c-1);
		}

		function sel25519(p, q, b) {
		  var t, c = ~(b-1);
		  for (var i = 0; i < 16; i++) {
		    t = c & (p[i] ^ q[i]);
		    p[i] ^= t;
		    q[i] ^= t;
		  }
		}

		function pack25519(o, n) {
		  var i, j, b;
		  var m = gf(), t = gf();
		  for (i = 0; i < 16; i++) t[i] = n[i];
		  car25519(t);
		  car25519(t);
		  car25519(t);
		  for (j = 0; j < 2; j++) {
		    m[0] = t[0] - 0xffed;
		    for (i = 1; i < 15; i++) {
		      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
		      m[i-1] &= 0xffff;
		    }
		    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
		    b = (m[15]>>16) & 1;
		    m[14] &= 0xffff;
		    sel25519(t, m, 1-b);
		  }
		  for (i = 0; i < 16; i++) {
		    o[2*i] = t[i] & 0xff;
		    o[2*i+1] = t[i]>>8;
		  }
		}

		function neq25519(a, b) {
		  var c = new Uint8Array(32), d = new Uint8Array(32);
		  pack25519(c, a);
		  pack25519(d, b);
		  return crypto_verify_32(c, 0, d, 0);
		}

		function par25519(a) {
		  var d = new Uint8Array(32);
		  pack25519(d, a);
		  return d[0] & 1;
		}

		function unpack25519(o, n) {
		  var i;
		  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
		  o[15] &= 0x7fff;
		}

		function A(o, a, b) {
		  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
		}

		function Z(o, a, b) {
		  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
		}

		function M(o, a, b) {
		  var v, c,
		     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
		     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
		    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
		    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
		    b0 = b[0],
		    b1 = b[1],
		    b2 = b[2],
		    b3 = b[3],
		    b4 = b[4],
		    b5 = b[5],
		    b6 = b[6],
		    b7 = b[7],
		    b8 = b[8],
		    b9 = b[9],
		    b10 = b[10],
		    b11 = b[11],
		    b12 = b[12],
		    b13 = b[13],
		    b14 = b[14],
		    b15 = b[15];

		  v = a[0];
		  t0 += v * b0;
		  t1 += v * b1;
		  t2 += v * b2;
		  t3 += v * b3;
		  t4 += v * b4;
		  t5 += v * b5;
		  t6 += v * b6;
		  t7 += v * b7;
		  t8 += v * b8;
		  t9 += v * b9;
		  t10 += v * b10;
		  t11 += v * b11;
		  t12 += v * b12;
		  t13 += v * b13;
		  t14 += v * b14;
		  t15 += v * b15;
		  v = a[1];
		  t1 += v * b0;
		  t2 += v * b1;
		  t3 += v * b2;
		  t4 += v * b3;
		  t5 += v * b4;
		  t6 += v * b5;
		  t7 += v * b6;
		  t8 += v * b7;
		  t9 += v * b8;
		  t10 += v * b9;
		  t11 += v * b10;
		  t12 += v * b11;
		  t13 += v * b12;
		  t14 += v * b13;
		  t15 += v * b14;
		  t16 += v * b15;
		  v = a[2];
		  t2 += v * b0;
		  t3 += v * b1;
		  t4 += v * b2;
		  t5 += v * b3;
		  t6 += v * b4;
		  t7 += v * b5;
		  t8 += v * b6;
		  t9 += v * b7;
		  t10 += v * b8;
		  t11 += v * b9;
		  t12 += v * b10;
		  t13 += v * b11;
		  t14 += v * b12;
		  t15 += v * b13;
		  t16 += v * b14;
		  t17 += v * b15;
		  v = a[3];
		  t3 += v * b0;
		  t4 += v * b1;
		  t5 += v * b2;
		  t6 += v * b3;
		  t7 += v * b4;
		  t8 += v * b5;
		  t9 += v * b6;
		  t10 += v * b7;
		  t11 += v * b8;
		  t12 += v * b9;
		  t13 += v * b10;
		  t14 += v * b11;
		  t15 += v * b12;
		  t16 += v * b13;
		  t17 += v * b14;
		  t18 += v * b15;
		  v = a[4];
		  t4 += v * b0;
		  t5 += v * b1;
		  t6 += v * b2;
		  t7 += v * b3;
		  t8 += v * b4;
		  t9 += v * b5;
		  t10 += v * b6;
		  t11 += v * b7;
		  t12 += v * b8;
		  t13 += v * b9;
		  t14 += v * b10;
		  t15 += v * b11;
		  t16 += v * b12;
		  t17 += v * b13;
		  t18 += v * b14;
		  t19 += v * b15;
		  v = a[5];
		  t5 += v * b0;
		  t6 += v * b1;
		  t7 += v * b2;
		  t8 += v * b3;
		  t9 += v * b4;
		  t10 += v * b5;
		  t11 += v * b6;
		  t12 += v * b7;
		  t13 += v * b8;
		  t14 += v * b9;
		  t15 += v * b10;
		  t16 += v * b11;
		  t17 += v * b12;
		  t18 += v * b13;
		  t19 += v * b14;
		  t20 += v * b15;
		  v = a[6];
		  t6 += v * b0;
		  t7 += v * b1;
		  t8 += v * b2;
		  t9 += v * b3;
		  t10 += v * b4;
		  t11 += v * b5;
		  t12 += v * b6;
		  t13 += v * b7;
		  t14 += v * b8;
		  t15 += v * b9;
		  t16 += v * b10;
		  t17 += v * b11;
		  t18 += v * b12;
		  t19 += v * b13;
		  t20 += v * b14;
		  t21 += v * b15;
		  v = a[7];
		  t7 += v * b0;
		  t8 += v * b1;
		  t9 += v * b2;
		  t10 += v * b3;
		  t11 += v * b4;
		  t12 += v * b5;
		  t13 += v * b6;
		  t14 += v * b7;
		  t15 += v * b8;
		  t16 += v * b9;
		  t17 += v * b10;
		  t18 += v * b11;
		  t19 += v * b12;
		  t20 += v * b13;
		  t21 += v * b14;
		  t22 += v * b15;
		  v = a[8];
		  t8 += v * b0;
		  t9 += v * b1;
		  t10 += v * b2;
		  t11 += v * b3;
		  t12 += v * b4;
		  t13 += v * b5;
		  t14 += v * b6;
		  t15 += v * b7;
		  t16 += v * b8;
		  t17 += v * b9;
		  t18 += v * b10;
		  t19 += v * b11;
		  t20 += v * b12;
		  t21 += v * b13;
		  t22 += v * b14;
		  t23 += v * b15;
		  v = a[9];
		  t9 += v * b0;
		  t10 += v * b1;
		  t11 += v * b2;
		  t12 += v * b3;
		  t13 += v * b4;
		  t14 += v * b5;
		  t15 += v * b6;
		  t16 += v * b7;
		  t17 += v * b8;
		  t18 += v * b9;
		  t19 += v * b10;
		  t20 += v * b11;
		  t21 += v * b12;
		  t22 += v * b13;
		  t23 += v * b14;
		  t24 += v * b15;
		  v = a[10];
		  t10 += v * b0;
		  t11 += v * b1;
		  t12 += v * b2;
		  t13 += v * b3;
		  t14 += v * b4;
		  t15 += v * b5;
		  t16 += v * b6;
		  t17 += v * b7;
		  t18 += v * b8;
		  t19 += v * b9;
		  t20 += v * b10;
		  t21 += v * b11;
		  t22 += v * b12;
		  t23 += v * b13;
		  t24 += v * b14;
		  t25 += v * b15;
		  v = a[11];
		  t11 += v * b0;
		  t12 += v * b1;
		  t13 += v * b2;
		  t14 += v * b3;
		  t15 += v * b4;
		  t16 += v * b5;
		  t17 += v * b6;
		  t18 += v * b7;
		  t19 += v * b8;
		  t20 += v * b9;
		  t21 += v * b10;
		  t22 += v * b11;
		  t23 += v * b12;
		  t24 += v * b13;
		  t25 += v * b14;
		  t26 += v * b15;
		  v = a[12];
		  t12 += v * b0;
		  t13 += v * b1;
		  t14 += v * b2;
		  t15 += v * b3;
		  t16 += v * b4;
		  t17 += v * b5;
		  t18 += v * b6;
		  t19 += v * b7;
		  t20 += v * b8;
		  t21 += v * b9;
		  t22 += v * b10;
		  t23 += v * b11;
		  t24 += v * b12;
		  t25 += v * b13;
		  t26 += v * b14;
		  t27 += v * b15;
		  v = a[13];
		  t13 += v * b0;
		  t14 += v * b1;
		  t15 += v * b2;
		  t16 += v * b3;
		  t17 += v * b4;
		  t18 += v * b5;
		  t19 += v * b6;
		  t20 += v * b7;
		  t21 += v * b8;
		  t22 += v * b9;
		  t23 += v * b10;
		  t24 += v * b11;
		  t25 += v * b12;
		  t26 += v * b13;
		  t27 += v * b14;
		  t28 += v * b15;
		  v = a[14];
		  t14 += v * b0;
		  t15 += v * b1;
		  t16 += v * b2;
		  t17 += v * b3;
		  t18 += v * b4;
		  t19 += v * b5;
		  t20 += v * b6;
		  t21 += v * b7;
		  t22 += v * b8;
		  t23 += v * b9;
		  t24 += v * b10;
		  t25 += v * b11;
		  t26 += v * b12;
		  t27 += v * b13;
		  t28 += v * b14;
		  t29 += v * b15;
		  v = a[15];
		  t15 += v * b0;
		  t16 += v * b1;
		  t17 += v * b2;
		  t18 += v * b3;
		  t19 += v * b4;
		  t20 += v * b5;
		  t21 += v * b6;
		  t22 += v * b7;
		  t23 += v * b8;
		  t24 += v * b9;
		  t25 += v * b10;
		  t26 += v * b11;
		  t27 += v * b12;
		  t28 += v * b13;
		  t29 += v * b14;
		  t30 += v * b15;

		  t0  += 38 * t16;
		  t1  += 38 * t17;
		  t2  += 38 * t18;
		  t3  += 38 * t19;
		  t4  += 38 * t20;
		  t5  += 38 * t21;
		  t6  += 38 * t22;
		  t7  += 38 * t23;
		  t8  += 38 * t24;
		  t9  += 38 * t25;
		  t10 += 38 * t26;
		  t11 += 38 * t27;
		  t12 += 38 * t28;
		  t13 += 38 * t29;
		  t14 += 38 * t30;
		  // t15 left as is

		  // first car
		  c = 1;
		  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
		  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
		  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
		  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
		  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
		  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
		  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
		  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
		  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
		  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
		  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
		  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
		  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
		  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
		  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
		  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
		  t0 += c-1 + 37 * (c-1);

		  // second car
		  c = 1;
		  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
		  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
		  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
		  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
		  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
		  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
		  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
		  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
		  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
		  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
		  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
		  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
		  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
		  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
		  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
		  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
		  t0 += c-1 + 37 * (c-1);

		  o[ 0] = t0;
		  o[ 1] = t1;
		  o[ 2] = t2;
		  o[ 3] = t3;
		  o[ 4] = t4;
		  o[ 5] = t5;
		  o[ 6] = t6;
		  o[ 7] = t7;
		  o[ 8] = t8;
		  o[ 9] = t9;
		  o[10] = t10;
		  o[11] = t11;
		  o[12] = t12;
		  o[13] = t13;
		  o[14] = t14;
		  o[15] = t15;
		}

		function S(o, a) {
		  M(o, a, a);
		}

		function inv25519(o, i) {
		  var c = gf();
		  var a;
		  for (a = 0; a < 16; a++) c[a] = i[a];
		  for (a = 253; a >= 0; a--) {
		    S(c, c);
		    if(a !== 2 && a !== 4) M(c, c, i);
		  }
		  for (a = 0; a < 16; a++) o[a] = c[a];
		}

		function pow2523(o, i) {
		  var c = gf();
		  var a;
		  for (a = 0; a < 16; a++) c[a] = i[a];
		  for (a = 250; a >= 0; a--) {
		      S(c, c);
		      if(a !== 1) M(c, c, i);
		  }
		  for (a = 0; a < 16; a++) o[a] = c[a];
		}

		function crypto_scalarmult(q, n, p) {
		  var z = new Uint8Array(32);
		  var x = new Float64Array(80), r, i;
		  var a = gf(), b = gf(), c = gf(),
		      d = gf(), e = gf(), f = gf();
		  for (i = 0; i < 31; i++) z[i] = n[i];
		  z[31]=(n[31]&127)|64;
		  z[0]&=248;
		  unpack25519(x,p);
		  for (i = 0; i < 16; i++) {
		    b[i]=x[i];
		    d[i]=a[i]=c[i]=0;
		  }
		  a[0]=d[0]=1;
		  for (i=254; i>=0; --i) {
		    r=(z[i>>>3]>>>(i&7))&1;
		    sel25519(a,b,r);
		    sel25519(c,d,r);
		    A(e,a,c);
		    Z(a,a,c);
		    A(c,b,d);
		    Z(b,b,d);
		    S(d,e);
		    S(f,a);
		    M(a,c,a);
		    M(c,b,e);
		    A(e,a,c);
		    Z(a,a,c);
		    S(b,a);
		    Z(c,d,f);
		    M(a,c,_121665);
		    A(a,a,d);
		    M(c,c,a);
		    M(a,d,f);
		    M(d,b,x);
		    S(b,e);
		    sel25519(a,b,r);
		    sel25519(c,d,r);
		  }
		  for (i = 0; i < 16; i++) {
		    x[i+16]=a[i];
		    x[i+32]=c[i];
		    x[i+48]=b[i];
		    x[i+64]=d[i];
		  }
		  var x32 = x.subarray(32);
		  var x16 = x.subarray(16);
		  inv25519(x32,x32);
		  M(x16,x16,x32);
		  pack25519(q,x16);
		  return 0;
		}

		function crypto_scalarmult_base(q, n) {
		  return crypto_scalarmult(q, n, _9);
		}

		function crypto_box_keypair(y, x) {
		  randombytes(x, 32);
		  return crypto_scalarmult_base(y, x);
		}

		function crypto_box_beforenm(k, y, x) {
		  var s = new Uint8Array(32);
		  crypto_scalarmult(s, x, y);
		  return crypto_core_hsalsa20(k, _0, s, sigma);
		}

		var crypto_box_afternm = crypto_secretbox;
		var crypto_box_open_afternm = crypto_secretbox_open;

		function crypto_box(c, m, d, n, y, x) {
		  var k = new Uint8Array(32);
		  crypto_box_beforenm(k, y, x);
		  return crypto_box_afternm(c, m, d, n, k);
		}

		function crypto_box_open(m, c, d, n, y, x) {
		  var k = new Uint8Array(32);
		  crypto_box_beforenm(k, y, x);
		  return crypto_box_open_afternm(m, c, d, n, k);
		}

		var K = [
		  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
		  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
		  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
		  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
		  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
		  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
		  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
		  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
		  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
		  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
		  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
		  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
		  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
		  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
		  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
		  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
		  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
		  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
		  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
		  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
		  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
		  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
		  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
		  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
		  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
		  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
		  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
		  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
		  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
		  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
		  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
		  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
		  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
		  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
		  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
		  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
		  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
		  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
		  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
		  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
		];

		function crypto_hashblocks_hl(hh, hl, m, n) {
		  var wh = new Int32Array(16), wl = new Int32Array(16),
		      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
		      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
		      th, tl, i, j, h, l, a, b, c, d;

		  var ah0 = hh[0],
		      ah1 = hh[1],
		      ah2 = hh[2],
		      ah3 = hh[3],
		      ah4 = hh[4],
		      ah5 = hh[5],
		      ah6 = hh[6],
		      ah7 = hh[7],

		      al0 = hl[0],
		      al1 = hl[1],
		      al2 = hl[2],
		      al3 = hl[3],
		      al4 = hl[4],
		      al5 = hl[5],
		      al6 = hl[6],
		      al7 = hl[7];

		  var pos = 0;
		  while (n >= 128) {
		    for (i = 0; i < 16; i++) {
		      j = 8 * i + pos;
		      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
		      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
		    }
		    for (i = 0; i < 80; i++) {
		      bh0 = ah0;
		      bh1 = ah1;
		      bh2 = ah2;
		      bh3 = ah3;
		      bh4 = ah4;
		      bh5 = ah5;
		      bh6 = ah6;
		      bh7 = ah7;

		      bl0 = al0;
		      bl1 = al1;
		      bl2 = al2;
		      bl3 = al3;
		      bl4 = al4;
		      bl5 = al5;
		      bl6 = al6;
		      bl7 = al7;

		      // add
		      h = ah7;
		      l = al7;

		      a = l & 0xffff; b = l >>> 16;
		      c = h & 0xffff; d = h >>> 16;

		      // Sigma1
		      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
		      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

		      a += l & 0xffff; b += l >>> 16;
		      c += h & 0xffff; d += h >>> 16;

		      // Ch
		      h = (ah4 & ah5) ^ (~ah4 & ah6);
		      l = (al4 & al5) ^ (~al4 & al6);

		      a += l & 0xffff; b += l >>> 16;
		      c += h & 0xffff; d += h >>> 16;

		      // K
		      h = K[i*2];
		      l = K[i*2+1];

		      a += l & 0xffff; b += l >>> 16;
		      c += h & 0xffff; d += h >>> 16;

		      // w
		      h = wh[i%16];
		      l = wl[i%16];

		      a += l & 0xffff; b += l >>> 16;
		      c += h & 0xffff; d += h >>> 16;

		      b += a >>> 16;
		      c += b >>> 16;
		      d += c >>> 16;

		      th = c & 0xffff | d << 16;
		      tl = a & 0xffff | b << 16;

		      // add
		      h = th;
		      l = tl;

		      a = l & 0xffff; b = l >>> 16;
		      c = h & 0xffff; d = h >>> 16;

		      // Sigma0
		      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
		      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

		      a += l & 0xffff; b += l >>> 16;
		      c += h & 0xffff; d += h >>> 16;

		      // Maj
		      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
		      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

		      a += l & 0xffff; b += l >>> 16;
		      c += h & 0xffff; d += h >>> 16;

		      b += a >>> 16;
		      c += b >>> 16;
		      d += c >>> 16;

		      bh7 = (c & 0xffff) | (d << 16);
		      bl7 = (a & 0xffff) | (b << 16);

		      // add
		      h = bh3;
		      l = bl3;

		      a = l & 0xffff; b = l >>> 16;
		      c = h & 0xffff; d = h >>> 16;

		      h = th;
		      l = tl;

		      a += l & 0xffff; b += l >>> 16;
		      c += h & 0xffff; d += h >>> 16;

		      b += a >>> 16;
		      c += b >>> 16;
		      d += c >>> 16;

		      bh3 = (c & 0xffff) | (d << 16);
		      bl3 = (a & 0xffff) | (b << 16);

		      ah1 = bh0;
		      ah2 = bh1;
		      ah3 = bh2;
		      ah4 = bh3;
		      ah5 = bh4;
		      ah6 = bh5;
		      ah7 = bh6;
		      ah0 = bh7;

		      al1 = bl0;
		      al2 = bl1;
		      al3 = bl2;
		      al4 = bl3;
		      al5 = bl4;
		      al6 = bl5;
		      al7 = bl6;
		      al0 = bl7;

		      if (i%16 === 15) {
		        for (j = 0; j < 16; j++) {
		          // add
		          h = wh[j];
		          l = wl[j];

		          a = l & 0xffff; b = l >>> 16;
		          c = h & 0xffff; d = h >>> 16;

		          h = wh[(j+9)%16];
		          l = wl[(j+9)%16];

		          a += l & 0xffff; b += l >>> 16;
		          c += h & 0xffff; d += h >>> 16;

		          // sigma0
		          th = wh[(j+1)%16];
		          tl = wl[(j+1)%16];
		          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
		          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

		          a += l & 0xffff; b += l >>> 16;
		          c += h & 0xffff; d += h >>> 16;

		          // sigma1
		          th = wh[(j+14)%16];
		          tl = wl[(j+14)%16];
		          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
		          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

		          a += l & 0xffff; b += l >>> 16;
		          c += h & 0xffff; d += h >>> 16;

		          b += a >>> 16;
		          c += b >>> 16;
		          d += c >>> 16;

		          wh[j] = (c & 0xffff) | (d << 16);
		          wl[j] = (a & 0xffff) | (b << 16);
		        }
		      }
		    }

		    // add
		    h = ah0;
		    l = al0;

		    a = l & 0xffff; b = l >>> 16;
		    c = h & 0xffff; d = h >>> 16;

		    h = hh[0];
		    l = hl[0];

		    a += l & 0xffff; b += l >>> 16;
		    c += h & 0xffff; d += h >>> 16;

		    b += a >>> 16;
		    c += b >>> 16;
		    d += c >>> 16;

		    hh[0] = ah0 = (c & 0xffff) | (d << 16);
		    hl[0] = al0 = (a & 0xffff) | (b << 16);

		    h = ah1;
		    l = al1;

		    a = l & 0xffff; b = l >>> 16;
		    c = h & 0xffff; d = h >>> 16;

		    h = hh[1];
		    l = hl[1];

		    a += l & 0xffff; b += l >>> 16;
		    c += h & 0xffff; d += h >>> 16;

		    b += a >>> 16;
		    c += b >>> 16;
		    d += c >>> 16;

		    hh[1] = ah1 = (c & 0xffff) | (d << 16);
		    hl[1] = al1 = (a & 0xffff) | (b << 16);

		    h = ah2;
		    l = al2;

		    a = l & 0xffff; b = l >>> 16;
		    c = h & 0xffff; d = h >>> 16;

		    h = hh[2];
		    l = hl[2];

		    a += l & 0xffff; b += l >>> 16;
		    c += h & 0xffff; d += h >>> 16;

		    b += a >>> 16;
		    c += b >>> 16;
		    d += c >>> 16;

		    hh[2] = ah2 = (c & 0xffff) | (d << 16);
		    hl[2] = al2 = (a & 0xffff) | (b << 16);

		    h = ah3;
		    l = al3;

		    a = l & 0xffff; b = l >>> 16;
		    c = h & 0xffff; d = h >>> 16;

		    h = hh[3];
		    l = hl[3];

		    a += l & 0xffff; b += l >>> 16;
		    c += h & 0xffff; d += h >>> 16;

		    b += a >>> 16;
		    c += b >>> 16;
		    d += c >>> 16;

		    hh[3] = ah3 = (c & 0xffff) | (d << 16);
		    hl[3] = al3 = (a & 0xffff) | (b << 16);

		    h = ah4;
		    l = al4;

		    a = l & 0xffff; b = l >>> 16;
		    c = h & 0xffff; d = h >>> 16;

		    h = hh[4];
		    l = hl[4];

		    a += l & 0xffff; b += l >>> 16;
		    c += h & 0xffff; d += h >>> 16;

		    b += a >>> 16;
		    c += b >>> 16;
		    d += c >>> 16;

		    hh[4] = ah4 = (c & 0xffff) | (d << 16);
		    hl[4] = al4 = (a & 0xffff) | (b << 16);

		    h = ah5;
		    l = al5;

		    a = l & 0xffff; b = l >>> 16;
		    c = h & 0xffff; d = h >>> 16;

		    h = hh[5];
		    l = hl[5];

		    a += l & 0xffff; b += l >>> 16;
		    c += h & 0xffff; d += h >>> 16;

		    b += a >>> 16;
		    c += b >>> 16;
		    d += c >>> 16;

		    hh[5] = ah5 = (c & 0xffff) | (d << 16);
		    hl[5] = al5 = (a & 0xffff) | (b << 16);

		    h = ah6;
		    l = al6;

		    a = l & 0xffff; b = l >>> 16;
		    c = h & 0xffff; d = h >>> 16;

		    h = hh[6];
		    l = hl[6];

		    a += l & 0xffff; b += l >>> 16;
		    c += h & 0xffff; d += h >>> 16;

		    b += a >>> 16;
		    c += b >>> 16;
		    d += c >>> 16;

		    hh[6] = ah6 = (c & 0xffff) | (d << 16);
		    hl[6] = al6 = (a & 0xffff) | (b << 16);

		    h = ah7;
		    l = al7;

		    a = l & 0xffff; b = l >>> 16;
		    c = h & 0xffff; d = h >>> 16;

		    h = hh[7];
		    l = hl[7];

		    a += l & 0xffff; b += l >>> 16;
		    c += h & 0xffff; d += h >>> 16;

		    b += a >>> 16;
		    c += b >>> 16;
		    d += c >>> 16;

		    hh[7] = ah7 = (c & 0xffff) | (d << 16);
		    hl[7] = al7 = (a & 0xffff) | (b << 16);

		    pos += 128;
		    n -= 128;
		  }

		  return n;
		}

		function crypto_hash(out, m, n) {
		  var hh = new Int32Array(8),
		      hl = new Int32Array(8),
		      x = new Uint8Array(256),
		      i, b = n;

		  hh[0] = 0x6a09e667;
		  hh[1] = 0xbb67ae85;
		  hh[2] = 0x3c6ef372;
		  hh[3] = 0xa54ff53a;
		  hh[4] = 0x510e527f;
		  hh[5] = 0x9b05688c;
		  hh[6] = 0x1f83d9ab;
		  hh[7] = 0x5be0cd19;

		  hl[0] = 0xf3bcc908;
		  hl[1] = 0x84caa73b;
		  hl[2] = 0xfe94f82b;
		  hl[3] = 0x5f1d36f1;
		  hl[4] = 0xade682d1;
		  hl[5] = 0x2b3e6c1f;
		  hl[6] = 0xfb41bd6b;
		  hl[7] = 0x137e2179;

		  crypto_hashblocks_hl(hh, hl, m, n);
		  n %= 128;

		  for (i = 0; i < n; i++) x[i] = m[b-n+i];
		  x[n] = 128;

		  n = 256-128*(n<112?1:0);
		  x[n-9] = 0;
		  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
		  crypto_hashblocks_hl(hh, hl, x, n);

		  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

		  return 0;
		}

		function add(p, q) {
		  var a = gf(), b = gf(), c = gf(),
		      d = gf(), e = gf(), f = gf(),
		      g = gf(), h = gf(), t = gf();

		  Z(a, p[1], p[0]);
		  Z(t, q[1], q[0]);
		  M(a, a, t);
		  A(b, p[0], p[1]);
		  A(t, q[0], q[1]);
		  M(b, b, t);
		  M(c, p[3], q[3]);
		  M(c, c, D2);
		  M(d, p[2], q[2]);
		  A(d, d, d);
		  Z(e, b, a);
		  Z(f, d, c);
		  A(g, d, c);
		  A(h, b, a);

		  M(p[0], e, f);
		  M(p[1], h, g);
		  M(p[2], g, f);
		  M(p[3], e, h);
		}

		function cswap(p, q, b) {
		  var i;
		  for (i = 0; i < 4; i++) {
		    sel25519(p[i], q[i], b);
		  }
		}

		function pack(r, p) {
		  var tx = gf(), ty = gf(), zi = gf();
		  inv25519(zi, p[2]);
		  M(tx, p[0], zi);
		  M(ty, p[1], zi);
		  pack25519(r, ty);
		  r[31] ^= par25519(tx) << 7;
		}

		function scalarmult(p, q, s) {
		  var b, i;
		  set25519(p[0], gf0);
		  set25519(p[1], gf1);
		  set25519(p[2], gf1);
		  set25519(p[3], gf0);
		  for (i = 255; i >= 0; --i) {
		    b = (s[(i/8)|0] >> (i&7)) & 1;
		    cswap(p, q, b);
		    add(q, p);
		    add(p, p);
		    cswap(p, q, b);
		  }
		}

		function scalarbase(p, s) {
		  var q = [gf(), gf(), gf(), gf()];
		  set25519(q[0], X);
		  set25519(q[1], Y);
		  set25519(q[2], gf1);
		  M(q[3], X, Y);
		  scalarmult(p, q, s);
		}

		function crypto_sign_keypair(pk, sk, seeded) {
		  var d = new Uint8Array(64);
		  var p = [gf(), gf(), gf(), gf()];
		  var i;

		  if (!seeded) randombytes(sk, 32);
		  crypto_hash(d, sk, 32);
		  d[0] &= 248;
		  d[31] &= 127;
		  d[31] |= 64;

		  scalarbase(p, d);
		  pack(pk, p);

		  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
		  return 0;
		}

		var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

		function modL(r, x) {
		  var carry, i, j, k;
		  for (i = 63; i >= 32; --i) {
		    carry = 0;
		    for (j = i - 32, k = i - 12; j < k; ++j) {
		      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
		      carry = (x[j] + 128) >> 8;
		      x[j] -= carry * 256;
		    }
		    x[j] += carry;
		    x[i] = 0;
		  }
		  carry = 0;
		  for (j = 0; j < 32; j++) {
		    x[j] += carry - (x[31] >> 4) * L[j];
		    carry = x[j] >> 8;
		    x[j] &= 255;
		  }
		  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
		  for (i = 0; i < 32; i++) {
		    x[i+1] += x[i] >> 8;
		    r[i] = x[i] & 255;
		  }
		}

		function reduce(r) {
		  var x = new Float64Array(64), i;
		  for (i = 0; i < 64; i++) x[i] = r[i];
		  for (i = 0; i < 64; i++) r[i] = 0;
		  modL(r, x);
		}

		// Note: difference from C - smlen returned, not passed as argument.
		function crypto_sign(sm, m, n, sk) {
		  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
		  var i, j, x = new Float64Array(64);
		  var p = [gf(), gf(), gf(), gf()];

		  crypto_hash(d, sk, 32);
		  d[0] &= 248;
		  d[31] &= 127;
		  d[31] |= 64;

		  var smlen = n + 64;
		  for (i = 0; i < n; i++) sm[64 + i] = m[i];
		  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

		  crypto_hash(r, sm.subarray(32), n+32);
		  reduce(r);
		  scalarbase(p, r);
		  pack(sm, p);

		  for (i = 32; i < 64; i++) sm[i] = sk[i];
		  crypto_hash(h, sm, n + 64);
		  reduce(h);

		  for (i = 0; i < 64; i++) x[i] = 0;
		  for (i = 0; i < 32; i++) x[i] = r[i];
		  for (i = 0; i < 32; i++) {
		    for (j = 0; j < 32; j++) {
		      x[i+j] += h[i] * d[j];
		    }
		  }

		  modL(sm.subarray(32), x);
		  return smlen;
		}

		function unpackneg(r, p) {
		  var t = gf(), chk = gf(), num = gf(),
		      den = gf(), den2 = gf(), den4 = gf(),
		      den6 = gf();

		  set25519(r[2], gf1);
		  unpack25519(r[1], p);
		  S(num, r[1]);
		  M(den, num, D);
		  Z(num, num, r[2]);
		  A(den, r[2], den);

		  S(den2, den);
		  S(den4, den2);
		  M(den6, den4, den2);
		  M(t, den6, num);
		  M(t, t, den);

		  pow2523(t, t);
		  M(t, t, num);
		  M(t, t, den);
		  M(t, t, den);
		  M(r[0], t, den);

		  S(chk, r[0]);
		  M(chk, chk, den);
		  if (neq25519(chk, num)) M(r[0], r[0], I);

		  S(chk, r[0]);
		  M(chk, chk, den);
		  if (neq25519(chk, num)) return -1;

		  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

		  M(r[3], r[0], r[1]);
		  return 0;
		}

		function crypto_sign_open(m, sm, n, pk) {
		  var i, mlen;
		  var t = new Uint8Array(32), h = new Uint8Array(64);
		  var p = [gf(), gf(), gf(), gf()],
		      q = [gf(), gf(), gf(), gf()];

		  mlen = -1;
		  if (n < 64) return -1;

		  if (unpackneg(q, pk)) return -1;

		  for (i = 0; i < n; i++) m[i] = sm[i];
		  for (i = 0; i < 32; i++) m[i+32] = pk[i];
		  crypto_hash(h, m, n);
		  reduce(h);
		  scalarmult(p, q, h);

		  scalarbase(q, sm.subarray(32));
		  add(p, q);
		  pack(t, p);

		  n -= 64;
		  if (crypto_verify_32(sm, 0, t, 0)) {
		    for (i = 0; i < n; i++) m[i] = 0;
		    return -1;
		  }

		  for (i = 0; i < n; i++) m[i] = sm[i + 64];
		  mlen = n;
		  return mlen;
		}

		var crypto_secretbox_KEYBYTES = 32,
		    crypto_secretbox_NONCEBYTES = 24,
		    crypto_secretbox_ZEROBYTES = 32,
		    crypto_secretbox_BOXZEROBYTES = 16,
		    crypto_scalarmult_BYTES = 32,
		    crypto_scalarmult_SCALARBYTES = 32,
		    crypto_box_PUBLICKEYBYTES = 32,
		    crypto_box_SECRETKEYBYTES = 32,
		    crypto_box_BEFORENMBYTES = 32,
		    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
		    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
		    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
		    crypto_sign_BYTES = 64,
		    crypto_sign_PUBLICKEYBYTES = 32,
		    crypto_sign_SECRETKEYBYTES = 64,
		    crypto_sign_SEEDBYTES = 32,
		    crypto_hash_BYTES = 64;

		nacl.lowlevel = {
		  crypto_core_hsalsa20: crypto_core_hsalsa20,
		  crypto_stream_xor: crypto_stream_xor,
		  crypto_stream: crypto_stream,
		  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
		  crypto_stream_salsa20: crypto_stream_salsa20,
		  crypto_onetimeauth: crypto_onetimeauth,
		  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
		  crypto_verify_16: crypto_verify_16,
		  crypto_verify_32: crypto_verify_32,
		  crypto_secretbox: crypto_secretbox,
		  crypto_secretbox_open: crypto_secretbox_open,
		  crypto_scalarmult: crypto_scalarmult,
		  crypto_scalarmult_base: crypto_scalarmult_base,
		  crypto_box_beforenm: crypto_box_beforenm,
		  crypto_box_afternm: crypto_box_afternm,
		  crypto_box: crypto_box,
		  crypto_box_open: crypto_box_open,
		  crypto_box_keypair: crypto_box_keypair,
		  crypto_hash: crypto_hash,
		  crypto_sign: crypto_sign,
		  crypto_sign_keypair: crypto_sign_keypair,
		  crypto_sign_open: crypto_sign_open,

		  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
		  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
		  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
		  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
		  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
		  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
		  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
		  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
		  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
		  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
		  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
		  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
		  crypto_sign_BYTES: crypto_sign_BYTES,
		  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
		  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
		  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
		  crypto_hash_BYTES: crypto_hash_BYTES
		};

		/* High-level API */

		function checkLengths(k, n) {
		  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
		  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
		}

		function checkBoxLengths(pk, sk) {
		  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
		  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
		}

		function checkArrayTypes() {
		  var t, i;
		  for (i = 0; i < arguments.length; i++) {
		     if ((t = Object.prototype.toString.call(arguments[i])) !== '[object Uint8Array]')
		       throw new TypeError('unexpected type ' + t + ', use Uint8Array');
		  }
		}

		function cleanup(arr) {
		  for (var i = 0; i < arr.length; i++) arr[i] = 0;
		}

		// TODO: Completely remove this in v0.15.
		if (!nacl.util) {
		  nacl.util = {};
		  nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function() {
		    throw new Error('nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js');
		  };
		}

		nacl.randomBytes = function(n) {
		  var b = new Uint8Array(n);
		  randombytes(b, n);
		  return b;
		};

		nacl.secretbox = function(msg, nonce, key) {
		  checkArrayTypes(msg, nonce, key);
		  checkLengths(key, nonce);
		  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
		  var c = new Uint8Array(m.length);
		  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
		  crypto_secretbox(c, m, m.length, nonce, key);
		  return c.subarray(crypto_secretbox_BOXZEROBYTES);
		};

		nacl.secretbox.open = function(box, nonce, key) {
		  checkArrayTypes(box, nonce, key);
		  checkLengths(key, nonce);
		  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
		  var m = new Uint8Array(c.length);
		  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
		  if (c.length < 32) return false;
		  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return false;
		  return m.subarray(crypto_secretbox_ZEROBYTES);
		};

		nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
		nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
		nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

		nacl.scalarMult = function(n, p) {
		  checkArrayTypes(n, p);
		  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
		  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
		  var q = new Uint8Array(crypto_scalarmult_BYTES);
		  crypto_scalarmult(q, n, p);
		  return q;
		};

		nacl.scalarMult.base = function(n) {
		  checkArrayTypes(n);
		  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
		  var q = new Uint8Array(crypto_scalarmult_BYTES);
		  crypto_scalarmult_base(q, n);
		  return q;
		};

		nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
		nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

		nacl.box = function(msg, nonce, publicKey, secretKey) {
		  var k = nacl.box.before(publicKey, secretKey);
		  return nacl.secretbox(msg, nonce, k);
		};

		nacl.box.before = function(publicKey, secretKey) {
		  checkArrayTypes(publicKey, secretKey);
		  checkBoxLengths(publicKey, secretKey);
		  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
		  crypto_box_beforenm(k, publicKey, secretKey);
		  return k;
		};

		nacl.box.after = nacl.secretbox;

		nacl.box.open = function(msg, nonce, publicKey, secretKey) {
		  var k = nacl.box.before(publicKey, secretKey);
		  return nacl.secretbox.open(msg, nonce, k);
		};

		nacl.box.open.after = nacl.secretbox.open;

		nacl.box.keyPair = function() {
		  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
		  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
		  crypto_box_keypair(pk, sk);
		  return {publicKey: pk, secretKey: sk};
		};

		nacl.box.keyPair.fromSecretKey = function(secretKey) {
		  checkArrayTypes(secretKey);
		  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
		    throw new Error('bad secret key size');
		  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
		  crypto_scalarmult_base(pk, secretKey);
		  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
		};

		nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
		nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
		nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
		nacl.box.nonceLength = crypto_box_NONCEBYTES;
		nacl.box.overheadLength = nacl.secretbox.overheadLength;

		nacl.sign = function(msg, secretKey) {
		  checkArrayTypes(msg, secretKey);
		  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
		    throw new Error('bad secret key size');
		  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
		  crypto_sign(signedMsg, msg, msg.length, secretKey);
		  return signedMsg;
		};

		nacl.sign.open = function(signedMsg, publicKey) {
		  if (arguments.length !== 2)
		    throw new Error('nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?');
		  checkArrayTypes(signedMsg, publicKey);
		  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
		    throw new Error('bad public key size');
		  var tmp = new Uint8Array(signedMsg.length);
		  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
		  if (mlen < 0) return null;
		  var m = new Uint8Array(mlen);
		  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
		  return m;
		};

		nacl.sign.detached = function(msg, secretKey) {
		  var signedMsg = nacl.sign(msg, secretKey);
		  var sig = new Uint8Array(crypto_sign_BYTES);
		  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
		  return sig;
		};

		nacl.sign.detached.verify = function(msg, sig, publicKey) {
		  checkArrayTypes(msg, sig, publicKey);
		  if (sig.length !== crypto_sign_BYTES)
		    throw new Error('bad signature size');
		  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
		    throw new Error('bad public key size');
		  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
		  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
		  var i;
		  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
		  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
		  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
		};

		nacl.sign.keyPair = function() {
		  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
		  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
		  crypto_sign_keypair(pk, sk);
		  return {publicKey: pk, secretKey: sk};
		};

		nacl.sign.keyPair.fromSecretKey = function(secretKey) {
		  checkArrayTypes(secretKey);
		  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
		    throw new Error('bad secret key size');
		  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
		  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
		  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
		};

		nacl.sign.keyPair.fromSeed = function(seed) {
		  checkArrayTypes(seed);
		  if (seed.length !== crypto_sign_SEEDBYTES)
		    throw new Error('bad seed size');
		  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
		  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
		  for (var i = 0; i < 32; i++) sk[i] = seed[i];
		  crypto_sign_keypair(pk, sk, true);
		  return {publicKey: pk, secretKey: sk};
		};

		nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
		nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
		nacl.sign.seedLength = crypto_sign_SEEDBYTES;
		nacl.sign.signatureLength = crypto_sign_BYTES;

		nacl.hash = function(msg) {
		  checkArrayTypes(msg);
		  var h = new Uint8Array(crypto_hash_BYTES);
		  crypto_hash(h, msg, msg.length);
		  return h;
		};

		nacl.hash.hashLength = crypto_hash_BYTES;

		nacl.verify = function(x, y) {
		  checkArrayTypes(x, y);
		  // Zero length arguments are considered not equal.
		  if (x.length === 0 || y.length === 0) return false;
		  if (x.length !== y.length) return false;
		  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
		};

		nacl.setPRNG = function(fn) {
		  randombytes = fn;
		};

		(function() {
		  // Initialize PRNG if environment provides CSPRNG.
		  // If not, methods calling randombytes will throw.
		  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
		  if (crypto && crypto.getRandomValues) {
		    // Browsers.
		    var QUOTA = 65536;
		    nacl.setPRNG(function(x, n) {
		      var i, v = new Uint8Array(n);
		      for (i = 0; i < n; i += QUOTA) {
		        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
		      }
		      for (i = 0; i < n; i++) x[i] = v[i];
		      cleanup(v);
		    });
		  } else if (typeof commonjsRequire !== 'undefined') {
		    // Node.js.
		    crypto = require$$0$5;
		    if (crypto && crypto.randomBytes) {
		      nacl.setPRNG(function(x, n) {
		        var i, v = crypto.randomBytes(n);
		        for (i = 0; i < n; i++) x[i] = v[i];
		        cleanup(v);
		      });
		    }
		  }
		})();

		})(module.exports ? module.exports : (self.nacl = self.nacl || {})); 
	} (naclFast));
	return naclFast.exports;
}

var utils$5;
var hasRequiredUtils$5;

function requireUtils$5 () {
	if (hasRequiredUtils$5) return utils$5;
	hasRequiredUtils$5 = 1;
	// Copyright 2015 Joyent, Inc.

	utils$5 = {
		bufferSplit: bufferSplit,
		addRSAMissing: addRSAMissing,
		calculateDSAPublic: calculateDSAPublic,
		calculateED25519Public: calculateED25519Public,
		calculateX25519Public: calculateX25519Public,
		mpNormalize: mpNormalize,
		mpDenormalize: mpDenormalize,
		ecNormalize: ecNormalize,
		countZeros: countZeros,
		assertCompatible: assertCompatible,
		isCompatible: isCompatible,
		opensslKeyDeriv: opensslKeyDeriv,
		opensshCipherInfo: opensshCipherInfo,
		publicFromPrivateECDSA: publicFromPrivateECDSA,
		zeroPadToLength: zeroPadToLength,
		writeBitString: writeBitString,
		readBitString: readBitString,
		pbkdf2: pbkdf2
	};

	var assert = requireAssert();
	var Buffer = requireSafer().Buffer;
	var PrivateKey = requirePrivateKey();
	var Key = requireKey();
	var crypto = require$$0$5;
	var algs = requireAlgs();
	var asn1 = requireLib$9();

	var ec = requireEc();
	var jsbn = requireJsbn().BigInteger;
	var nacl = requireNaclFast();

	var MAX_CLASS_DEPTH = 3;

	function isCompatible(obj, klass, needVer) {
		if (obj === null || typeof (obj) !== 'object')
			return (false);
		if (needVer === undefined)
			needVer = klass.prototype._sshpkApiVersion;
		if (obj instanceof klass &&
		    klass.prototype._sshpkApiVersion[0] == needVer[0])
			return (true);
		var proto = Object.getPrototypeOf(obj);
		var depth = 0;
		while (proto.constructor.name !== klass.name) {
			proto = Object.getPrototypeOf(proto);
			if (!proto || ++depth > MAX_CLASS_DEPTH)
				return (false);
		}
		if (proto.constructor.name !== klass.name)
			return (false);
		var ver = proto._sshpkApiVersion;
		if (ver === undefined)
			ver = klass._oldVersionDetect(obj);
		if (ver[0] != needVer[0] || ver[1] < needVer[1])
			return (false);
		return (true);
	}

	function assertCompatible(obj, klass, needVer, name) {
		if (name === undefined)
			name = 'object';
		assert.ok(obj, name + ' must not be null');
		assert.object(obj, name + ' must be an object');
		if (needVer === undefined)
			needVer = klass.prototype._sshpkApiVersion;
		if (obj instanceof klass &&
		    klass.prototype._sshpkApiVersion[0] == needVer[0])
			return;
		var proto = Object.getPrototypeOf(obj);
		var depth = 0;
		while (proto.constructor.name !== klass.name) {
			proto = Object.getPrototypeOf(proto);
			assert.ok(proto && ++depth <= MAX_CLASS_DEPTH,
			    name + ' must be a ' + klass.name + ' instance');
		}
		assert.strictEqual(proto.constructor.name, klass.name,
		    name + ' must be a ' + klass.name + ' instance');
		var ver = proto._sshpkApiVersion;
		if (ver === undefined)
			ver = klass._oldVersionDetect(obj);
		assert.ok(ver[0] == needVer[0] && ver[1] >= needVer[1],
		    name + ' must be compatible with ' + klass.name + ' klass ' +
		    'version ' + needVer[0] + '.' + needVer[1]);
	}

	var CIPHER_LEN = {
		'des-ede3-cbc': { key: 24, iv: 8 },
		'aes-128-cbc': { key: 16, iv: 16 },
		'aes-256-cbc': { key: 32, iv: 16 }
	};
	var PKCS5_SALT_LEN = 8;

	function opensslKeyDeriv(cipher, salt, passphrase, count) {
		assert.buffer(salt, 'salt');
		assert.buffer(passphrase, 'passphrase');
		assert.number(count, 'iteration count');

		var clen = CIPHER_LEN[cipher];
		assert.object(clen, 'supported cipher');

		salt = salt.slice(0, PKCS5_SALT_LEN);

		var D, D_prev, bufs;
		var material = Buffer.alloc(0);
		while (material.length < clen.key + clen.iv) {
			bufs = [];
			if (D_prev)
				bufs.push(D_prev);
			bufs.push(passphrase);
			bufs.push(salt);
			D = Buffer.concat(bufs);
			for (var j = 0; j < count; ++j)
				D = crypto.createHash('md5').update(D).digest();
			material = Buffer.concat([material, D]);
			D_prev = D;
		}

		return ({
		    key: material.slice(0, clen.key),
		    iv: material.slice(clen.key, clen.key + clen.iv)
		});
	}

	/* See: RFC2898 */
	function pbkdf2(hashAlg, salt, iterations, size, passphrase) {
		var hkey = Buffer.alloc(salt.length + 4);
		salt.copy(hkey);

		var gen = 0, ts = [];
		var i = 1;
		while (gen < size) {
			var t = T(i++);
			gen += t.length;
			ts.push(t);
		}
		return (Buffer.concat(ts).slice(0, size));

		function T(I) {
			hkey.writeUInt32BE(I, hkey.length - 4);

			var hmac = crypto.createHmac(hashAlg, passphrase);
			hmac.update(hkey);

			var Ti = hmac.digest();
			var Uc = Ti;
			var c = 1;
			while (c++ < iterations) {
				hmac = crypto.createHmac(hashAlg, passphrase);
				hmac.update(Uc);
				Uc = hmac.digest();
				for (var x = 0; x < Ti.length; ++x)
					Ti[x] ^= Uc[x];
			}
			return (Ti);
		}
	}

	/* Count leading zero bits on a buffer */
	function countZeros(buf) {
		var o = 0, obit = 8;
		while (o < buf.length) {
			var mask = (1 << obit);
			if ((buf[o] & mask) === mask)
				break;
			obit--;
			if (obit < 0) {
				o++;
				obit = 8;
			}
		}
		return (o*8 + (8 - obit) - 1);
	}

	function bufferSplit(buf, chr) {
		assert.buffer(buf);
		assert.string(chr);

		var parts = [];
		var lastPart = 0;
		var matches = 0;
		for (var i = 0; i < buf.length; ++i) {
			if (buf[i] === chr.charCodeAt(matches))
				++matches;
			else if (buf[i] === chr.charCodeAt(0))
				matches = 1;
			else
				matches = 0;

			if (matches >= chr.length) {
				var newPart = i + 1;
				parts.push(buf.slice(lastPart, newPart - matches));
				lastPart = newPart;
				matches = 0;
			}
		}
		if (lastPart <= buf.length)
			parts.push(buf.slice(lastPart, buf.length));

		return (parts);
	}

	function ecNormalize(buf, addZero) {
		assert.buffer(buf);
		if (buf[0] === 0x00 && buf[1] === 0x04) {
			if (addZero)
				return (buf);
			return (buf.slice(1));
		} else if (buf[0] === 0x04) {
			if (!addZero)
				return (buf);
		} else {
			while (buf[0] === 0x00)
				buf = buf.slice(1);
			if (buf[0] === 0x02 || buf[0] === 0x03)
				throw (new Error('Compressed elliptic curve points ' +
				    'are not supported'));
			if (buf[0] !== 0x04)
				throw (new Error('Not a valid elliptic curve point'));
			if (!addZero)
				return (buf);
		}
		var b = Buffer.alloc(buf.length + 1);
		b[0] = 0x0;
		buf.copy(b, 1);
		return (b);
	}

	function readBitString(der, tag) {
		if (tag === undefined)
			tag = asn1.Ber.BitString;
		var buf = der.readString(tag, true);
		assert.strictEqual(buf[0], 0x00, 'bit strings with unused bits are ' +
		    'not supported (0x' + buf[0].toString(16) + ')');
		return (buf.slice(1));
	}

	function writeBitString(der, buf, tag) {
		if (tag === undefined)
			tag = asn1.Ber.BitString;
		var b = Buffer.alloc(buf.length + 1);
		b[0] = 0x00;
		buf.copy(b, 1);
		der.writeBuffer(b, tag);
	}

	function mpNormalize(buf) {
		assert.buffer(buf);
		while (buf.length > 1 && buf[0] === 0x00 && (buf[1] & 0x80) === 0x00)
			buf = buf.slice(1);
		if ((buf[0] & 0x80) === 0x80) {
			var b = Buffer.alloc(buf.length + 1);
			b[0] = 0x00;
			buf.copy(b, 1);
			buf = b;
		}
		return (buf);
	}

	function mpDenormalize(buf) {
		assert.buffer(buf);
		while (buf.length > 1 && buf[0] === 0x00)
			buf = buf.slice(1);
		return (buf);
	}

	function zeroPadToLength(buf, len) {
		assert.buffer(buf);
		assert.number(len);
		while (buf.length > len) {
			assert.equal(buf[0], 0x00);
			buf = buf.slice(1);
		}
		while (buf.length < len) {
			var b = Buffer.alloc(buf.length + 1);
			b[0] = 0x00;
			buf.copy(b, 1);
			buf = b;
		}
		return (buf);
	}

	function bigintToMpBuf(bigint) {
		var buf = Buffer.from(bigint.toByteArray());
		buf = mpNormalize(buf);
		return (buf);
	}

	function calculateDSAPublic(g, p, x) {
		assert.buffer(g);
		assert.buffer(p);
		assert.buffer(x);
		g = new jsbn(g);
		p = new jsbn(p);
		x = new jsbn(x);
		var y = g.modPow(x, p);
		var ybuf = bigintToMpBuf(y);
		return (ybuf);
	}

	function calculateED25519Public(k) {
		assert.buffer(k);

		var kp = nacl.sign.keyPair.fromSeed(new Uint8Array(k));
		return (Buffer.from(kp.publicKey));
	}

	function calculateX25519Public(k) {
		assert.buffer(k);

		var kp = nacl.box.keyPair.fromSeed(new Uint8Array(k));
		return (Buffer.from(kp.publicKey));
	}

	function addRSAMissing(key) {
		assert.object(key);
		assertCompatible(key, PrivateKey, [1, 1]);

		var d = new jsbn(key.part.d.data);
		var buf;

		if (!key.part.dmodp) {
			var p = new jsbn(key.part.p.data);
			var dmodp = d.mod(p.subtract(1));

			buf = bigintToMpBuf(dmodp);
			key.part.dmodp = {name: 'dmodp', data: buf};
			key.parts.push(key.part.dmodp);
		}
		if (!key.part.dmodq) {
			var q = new jsbn(key.part.q.data);
			var dmodq = d.mod(q.subtract(1));

			buf = bigintToMpBuf(dmodq);
			key.part.dmodq = {name: 'dmodq', data: buf};
			key.parts.push(key.part.dmodq);
		}
	}

	function publicFromPrivateECDSA(curveName, priv) {
		assert.string(curveName, 'curveName');
		assert.buffer(priv);
		var params = algs.curves[curveName];
		var p = new jsbn(params.p);
		var a = new jsbn(params.a);
		var b = new jsbn(params.b);
		var curve = new ec.ECCurveFp(p, a, b);
		var G = curve.decodePointHex(params.G.toString('hex'));

		var d = new jsbn(mpNormalize(priv));
		var pub = G.multiply(d);
		pub = Buffer.from(curve.encodePointHex(pub), 'hex');

		var parts = [];
		parts.push({name: 'curve', data: Buffer.from(curveName)});
		parts.push({name: 'Q', data: pub});

		var key = new Key({type: 'ecdsa', curve: curve, parts: parts});
		return (key);
	}

	function opensshCipherInfo(cipher) {
		var inf = {};
		switch (cipher) {
		case '3des-cbc':
			inf.keySize = 24;
			inf.blockSize = 8;
			inf.opensslName = 'des-ede3-cbc';
			break;
		case 'blowfish-cbc':
			inf.keySize = 16;
			inf.blockSize = 8;
			inf.opensslName = 'bf-cbc';
			break;
		case 'aes128-cbc':
		case 'aes128-ctr':
		case 'aes128-gcm@openssh.com':
			inf.keySize = 16;
			inf.blockSize = 16;
			inf.opensslName = 'aes-128-' + cipher.slice(7, 10);
			break;
		case 'aes192-cbc':
		case 'aes192-ctr':
		case 'aes192-gcm@openssh.com':
			inf.keySize = 24;
			inf.blockSize = 16;
			inf.opensslName = 'aes-192-' + cipher.slice(7, 10);
			break;
		case 'aes256-cbc':
		case 'aes256-ctr':
		case 'aes256-gcm@openssh.com':
			inf.keySize = 32;
			inf.blockSize = 16;
			inf.opensslName = 'aes-256-' + cipher.slice(7, 10);
			break;
		default:
			throw (new Error(
			    'Unsupported openssl cipher "' + cipher + '"'));
		}
		return (inf);
	}
	return utils$5;
}

var sshBuffer;
var hasRequiredSshBuffer;

function requireSshBuffer () {
	if (hasRequiredSshBuffer) return sshBuffer;
	hasRequiredSshBuffer = 1;
	// Copyright 2015 Joyent, Inc.

	sshBuffer = SSHBuffer;

	var assert = requireAssert();
	var Buffer = requireSafer().Buffer;

	function SSHBuffer(opts) {
		assert.object(opts, 'options');
		if (opts.buffer !== undefined)
			assert.buffer(opts.buffer, 'options.buffer');

		this._size = opts.buffer ? opts.buffer.length : 1024;
		this._buffer = opts.buffer || Buffer.alloc(this._size);
		this._offset = 0;
	}

	SSHBuffer.prototype.toBuffer = function () {
		return (this._buffer.slice(0, this._offset));
	};

	SSHBuffer.prototype.atEnd = function () {
		return (this._offset >= this._buffer.length);
	};

	SSHBuffer.prototype.remainder = function () {
		return (this._buffer.slice(this._offset));
	};

	SSHBuffer.prototype.skip = function (n) {
		this._offset += n;
	};

	SSHBuffer.prototype.expand = function () {
		this._size *= 2;
		var buf = Buffer.alloc(this._size);
		this._buffer.copy(buf, 0);
		this._buffer = buf;
	};

	SSHBuffer.prototype.readPart = function () {
		return ({data: this.readBuffer()});
	};

	SSHBuffer.prototype.readBuffer = function () {
		var len = this._buffer.readUInt32BE(this._offset);
		this._offset += 4;
		assert.ok(this._offset + len <= this._buffer.length,
		    'length out of bounds at +0x' + this._offset.toString(16) +
		    ' (data truncated?)');
		var buf = this._buffer.slice(this._offset, this._offset + len);
		this._offset += len;
		return (buf);
	};

	SSHBuffer.prototype.readString = function () {
		return (this.readBuffer().toString());
	};

	SSHBuffer.prototype.readCString = function () {
		var offset = this._offset;
		while (offset < this._buffer.length &&
		    this._buffer[offset] !== 0x00)
			offset++;
		assert.ok(offset < this._buffer.length, 'c string does not terminate');
		var str = this._buffer.slice(this._offset, offset).toString();
		this._offset = offset + 1;
		return (str);
	};

	SSHBuffer.prototype.readInt = function () {
		var v = this._buffer.readUInt32BE(this._offset);
		this._offset += 4;
		return (v);
	};

	SSHBuffer.prototype.readInt64 = function () {
		assert.ok(this._offset + 8 < this._buffer.length,
		    'buffer not long enough to read Int64');
		var v = this._buffer.slice(this._offset, this._offset + 8);
		this._offset += 8;
		return (v);
	};

	SSHBuffer.prototype.readChar = function () {
		var v = this._buffer[this._offset++];
		return (v);
	};

	SSHBuffer.prototype.writeBuffer = function (buf) {
		while (this._offset + 4 + buf.length > this._size)
			this.expand();
		this._buffer.writeUInt32BE(buf.length, this._offset);
		this._offset += 4;
		buf.copy(this._buffer, this._offset);
		this._offset += buf.length;
	};

	SSHBuffer.prototype.writeString = function (str) {
		this.writeBuffer(Buffer.from(str, 'utf8'));
	};

	SSHBuffer.prototype.writeCString = function (str) {
		while (this._offset + 1 + str.length > this._size)
			this.expand();
		this._buffer.write(str, this._offset);
		this._offset += str.length;
		this._buffer[this._offset++] = 0;
	};

	SSHBuffer.prototype.writeInt = function (v) {
		while (this._offset + 4 > this._size)
			this.expand();
		this._buffer.writeUInt32BE(v, this._offset);
		this._offset += 4;
	};

	SSHBuffer.prototype.writeInt64 = function (v) {
		assert.buffer(v, 'value');
		if (v.length > 8) {
			var lead = v.slice(0, v.length - 8);
			for (var i = 0; i < lead.length; ++i) {
				assert.strictEqual(lead[i], 0,
				    'must fit in 64 bits of precision');
			}
			v = v.slice(v.length - 8, v.length);
		}
		while (this._offset + 8 > this._size)
			this.expand();
		v.copy(this._buffer, this._offset);
		this._offset += 8;
	};

	SSHBuffer.prototype.writeChar = function (v) {
		while (this._offset + 1 > this._size)
			this.expand();
		this._buffer[this._offset++] = v;
	};

	SSHBuffer.prototype.writePart = function (p) {
		this.writeBuffer(p.data);
	};

	SSHBuffer.prototype.write = function (buf) {
		while (this._offset + buf.length > this._size)
			this.expand();
		buf.copy(this._buffer, this._offset);
		this._offset += buf.length;
	};
	return sshBuffer;
}

var signature;
var hasRequiredSignature;

function requireSignature () {
	if (hasRequiredSignature) return signature;
	hasRequiredSignature = 1;
	// Copyright 2015 Joyent, Inc.

	signature = Signature;

	var assert = requireAssert();
	var Buffer = requireSafer().Buffer;
	requireAlgs();
	var errs = requireErrors$1();
	var utils = requireUtils$5();
	var asn1 = requireLib$9();
	var SSHBuffer = requireSshBuffer();

	var InvalidAlgorithmError = errs.InvalidAlgorithmError;
	var SignatureParseError = errs.SignatureParseError;

	function Signature(opts) {
		assert.object(opts, 'options');
		assert.arrayOfObject(opts.parts, 'options.parts');
		assert.string(opts.type, 'options.type');

		var partLookup = {};
		for (var i = 0; i < opts.parts.length; ++i) {
			var part = opts.parts[i];
			partLookup[part.name] = part;
		}

		this.type = opts.type;
		this.hashAlgorithm = opts.hashAlgo;
		this.curve = opts.curve;
		this.parts = opts.parts;
		this.part = partLookup;
	}

	Signature.prototype.toBuffer = function (format) {
		if (format === undefined)
			format = 'asn1';
		assert.string(format, 'format');

		var buf;
		var stype = 'ssh-' + this.type;

		switch (this.type) {
		case 'rsa':
			switch (this.hashAlgorithm) {
			case 'sha256':
				stype = 'rsa-sha2-256';
				break;
			case 'sha512':
				stype = 'rsa-sha2-512';
				break;
			case 'sha1':
			case undefined:
				break;
			default:
				throw (new Error('SSH signature ' +
				    'format does not support hash ' +
				    'algorithm ' + this.hashAlgorithm));
			}
			if (format === 'ssh') {
				buf = new SSHBuffer({});
				buf.writeString(stype);
				buf.writePart(this.part.sig);
				return (buf.toBuffer());
			} else {
				return (this.part.sig.data);
			}

		case 'ed25519':
			if (format === 'ssh') {
				buf = new SSHBuffer({});
				buf.writeString(stype);
				buf.writePart(this.part.sig);
				return (buf.toBuffer());
			} else {
				return (this.part.sig.data);
			}

		case 'dsa':
		case 'ecdsa':
			var r, s;
			if (format === 'asn1') {
				var der = new asn1.BerWriter();
				der.startSequence();
				r = utils.mpNormalize(this.part.r.data);
				s = utils.mpNormalize(this.part.s.data);
				der.writeBuffer(r, asn1.Ber.Integer);
				der.writeBuffer(s, asn1.Ber.Integer);
				der.endSequence();
				return (der.buffer);
			} else if (format === 'ssh' && this.type === 'dsa') {
				buf = new SSHBuffer({});
				buf.writeString('ssh-dss');
				r = this.part.r.data;
				if (r.length > 20 && r[0] === 0x00)
					r = r.slice(1);
				s = this.part.s.data;
				if (s.length > 20 && s[0] === 0x00)
					s = s.slice(1);
				if ((this.hashAlgorithm &&
				    this.hashAlgorithm !== 'sha1') ||
				    r.length + s.length !== 40) {
					throw (new Error('OpenSSH only supports ' +
					    'DSA signatures with SHA1 hash'));
				}
				buf.writeBuffer(Buffer.concat([r, s]));
				return (buf.toBuffer());
			} else if (format === 'ssh' && this.type === 'ecdsa') {
				var inner = new SSHBuffer({});
				r = this.part.r.data;
				inner.writeBuffer(r);
				inner.writePart(this.part.s);

				buf = new SSHBuffer({});
				/* XXX: find a more proper way to do this? */
				var curve;
				if (r[0] === 0x00)
					r = r.slice(1);
				var sz = r.length * 8;
				if (sz === 256)
					curve = 'nistp256';
				else if (sz === 384)
					curve = 'nistp384';
				else if (sz === 528)
					curve = 'nistp521';
				buf.writeString('ecdsa-sha2-' + curve);
				buf.writeBuffer(inner.toBuffer());
				return (buf.toBuffer());
			}
			throw (new Error('Invalid signature format'));
		default:
			throw (new Error('Invalid signature data'));
		}
	};

	Signature.prototype.toString = function (format) {
		assert.optionalString(format, 'format');
		return (this.toBuffer(format).toString('base64'));
	};

	Signature.parse = function (data, type, format) {
		if (typeof (data) === 'string')
			data = Buffer.from(data, 'base64');
		assert.buffer(data, 'data');
		assert.string(format, 'format');
		assert.string(type, 'type');

		var opts = {};
		opts.type = type.toLowerCase();
		opts.parts = [];

		try {
			assert.ok(data.length > 0, 'signature must not be empty');
			switch (opts.type) {
			case 'rsa':
				return (parseOneNum(data, type, format, opts));
			case 'ed25519':
				return (parseOneNum(data, type, format, opts));

			case 'dsa':
			case 'ecdsa':
				if (format === 'asn1')
					return (parseDSAasn1(data, type, format, opts));
				else if (opts.type === 'dsa')
					return (parseDSA(data, type, format, opts));
				else
					return (parseECDSA(data, type, format, opts));

			default:
				throw (new InvalidAlgorithmError(type));
			}

		} catch (e) {
			if (e instanceof InvalidAlgorithmError)
				throw (e);
			throw (new SignatureParseError(type, format, e));
		}
	};

	function parseOneNum(data, type, format, opts) {
		if (format === 'ssh') {
			try {
				var buf = new SSHBuffer({buffer: data});
				var head = buf.readString();
			} catch (e) {
				/* fall through */
			}
			if (buf !== undefined) {
				var msg = 'SSH signature does not match expected ' +
				    'type (expected ' + type + ', got ' + head + ')';
				switch (head) {
				case 'ssh-rsa':
					assert.strictEqual(type, 'rsa', msg);
					opts.hashAlgo = 'sha1';
					break;
				case 'rsa-sha2-256':
					assert.strictEqual(type, 'rsa', msg);
					opts.hashAlgo = 'sha256';
					break;
				case 'rsa-sha2-512':
					assert.strictEqual(type, 'rsa', msg);
					opts.hashAlgo = 'sha512';
					break;
				case 'ssh-ed25519':
					assert.strictEqual(type, 'ed25519', msg);
					opts.hashAlgo = 'sha512';
					break;
				default:
					throw (new Error('Unknown SSH signature ' +
					    'type: ' + head));
				}
				var sig = buf.readPart();
				assert.ok(buf.atEnd(), 'extra trailing bytes');
				sig.name = 'sig';
				opts.parts.push(sig);
				return (new Signature(opts));
			}
		}
		opts.parts.push({name: 'sig', data: data});
		return (new Signature(opts));
	}

	function parseDSAasn1(data, type, format, opts) {
		var der = new asn1.BerReader(data);
		der.readSequence();
		var r = der.readString(asn1.Ber.Integer, true);
		var s = der.readString(asn1.Ber.Integer, true);

		opts.parts.push({name: 'r', data: utils.mpNormalize(r)});
		opts.parts.push({name: 's', data: utils.mpNormalize(s)});

		return (new Signature(opts));
	}

	function parseDSA(data, type, format, opts) {
		if (data.length != 40) {
			var buf = new SSHBuffer({buffer: data});
			var d = buf.readBuffer();
			if (d.toString('ascii') === 'ssh-dss')
				d = buf.readBuffer();
			assert.ok(buf.atEnd(), 'extra trailing bytes');
			assert.strictEqual(d.length, 40, 'invalid inner length');
			data = d;
		}
		opts.parts.push({name: 'r', data: data.slice(0, 20)});
		opts.parts.push({name: 's', data: data.slice(20, 40)});
		return (new Signature(opts));
	}

	function parseECDSA(data, type, format, opts) {
		var buf = new SSHBuffer({buffer: data});

		var r, s;
		var inner = buf.readBuffer();
		var stype = inner.toString('ascii');
		if (stype.slice(0, 6) === 'ecdsa-') {
			var parts = stype.split('-');
			assert.strictEqual(parts[0], 'ecdsa');
			assert.strictEqual(parts[1], 'sha2');
			opts.curve = parts[2];
			switch (opts.curve) {
			case 'nistp256':
				opts.hashAlgo = 'sha256';
				break;
			case 'nistp384':
				opts.hashAlgo = 'sha384';
				break;
			case 'nistp521':
				opts.hashAlgo = 'sha512';
				break;
			default:
				throw (new Error('Unsupported ECDSA curve: ' +
				    opts.curve));
			}
			inner = buf.readBuffer();
			assert.ok(buf.atEnd(), 'extra trailing bytes on outer');
			buf = new SSHBuffer({buffer: inner});
			r = buf.readPart();
		} else {
			r = {data: inner};
		}

		s = buf.readPart();
		assert.ok(buf.atEnd(), 'extra trailing bytes');

		r.name = 'r';
		s.name = 's';

		opts.parts.push(r);
		opts.parts.push(s);
		return (new Signature(opts));
	}

	Signature.isSignature = function (obj, ver) {
		return (utils.isCompatible(obj, Signature, ver));
	};

	/*
	 * API versions for Signature:
	 * [1,0] -- initial ver
	 * [2,0] -- support for rsa in full ssh format, compat with sshpk-agent
	 *          hashAlgorithm property
	 * [2,1] -- first tagged version
	 */
	Signature.prototype._sshpkApiVersion = [2, 1];

	Signature._oldVersionDetect = function (obj) {
		assert.func(obj.toBuffer);
		if (obj.hasOwnProperty('hashAlgorithm'))
			return ([2, 0]);
		return ([1, 0]);
	};
	return signature;
}

var eccJsbn = {};

var sec;
var hasRequiredSec;

function requireSec () {
	if (hasRequiredSec) return sec;
	hasRequiredSec = 1;
	// Named EC curves

	// Requires ec.js, jsbn.js, and jsbn2.js
	var BigInteger = requireJsbn().BigInteger;
	var ECCurveFp = requireEc().ECCurveFp;


	// ----------------
	// X9ECParameters

	// constructor
	function X9ECParameters(curve,g,n,h) {
	    this.curve = curve;
	    this.g = g;
	    this.n = n;
	    this.h = h;
	}

	function x9getCurve() {
	    return this.curve;
	}

	function x9getG() {
	    return this.g;
	}

	function x9getN() {
	    return this.n;
	}

	function x9getH() {
	    return this.h;
	}

	X9ECParameters.prototype.getCurve = x9getCurve;
	X9ECParameters.prototype.getG = x9getG;
	X9ECParameters.prototype.getN = x9getN;
	X9ECParameters.prototype.getH = x9getH;

	// ----------------
	// SECNamedCurves

	function fromHex(s) { return new BigInteger(s, 16); }

	function secp128r1() {
	    // p = 2^128 - 2^97 - 1
	    var p = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF");
	    var a = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC");
	    var b = fromHex("E87579C11079F43DD824993C2CEE5ED3");
	    //byte[] S = Hex.decode("000E0D4D696E6768756151750CC03A4473D03679");
	    var n = fromHex("FFFFFFFE0000000075A30D1B9038A115");
	    var h = BigInteger.ONE;
	    var curve = new ECCurveFp(p, a, b);
	    var G = curve.decodePointHex("04"
	                + "161FF7528B899B2D0C28607CA52C5B86"
			+ "CF5AC8395BAFEB13C02DA292DDED7A83");
	    return new X9ECParameters(curve, G, n, h);
	}

	function secp160k1() {
	    // p = 2^160 - 2^32 - 2^14 - 2^12 - 2^9 - 2^8 - 2^7 - 2^3 - 2^2 - 1
	    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73");
	    var a = BigInteger.ZERO;
	    var b = fromHex("7");
	    //byte[] S = null;
	    var n = fromHex("0100000000000000000001B8FA16DFAB9ACA16B6B3");
	    var h = BigInteger.ONE;
	    var curve = new ECCurveFp(p, a, b);
	    var G = curve.decodePointHex("04"
	                + "3B4C382CE37AA192A4019E763036F4F5DD4D7EBB"
	                + "938CF935318FDCED6BC28286531733C3F03C4FEE");
	    return new X9ECParameters(curve, G, n, h);
	}

	function secp160r1() {
	    // p = 2^160 - 2^31 - 1
	    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF");
	    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC");
	    var b = fromHex("1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45");
	    //byte[] S = Hex.decode("1053CDE42C14D696E67687561517533BF3F83345");
	    var n = fromHex("0100000000000000000001F4C8F927AED3CA752257");
	    var h = BigInteger.ONE;
	    var curve = new ECCurveFp(p, a, b);
	    var G = curve.decodePointHex("04"
			+ "4A96B5688EF573284664698968C38BB913CBFC82"
			+ "23A628553168947D59DCC912042351377AC5FB32");
	    return new X9ECParameters(curve, G, n, h);
	}

	function secp192k1() {
	    // p = 2^192 - 2^32 - 2^12 - 2^8 - 2^7 - 2^6 - 2^3 - 1
	    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37");
	    var a = BigInteger.ZERO;
	    var b = fromHex("3");
	    //byte[] S = null;
	    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D");
	    var h = BigInteger.ONE;
	    var curve = new ECCurveFp(p, a, b);
	    var G = curve.decodePointHex("04"
	                + "DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D"
	                + "9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D");
	    return new X9ECParameters(curve, G, n, h);
	}

	function secp192r1() {
	    // p = 2^192 - 2^64 - 1
	    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF");
	    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC");
	    var b = fromHex("64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1");
	    //byte[] S = Hex.decode("3045AE6FC8422F64ED579528D38120EAE12196D5");
	    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831");
	    var h = BigInteger.ONE;
	    var curve = new ECCurveFp(p, a, b);
	    var G = curve.decodePointHex("04"
	                + "188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012"
	                + "07192B95FFC8DA78631011ED6B24CDD573F977A11E794811");
	    return new X9ECParameters(curve, G, n, h);
	}

	function secp224r1() {
	    // p = 2^224 - 2^96 + 1
	    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001");
	    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE");
	    var b = fromHex("B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4");
	    //byte[] S = Hex.decode("BD71344799D5C7FCDC45B59FA3B9AB8F6A948BC5");
	    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D");
	    var h = BigInteger.ONE;
	    var curve = new ECCurveFp(p, a, b);
	    var G = curve.decodePointHex("04"
	                + "B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21"
	                + "BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34");
	    return new X9ECParameters(curve, G, n, h);
	}

	function secp256r1() {
	    // p = 2^224 (2^32 - 1) + 2^192 + 2^96 - 1
	    var p = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF");
	    var a = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC");
	    var b = fromHex("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B");
	    //byte[] S = Hex.decode("C49D360886E704936A6678E1139D26B7819F7E90");
	    var n = fromHex("FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551");
	    var h = BigInteger.ONE;
	    var curve = new ECCurveFp(p, a, b);
	    var G = curve.decodePointHex("04"
	                + "6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296"
			+ "4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5");
	    return new X9ECParameters(curve, G, n, h);
	}

	sec = {
	  "secp128r1":secp128r1,
	  "secp160k1":secp160k1,
	  "secp160r1":secp160r1,
	  "secp192k1":secp192k1,
	  "secp192r1":secp192r1,
	  "secp224r1":secp224r1,
	  "secp256r1":secp256r1
	};
	return sec;
}

var hasRequiredEccJsbn;

function requireEccJsbn () {
	if (hasRequiredEccJsbn) return eccJsbn;
	hasRequiredEccJsbn = 1;
	var crypto = require$$0$5;
	var BigInteger = requireJsbn().BigInteger;
	requireEc().ECPointFp;
	var Buffer = requireSafer().Buffer;
	eccJsbn.ECCurves = requireSec();

	// zero prepad
	function unstupid(hex,len)
	{
		return (hex.length >= len) ? hex : unstupid("0"+hex,len);
	}

	eccJsbn.ECKey = function(curve, key, isPublic)
	{
	  var priv;
		var c = curve();
		var n = c.getN();
	  var bytes = Math.floor(n.bitLength()/8);

	  if(key)
	  {
	    if(isPublic)
	    {
	      var curve = c.getCurve();
	//      var x = key.slice(1,bytes+1); // skip the 04 for uncompressed format
	//      var y = key.slice(bytes+1);
	//      this.P = new ECPointFp(curve,
	//        curve.fromBigInteger(new BigInteger(x.toString("hex"), 16)),
	//        curve.fromBigInteger(new BigInteger(y.toString("hex"), 16)));      
	      this.P = curve.decodePointHex(key.toString("hex"));
	    }else {
	      if(key.length != bytes) return false;
	      priv = new BigInteger(key.toString("hex"), 16);      
	    }
	  }else {
	    var n1 = n.subtract(BigInteger.ONE);
	    var r = new BigInteger(crypto.randomBytes(n.bitLength()));
	    priv = r.mod(n1).add(BigInteger.ONE);
	    this.P = c.getG().multiply(priv);
	  }
	  if(this.P)
	  {
	//  var pubhex = unstupid(this.P.getX().toBigInteger().toString(16),bytes*2)+unstupid(this.P.getY().toBigInteger().toString(16),bytes*2);
	//  this.PublicKey = Buffer.from("04"+pubhex,"hex");
	    this.PublicKey = Buffer.from(c.getCurve().encodeCompressedPointHex(this.P),"hex");
	  }
	  if(priv)
	  {
	    this.PrivateKey = Buffer.from(unstupid(priv.toString(16),bytes*2),"hex");
	    this.deriveSharedSecret = function(key)
	    {
	      if(!key || !key.P) return false;
	      var S = key.P.multiply(priv);
	      return Buffer.from(unstupid(S.getX().toBigInteger().toString(16),bytes*2),"hex");
	   };     
	  }
	};
	return eccJsbn;
}

var dhe;
var hasRequiredDhe;

function requireDhe () {
	if (hasRequiredDhe) return dhe;
	hasRequiredDhe = 1;
	// Copyright 2017 Joyent, Inc.

	dhe = {
		DiffieHellman: DiffieHellman,
		generateECDSA: generateECDSA,
		generateED25519: generateED25519
	};

	var assert = requireAssert();
	var crypto = require$$0$5;
	var Buffer = requireSafer().Buffer;
	var algs = requireAlgs();
	var utils = requireUtils$5();
	var nacl = requireNaclFast();

	var Key = requireKey();
	var PrivateKey = requirePrivateKey();

	var CRYPTO_HAVE_ECDH = (crypto.createECDH !== undefined);

	requireEccJsbn();
	var ec = requireEc();
	var jsbn = requireJsbn().BigInteger;

	function DiffieHellman(key) {
		utils.assertCompatible(key, Key, [1, 4], 'key');
		this._isPriv = PrivateKey.isPrivateKey(key, [1, 3]);
		this._algo = key.type;
		this._curve = key.curve;
		this._key = key;
		if (key.type === 'dsa') {
			if (!CRYPTO_HAVE_ECDH) {
				throw (new Error('Due to bugs in the node 0.10 ' +
				    'crypto API, node 0.12.x or later is required ' +
				    'to use DH'));
			}
			this._dh = crypto.createDiffieHellman(
			    key.part.p.data, undefined,
			    key.part.g.data, undefined);
			this._p = key.part.p;
			this._g = key.part.g;
			if (this._isPriv)
				this._dh.setPrivateKey(key.part.x.data);
			this._dh.setPublicKey(key.part.y.data);

		} else if (key.type === 'ecdsa') {
			if (!CRYPTO_HAVE_ECDH) {
				this._ecParams = new X9ECParameters(this._curve);

				if (this._isPriv) {
					this._priv = new ECPrivate(
					    this._ecParams, key.part.d.data);
				}
				return;
			}

			var curve = {
				'nistp256': 'prime256v1',
				'nistp384': 'secp384r1',
				'nistp521': 'secp521r1'
			}[key.curve];
			this._dh = crypto.createECDH(curve);
			if (typeof (this._dh) !== 'object' ||
			    typeof (this._dh.setPrivateKey) !== 'function') {
				CRYPTO_HAVE_ECDH = false;
				DiffieHellman.call(this, key);
				return;
			}
			if (this._isPriv)
				this._dh.setPrivateKey(key.part.d.data);
			this._dh.setPublicKey(key.part.Q.data);

		} else if (key.type === 'curve25519') {
			if (this._isPriv) {
				utils.assertCompatible(key, PrivateKey, [1, 5], 'key');
				this._priv = key.part.k.data;
			}

		} else {
			throw (new Error('DH not supported for ' + key.type + ' keys'));
		}
	}

	DiffieHellman.prototype.getPublicKey = function () {
		if (this._isPriv)
			return (this._key.toPublic());
		return (this._key);
	};

	DiffieHellman.prototype.getPrivateKey = function () {
		if (this._isPriv)
			return (this._key);
		else
			return (undefined);
	};
	DiffieHellman.prototype.getKey = DiffieHellman.prototype.getPrivateKey;

	DiffieHellman.prototype._keyCheck = function (pk, isPub) {
		assert.object(pk, 'key');
		if (!isPub)
			utils.assertCompatible(pk, PrivateKey, [1, 3], 'key');
		utils.assertCompatible(pk, Key, [1, 4], 'key');

		if (pk.type !== this._algo) {
			throw (new Error('A ' + pk.type + ' key cannot be used in ' +
			    this._algo + ' Diffie-Hellman'));
		}

		if (pk.curve !== this._curve) {
			throw (new Error('A key from the ' + pk.curve + ' curve ' +
			    'cannot be used with a ' + this._curve +
			    ' Diffie-Hellman'));
		}

		if (pk.type === 'dsa') {
			assert.deepEqual(pk.part.p, this._p,
			    'DSA key prime does not match');
			assert.deepEqual(pk.part.g, this._g,
			    'DSA key generator does not match');
		}
	};

	DiffieHellman.prototype.setKey = function (pk) {
		this._keyCheck(pk);

		if (pk.type === 'dsa') {
			this._dh.setPrivateKey(pk.part.x.data);
			this._dh.setPublicKey(pk.part.y.data);

		} else if (pk.type === 'ecdsa') {
			if (CRYPTO_HAVE_ECDH) {
				this._dh.setPrivateKey(pk.part.d.data);
				this._dh.setPublicKey(pk.part.Q.data);
			} else {
				this._priv = new ECPrivate(
				    this._ecParams, pk.part.d.data);
			}

		} else if (pk.type === 'curve25519') {
			var k = pk.part.k;
			if (!pk.part.k)
				k = pk.part.r;
			this._priv = k.data;
			if (this._priv[0] === 0x00)
				this._priv = this._priv.slice(1);
			this._priv = this._priv.slice(0, 32);
		}
		this._key = pk;
		this._isPriv = true;
	};
	DiffieHellman.prototype.setPrivateKey = DiffieHellman.prototype.setKey;

	DiffieHellman.prototype.computeSecret = function (otherpk) {
		this._keyCheck(otherpk, true);
		if (!this._isPriv)
			throw (new Error('DH exchange has not been initialized with ' +
			    'a private key yet'));

		var pub;
		if (this._algo === 'dsa') {
			return (this._dh.computeSecret(
			    otherpk.part.y.data));

		} else if (this._algo === 'ecdsa') {
			if (CRYPTO_HAVE_ECDH) {
				return (this._dh.computeSecret(
				    otherpk.part.Q.data));
			} else {
				pub = new ECPublic(
				    this._ecParams, otherpk.part.Q.data);
				return (this._priv.deriveSharedSecret(pub));
			}

		} else if (this._algo === 'curve25519') {
			pub = otherpk.part.A.data;
			while (pub[0] === 0x00 && pub.length > 32)
				pub = pub.slice(1);
			var priv = this._priv;
			assert.strictEqual(pub.length, 32);
			assert.strictEqual(priv.length, 32);

			var secret = nacl.box.before(new Uint8Array(pub),
			    new Uint8Array(priv));

			return (Buffer.from(secret));
		}

		throw (new Error('Invalid algorithm: ' + this._algo));
	};

	DiffieHellman.prototype.generateKey = function () {
		var parts = [];
		var priv, pub;
		if (this._algo === 'dsa') {
			this._dh.generateKeys();

			parts.push({name: 'p', data: this._p.data});
			parts.push({name: 'q', data: this._key.part.q.data});
			parts.push({name: 'g', data: this._g.data});
			parts.push({name: 'y', data: this._dh.getPublicKey()});
			parts.push({name: 'x', data: this._dh.getPrivateKey()});
			this._key = new PrivateKey({
				type: 'dsa',
				parts: parts
			});
			this._isPriv = true;
			return (this._key);

		} else if (this._algo === 'ecdsa') {
			if (CRYPTO_HAVE_ECDH) {
				this._dh.generateKeys();

				parts.push({name: 'curve',
				    data: Buffer.from(this._curve)});
				parts.push({name: 'Q', data: this._dh.getPublicKey()});
				parts.push({name: 'd', data: this._dh.getPrivateKey()});
				this._key = new PrivateKey({
					type: 'ecdsa',
					curve: this._curve,
					parts: parts
				});
				this._isPriv = true;
				return (this._key);

			} else {
				var n = this._ecParams.getN();
				var r = new jsbn(crypto.randomBytes(n.bitLength()));
				var n1 = n.subtract(jsbn.ONE);
				priv = r.mod(n1).add(jsbn.ONE);
				pub = this._ecParams.getG().multiply(priv);

				priv = Buffer.from(priv.toByteArray());
				pub = Buffer.from(this._ecParams.getCurve().
				    encodePointHex(pub), 'hex');

				this._priv = new ECPrivate(this._ecParams, priv);

				parts.push({name: 'curve',
				    data: Buffer.from(this._curve)});
				parts.push({name: 'Q', data: pub});
				parts.push({name: 'd', data: priv});

				this._key = new PrivateKey({
					type: 'ecdsa',
					curve: this._curve,
					parts: parts
				});
				this._isPriv = true;
				return (this._key);
			}

		} else if (this._algo === 'curve25519') {
			var pair = nacl.box.keyPair();
			priv = Buffer.from(pair.secretKey);
			pub = Buffer.from(pair.publicKey);
			priv = Buffer.concat([priv, pub]);
			assert.strictEqual(priv.length, 64);
			assert.strictEqual(pub.length, 32);

			parts.push({name: 'A', data: pub});
			parts.push({name: 'k', data: priv});
			this._key = new PrivateKey({
				type: 'curve25519',
				parts: parts
			});
			this._isPriv = true;
			return (this._key);
		}

		throw (new Error('Invalid algorithm: ' + this._algo));
	};
	DiffieHellman.prototype.generateKeys = DiffieHellman.prototype.generateKey;

	/* These are helpers for using ecc-jsbn (for node 0.10 compatibility). */

	function X9ECParameters(name) {
		var params = algs.curves[name];
		assert.object(params);

		var p = new jsbn(params.p);
		var a = new jsbn(params.a);
		var b = new jsbn(params.b);
		var n = new jsbn(params.n);
		var h = jsbn.ONE;
		var curve = new ec.ECCurveFp(p, a, b);
		var G = curve.decodePointHex(params.G.toString('hex'));

		this.curve = curve;
		this.g = G;
		this.n = n;
		this.h = h;
	}
	X9ECParameters.prototype.getCurve = function () { return (this.curve); };
	X9ECParameters.prototype.getG = function () { return (this.g); };
	X9ECParameters.prototype.getN = function () { return (this.n); };
	X9ECParameters.prototype.getH = function () { return (this.h); };

	function ECPublic(params, buffer) {
		this._params = params;
		if (buffer[0] === 0x00)
			buffer = buffer.slice(1);
		this._pub = params.getCurve().decodePointHex(buffer.toString('hex'));
	}

	function ECPrivate(params, buffer) {
		this._params = params;
		this._priv = new jsbn(utils.mpNormalize(buffer));
	}
	ECPrivate.prototype.deriveSharedSecret = function (pubKey) {
		assert.ok(pubKey instanceof ECPublic);
		var S = pubKey._pub.multiply(this._priv);
		return (Buffer.from(S.getX().toBigInteger().toByteArray()));
	};

	function generateED25519() {
		var pair = nacl.sign.keyPair();
		var priv = Buffer.from(pair.secretKey);
		var pub = Buffer.from(pair.publicKey);
		assert.strictEqual(priv.length, 64);
		assert.strictEqual(pub.length, 32);

		var parts = [];
		parts.push({name: 'A', data: pub});
		parts.push({name: 'k', data: priv.slice(0, 32)});
		var key = new PrivateKey({
			type: 'ed25519',
			parts: parts
		});
		return (key);
	}

	/* Generates a new ECDSA private key on a given curve. */
	function generateECDSA(curve) {
		var parts = [];
		var key;

		if (CRYPTO_HAVE_ECDH) {
			/*
			 * Node crypto doesn't expose key generation directly, but the
			 * ECDH instances can generate keys. It turns out this just
			 * calls into the OpenSSL generic key generator, and we can
			 * read its output happily without doing an actual DH. So we
			 * use that here.
			 */
			var osCurve = {
				'nistp256': 'prime256v1',
				'nistp384': 'secp384r1',
				'nistp521': 'secp521r1'
			}[curve];

			var dh = crypto.createECDH(osCurve);
			dh.generateKeys();

			parts.push({name: 'curve',
			    data: Buffer.from(curve)});
			parts.push({name: 'Q', data: dh.getPublicKey()});
			parts.push({name: 'd', data: dh.getPrivateKey()});

			key = new PrivateKey({
				type: 'ecdsa',
				curve: curve,
				parts: parts
			});
			return (key);
		} else {

			var ecParams = new X9ECParameters(curve);

			/* This algorithm taken from FIPS PUB 186-4 (section B.4.1) */
			var n = ecParams.getN();
			/*
			 * The crypto.randomBytes() function can only give us whole
			 * bytes, so taking a nod from X9.62, we round up.
			 */
			var cByteLen = Math.ceil((n.bitLength() + 64) / 8);
			var c = new jsbn(crypto.randomBytes(cByteLen));

			var n1 = n.subtract(jsbn.ONE);
			var priv = c.mod(n1).add(jsbn.ONE);
			var pub = ecParams.getG().multiply(priv);

			priv = Buffer.from(priv.toByteArray());
			pub = Buffer.from(ecParams.getCurve().
			    encodePointHex(pub), 'hex');

			parts.push({name: 'curve', data: Buffer.from(curve)});
			parts.push({name: 'Q', data: pub});
			parts.push({name: 'd', data: priv});

			key = new PrivateKey({
				type: 'ecdsa',
				curve: curve,
				parts: parts
			});
			return (key);
		}
	}
	return dhe;
}

var edCompat;
var hasRequiredEdCompat;

function requireEdCompat () {
	if (hasRequiredEdCompat) return edCompat;
	hasRequiredEdCompat = 1;
	// Copyright 2015 Joyent, Inc.

	edCompat = {
		Verifier: Verifier,
		Signer: Signer
	};

	var nacl = requireNaclFast();
	var stream = require$$0$6;
	var util = require$$1$2;
	var assert = requireAssert();
	var Buffer = requireSafer().Buffer;
	var Signature = requireSignature();

	function Verifier(key, hashAlgo) {
		if (hashAlgo.toLowerCase() !== 'sha512')
			throw (new Error('ED25519 only supports the use of ' +
			    'SHA-512 hashes'));

		this.key = key;
		this.chunks = [];

		stream.Writable.call(this, {});
	}
	util.inherits(Verifier, stream.Writable);

	Verifier.prototype._write = function (chunk, enc, cb) {
		this.chunks.push(chunk);
		cb();
	};

	Verifier.prototype.update = function (chunk) {
		if (typeof (chunk) === 'string')
			chunk = Buffer.from(chunk, 'binary');
		this.chunks.push(chunk);
	};

	Verifier.prototype.verify = function (signature, fmt) {
		var sig;
		if (Signature.isSignature(signature, [2, 0])) {
			if (signature.type !== 'ed25519')
				return (false);
			sig = signature.toBuffer('raw');

		} else if (typeof (signature) === 'string') {
			sig = Buffer.from(signature, 'base64');

		} else if (Signature.isSignature(signature, [1, 0])) {
			throw (new Error('signature was created by too old ' +
			    'a version of sshpk and cannot be verified'));
		}

		assert.buffer(sig);
		return (nacl.sign.detached.verify(
		    new Uint8Array(Buffer.concat(this.chunks)),
		    new Uint8Array(sig),
		    new Uint8Array(this.key.part.A.data)));
	};

	function Signer(key, hashAlgo) {
		if (hashAlgo.toLowerCase() !== 'sha512')
			throw (new Error('ED25519 only supports the use of ' +
			    'SHA-512 hashes'));

		this.key = key;
		this.chunks = [];

		stream.Writable.call(this, {});
	}
	util.inherits(Signer, stream.Writable);

	Signer.prototype._write = function (chunk, enc, cb) {
		this.chunks.push(chunk);
		cb();
	};

	Signer.prototype.update = function (chunk) {
		if (typeof (chunk) === 'string')
			chunk = Buffer.from(chunk, 'binary');
		this.chunks.push(chunk);
	};

	Signer.prototype.sign = function () {
		var sig = nacl.sign.detached(
		    new Uint8Array(Buffer.concat(this.chunks)),
		    new Uint8Array(Buffer.concat([
			this.key.part.k.data, this.key.part.A.data])));
		var sigBuf = Buffer.from(sig);
		var sigObj = Signature.parse(sigBuf, 'ed25519', 'raw');
		sigObj.hashAlgorithm = 'sha512';
		return (sigObj);
	};
	return edCompat;
}

var pkcs8;
var hasRequiredPkcs8;

function requirePkcs8 () {
	if (hasRequiredPkcs8) return pkcs8;
	hasRequiredPkcs8 = 1;
	// Copyright 2018 Joyent, Inc.

	pkcs8 = {
		read: read,
		readPkcs8: readPkcs8,
		write: write,
		writePkcs8: writePkcs8,
		pkcs8ToBuffer: pkcs8ToBuffer,

		readECDSACurve: readECDSACurve,
		writeECDSACurve: writeECDSACurve
	};

	var assert = requireAssert();
	var asn1 = requireLib$9();
	var Buffer = requireSafer().Buffer;
	var algs = requireAlgs();
	var utils = requireUtils$5();
	var Key = requireKey();
	var PrivateKey = requirePrivateKey();
	var pem = requirePem();

	function read(buf, options) {
		return (pem.read(buf, options, 'pkcs8'));
	}

	function write(key, options) {
		return (pem.write(key, options, 'pkcs8'));
	}

	/* Helper to read in a single mpint */
	function readMPInt(der, nm) {
		assert.strictEqual(der.peek(), asn1.Ber.Integer,
		    nm + ' is not an Integer');
		return (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));
	}

	function readPkcs8(alg, type, der) {
		/* Private keys in pkcs#8 format have a weird extra int */
		if (der.peek() === asn1.Ber.Integer) {
			assert.strictEqual(type, 'private',
			    'unexpected Integer at start of public key');
			der.readString(asn1.Ber.Integer, true);
		}

		der.readSequence();
		var next = der.offset + der.length;

		var oid = der.readOID();
		switch (oid) {
		case '1.2.840.113549.1.1.1':
			der._offset = next;
			if (type === 'public')
				return (readPkcs8RSAPublic(der));
			else
				return (readPkcs8RSAPrivate(der));
		case '1.2.840.10040.4.1':
			if (type === 'public')
				return (readPkcs8DSAPublic(der));
			else
				return (readPkcs8DSAPrivate(der));
		case '1.2.840.10045.2.1':
			if (type === 'public')
				return (readPkcs8ECDSAPublic(der));
			else
				return (readPkcs8ECDSAPrivate(der));
		case '1.3.101.112':
			if (type === 'public') {
				return (readPkcs8EdDSAPublic(der));
			} else {
				return (readPkcs8EdDSAPrivate(der));
			}
		case '1.3.101.110':
			if (type === 'public') {
				return (readPkcs8X25519Public(der));
			} else {
				return (readPkcs8X25519Private(der));
			}
		default:
			throw (new Error('Unknown key type OID ' + oid));
		}
	}

	function readPkcs8RSAPublic(der) {
		// bit string sequence
		der.readSequence(asn1.Ber.BitString);
		der.readByte();
		der.readSequence();

		// modulus
		var n = readMPInt(der, 'modulus');
		var e = readMPInt(der, 'exponent');

		// now, make the key
		var key = {
			type: 'rsa',
			source: der.originalInput,
			parts: [
				{ name: 'e', data: e },
				{ name: 'n', data: n }
			]
		};

		return (new Key(key));
	}

	function readPkcs8RSAPrivate(der) {
		der.readSequence(asn1.Ber.OctetString);
		der.readSequence();

		var ver = readMPInt(der, 'version');
		assert.equal(ver[0], 0x0, 'unknown RSA private key version');

		// modulus then public exponent
		var n = readMPInt(der, 'modulus');
		var e = readMPInt(der, 'public exponent');
		var d = readMPInt(der, 'private exponent');
		var p = readMPInt(der, 'prime1');
		var q = readMPInt(der, 'prime2');
		var dmodp = readMPInt(der, 'exponent1');
		var dmodq = readMPInt(der, 'exponent2');
		var iqmp = readMPInt(der, 'iqmp');

		// now, make the key
		var key = {
			type: 'rsa',
			parts: [
				{ name: 'n', data: n },
				{ name: 'e', data: e },
				{ name: 'd', data: d },
				{ name: 'iqmp', data: iqmp },
				{ name: 'p', data: p },
				{ name: 'q', data: q },
				{ name: 'dmodp', data: dmodp },
				{ name: 'dmodq', data: dmodq }
			]
		};

		return (new PrivateKey(key));
	}

	function readPkcs8DSAPublic(der) {
		der.readSequence();

		var p = readMPInt(der, 'p');
		var q = readMPInt(der, 'q');
		var g = readMPInt(der, 'g');

		// bit string sequence
		der.readSequence(asn1.Ber.BitString);
		der.readByte();

		var y = readMPInt(der, 'y');

		// now, make the key
		var key = {
			type: 'dsa',
			parts: [
				{ name: 'p', data: p },
				{ name: 'q', data: q },
				{ name: 'g', data: g },
				{ name: 'y', data: y }
			]
		};

		return (new Key(key));
	}

	function readPkcs8DSAPrivate(der) {
		der.readSequence();

		var p = readMPInt(der, 'p');
		var q = readMPInt(der, 'q');
		var g = readMPInt(der, 'g');

		der.readSequence(asn1.Ber.OctetString);
		var x = readMPInt(der, 'x');

		/* The pkcs#8 format does not include the public key */
		var y = utils.calculateDSAPublic(g, p, x);

		var key = {
			type: 'dsa',
			parts: [
				{ name: 'p', data: p },
				{ name: 'q', data: q },
				{ name: 'g', data: g },
				{ name: 'y', data: y },
				{ name: 'x', data: x }
			]
		};

		return (new PrivateKey(key));
	}

	function readECDSACurve(der) {
		var curveName, curveNames;
		var j, c, cd;

		if (der.peek() === asn1.Ber.OID) {
			var oid = der.readOID();

			curveNames = Object.keys(algs.curves);
			for (j = 0; j < curveNames.length; ++j) {
				c = curveNames[j];
				cd = algs.curves[c];
				if (cd.pkcs8oid === oid) {
					curveName = c;
					break;
				}
			}

		} else {
			// ECParameters sequence
			der.readSequence();
			var version = der.readString(asn1.Ber.Integer, true);
			assert.strictEqual(version[0], 1, 'ECDSA key not version 1');

			var curve = {};

			// FieldID sequence
			der.readSequence();
			var fieldTypeOid = der.readOID();
			assert.strictEqual(fieldTypeOid, '1.2.840.10045.1.1',
			    'ECDSA key is not from a prime-field');
			var p = curve.p = utils.mpNormalize(
			    der.readString(asn1.Ber.Integer, true));
			/*
			 * p always starts with a 1 bit, so count the zeros to get its
			 * real size.
			 */
			curve.size = p.length * 8 - utils.countZeros(p);

			// Curve sequence
			der.readSequence();
			curve.a = utils.mpNormalize(
			    der.readString(asn1.Ber.OctetString, true));
			curve.b = utils.mpNormalize(
			    der.readString(asn1.Ber.OctetString, true));
			if (der.peek() === asn1.Ber.BitString)
				curve.s = der.readString(asn1.Ber.BitString, true);

			// Combined Gx and Gy
			curve.G = der.readString(asn1.Ber.OctetString, true);
			assert.strictEqual(curve.G[0], 0x4,
			    'uncompressed G is required');

			curve.n = utils.mpNormalize(
			    der.readString(asn1.Ber.Integer, true));
			curve.h = utils.mpNormalize(
			    der.readString(asn1.Ber.Integer, true));
			assert.strictEqual(curve.h[0], 0x1, 'a cofactor=1 curve is ' +
			    'required');

			curveNames = Object.keys(algs.curves);
			var ks = Object.keys(curve);
			for (j = 0; j < curveNames.length; ++j) {
				c = curveNames[j];
				cd = algs.curves[c];
				var equal = true;
				for (var i = 0; i < ks.length; ++i) {
					var k = ks[i];
					if (cd[k] === undefined)
						continue;
					if (typeof (cd[k]) === 'object' &&
					    cd[k].equals !== undefined) {
						if (!cd[k].equals(curve[k])) {
							equal = false;
							break;
						}
					} else if (Buffer.isBuffer(cd[k])) {
						if (cd[k].toString('binary')
						    !== curve[k].toString('binary')) {
							equal = false;
							break;
						}
					} else {
						if (cd[k] !== curve[k]) {
							equal = false;
							break;
						}
					}
				}
				if (equal) {
					curveName = c;
					break;
				}
			}
		}
		return (curveName);
	}

	function readPkcs8ECDSAPrivate(der) {
		var curveName = readECDSACurve(der);
		assert.string(curveName, 'a known elliptic curve');

		der.readSequence(asn1.Ber.OctetString);
		der.readSequence();

		var version = readMPInt(der, 'version');
		assert.equal(version[0], 1, 'unknown version of ECDSA key');

		var d = der.readString(asn1.Ber.OctetString, true);
		var Q;

		if (der.peek() == 0xa0) {
			der.readSequence(0xa0);
			der._offset += der.length;
		}
		if (der.peek() == 0xa1) {
			der.readSequence(0xa1);
			Q = der.readString(asn1.Ber.BitString, true);
			Q = utils.ecNormalize(Q);
		}

		if (Q === undefined) {
			var pub = utils.publicFromPrivateECDSA(curveName, d);
			Q = pub.part.Q.data;
		}

		var key = {
			type: 'ecdsa',
			parts: [
				{ name: 'curve', data: Buffer.from(curveName) },
				{ name: 'Q', data: Q },
				{ name: 'd', data: d }
			]
		};

		return (new PrivateKey(key));
	}

	function readPkcs8ECDSAPublic(der) {
		var curveName = readECDSACurve(der);
		assert.string(curveName, 'a known elliptic curve');

		var Q = der.readString(asn1.Ber.BitString, true);
		Q = utils.ecNormalize(Q);

		var key = {
			type: 'ecdsa',
			parts: [
				{ name: 'curve', data: Buffer.from(curveName) },
				{ name: 'Q', data: Q }
			]
		};

		return (new Key(key));
	}

	function readPkcs8EdDSAPublic(der) {
		if (der.peek() === 0x00)
			der.readByte();

		var A = utils.readBitString(der);

		var key = {
			type: 'ed25519',
			parts: [
				{ name: 'A', data: utils.zeroPadToLength(A, 32) }
			]
		};

		return (new Key(key));
	}

	function readPkcs8X25519Public(der) {
		var A = utils.readBitString(der);

		var key = {
			type: 'curve25519',
			parts: [
				{ name: 'A', data: utils.zeroPadToLength(A, 32) }
			]
		};

		return (new Key(key));
	}

	function readPkcs8EdDSAPrivate(der) {
		if (der.peek() === 0x00)
			der.readByte();

		der.readSequence(asn1.Ber.OctetString);
		var k = der.readString(asn1.Ber.OctetString, true);
		k = utils.zeroPadToLength(k, 32);

		var A, tag;
		while ((tag = der.peek()) !== null) {
			if (tag === (asn1.Ber.Context | 1)) {
				A = utils.readBitString(der, tag);
			} else {
				der.readSequence(tag);
				der._offset += der.length;
			}
		}
		if (A === undefined)
			A = utils.calculateED25519Public(k);

		var key = {
			type: 'ed25519',
			parts: [
				{ name: 'A', data: utils.zeroPadToLength(A, 32) },
				{ name: 'k', data: utils.zeroPadToLength(k, 32) }
			]
		};

		return (new PrivateKey(key));
	}

	function readPkcs8X25519Private(der) {
		if (der.peek() === 0x00)
			der.readByte();

		der.readSequence(asn1.Ber.OctetString);
		var k = der.readString(asn1.Ber.OctetString, true);
		k = utils.zeroPadToLength(k, 32);

		var A = utils.calculateX25519Public(k);

		var key = {
			type: 'curve25519',
			parts: [
				{ name: 'A', data: utils.zeroPadToLength(A, 32) },
				{ name: 'k', data: utils.zeroPadToLength(k, 32) }
			]
		};

		return (new PrivateKey(key));
	}

	function pkcs8ToBuffer(key) {
		var der = new asn1.BerWriter();
		writePkcs8(der, key);
		return (der.buffer);
	}

	function writePkcs8(der, key) {
		der.startSequence();

		if (PrivateKey.isPrivateKey(key)) {
			var version = 0;
			if (key.type === 'ed25519')
				version = 1;
			var vbuf = Buffer.from([version]);
			der.writeBuffer(vbuf, asn1.Ber.Integer);
		}

		der.startSequence();
		switch (key.type) {
		case 'rsa':
			der.writeOID('1.2.840.113549.1.1.1');
			if (PrivateKey.isPrivateKey(key))
				writePkcs8RSAPrivate(key, der);
			else
				writePkcs8RSAPublic(key, der);
			break;
		case 'dsa':
			der.writeOID('1.2.840.10040.4.1');
			if (PrivateKey.isPrivateKey(key))
				writePkcs8DSAPrivate(key, der);
			else
				writePkcs8DSAPublic(key, der);
			break;
		case 'ecdsa':
			der.writeOID('1.2.840.10045.2.1');
			if (PrivateKey.isPrivateKey(key))
				writePkcs8ECDSAPrivate(key, der);
			else
				writePkcs8ECDSAPublic(key, der);
			break;
		case 'ed25519':
			der.writeOID('1.3.101.112');
			if (PrivateKey.isPrivateKey(key))
				writePkcs8EdDSAPrivate(key, der);
			else
				writePkcs8EdDSAPublic(key, der);
			break;
		default:
			throw (new Error('Unsupported key type: ' + key.type));
		}

		der.endSequence();
	}

	function writePkcs8RSAPrivate(key, der) {
		der.writeNull();
		der.endSequence();

		der.startSequence(asn1.Ber.OctetString);
		der.startSequence();

		var version = Buffer.from([0]);
		der.writeBuffer(version, asn1.Ber.Integer);

		der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.d.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
		if (!key.part.dmodp || !key.part.dmodq)
			utils.addRSAMissing(key);
		der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);

		der.endSequence();
		der.endSequence();
	}

	function writePkcs8RSAPublic(key, der) {
		der.writeNull();
		der.endSequence();

		der.startSequence(asn1.Ber.BitString);
		der.writeByte(0x00);

		der.startSequence();
		der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
		der.endSequence();

		der.endSequence();
	}

	function writePkcs8DSAPrivate(key, der) {
		der.startSequence();
		der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
		der.endSequence();

		der.endSequence();

		der.startSequence(asn1.Ber.OctetString);
		der.writeBuffer(key.part.x.data, asn1.Ber.Integer);
		der.endSequence();
	}

	function writePkcs8DSAPublic(key, der) {
		der.startSequence();
		der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
		der.endSequence();
		der.endSequence();

		der.startSequence(asn1.Ber.BitString);
		der.writeByte(0x00);
		der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
		der.endSequence();
	}

	function writeECDSACurve(key, der) {
		var curve = algs.curves[key.curve];
		if (curve.pkcs8oid) {
			/* This one has a name in pkcs#8, so just write the oid */
			der.writeOID(curve.pkcs8oid);

		} else {
			// ECParameters sequence
			der.startSequence();

			var version = Buffer.from([1]);
			der.writeBuffer(version, asn1.Ber.Integer);

			// FieldID sequence
			der.startSequence();
			der.writeOID('1.2.840.10045.1.1'); // prime-field
			der.writeBuffer(curve.p, asn1.Ber.Integer);
			der.endSequence();

			// Curve sequence
			der.startSequence();
			var a = curve.p;
			if (a[0] === 0x0)
				a = a.slice(1);
			der.writeBuffer(a, asn1.Ber.OctetString);
			der.writeBuffer(curve.b, asn1.Ber.OctetString);
			der.writeBuffer(curve.s, asn1.Ber.BitString);
			der.endSequence();

			der.writeBuffer(curve.G, asn1.Ber.OctetString);
			der.writeBuffer(curve.n, asn1.Ber.Integer);
			var h = curve.h;
			if (!h) {
				h = Buffer.from([1]);
			}
			der.writeBuffer(h, asn1.Ber.Integer);

			// ECParameters
			der.endSequence();
		}
	}

	function writePkcs8ECDSAPublic(key, der) {
		writeECDSACurve(key, der);
		der.endSequence();

		var Q = utils.ecNormalize(key.part.Q.data, true);
		der.writeBuffer(Q, asn1.Ber.BitString);
	}

	function writePkcs8ECDSAPrivate(key, der) {
		writeECDSACurve(key, der);
		der.endSequence();

		der.startSequence(asn1.Ber.OctetString);
		der.startSequence();

		var version = Buffer.from([1]);
		der.writeBuffer(version, asn1.Ber.Integer);

		der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);

		der.startSequence(0xa1);
		var Q = utils.ecNormalize(key.part.Q.data, true);
		der.writeBuffer(Q, asn1.Ber.BitString);
		der.endSequence();

		der.endSequence();
		der.endSequence();
	}

	function writePkcs8EdDSAPublic(key, der) {
		der.endSequence();

		utils.writeBitString(der, key.part.A.data);
	}

	function writePkcs8EdDSAPrivate(key, der) {
		der.endSequence();

		der.startSequence(asn1.Ber.OctetString);
		var k = utils.mpNormalize(key.part.k.data);
		/* RFCs call for storing exactly 32 bytes, so strip any leading zeros */
		while (k.length > 32 && k[0] === 0x00)
			k = k.slice(1);
		der.writeBuffer(k, asn1.Ber.OctetString);
		der.endSequence();

		utils.writeBitString(der, key.part.A.data, asn1.Ber.Context | 1);
	}
	return pkcs8;
}

var pkcs1;
var hasRequiredPkcs1;

function requirePkcs1 () {
	if (hasRequiredPkcs1) return pkcs1;
	hasRequiredPkcs1 = 1;
	// Copyright 2015 Joyent, Inc.

	pkcs1 = {
		read: read,
		readPkcs1: readPkcs1,
		write: write,
		writePkcs1: writePkcs1
	};

	var assert = requireAssert();
	var asn1 = requireLib$9();
	var Buffer = requireSafer().Buffer;
	var algs = requireAlgs();
	var utils = requireUtils$5();

	var Key = requireKey();
	var PrivateKey = requirePrivateKey();
	var pem = requirePem();

	var pkcs8 = requirePkcs8();
	var readECDSACurve = pkcs8.readECDSACurve;

	function read(buf, options) {
		return (pem.read(buf, options, 'pkcs1'));
	}

	function write(key, options) {
		return (pem.write(key, options, 'pkcs1'));
	}

	/* Helper to read in a single mpint */
	function readMPInt(der, nm) {
		assert.strictEqual(der.peek(), asn1.Ber.Integer,
		    nm + ' is not an Integer');
		return (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));
	}

	function readPkcs1(alg, type, der) {
		switch (alg) {
		case 'RSA':
			if (type === 'public')
				return (readPkcs1RSAPublic(der));
			else if (type === 'private')
				return (readPkcs1RSAPrivate(der));
			throw (new Error('Unknown key type: ' + type));
		case 'DSA':
			if (type === 'public')
				return (readPkcs1DSAPublic(der));
			else if (type === 'private')
				return (readPkcs1DSAPrivate(der));
			throw (new Error('Unknown key type: ' + type));
		case 'EC':
		case 'ECDSA':
			if (type === 'private')
				return (readPkcs1ECDSAPrivate(der));
			else if (type === 'public')
				return (readPkcs1ECDSAPublic(der));
			throw (new Error('Unknown key type: ' + type));
		case 'EDDSA':
		case 'EdDSA':
			if (type === 'private')
				return (readPkcs1EdDSAPrivate(der));
			throw (new Error(type + ' keys not supported with EdDSA'));
		default:
			throw (new Error('Unknown key algo: ' + alg));
		}
	}

	function readPkcs1RSAPublic(der) {
		// modulus and exponent
		var n = readMPInt(der, 'modulus');
		var e = readMPInt(der, 'exponent');

		// now, make the key
		var key = {
			type: 'rsa',
			parts: [
				{ name: 'e', data: e },
				{ name: 'n', data: n }
			]
		};

		return (new Key(key));
	}

	function readPkcs1RSAPrivate(der) {
		var version = readMPInt(der, 'version');
		assert.strictEqual(version[0], 0);

		// modulus then public exponent
		var n = readMPInt(der, 'modulus');
		var e = readMPInt(der, 'public exponent');
		var d = readMPInt(der, 'private exponent');
		var p = readMPInt(der, 'prime1');
		var q = readMPInt(der, 'prime2');
		var dmodp = readMPInt(der, 'exponent1');
		var dmodq = readMPInt(der, 'exponent2');
		var iqmp = readMPInt(der, 'iqmp');

		// now, make the key
		var key = {
			type: 'rsa',
			parts: [
				{ name: 'n', data: n },
				{ name: 'e', data: e },
				{ name: 'd', data: d },
				{ name: 'iqmp', data: iqmp },
				{ name: 'p', data: p },
				{ name: 'q', data: q },
				{ name: 'dmodp', data: dmodp },
				{ name: 'dmodq', data: dmodq }
			]
		};

		return (new PrivateKey(key));
	}

	function readPkcs1DSAPrivate(der) {
		var version = readMPInt(der, 'version');
		assert.strictEqual(version.readUInt8(0), 0);

		var p = readMPInt(der, 'p');
		var q = readMPInt(der, 'q');
		var g = readMPInt(der, 'g');
		var y = readMPInt(der, 'y');
		var x = readMPInt(der, 'x');

		// now, make the key
		var key = {
			type: 'dsa',
			parts: [
				{ name: 'p', data: p },
				{ name: 'q', data: q },
				{ name: 'g', data: g },
				{ name: 'y', data: y },
				{ name: 'x', data: x }
			]
		};

		return (new PrivateKey(key));
	}

	function readPkcs1EdDSAPrivate(der) {
		var version = readMPInt(der, 'version');
		assert.strictEqual(version.readUInt8(0), 1);

		// private key
		var k = der.readString(asn1.Ber.OctetString, true);

		der.readSequence(0xa0);
		var oid = der.readOID();
		assert.strictEqual(oid, '1.3.101.112', 'the ed25519 curve identifier');

		der.readSequence(0xa1);
		var A = utils.readBitString(der);

		var key = {
			type: 'ed25519',
			parts: [
				{ name: 'A', data: utils.zeroPadToLength(A, 32) },
				{ name: 'k', data: k }
			]
		};

		return (new PrivateKey(key));
	}

	function readPkcs1DSAPublic(der) {
		var y = readMPInt(der, 'y');
		var p = readMPInt(der, 'p');
		var q = readMPInt(der, 'q');
		var g = readMPInt(der, 'g');

		var key = {
			type: 'dsa',
			parts: [
				{ name: 'y', data: y },
				{ name: 'p', data: p },
				{ name: 'q', data: q },
				{ name: 'g', data: g }
			]
		};

		return (new Key(key));
	}

	function readPkcs1ECDSAPublic(der) {
		der.readSequence();

		var oid = der.readOID();
		assert.strictEqual(oid, '1.2.840.10045.2.1', 'must be ecPublicKey');

		var curveOid = der.readOID();

		var curve;
		var curves = Object.keys(algs.curves);
		for (var j = 0; j < curves.length; ++j) {
			var c = curves[j];
			var cd = algs.curves[c];
			if (cd.pkcs8oid === curveOid) {
				curve = c;
				break;
			}
		}
		assert.string(curve, 'a known ECDSA named curve');

		var Q = der.readString(asn1.Ber.BitString, true);
		Q = utils.ecNormalize(Q);

		var key = {
			type: 'ecdsa',
			parts: [
				{ name: 'curve', data: Buffer.from(curve) },
				{ name: 'Q', data: Q }
			]
		};

		return (new Key(key));
	}

	function readPkcs1ECDSAPrivate(der) {
		var version = readMPInt(der, 'version');
		assert.strictEqual(version.readUInt8(0), 1);

		// private key
		var d = der.readString(asn1.Ber.OctetString, true);

		der.readSequence(0xa0);
		var curve = readECDSACurve(der);
		assert.string(curve, 'a known elliptic curve');

		der.readSequence(0xa1);
		var Q = der.readString(asn1.Ber.BitString, true);
		Q = utils.ecNormalize(Q);

		var key = {
			type: 'ecdsa',
			parts: [
				{ name: 'curve', data: Buffer.from(curve) },
				{ name: 'Q', data: Q },
				{ name: 'd', data: d }
			]
		};

		return (new PrivateKey(key));
	}

	function writePkcs1(der, key) {
		der.startSequence();

		switch (key.type) {
		case 'rsa':
			if (PrivateKey.isPrivateKey(key))
				writePkcs1RSAPrivate(der, key);
			else
				writePkcs1RSAPublic(der, key);
			break;
		case 'dsa':
			if (PrivateKey.isPrivateKey(key))
				writePkcs1DSAPrivate(der, key);
			else
				writePkcs1DSAPublic(der, key);
			break;
		case 'ecdsa':
			if (PrivateKey.isPrivateKey(key))
				writePkcs1ECDSAPrivate(der, key);
			else
				writePkcs1ECDSAPublic(der, key);
			break;
		case 'ed25519':
			if (PrivateKey.isPrivateKey(key))
				writePkcs1EdDSAPrivate(der, key);
			else
				writePkcs1EdDSAPublic();
			break;
		default:
			throw (new Error('Unknown key algo: ' + key.type));
		}

		der.endSequence();
	}

	function writePkcs1RSAPublic(der, key) {
		der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
	}

	function writePkcs1RSAPrivate(der, key) {
		var ver = Buffer.from([0]);
		der.writeBuffer(ver, asn1.Ber.Integer);

		der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.d.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
		if (!key.part.dmodp || !key.part.dmodq)
			utils.addRSAMissing(key);
		der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);
	}

	function writePkcs1DSAPrivate(der, key) {
		var ver = Buffer.from([0]);
		der.writeBuffer(ver, asn1.Ber.Integer);

		der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.x.data, asn1.Ber.Integer);
	}

	function writePkcs1DSAPublic(der, key) {
		der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
	}

	function writePkcs1ECDSAPublic(der, key) {
		der.startSequence();

		der.writeOID('1.2.840.10045.2.1'); /* ecPublicKey */
		var curve = key.part.curve.data.toString();
		var curveOid = algs.curves[curve].pkcs8oid;
		assert.string(curveOid, 'a known ECDSA named curve');
		der.writeOID(curveOid);

		der.endSequence();

		var Q = utils.ecNormalize(key.part.Q.data, true);
		der.writeBuffer(Q, asn1.Ber.BitString);
	}

	function writePkcs1ECDSAPrivate(der, key) {
		var ver = Buffer.from([1]);
		der.writeBuffer(ver, asn1.Ber.Integer);

		der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);

		der.startSequence(0xa0);
		var curve = key.part.curve.data.toString();
		var curveOid = algs.curves[curve].pkcs8oid;
		assert.string(curveOid, 'a known ECDSA named curve');
		der.writeOID(curveOid);
		der.endSequence();

		der.startSequence(0xa1);
		var Q = utils.ecNormalize(key.part.Q.data, true);
		der.writeBuffer(Q, asn1.Ber.BitString);
		der.endSequence();
	}

	function writePkcs1EdDSAPrivate(der, key) {
		var ver = Buffer.from([1]);
		der.writeBuffer(ver, asn1.Ber.Integer);

		der.writeBuffer(key.part.k.data, asn1.Ber.OctetString);

		der.startSequence(0xa0);
		der.writeOID('1.3.101.112');
		der.endSequence();

		der.startSequence(0xa1);
		utils.writeBitString(der, key.part.A.data);
		der.endSequence();
	}

	function writePkcs1EdDSAPublic(der, key) {
		throw (new Error('Public keys are not supported for EdDSA PKCS#1'));
	}
	return pkcs1;
}

var rfc4253;
var hasRequiredRfc4253;

function requireRfc4253 () {
	if (hasRequiredRfc4253) return rfc4253;
	hasRequiredRfc4253 = 1;
	// Copyright 2015 Joyent, Inc.

	rfc4253 = {
		read: read.bind(undefined, false, undefined),
		readType: read.bind(undefined, false),
		write: write,
		/* semi-private api, used by sshpk-agent */
		readPartial: read.bind(undefined, true),

		/* shared with ssh format */
		readInternal: read,
		keyTypeToAlg: keyTypeToAlg,
		algToKeyType: algToKeyType
	};

	var assert = requireAssert();
	var Buffer = requireSafer().Buffer;
	var algs = requireAlgs();
	var utils = requireUtils$5();
	var Key = requireKey();
	var PrivateKey = requirePrivateKey();
	var SSHBuffer = requireSshBuffer();

	function algToKeyType(alg) {
		assert.string(alg);
		if (alg === 'ssh-dss')
			return ('dsa');
		else if (alg === 'ssh-rsa')
			return ('rsa');
		else if (alg === 'ssh-ed25519')
			return ('ed25519');
		else if (alg === 'ssh-curve25519')
			return ('curve25519');
		else if (alg.match(/^ecdsa-sha2-/))
			return ('ecdsa');
		else
			throw (new Error('Unknown algorithm ' + alg));
	}

	function keyTypeToAlg(key) {
		assert.object(key);
		if (key.type === 'dsa')
			return ('ssh-dss');
		else if (key.type === 'rsa')
			return ('ssh-rsa');
		else if (key.type === 'ed25519')
			return ('ssh-ed25519');
		else if (key.type === 'curve25519')
			return ('ssh-curve25519');
		else if (key.type === 'ecdsa')
			return ('ecdsa-sha2-' + key.part.curve.data.toString());
		else
			throw (new Error('Unknown key type ' + key.type));
	}

	function read(partial, type, buf, options) {
		if (typeof (buf) === 'string')
			buf = Buffer.from(buf);
		assert.buffer(buf, 'buf');

		var key = {};

		var parts = key.parts = [];
		var sshbuf = new SSHBuffer({buffer: buf});

		var alg = sshbuf.readString();
		assert.ok(!sshbuf.atEnd(), 'key must have at least one part');

		key.type = algToKeyType(alg);

		var partCount = algs.info[key.type].parts.length;
		if (type && type === 'private')
			partCount = algs.privInfo[key.type].parts.length;

		while (!sshbuf.atEnd() && parts.length < partCount)
			parts.push(sshbuf.readPart());
		while (!partial && !sshbuf.atEnd())
			parts.push(sshbuf.readPart());

		assert.ok(parts.length >= 1,
		    'key must have at least one part');
		assert.ok(partial || sshbuf.atEnd(),
		    'leftover bytes at end of key');

		var Constructor = Key;
		var algInfo = algs.info[key.type];
		if (type === 'private' || algInfo.parts.length !== parts.length) {
			algInfo = algs.privInfo[key.type];
			Constructor = PrivateKey;
		}
		assert.strictEqual(algInfo.parts.length, parts.length);

		if (key.type === 'ecdsa') {
			var res = /^ecdsa-sha2-(.+)$/.exec(alg);
			assert.ok(res !== null);
			assert.strictEqual(res[1], parts[0].data.toString());
		}

		var normalized = true;
		for (var i = 0; i < algInfo.parts.length; ++i) {
			var p = parts[i];
			p.name = algInfo.parts[i];
			/*
			 * OpenSSH stores ed25519 "private" keys as seed + public key
			 * concat'd together (k followed by A). We want to keep them
			 * separate for other formats that don't do this.
			 */
			if (key.type === 'ed25519' && p.name === 'k')
				p.data = p.data.slice(0, 32);

			if (p.name !== 'curve' && algInfo.normalize !== false) {
				var nd;
				if (key.type === 'ed25519') {
					nd = utils.zeroPadToLength(p.data, 32);
				} else {
					nd = utils.mpNormalize(p.data);
				}
				if (nd.toString('binary') !==
				    p.data.toString('binary')) {
					p.data = nd;
					normalized = false;
				}
			}
		}

		if (normalized)
			key._rfc4253Cache = sshbuf.toBuffer();

		if (partial && typeof (partial) === 'object') {
			partial.remainder = sshbuf.remainder();
			partial.consumed = sshbuf._offset;
		}

		return (new Constructor(key));
	}

	function write(key, options) {
		assert.object(key);

		var alg = keyTypeToAlg(key);
		var i;

		var algInfo = algs.info[key.type];
		if (PrivateKey.isPrivateKey(key))
			algInfo = algs.privInfo[key.type];
		var parts = algInfo.parts;

		var buf = new SSHBuffer({});

		buf.writeString(alg);

		for (i = 0; i < parts.length; ++i) {
			var data = key.part[parts[i]].data;
			if (algInfo.normalize !== false) {
				if (key.type === 'ed25519')
					data = utils.zeroPadToLength(data, 32);
				else
					data = utils.mpNormalize(data);
			}
			if (key.type === 'ed25519' && parts[i] === 'k')
				data = Buffer.concat([data, key.part.A.data]);
			buf.writeBuffer(data);
		}

		return (buf.toBuffer());
	}
	return rfc4253;
}

var bcryptPbkdf;
var hasRequiredBcryptPbkdf;

function requireBcryptPbkdf () {
	if (hasRequiredBcryptPbkdf) return bcryptPbkdf;
	hasRequiredBcryptPbkdf = 1;

	var crypto_hash_sha512 = requireNaclFast().lowlevel.crypto_hash;

	/*
	 * This file is a 1:1 port from the OpenBSD blowfish.c and bcrypt_pbkdf.c. As a
	 * result, it retains the original copyright and license. The two files are
	 * under slightly different (but compatible) licenses, and are here combined in
	 * one file.
	 *
	 * Credit for the actual porting work goes to:
	 *  Devi Mandiri <me@devi.web.id>
	 */

	/*
	 * The Blowfish portions are under the following license:
	 *
	 * Blowfish block cipher for OpenBSD
	 * Copyright 1997 Niels Provos <provos@physnet.uni-hamburg.de>
	 * All rights reserved.
	 *
	 * Implementation advice by David Mazieres <dm@lcs.mit.edu>.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 * 1. Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright
	 *    notice, this list of conditions and the following disclaimer in the
	 *    documentation and/or other materials provided with the distribution.
	 * 3. The name of the author may not be used to endorse or promote products
	 *    derived from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
	 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
	 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
	 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
	 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
	 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	/*
	 * The bcrypt_pbkdf portions are under the following license:
	 *
	 * Copyright (c) 2013 Ted Unangst <tedu@openbsd.org>
	 *
	 * Permission to use, copy, modify, and distribute this software for any
	 * purpose with or without fee is hereby granted, provided that the above
	 * copyright notice and this permission notice appear in all copies.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
	 */

	/*
	 * Performance improvements (Javascript-specific):
	 *
	 * Copyright 2016, Joyent Inc
	 * Author: Alex Wilson <alex.wilson@joyent.com>
	 *
	 * Permission to use, copy, modify, and distribute this software for any
	 * purpose with or without fee is hereby granted, provided that the above
	 * copyright notice and this permission notice appear in all copies.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
	 */

	// Ported from OpenBSD bcrypt_pbkdf.c v1.9

	var BLF_J = 0;

	var Blowfish = function() {
	  this.S = [
	    new Uint32Array([
	      0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7,
	      0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99,
	      0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16,
	      0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e,
	      0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee,
	      0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013,
	      0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef,
	      0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e,
	      0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60,
	      0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440,
	      0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce,
	      0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a,
	      0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e,
	      0xafd6ba33, 0x6c24cf5c, 0x7a325381, 0x28958677,
	      0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193,
	      0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032,
	      0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88,
	      0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239,
	      0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e,
	      0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0,
	      0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3,
	      0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98,
	      0xa1f1651d, 0x39af0176, 0x66ca593e, 0x82430e88,
	      0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe,
	      0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6,
	      0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d,
	      0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b,
	      0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7,
	      0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba,
	      0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,
	      0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f,
	      0x6dfc511f, 0x9b30952c, 0xcc814544, 0xaf5ebd09,
	      0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3,
	      0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb,
	      0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279,
	      0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8,
	      0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab,
	      0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82,
	      0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db,
	      0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573,
	      0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0,
	      0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b,
	      0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790,
	      0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8,
	      0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4,
	      0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0,
	      0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7,
	      0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c,
	      0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad,
	      0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1,
	      0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299,
	      0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9,
	      0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477,
	      0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf,
	      0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49,
	      0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af,
	      0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa,
	      0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5,
	      0x83260376, 0x6295cfa9, 0x11c81968, 0x4e734a41,
	      0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,
	      0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400,
	      0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915,
	      0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664,
	      0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a]),
	    new Uint32Array([
	      0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623,
	      0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266,
	      0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1,
	      0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e,
	      0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6,
	      0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,
	      0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e,
	      0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1,
	      0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737,
	      0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8,
	      0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff,
	      0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd,
	      0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701,
	      0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7,
	      0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41,
	      0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331,
	      0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf,
	      0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af,
	      0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e,
	      0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87,
	      0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c,
	      0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2,
	      0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16,
	      0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd,
	      0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b,
	      0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509,
	      0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e,
	      0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3,
	      0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f,
	      0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a,
	      0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4,
	      0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960,
	      0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66,
	      0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28,
	      0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802,
	      0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84,
	      0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510,
	      0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf,
	      0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14,
	      0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e,
	      0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50,
	      0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7,
	      0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8,
	      0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281,
	      0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99,
	      0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696,
	      0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128,
	      0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73,
	      0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0,
	      0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0,
	      0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105,
	      0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250,
	      0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3,
	      0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285,
	      0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00,
	      0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,
	      0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb,
	      0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e,
	      0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735,
	      0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc,
	      0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9,
	      0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340,
	      0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20,
	      0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7]),
	    new Uint32Array([
	      0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934,
	      0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068,
	      0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af,
	      0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840,
	      0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45,
	      0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504,
	      0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a,
	      0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb,
	      0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee,
	      0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6,
	      0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42,
	      0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,
	      0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2,
	      0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb,
	      0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527,
	      0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b,
	      0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33,
	      0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c,
	      0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3,
	      0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc,
	      0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17,
	      0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564,
	      0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b,
	      0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115,
	      0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922,
	      0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728,
	      0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0,
	      0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e,
	      0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37,
	      0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d,
	      0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804,
	      0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b,
	      0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3,
	      0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb,
	      0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d,
	      0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c,
	      0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350,
	      0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9,
	      0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a,
	      0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe,
	      0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d,
	      0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc,
	      0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f,
	      0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61,
	      0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2,
	      0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9,
	      0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2,
	      0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c,
	      0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e,
	      0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633,
	      0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10,
	      0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169,
	      0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52,
	      0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027,
	      0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5,
	      0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62,
	      0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634,
	      0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76,
	      0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24,
	      0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc,
	      0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4,
	      0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c,
	      0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837,
	      0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0]),
	    new Uint32Array([
	      0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b,
	      0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe,
	      0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b,
	      0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4,
	      0x5748ab2f, 0xbc946e79, 0xc6a376d2, 0x6549c2c8,
	      0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6,
	      0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304,
	      0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22,
	      0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4,
	      0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6,
	      0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9,
	      0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59,
	      0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593,
	      0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51,
	      0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28,
	      0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c,
	      0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b,
	      0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,
	      0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c,
	      0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd,
	      0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a,
	      0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319,
	      0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb,
	      0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f,
	      0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991,
	      0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32,
	      0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680,
	      0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166,
	      0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae,
	      0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb,
	      0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5,
	      0x72eacea8, 0xfa6484bb, 0x8d6612ae, 0xbf3c6f47,
	      0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370,
	      0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d,
	      0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84,
	      0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048,
	      0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8,
	      0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd,
	      0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9,
	      0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7,
	      0x1a908749, 0xd44fbd9a, 0xd0dadecb, 0xd50ada38,
	      0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f,
	      0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c,
	      0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525,
	      0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1,
	      0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442,
	      0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964,
	      0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,
	      0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8,
	      0xdf359f8d, 0x9b992f2e, 0xe60b6f47, 0x0fe3f11d,
	      0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f,
	      0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299,
	      0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02,
	      0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc,
	      0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614,
	      0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a,
	      0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6,
	      0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b,
	      0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0,
	      0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060,
	      0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e,
	      0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9,
	      0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f,
	      0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6])
	    ];
	  this.P = new Uint32Array([
	    0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344,
	    0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89,
	    0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c,
	    0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917,
	    0x9216d5d9, 0x8979fb1b]);
	};

	function F(S, x8, i) {
	  return (((S[0][x8[i+3]] +
	            S[1][x8[i+2]]) ^
	            S[2][x8[i+1]]) +
	            S[3][x8[i]]);
	}
	Blowfish.prototype.encipher = function(x, x8) {
	  if (x8 === undefined) {
	    x8 = new Uint8Array(x.buffer);
	    if (x.byteOffset !== 0)
	      x8 = x8.subarray(x.byteOffset);
	  }
	  x[0] ^= this.P[0];
	  for (var i = 1; i < 16; i += 2) {
	    x[1] ^= F(this.S, x8, 0) ^ this.P[i];
	    x[0] ^= F(this.S, x8, 4) ^ this.P[i+1];
	  }
	  var t = x[0];
	  x[0] = x[1] ^ this.P[17];
	  x[1] = t;
	};

	Blowfish.prototype.decipher = function(x) {
	  var x8 = new Uint8Array(x.buffer);
	  if (x.byteOffset !== 0)
	    x8 = x8.subarray(x.byteOffset);
	  x[0] ^= this.P[17];
	  for (var i = 16; i > 0; i -= 2) {
	    x[1] ^= F(this.S, x8, 0) ^ this.P[i];
	    x[0] ^= F(this.S, x8, 4) ^ this.P[i-1];
	  }
	  var t = x[0];
	  x[0] = x[1] ^ this.P[0];
	  x[1] = t;
	};

	function stream2word(data, databytes){
	  var i, temp = 0;
	  for (i = 0; i < 4; i++, BLF_J++) {
	    if (BLF_J >= databytes) BLF_J = 0;
	    temp = (temp << 8) | data[BLF_J];
	  }
	  return temp;
	}
	Blowfish.prototype.expand0state = function(key, keybytes) {
	  var d = new Uint32Array(2), i, k;
	  var d8 = new Uint8Array(d.buffer);

	  for (i = 0, BLF_J = 0; i < 18; i++) {
	    this.P[i] ^= stream2word(key, keybytes);
	  }
	  BLF_J = 0;

	  for (i = 0; i < 18; i += 2) {
	    this.encipher(d, d8);
	    this.P[i]   = d[0];
	    this.P[i+1] = d[1];
	  }

	  for (i = 0; i < 4; i++) {
	    for (k = 0; k < 256; k += 2) {
	      this.encipher(d, d8);
	      this.S[i][k]   = d[0];
	      this.S[i][k+1] = d[1];
	    }
	  }
	};

	Blowfish.prototype.expandstate = function(data, databytes, key, keybytes) {
	  var d = new Uint32Array(2), i, k;

	  for (i = 0, BLF_J = 0; i < 18; i++) {
	    this.P[i] ^= stream2word(key, keybytes);
	  }

	  for (i = 0, BLF_J = 0; i < 18; i += 2) {
	    d[0] ^= stream2word(data, databytes);
	    d[1] ^= stream2word(data, databytes);
	    this.encipher(d);
	    this.P[i]   = d[0];
	    this.P[i+1] = d[1];
	  }

	  for (i = 0; i < 4; i++) {
	    for (k = 0; k < 256; k += 2) {
	      d[0] ^= stream2word(data, databytes);
	      d[1] ^= stream2word(data, databytes);
	      this.encipher(d);
	      this.S[i][k]   = d[0];
	      this.S[i][k+1] = d[1];
	    }
	  }
	  BLF_J = 0;
	};

	Blowfish.prototype.enc = function(data, blocks) {
	  for (var i = 0; i < blocks; i++) {
	    this.encipher(data.subarray(i*2));
	  }
	};

	Blowfish.prototype.dec = function(data, blocks) {
	  for (var i = 0; i < blocks; i++) {
	    this.decipher(data.subarray(i*2));
	  }
	};

	var BCRYPT_BLOCKS = 8,
	    BCRYPT_HASHSIZE = 32;

	function bcrypt_hash(sha2pass, sha2salt, out) {
	  var state = new Blowfish(),
	      cdata = new Uint32Array(BCRYPT_BLOCKS), i,
	      ciphertext = new Uint8Array([79,120,121,99,104,114,111,109,97,116,105,
	            99,66,108,111,119,102,105,115,104,83,119,97,116,68,121,110,97,109,
	            105,116,101]); //"OxychromaticBlowfishSwatDynamite"

	  state.expandstate(sha2salt, 64, sha2pass, 64);
	  for (i = 0; i < 64; i++) {
	    state.expand0state(sha2salt, 64);
	    state.expand0state(sha2pass, 64);
	  }

	  for (i = 0; i < BCRYPT_BLOCKS; i++)
	    cdata[i] = stream2word(ciphertext, ciphertext.byteLength);
	  for (i = 0; i < 64; i++)
	    state.enc(cdata, cdata.byteLength / 8);

	  for (i = 0; i < BCRYPT_BLOCKS; i++) {
	    out[4*i+3] = cdata[i] >>> 24;
	    out[4*i+2] = cdata[i] >>> 16;
	    out[4*i+1] = cdata[i] >>> 8;
	    out[4*i+0] = cdata[i];
	  }
	}
	function bcrypt_pbkdf(pass, passlen, salt, saltlen, key, keylen, rounds) {
	  var sha2pass = new Uint8Array(64),
	      sha2salt = new Uint8Array(64),
	      out = new Uint8Array(BCRYPT_HASHSIZE),
	      tmpout = new Uint8Array(BCRYPT_HASHSIZE),
	      countsalt = new Uint8Array(saltlen+4),
	      i, j, amt, stride, dest, count,
	      origkeylen = keylen;

	  if (rounds < 1)
	    return -1;
	  if (passlen === 0 || saltlen === 0 || keylen === 0 ||
	      keylen > (out.byteLength * out.byteLength) || saltlen > (1<<20))
	    return -1;

	  stride = Math.floor((keylen + out.byteLength - 1) / out.byteLength);
	  amt = Math.floor((keylen + stride - 1) / stride);

	  for (i = 0; i < saltlen; i++)
	    countsalt[i] = salt[i];

	  crypto_hash_sha512(sha2pass, pass, passlen);

	  for (count = 1; keylen > 0; count++) {
	    countsalt[saltlen+0] = count >>> 24;
	    countsalt[saltlen+1] = count >>> 16;
	    countsalt[saltlen+2] = count >>>  8;
	    countsalt[saltlen+3] = count;

	    crypto_hash_sha512(sha2salt, countsalt, saltlen + 4);
	    bcrypt_hash(sha2pass, sha2salt, tmpout);
	    for (i = out.byteLength; i--;)
	      out[i] = tmpout[i];

	    for (i = 1; i < rounds; i++) {
	      crypto_hash_sha512(sha2salt, tmpout, tmpout.byteLength);
	      bcrypt_hash(sha2pass, sha2salt, tmpout);
	      for (j = 0; j < out.byteLength; j++)
	        out[j] ^= tmpout[j];
	    }

	    amt = Math.min(amt, keylen);
	    for (i = 0; i < amt; i++) {
	      dest = i * stride + (count - 1);
	      if (dest >= origkeylen)
	        break;
	      key[dest] = out[i];
	    }
	    keylen -= i;
	  }

	  return 0;
	}
	bcryptPbkdf = {
	      BLOCKS: BCRYPT_BLOCKS,
	      HASHSIZE: BCRYPT_HASHSIZE,
	      hash: bcrypt_hash,
	      pbkdf: bcrypt_pbkdf
	};
	return bcryptPbkdf;
}

var sshPrivate;
var hasRequiredSshPrivate;

function requireSshPrivate () {
	if (hasRequiredSshPrivate) return sshPrivate;
	hasRequiredSshPrivate = 1;
	// Copyright 2015 Joyent, Inc.

	sshPrivate = {
		read: read,
		readSSHPrivate: readSSHPrivate,
		write: write
	};

	var assert = requireAssert();
	requireLib$9();
	var Buffer = requireSafer().Buffer;
	requireAlgs();
	var utils = requireUtils$5();
	var crypto = require$$0$5;

	requireKey();
	var PrivateKey = requirePrivateKey();
	var pem = requirePem();
	var rfc4253 = requireRfc4253();
	var SSHBuffer = requireSshBuffer();
	var errors = requireErrors$1();

	var bcrypt;

	function read(buf, options) {
		return (pem.read(buf, options));
	}

	var MAGIC = 'openssh-key-v1';

	function readSSHPrivate(type, buf, options) {
		buf = new SSHBuffer({buffer: buf});

		var magic = buf.readCString();
		assert.strictEqual(magic, MAGIC, 'bad magic string');

		var cipher = buf.readString();
		var kdf = buf.readString();
		var kdfOpts = buf.readBuffer();

		var nkeys = buf.readInt();
		if (nkeys !== 1) {
			throw (new Error('OpenSSH-format key file contains ' +
			    'multiple keys: this is unsupported.'));
		}

		var pubKey = buf.readBuffer();

		if (type === 'public') {
			assert.ok(buf.atEnd(), 'excess bytes left after key');
			return (rfc4253.read(pubKey));
		}

		var privKeyBlob = buf.readBuffer();
		assert.ok(buf.atEnd(), 'excess bytes left after key');

		var kdfOptsBuf = new SSHBuffer({ buffer: kdfOpts });
		switch (kdf) {
		case 'none':
			if (cipher !== 'none') {
				throw (new Error('OpenSSH-format key uses KDF "none" ' +
				     'but specifies a cipher other than "none"'));
			}
			break;
		case 'bcrypt':
			var salt = kdfOptsBuf.readBuffer();
			var rounds = kdfOptsBuf.readInt();
			var cinf = utils.opensshCipherInfo(cipher);
			if (bcrypt === undefined) {
				bcrypt = requireBcryptPbkdf();
			}

			if (typeof (options.passphrase) === 'string') {
				options.passphrase = Buffer.from(options.passphrase,
				    'utf-8');
			}
			if (!Buffer.isBuffer(options.passphrase)) {
				throw (new errors.KeyEncryptedError(
				    options.filename, 'OpenSSH'));
			}

			var pass = new Uint8Array(options.passphrase);
			var salti = new Uint8Array(salt);
			/* Use the pbkdf to derive both the key and the IV. */
			var out = new Uint8Array(cinf.keySize + cinf.blockSize);
			var res = bcrypt.pbkdf(pass, pass.length, salti, salti.length,
			    out, out.length, rounds);
			if (res !== 0) {
				throw (new Error('bcrypt_pbkdf function returned ' +
				    'failure, parameters invalid'));
			}
			out = Buffer.from(out);
			var ckey = out.slice(0, cinf.keySize);
			var iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);
			var cipherStream = crypto.createDecipheriv(cinf.opensslName,
			    ckey, iv);
			cipherStream.setAutoPadding(false);
			var chunk, chunks = [];
			cipherStream.once('error', function (e) {
				if (e.toString().indexOf('bad decrypt') !== -1) {
					throw (new Error('Incorrect passphrase ' +
					    'supplied, could not decrypt key'));
				}
				throw (e);
			});
			cipherStream.write(privKeyBlob);
			cipherStream.end();
			while ((chunk = cipherStream.read()) !== null)
				chunks.push(chunk);
			privKeyBlob = Buffer.concat(chunks);
			break;
		default:
			throw (new Error(
			    'OpenSSH-format key uses unknown KDF "' + kdf + '"'));
		}

		buf = new SSHBuffer({buffer: privKeyBlob});

		var checkInt1 = buf.readInt();
		var checkInt2 = buf.readInt();
		if (checkInt1 !== checkInt2) {
			throw (new Error('Incorrect passphrase supplied, could not ' +
			    'decrypt key'));
		}

		var ret = {};
		var key = rfc4253.readInternal(ret, 'private', buf.remainder());

		buf.skip(ret.consumed);

		var comment = buf.readString();
		key.comment = comment;

		return (key);
	}

	function write(key, options) {
		var pubKey;
		if (PrivateKey.isPrivateKey(key))
			pubKey = key.toPublic();
		else
			pubKey = key;

		var cipher = 'none';
		var kdf = 'none';
		var kdfopts = Buffer.alloc(0);
		var cinf = { blockSize: 8 };
		var passphrase;
		if (options !== undefined) {
			passphrase = options.passphrase;
			if (typeof (passphrase) === 'string')
				passphrase = Buffer.from(passphrase, 'utf-8');
			if (passphrase !== undefined) {
				assert.buffer(passphrase, 'options.passphrase');
				assert.optionalString(options.cipher, 'options.cipher');
				cipher = options.cipher;
				if (cipher === undefined)
					cipher = 'aes128-ctr';
				cinf = utils.opensshCipherInfo(cipher);
				kdf = 'bcrypt';
			}
		}

		var privBuf;
		if (PrivateKey.isPrivateKey(key)) {
			privBuf = new SSHBuffer({});
			var checkInt = crypto.randomBytes(4).readUInt32BE(0);
			privBuf.writeInt(checkInt);
			privBuf.writeInt(checkInt);
			privBuf.write(key.toBuffer('rfc4253'));
			privBuf.writeString(key.comment || '');

			var n = 1;
			while (privBuf._offset % cinf.blockSize !== 0)
				privBuf.writeChar(n++);
			privBuf = privBuf.toBuffer();
		}

		switch (kdf) {
		case 'none':
			break;
		case 'bcrypt':
			var salt = crypto.randomBytes(16);
			var rounds = 16;
			var kdfssh = new SSHBuffer({});
			kdfssh.writeBuffer(salt);
			kdfssh.writeInt(rounds);
			kdfopts = kdfssh.toBuffer();

			if (bcrypt === undefined) {
				bcrypt = requireBcryptPbkdf();
			}
			var pass = new Uint8Array(passphrase);
			var salti = new Uint8Array(salt);
			/* Use the pbkdf to derive both the key and the IV. */
			var out = new Uint8Array(cinf.keySize + cinf.blockSize);
			var res = bcrypt.pbkdf(pass, pass.length, salti, salti.length,
			    out, out.length, rounds);
			if (res !== 0) {
				throw (new Error('bcrypt_pbkdf function returned ' +
				    'failure, parameters invalid'));
			}
			out = Buffer.from(out);
			var ckey = out.slice(0, cinf.keySize);
			var iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);

			var cipherStream = crypto.createCipheriv(cinf.opensslName,
			    ckey, iv);
			cipherStream.setAutoPadding(false);
			var chunk, chunks = [];
			cipherStream.once('error', function (e) {
				throw (e);
			});
			cipherStream.write(privBuf);
			cipherStream.end();
			while ((chunk = cipherStream.read()) !== null)
				chunks.push(chunk);
			privBuf = Buffer.concat(chunks);
			break;
		default:
			throw (new Error('Unsupported kdf ' + kdf));
		}

		var buf = new SSHBuffer({});

		buf.writeCString(MAGIC);
		buf.writeString(cipher);	/* cipher */
		buf.writeString(kdf);		/* kdf */
		buf.writeBuffer(kdfopts);	/* kdfoptions */

		buf.writeInt(1);		/* nkeys */
		buf.writeBuffer(pubKey.toBuffer('rfc4253'));

		if (privBuf)
			buf.writeBuffer(privBuf);

		buf = buf.toBuffer();

		var header;
		if (PrivateKey.isPrivateKey(key))
			header = 'OPENSSH PRIVATE KEY';
		else
			header = 'OPENSSH PUBLIC KEY';

		var tmp = buf.toString('base64');
		var len = tmp.length + (tmp.length / 70) +
		    18 + 16 + header.length*2 + 10;
		buf = Buffer.alloc(len);
		var o = 0;
		o += buf.write('-----BEGIN ' + header + '-----\n', o);
		for (var i = 0; i < tmp.length; ) {
			var limit = i + 70;
			if (limit > tmp.length)
				limit = tmp.length;
			o += buf.write(tmp.slice(i, limit), o);
			buf[o++] = 10;
			i = limit;
		}
		o += buf.write('-----END ' + header + '-----\n', o);

		return (buf.slice(0, o));
	}
	return sshPrivate;
}

var pem;
var hasRequiredPem;

function requirePem () {
	if (hasRequiredPem) return pem;
	hasRequiredPem = 1;
	// Copyright 2018 Joyent, Inc.

	pem = {
		read: read,
		write: write
	};

	var assert = requireAssert();
	var asn1 = requireLib$9();
	var crypto = require$$0$5;
	var Buffer = requireSafer().Buffer;
	requireAlgs();
	var utils = requireUtils$5();
	var Key = requireKey();
	var PrivateKey = requirePrivateKey();

	var pkcs1 = requirePkcs1();
	var pkcs8 = requirePkcs8();
	var sshpriv = requireSshPrivate();
	var rfc4253 = requireRfc4253();

	var errors = requireErrors$1();

	var OID_PBES2 = '1.2.840.113549.1.5.13';
	var OID_PBKDF2 = '1.2.840.113549.1.5.12';

	var OID_TO_CIPHER = {
		'1.2.840.113549.3.7': '3des-cbc',
		'2.16.840.1.101.3.4.1.2': 'aes128-cbc',
		'2.16.840.1.101.3.4.1.42': 'aes256-cbc'
	};
	Object.keys(OID_TO_CIPHER).forEach(function (k) {
	});

	var OID_TO_HASH = {
		'1.2.840.113549.2.7': 'sha1',
		'1.2.840.113549.2.9': 'sha256',
		'1.2.840.113549.2.11': 'sha512'
	};
	Object.keys(OID_TO_HASH).forEach(function (k) {
	});

	/*
	 * For reading we support both PKCS#1 and PKCS#8. If we find a private key,
	 * we just take the public component of it and use that.
	 */
	function read(buf, options, forceType) {
		var input = buf;
		if (typeof (buf) !== 'string') {
			assert.buffer(buf, 'buf');
			buf = buf.toString('ascii');
		}

		var lines = buf.trim().split(/[\r\n]+/g);

		var m;
		var si = -1;
		while (!m && si < lines.length) {
			m = lines[++si].match(/*JSSTYLED*/
			    /[-]+[ ]*BEGIN ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
		}
		assert.ok(m, 'invalid PEM header');

		var m2;
		var ei = lines.length;
		while (!m2 && ei > 0) {
			m2 = lines[--ei].match(/*JSSTYLED*/
			    /[-]+[ ]*END ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
		}
		assert.ok(m2, 'invalid PEM footer');

		/* Begin and end banners must match key type */
		assert.equal(m[2], m2[2]);
		var type = m[2].toLowerCase();

		var alg;
		if (m[1]) {
			/* They also must match algorithms, if given */
			assert.equal(m[1], m2[1], 'PEM header and footer mismatch');
			alg = m[1].trim();
		}

		lines = lines.slice(si, ei + 1);

		var headers = {};
		while (true) {
			lines = lines.slice(1);
			m = lines[0].match(/*JSSTYLED*/
			    /^([A-Za-z0-9-]+): (.+)$/);
			if (!m)
				break;
			headers[m[1].toLowerCase()] = m[2];
		}

		/* Chop off the first and last lines */
		lines = lines.slice(0, -1).join('');
		buf = Buffer.from(lines, 'base64');

		var cipher, key, iv;
		if (headers['proc-type']) {
			var parts = headers['proc-type'].split(',');
			if (parts[0] === '4' && parts[1] === 'ENCRYPTED') {
				if (typeof (options.passphrase) === 'string') {
					options.passphrase = Buffer.from(
					    options.passphrase, 'utf-8');
				}
				if (!Buffer.isBuffer(options.passphrase)) {
					throw (new errors.KeyEncryptedError(
					    options.filename, 'PEM'));
				} else {
					parts = headers['dek-info'].split(',');
					assert.ok(parts.length === 2);
					cipher = parts[0].toLowerCase();
					iv = Buffer.from(parts[1], 'hex');
					key = utils.opensslKeyDeriv(cipher, iv,
					    options.passphrase, 1).key;
				}
			}
		}

		if (alg && alg.toLowerCase() === 'encrypted') {
			var eder = new asn1.BerReader(buf);
			var pbesEnd;
			eder.readSequence();

			eder.readSequence();
			pbesEnd = eder.offset + eder.length;

			var method = eder.readOID();
			if (method !== OID_PBES2) {
				throw (new Error('Unsupported PEM/PKCS8 encryption ' +
				    'scheme: ' + method));
			}

			eder.readSequence();	/* PBES2-params */

			eder.readSequence();	/* keyDerivationFunc */
			var kdfEnd = eder.offset + eder.length;
			var kdfOid = eder.readOID();
			if (kdfOid !== OID_PBKDF2)
				throw (new Error('Unsupported PBES2 KDF: ' + kdfOid));
			eder.readSequence();
			var salt = eder.readString(asn1.Ber.OctetString, true);
			var iterations = eder.readInt();
			var hashAlg = 'sha1';
			if (eder.offset < kdfEnd) {
				eder.readSequence();
				var hashAlgOid = eder.readOID();
				hashAlg = OID_TO_HASH[hashAlgOid];
				if (hashAlg === undefined) {
					throw (new Error('Unsupported PBKDF2 hash: ' +
					    hashAlgOid));
				}
			}
			eder._offset = kdfEnd;

			eder.readSequence();	/* encryptionScheme */
			var cipherOid = eder.readOID();
			cipher = OID_TO_CIPHER[cipherOid];
			if (cipher === undefined) {
				throw (new Error('Unsupported PBES2 cipher: ' +
				    cipherOid));
			}
			iv = eder.readString(asn1.Ber.OctetString, true);

			eder._offset = pbesEnd;
			buf = eder.readString(asn1.Ber.OctetString, true);

			if (typeof (options.passphrase) === 'string') {
				options.passphrase = Buffer.from(
				    options.passphrase, 'utf-8');
			}
			if (!Buffer.isBuffer(options.passphrase)) {
				throw (new errors.KeyEncryptedError(
				    options.filename, 'PEM'));
			}

			var cinfo = utils.opensshCipherInfo(cipher);

			cipher = cinfo.opensslName;
			key = utils.pbkdf2(hashAlg, salt, iterations, cinfo.keySize,
			    options.passphrase);
			alg = undefined;
		}

		if (cipher && key && iv) {
			var cipherStream = crypto.createDecipheriv(cipher, key, iv);
			var chunk, chunks = [];
			cipherStream.once('error', function (e) {
				if (e.toString().indexOf('bad decrypt') !== -1) {
					throw (new Error('Incorrect passphrase ' +
					    'supplied, could not decrypt key'));
				}
				throw (e);
			});
			cipherStream.write(buf);
			cipherStream.end();
			while ((chunk = cipherStream.read()) !== null)
				chunks.push(chunk);
			buf = Buffer.concat(chunks);
		}

		/* The new OpenSSH internal format abuses PEM headers */
		if (alg && alg.toLowerCase() === 'openssh')
			return (sshpriv.readSSHPrivate(type, buf, options));
		if (alg && alg.toLowerCase() === 'ssh2')
			return (rfc4253.readType(type, buf, options));

		var der = new asn1.BerReader(buf);
		der.originalInput = input;

		/*
		 * All of the PEM file types start with a sequence tag, so chop it
		 * off here
		 */
		der.readSequence();

		/* PKCS#1 type keys name an algorithm in the banner explicitly */
		if (alg) {
			if (forceType)
				assert.strictEqual(forceType, 'pkcs1');
			return (pkcs1.readPkcs1(alg, type, der));
		} else {
			if (forceType)
				assert.strictEqual(forceType, 'pkcs8');
			return (pkcs8.readPkcs8(alg, type, der));
		}
	}

	function write(key, options, type) {
		assert.object(key);

		var alg = {
		    'ecdsa': 'EC',
		    'rsa': 'RSA',
		    'dsa': 'DSA',
		    'ed25519': 'EdDSA'
		}[key.type];
		var header;

		var der = new asn1.BerWriter();

		if (PrivateKey.isPrivateKey(key)) {
			if (type && type === 'pkcs8') {
				header = 'PRIVATE KEY';
				pkcs8.writePkcs8(der, key);
			} else {
				if (type)
					assert.strictEqual(type, 'pkcs1');
				header = alg + ' PRIVATE KEY';
				pkcs1.writePkcs1(der, key);
			}

		} else if (Key.isKey(key)) {
			if (type && type === 'pkcs1') {
				header = alg + ' PUBLIC KEY';
				pkcs1.writePkcs1(der, key);
			} else {
				if (type)
					assert.strictEqual(type, 'pkcs8');
				header = 'PUBLIC KEY';
				pkcs8.writePkcs8(der, key);
			}

		} else {
			throw (new Error('key is not a Key or PrivateKey'));
		}

		var tmp = der.buffer.toString('base64');
		var len = tmp.length + (tmp.length / 64) +
		    18 + 16 + header.length*2 + 10;
		var buf = Buffer.alloc(len);
		var o = 0;
		o += buf.write('-----BEGIN ' + header + '-----\n', o);
		for (var i = 0; i < tmp.length; ) {
			var limit = i + 64;
			if (limit > tmp.length)
				limit = tmp.length;
			o += buf.write(tmp.slice(i, limit), o);
			buf[o++] = 10;
			i = limit;
		}
		o += buf.write('-----END ' + header + '-----\n', o);

		return (buf.slice(0, o));
	}
	return pem;
}

var ssh;
var hasRequiredSsh;

function requireSsh () {
	if (hasRequiredSsh) return ssh;
	hasRequiredSsh = 1;
	// Copyright 2015 Joyent, Inc.

	ssh = {
		read: read,
		write: write
	};

	var assert = requireAssert();
	var Buffer = requireSafer().Buffer;
	var rfc4253 = requireRfc4253();
	requireUtils$5();
	var Key = requireKey();
	requirePrivateKey();

	requireSshPrivate();

	/*JSSTYLED*/
	var SSHKEY_RE = /^([a-z0-9-]+)[ \t]+([a-zA-Z0-9+\/]+[=]*)([ \t]+([^ \t][^\n]*[\n]*)?)?$/;
	/*JSSTYLED*/
	var SSHKEY_RE2 = /^([a-z0-9-]+)[ \t\n]+([a-zA-Z0-9+\/][a-zA-Z0-9+\/ \t\n=]*)([^a-zA-Z0-9+\/ \t\n=].*)?$/;

	function read(buf, options) {
		if (typeof (buf) !== 'string') {
			assert.buffer(buf, 'buf');
			buf = buf.toString('ascii');
		}

		var trimmed = buf.trim().replace(/[\\\r]/g, '');
		var m = trimmed.match(SSHKEY_RE);
		if (!m)
			m = trimmed.match(SSHKEY_RE2);
		assert.ok(m, 'key must match regex');

		var type = rfc4253.algToKeyType(m[1]);
		var kbuf = Buffer.from(m[2], 'base64');

		/*
		 * This is a bit tricky. If we managed to parse the key and locate the
		 * key comment with the regex, then do a non-partial read and assert
		 * that we have consumed all bytes. If we couldn't locate the key
		 * comment, though, there may be whitespace shenanigans going on that
		 * have conjoined the comment to the rest of the key. We do a partial
		 * read in this case to try to make the best out of a sorry situation.
		 */
		var key;
		var ret = {};
		if (m[4]) {
			try {
				key = rfc4253.read(kbuf);

			} catch (e) {
				m = trimmed.match(SSHKEY_RE2);
				assert.ok(m, 'key must match regex');
				kbuf = Buffer.from(m[2], 'base64');
				key = rfc4253.readInternal(ret, 'public', kbuf);
			}
		} else {
			key = rfc4253.readInternal(ret, 'public', kbuf);
		}

		assert.strictEqual(type, key.type);

		if (m[4] && m[4].length > 0) {
			key.comment = m[4];

		} else if (ret.consumed) {
			/*
			 * Now the magic: trying to recover the key comment when it's
			 * gotten conjoined to the key or otherwise shenanigan'd.
			 *
			 * Work out how much base64 we used, then drop all non-base64
			 * chars from the beginning up to this point in the the string.
			 * Then offset in this and try to make up for missing = chars.
			 */
			var data = m[2] + (m[3] ? m[3] : '');
			var realOffset = Math.ceil(ret.consumed / 3) * 4;
			data = data.slice(0, realOffset - 2). /*JSSTYLED*/
			    replace(/[^a-zA-Z0-9+\/=]/g, '') +
			    data.slice(realOffset - 2);

			var padding = ret.consumed % 3;
			if (padding > 0 &&
			    data.slice(realOffset - 1, realOffset) !== '=')
				realOffset--;
			while (data.slice(realOffset, realOffset + 1) === '=')
				realOffset++;

			/* Finally, grab what we think is the comment & clean it up. */
			var trailer = data.slice(realOffset);
			trailer = trailer.replace(/[\r\n]/g, ' ').
			    replace(/^\s+/, '');
			if (trailer.match(/^[a-zA-Z0-9]/))
				key.comment = trailer;
		}

		return (key);
	}

	function write(key, options) {
		assert.object(key);
		if (!Key.isKey(key))
			throw (new Error('Must be a public key'));

		var parts = [];
		var alg = rfc4253.keyTypeToAlg(key);
		parts.push(alg);

		var buf = rfc4253.write(key);
		parts.push(buf.toString('base64'));

		if (key.comment)
			parts.push(key.comment);

		return (Buffer.from(parts.join(' ')));
	}
	return ssh;
}

var dnssec;
var hasRequiredDnssec;

function requireDnssec () {
	if (hasRequiredDnssec) return dnssec;
	hasRequiredDnssec = 1;
	// Copyright 2017 Joyent, Inc.

	dnssec = {
		read: read,
		write: write
	};

	var assert = requireAssert();
	var Buffer = requireSafer().Buffer;
	var Key = requireKey();
	var PrivateKey = requirePrivateKey();
	var utils = requireUtils$5();
	requireSshBuffer();
	requireDhe();

	var supportedAlgos = {
		'rsa-sha1' : 5,
		'rsa-sha256' : 8,
		'rsa-sha512' : 10,
		'ecdsa-p256-sha256' : 13,
		'ecdsa-p384-sha384' : 14
		/*
		 * ed25519 is hypothetically supported with id 15
		 * but the common tools available don't appear to be
		 * capable of generating/using ed25519 keys
		 */
	};

	var supportedAlgosById = {};
	Object.keys(supportedAlgos).forEach(function (k) {
		supportedAlgosById[supportedAlgos[k]] = k.toUpperCase();
	});

	function read(buf, options) {
		if (typeof (buf) !== 'string') {
			assert.buffer(buf, 'buf');
			buf = buf.toString('ascii');
		}
		var lines = buf.split('\n');
		if (lines[0].match(/^Private-key-format\: v1/)) {
			var algElems = lines[1].split(' ');
			var algoNum = parseInt(algElems[1], 10);
			var algoName = algElems[2];
			if (!supportedAlgosById[algoNum])
				throw (new Error('Unsupported algorithm: ' + algoName));
			return (readDNSSECPrivateKey(algoNum, lines.slice(2)));
		}

		// skip any comment-lines
		var line = 0;
		/* JSSTYLED */
		while (lines[line].match(/^\;/))
			line++;
		// we should now have *one single* line left with our KEY on it.
		if ((lines[line].match(/\. IN KEY /) ||
		    lines[line].match(/\. IN DNSKEY /)) && lines[line+1].length === 0) {
			return (readRFC3110(lines[line]));
		}
		throw (new Error('Cannot parse dnssec key'));
	}

	function readRFC3110(keyString) {
		var elems = keyString.split(' ');
		//unused var flags = parseInt(elems[3], 10);
		//unused var protocol = parseInt(elems[4], 10);
		var algorithm = parseInt(elems[5], 10);
		if (!supportedAlgosById[algorithm])
			throw (new Error('Unsupported algorithm: ' + algorithm));
		var base64key = elems.slice(6, elems.length).join();
		var keyBuffer = Buffer.from(base64key, 'base64');
		if (supportedAlgosById[algorithm].match(/^RSA-/)) {
			// join the rest of the body into a single base64-blob
			var publicExponentLen = keyBuffer.readUInt8(0);
			if (publicExponentLen != 3 && publicExponentLen != 1)
				throw (new Error('Cannot parse dnssec key: ' +
				    'unsupported exponent length'));

			var publicExponent = keyBuffer.slice(1, publicExponentLen+1);
			publicExponent = utils.mpNormalize(publicExponent);
			var modulus = keyBuffer.slice(1+publicExponentLen);
			modulus = utils.mpNormalize(modulus);
			// now, make the key
			var rsaKey = {
				type: 'rsa',
				parts: []
			};
			rsaKey.parts.push({ name: 'e', data: publicExponent});
			rsaKey.parts.push({ name: 'n', data: modulus});
			return (new Key(rsaKey));
		}
		if (supportedAlgosById[algorithm] === 'ECDSA-P384-SHA384' ||
		    supportedAlgosById[algorithm] === 'ECDSA-P256-SHA256') {
			var curve = 'nistp384';
			var size = 384;
			if (supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {
				curve = 'nistp256';
				size = 256;
			}

			var ecdsaKey = {
				type: 'ecdsa',
				curve: curve,
				size: size,
				parts: [
					{name: 'curve', data: Buffer.from(curve) },
					{name: 'Q', data: utils.ecNormalize(keyBuffer) }
				]
			};
			return (new Key(ecdsaKey));
		}
		throw (new Error('Unsupported algorithm: ' +
		    supportedAlgosById[algorithm]));
	}

	function elementToBuf(e) {
		return (Buffer.from(e.split(' ')[1], 'base64'));
	}

	function readDNSSECRSAPrivateKey(elements) {
		var rsaParams = {};
		elements.forEach(function (element) {
			if (element.split(' ')[0] === 'Modulus:')
				rsaParams['n'] = elementToBuf(element);
			else if (element.split(' ')[0] === 'PublicExponent:')
				rsaParams['e'] = elementToBuf(element);
			else if (element.split(' ')[0] === 'PrivateExponent:')
				rsaParams['d'] = elementToBuf(element);
			else if (element.split(' ')[0] === 'Prime1:')
				rsaParams['p'] = elementToBuf(element);
			else if (element.split(' ')[0] === 'Prime2:')
				rsaParams['q'] = elementToBuf(element);
			else if (element.split(' ')[0] === 'Exponent1:')
				rsaParams['dmodp'] = elementToBuf(element);
			else if (element.split(' ')[0] === 'Exponent2:')
				rsaParams['dmodq'] = elementToBuf(element);
			else if (element.split(' ')[0] === 'Coefficient:')
				rsaParams['iqmp'] = elementToBuf(element);
		});
		// now, make the key
		var key = {
			type: 'rsa',
			parts: [
				{ name: 'e', data: utils.mpNormalize(rsaParams['e'])},
				{ name: 'n', data: utils.mpNormalize(rsaParams['n'])},
				{ name: 'd', data: utils.mpNormalize(rsaParams['d'])},
				{ name: 'p', data: utils.mpNormalize(rsaParams['p'])},
				{ name: 'q', data: utils.mpNormalize(rsaParams['q'])},
				{ name: 'dmodp',
				    data: utils.mpNormalize(rsaParams['dmodp'])},
				{ name: 'dmodq',
				    data: utils.mpNormalize(rsaParams['dmodq'])},
				{ name: 'iqmp',
				    data: utils.mpNormalize(rsaParams['iqmp'])}
			]
		};
		return (new PrivateKey(key));
	}

	function readDNSSECPrivateKey(alg, elements) {
		if (supportedAlgosById[alg].match(/^RSA-/)) {
			return (readDNSSECRSAPrivateKey(elements));
		}
		if (supportedAlgosById[alg] === 'ECDSA-P384-SHA384' ||
		    supportedAlgosById[alg] === 'ECDSA-P256-SHA256') {
			var d = Buffer.from(elements[0].split(' ')[1], 'base64');
			var curve = 'nistp384';
			var size = 384;
			if (supportedAlgosById[alg] === 'ECDSA-P256-SHA256') {
				curve = 'nistp256';
				size = 256;
			}
			// DNSSEC generates the public-key on the fly (go calculate it)
			var publicKey = utils.publicFromPrivateECDSA(curve, d);
			var Q = publicKey.part['Q'].data;
			var ecdsaKey = {
				type: 'ecdsa',
				curve: curve,
				size: size,
				parts: [
					{name: 'curve', data: Buffer.from(curve) },
					{name: 'd', data: d },
					{name: 'Q', data: Q }
				]
			};
			return (new PrivateKey(ecdsaKey));
		}
		throw (new Error('Unsupported algorithm: ' + supportedAlgosById[alg]));
	}

	function dnssecTimestamp(date) {
		var year = date.getFullYear() + ''; //stringify
		var month = (date.getMonth() + 1);
		var timestampStr = year + month + date.getUTCDate();
		timestampStr += '' + date.getUTCHours() + date.getUTCMinutes();
		timestampStr += date.getUTCSeconds();
		return (timestampStr);
	}

	function rsaAlgFromOptions(opts) {
		if (!opts || !opts.hashAlgo || opts.hashAlgo === 'sha1')
			return ('5 (RSASHA1)');
		else if (opts.hashAlgo === 'sha256')
			return ('8 (RSASHA256)');
		else if (opts.hashAlgo === 'sha512')
			return ('10 (RSASHA512)');
		else
			throw (new Error('Unknown or unsupported hash: ' +
			    opts.hashAlgo));
	}

	function writeRSA(key, options) {
		// if we're missing parts, add them.
		if (!key.part.dmodp || !key.part.dmodq) {
			utils.addRSAMissing(key);
		}

		var out = '';
		out += 'Private-key-format: v1.3\n';
		out += 'Algorithm: ' + rsaAlgFromOptions(options) + '\n';
		var n = utils.mpDenormalize(key.part['n'].data);
		out += 'Modulus: ' + n.toString('base64') + '\n';
		var e = utils.mpDenormalize(key.part['e'].data);
		out += 'PublicExponent: ' + e.toString('base64') + '\n';
		var d = utils.mpDenormalize(key.part['d'].data);
		out += 'PrivateExponent: ' + d.toString('base64') + '\n';
		var p = utils.mpDenormalize(key.part['p'].data);
		out += 'Prime1: ' + p.toString('base64') + '\n';
		var q = utils.mpDenormalize(key.part['q'].data);
		out += 'Prime2: ' + q.toString('base64') + '\n';
		var dmodp = utils.mpDenormalize(key.part['dmodp'].data);
		out += 'Exponent1: ' + dmodp.toString('base64') + '\n';
		var dmodq = utils.mpDenormalize(key.part['dmodq'].data);
		out += 'Exponent2: ' + dmodq.toString('base64') + '\n';
		var iqmp = utils.mpDenormalize(key.part['iqmp'].data);
		out += 'Coefficient: ' + iqmp.toString('base64') + '\n';
		// Assume that we're valid as-of now
		var timestamp = new Date();
		out += 'Created: ' + dnssecTimestamp(timestamp) + '\n';
		out += 'Publish: ' + dnssecTimestamp(timestamp) + '\n';
		out += 'Activate: ' + dnssecTimestamp(timestamp) + '\n';
		return (Buffer.from(out, 'ascii'));
	}

	function writeECDSA(key, options) {
		var out = '';
		out += 'Private-key-format: v1.3\n';

		if (key.curve === 'nistp256') {
			out += 'Algorithm: 13 (ECDSAP256SHA256)\n';
		} else if (key.curve === 'nistp384') {
			out += 'Algorithm: 14 (ECDSAP384SHA384)\n';
		} else {
			throw (new Error('Unsupported curve'));
		}
		var base64Key = key.part['d'].data.toString('base64');
		out += 'PrivateKey: ' + base64Key + '\n';

		// Assume that we're valid as-of now
		var timestamp = new Date();
		out += 'Created: ' + dnssecTimestamp(timestamp) + '\n';
		out += 'Publish: ' + dnssecTimestamp(timestamp) + '\n';
		out += 'Activate: ' + dnssecTimestamp(timestamp) + '\n';

		return (Buffer.from(out, 'ascii'));
	}

	function write(key, options) {
		if (PrivateKey.isPrivateKey(key)) {
			if (key.type === 'rsa') {
				return (writeRSA(key, options));
			} else if (key.type === 'ecdsa') {
				return (writeECDSA(key));
			} else {
				throw (new Error('Unsupported algorithm: ' + key.type));
			}
		} else if (Key.isKey(key)) {
			/*
			 * RFC3110 requires a keyname, and a keytype, which we
			 * don't really have a mechanism for specifying such
			 * additional metadata.
			 */
			throw (new Error('Format "dnssec" only supports ' +
			    'writing private keys'));
		} else {
			throw (new Error('key is not a Key or PrivateKey'));
		}
	}
	return dnssec;
}

var putty;
var hasRequiredPutty;

function requirePutty () {
	if (hasRequiredPutty) return putty;
	hasRequiredPutty = 1;
	// Copyright 2018 Joyent, Inc.

	putty = {
		read: read,
		write: write
	};

	var assert = requireAssert();
	var Buffer = requireSafer().Buffer;
	var rfc4253 = requireRfc4253();
	var Key = requireKey();
	var SSHBuffer = requireSshBuffer();
	var crypto = require$$0$5;
	var PrivateKey = requirePrivateKey();

	var errors = requireErrors$1();

	// https://tartarus.org/~simon/putty-prerel-snapshots/htmldoc/AppendixC.html
	function read(buf, options) {
		var lines = buf.toString('ascii').split(/[\r\n]+/);
		var found = false;
		var parts;
		var si = 0;
		var formatVersion;
		while (si < lines.length) {
			parts = splitHeader(lines[si++]);
			if (parts) {
				formatVersion = {
					'putty-user-key-file-2': 2,
					'putty-user-key-file-3': 3
				}[parts[0].toLowerCase()];
				if (formatVersion) {
					found = true;
					break;
				}
			}
		}
		if (!found) {
			throw (new Error('No PuTTY format first line found'));
		}
		var alg = parts[1];

		parts = splitHeader(lines[si++]);
		assert.equal(parts[0].toLowerCase(), 'encryption');
		var encryption = parts[1];

		parts = splitHeader(lines[si++]);
		assert.equal(parts[0].toLowerCase(), 'comment');
		var comment = parts[1];

		parts = splitHeader(lines[si++]);
		assert.equal(parts[0].toLowerCase(), 'public-lines');
		var publicLines = parseInt(parts[1], 10);
		if (!isFinite(publicLines) || publicLines < 0 ||
		    publicLines > lines.length) {
			throw (new Error('Invalid public-lines count'));
		}

		var publicBuf = Buffer.from(
		    lines.slice(si, si + publicLines).join(''), 'base64');
		var keyType = rfc4253.algToKeyType(alg);
		var key = rfc4253.read(publicBuf);
		if (key.type !== keyType) {
			throw (new Error('Outer key algorithm mismatch'));
		}

		si += publicLines;
		if (lines[si]) {
			parts = splitHeader(lines[si++]);
			assert.equal(parts[0].toLowerCase(), 'private-lines');
			var privateLines = parseInt(parts[1], 10);
			if (!isFinite(privateLines) || privateLines < 0 ||
			    privateLines > lines.length) {
				throw (new Error('Invalid private-lines count'));
			}

			var privateBuf = Buffer.from(
				lines.slice(si, si + privateLines).join(''), 'base64');

			if (encryption !== 'none' && formatVersion === 3) {
				throw new Error('Encrypted keys arenot supported for' +
				' PuTTY format version 3');
			}

			if (encryption === 'aes256-cbc') {
				if (!options.passphrase) {
					throw (new errors.KeyEncryptedError(
						options.filename, 'PEM'));
				}

				var iv = Buffer.alloc(16, 0);
				var decipher = crypto.createDecipheriv(
					'aes-256-cbc',
					derivePPK2EncryptionKey(options.passphrase),
					iv);
				decipher.setAutoPadding(false);
				privateBuf = Buffer.concat([
					decipher.update(privateBuf), decipher.final()]);
			}

			key = new PrivateKey(key);
			if (key.type !== keyType) {
				throw (new Error('Outer key algorithm mismatch'));
			}

			var sshbuf = new SSHBuffer({buffer: privateBuf});
			var privateKeyParts;
			if (alg === 'ssh-dss') {
				privateKeyParts = [ {
					name: 'x',
					data: sshbuf.readBuffer()
				}];
			} else if (alg === 'ssh-rsa') {
				privateKeyParts = [
					{ name: 'd', data: sshbuf.readBuffer() },
					{ name: 'p', data: sshbuf.readBuffer() },
					{ name: 'q', data: sshbuf.readBuffer() },
					{ name: 'iqmp', data: sshbuf.readBuffer() }
				];
			} else if (alg.match(/^ecdsa-sha2-nistp/)) {
				privateKeyParts = [ {
					name: 'd', data: sshbuf.readBuffer()
				} ];
			} else if (alg === 'ssh-ed25519') {
				privateKeyParts = [ {
					name: 'k', data: sshbuf.readBuffer()
				} ];
			} else {
				throw new Error('Unsupported PPK key type: ' + alg);
			}

			key = new PrivateKey({
				type: key.type,
				parts: key.parts.concat(privateKeyParts)
			});
		}

		key.comment = comment;
		return (key);
	}

	function derivePPK2EncryptionKey(passphrase) {
		var hash1 = crypto.createHash('sha1').update(Buffer.concat([
			Buffer.from([0, 0, 0, 0]),
			Buffer.from(passphrase)
		])).digest();
		var hash2 = crypto.createHash('sha1').update(Buffer.concat([
			Buffer.from([0, 0, 0, 1]),
			Buffer.from(passphrase)
		])).digest();
		return (Buffer.concat([hash1, hash2]).slice(0, 32));
	}

	function splitHeader(line) {
		var idx = line.indexOf(':');
		if (idx === -1)
			return (null);
		var header = line.slice(0, idx);
		++idx;
		while (line[idx] === ' ')
			++idx;
		var rest = line.slice(idx);
		return ([header, rest]);
	}

	function write(key, options) {
		assert.object(key);
		if (!Key.isKey(key))
			throw (new Error('Must be a public key'));

		var alg = rfc4253.keyTypeToAlg(key);
		var buf = rfc4253.write(key);
		var comment = key.comment || '';

		var b64 = buf.toString('base64');
		var lines = wrap(b64);

		lines.unshift('Public-Lines: ' + lines.length);
		lines.unshift('Comment: ' + comment);
		lines.unshift('Encryption: none');
		lines.unshift('PuTTY-User-Key-File-2: ' + alg);

		return (Buffer.from(lines.join('\n') + '\n'));
	}

	function wrap(txt, len) {
		var lines = [];
		var pos = 0;
		while (pos < txt.length) {
			lines.push(txt.slice(pos, pos + 64));
			pos += 64;
		}
		return (lines);
	}
	return putty;
}

var auto;
var hasRequiredAuto;

function requireAuto () {
	if (hasRequiredAuto) return auto;
	hasRequiredAuto = 1;
	// Copyright 2018 Joyent, Inc.

	auto = {
		read: read,
		write: write
	};

	var assert = requireAssert();
	var Buffer = requireSafer().Buffer;
	requireUtils$5();
	requireKey();
	requirePrivateKey();

	var pem = requirePem();
	var ssh = requireSsh();
	var rfc4253 = requireRfc4253();
	var dnssec = requireDnssec();
	var putty = requirePutty();

	var DNSSEC_PRIVKEY_HEADER_PREFIX = 'Private-key-format: v1';

	function read(buf, options) {
		if (typeof (buf) === 'string') {
			if (buf.trim().match(/^[-]+[ ]*BEGIN/))
				return (pem.read(buf, options));
			if (buf.match(/^\s*ssh-[a-z]/))
				return (ssh.read(buf, options));
			if (buf.match(/^\s*ecdsa-/))
				return (ssh.read(buf, options));
			if (buf.match(/^putty-user-key-file-2:/i))
				return (putty.read(buf, options));
			if (findDNSSECHeader(buf))
				return (dnssec.read(buf, options));
			buf = Buffer.from(buf, 'binary');
		} else {
			assert.buffer(buf);
			if (findPEMHeader(buf))
				return (pem.read(buf, options));
			if (findSSHHeader(buf))
				return (ssh.read(buf, options));
			if (findPuTTYHeader(buf))
				return (putty.read(buf, options));
			if (findDNSSECHeader(buf))
				return (dnssec.read(buf, options));
		}
		if (buf.readUInt32BE(0) < buf.length)
			return (rfc4253.read(buf, options));
		throw (new Error('Failed to auto-detect format of key'));
	}

	function findPuTTYHeader(buf) {
		var offset = 0;
		while (offset < buf.length &&
		    (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))
			++offset;
		if (offset + 22 <= buf.length &&
		    buf.slice(offset, offset + 22).toString('ascii').toLowerCase() ===
		    'putty-user-key-file-2:')
			return (true);
		return (false);
	}

	function findSSHHeader(buf) {
		var offset = 0;
		while (offset < buf.length &&
		    (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))
			++offset;
		if (offset + 4 <= buf.length &&
		    buf.slice(offset, offset + 4).toString('ascii') === 'ssh-')
			return (true);
		if (offset + 6 <= buf.length &&
		    buf.slice(offset, offset + 6).toString('ascii') === 'ecdsa-')
			return (true);
		return (false);
	}

	function findPEMHeader(buf) {
		var offset = 0;
		while (offset < buf.length &&
		    (buf[offset] === 32 || buf[offset] === 10))
			++offset;
		if (buf[offset] !== 45)
			return (false);
		while (offset < buf.length &&
		    (buf[offset] === 45))
			++offset;
		while (offset < buf.length &&
		    (buf[offset] === 32))
			++offset;
		if (offset + 5 > buf.length ||
		    buf.slice(offset, offset + 5).toString('ascii') !== 'BEGIN')
			return (false);
		return (true);
	}

	function findDNSSECHeader(buf) {
		// private case first
		if (buf.length <= DNSSEC_PRIVKEY_HEADER_PREFIX.length)
			return (false);
		var headerCheck = buf.slice(0, DNSSEC_PRIVKEY_HEADER_PREFIX.length);
		if (headerCheck.toString('ascii') === DNSSEC_PRIVKEY_HEADER_PREFIX)
			return (true);

		// public-key RFC3110 ?
		// 'domain.com. IN KEY ...' or 'domain.com. IN DNSKEY ...'
		// skip any comment-lines
		if (typeof (buf) !== 'string') {
			buf = buf.toString('ascii');
		}
		var lines = buf.split('\n');
		var line = 0;
		/* JSSTYLED */
		while (lines[line].match(/^\;/))
			line++;
		if (lines[line].toString('ascii').match(/\. IN KEY /))
			return (true);
		if (lines[line].toString('ascii').match(/\. IN DNSKEY /))
			return (true);
		return (false);
	}

	function write(key, options) {
		throw (new Error('"auto" format cannot be used for writing'));
	}
	return auto;
}

var privateKey;
var hasRequiredPrivateKey;

function requirePrivateKey () {
	if (hasRequiredPrivateKey) return privateKey;
	hasRequiredPrivateKey = 1;
	// Copyright 2017 Joyent, Inc.

	privateKey = PrivateKey;

	var assert = requireAssert();
	var Buffer = requireSafer().Buffer;
	var algs = requireAlgs();
	var crypto = require$$0$5;
	requireFingerprint();
	var Signature = requireSignature();
	var errs = requireErrors$1();
	var util = require$$1$2;
	var utils = requireUtils$5();
	var dhe = requireDhe();
	var generateECDSA = dhe.generateECDSA;
	var generateED25519 = dhe.generateED25519;
	var edCompat = requireEdCompat();
	var nacl = requireNaclFast();

	var Key = requireKey();

	errs.InvalidAlgorithmError;
	var KeyParseError = errs.KeyParseError;
	errs.KeyEncryptedError;

	var formats = {};
	formats['auto'] = requireAuto();
	formats['pem'] = requirePem();
	formats['pkcs1'] = requirePkcs1();
	formats['pkcs8'] = requirePkcs8();
	formats['rfc4253'] = requireRfc4253();
	formats['ssh-private'] = requireSshPrivate();
	formats['openssh'] = formats['ssh-private'];
	formats['ssh'] = formats['ssh-private'];
	formats['dnssec'] = requireDnssec();
	formats['putty'] = requirePutty();

	function PrivateKey(opts) {
		assert.object(opts, 'options');
		Key.call(this, opts);

		this._pubCache = undefined;
	}
	util.inherits(PrivateKey, Key);

	PrivateKey.formats = formats;

	PrivateKey.prototype.toBuffer = function (format, options) {
		if (format === undefined)
			format = 'pkcs1';
		assert.string(format, 'format');
		assert.object(formats[format], 'formats[format]');
		assert.optionalObject(options, 'options');

		return (formats[format].write(this, options));
	};

	PrivateKey.prototype.hash = function (algo, type) {
		return (this.toPublic().hash(algo, type));
	};

	PrivateKey.prototype.fingerprint = function (algo, type) {
		return (this.toPublic().fingerprint(algo, type));
	};

	PrivateKey.prototype.toPublic = function () {
		if (this._pubCache)
			return (this._pubCache);

		var algInfo = algs.info[this.type];
		var pubParts = [];
		for (var i = 0; i < algInfo.parts.length; ++i) {
			var p = algInfo.parts[i];
			pubParts.push(this.part[p]);
		}

		this._pubCache = new Key({
			type: this.type,
			source: this,
			parts: pubParts
		});
		if (this.comment)
			this._pubCache.comment = this.comment;
		return (this._pubCache);
	};

	PrivateKey.prototype.derive = function (newType) {
		assert.string(newType, 'type');
		var priv, pub, pair;

		if (this.type === 'ed25519' && newType === 'curve25519') {
			priv = this.part.k.data;
			if (priv[0] === 0x00)
				priv = priv.slice(1);

			pair = nacl.box.keyPair.fromSecretKey(new Uint8Array(priv));
			pub = Buffer.from(pair.publicKey);

			return (new PrivateKey({
				type: 'curve25519',
				parts: [
					{ name: 'A', data: utils.mpNormalize(pub) },
					{ name: 'k', data: utils.mpNormalize(priv) }
				]
			}));
		} else if (this.type === 'curve25519' && newType === 'ed25519') {
			priv = this.part.k.data;
			if (priv[0] === 0x00)
				priv = priv.slice(1);

			pair = nacl.sign.keyPair.fromSeed(new Uint8Array(priv));
			pub = Buffer.from(pair.publicKey);

			return (new PrivateKey({
				type: 'ed25519',
				parts: [
					{ name: 'A', data: utils.mpNormalize(pub) },
					{ name: 'k', data: utils.mpNormalize(priv) }
				]
			}));
		}
		throw (new Error('Key derivation not supported from ' + this.type +
		    ' to ' + newType));
	};

	PrivateKey.prototype.createVerify = function (hashAlgo) {
		return (this.toPublic().createVerify(hashAlgo));
	};

	PrivateKey.prototype.createSign = function (hashAlgo) {
		if (hashAlgo === undefined)
			hashAlgo = this.defaultHashAlgorithm();
		assert.string(hashAlgo, 'hash algorithm');

		/* ED25519 is not supported by OpenSSL, use a javascript impl. */
		if (this.type === 'ed25519' && edCompat !== undefined)
			return (new edCompat.Signer(this, hashAlgo));
		if (this.type === 'curve25519')
			throw (new Error('Curve25519 keys are not suitable for ' +
			    'signing or verification'));

		var v, nm, err;
		try {
			nm = hashAlgo.toUpperCase();
			v = crypto.createSign(nm);
		} catch (e) {
			err = e;
		}
		if (v === undefined || (err instanceof Error &&
		    err.message.match(/Unknown message digest/))) {
			nm = 'RSA-';
			nm += hashAlgo.toUpperCase();
			v = crypto.createSign(nm);
		}
		assert.ok(v, 'failed to create verifier');
		var oldSign = v.sign.bind(v);
		var key = this.toBuffer('pkcs1');
		var type = this.type;
		var curve = this.curve;
		v.sign = function () {
			var sig = oldSign(key);
			if (typeof (sig) === 'string')
				sig = Buffer.from(sig, 'binary');
			sig = Signature.parse(sig, type, 'asn1');
			sig.hashAlgorithm = hashAlgo;
			sig.curve = curve;
			return (sig);
		};
		return (v);
	};

	PrivateKey.parse = function (data, format, options) {
		if (typeof (data) !== 'string')
			assert.buffer(data, 'data');
		if (format === undefined)
			format = 'auto';
		assert.string(format, 'format');
		if (typeof (options) === 'string')
			options = { filename: options };
		assert.optionalObject(options, 'options');
		if (options === undefined)
			options = {};
		assert.optionalString(options.filename, 'options.filename');
		if (options.filename === undefined)
			options.filename = '(unnamed)';

		assert.object(formats[format], 'formats[format]');

		try {
			var k = formats[format].read(data, options);
			assert.ok(k instanceof PrivateKey, 'key is not a private key');
			if (!k.comment)
				k.comment = options.filename;
			return (k);
		} catch (e) {
			if (e.name === 'KeyEncryptedError')
				throw (e);
			throw (new KeyParseError(options.filename, format, e));
		}
	};

	PrivateKey.isPrivateKey = function (obj, ver) {
		return (utils.isCompatible(obj, PrivateKey, ver));
	};

	PrivateKey.generate = function (type, options) {
		if (options === undefined)
			options = {};
		assert.object(options, 'options');

		switch (type) {
		case 'ecdsa':
			if (options.curve === undefined)
				options.curve = 'nistp256';
			assert.string(options.curve, 'options.curve');
			return (generateECDSA(options.curve));
		case 'ed25519':
			return (generateED25519());
		default:
			throw (new Error('Key generation not supported with key ' +
			    'type "' + type + '"'));
		}
	};

	/*
	 * API versions for PrivateKey:
	 * [1,0] -- initial ver
	 * [1,1] -- added auto, pkcs[18], openssh/ssh-private formats
	 * [1,2] -- added defaultHashAlgorithm
	 * [1,3] -- added derive, ed, createDH
	 * [1,4] -- first tagged version
	 * [1,5] -- changed ed25519 part names and format
	 * [1,6] -- type arguments for hash() and fingerprint()
	 */
	PrivateKey.prototype._sshpkApiVersion = [1, 6];

	PrivateKey._oldVersionDetect = function (obj) {
		assert.func(obj.toPublic);
		assert.func(obj.createSign);
		if (obj.derive)
			return ([1, 3]);
		if (obj.defaultHashAlgorithm)
			return ([1, 2]);
		if (obj.formats['auto'])
			return ([1, 1]);
		return ([1, 0]);
	};
	return privateKey;
}

var identity;
var hasRequiredIdentity;

function requireIdentity () {
	if (hasRequiredIdentity) return identity;
	hasRequiredIdentity = 1;
	// Copyright 2017 Joyent, Inc.

	identity = Identity;

	var assert = requireAssert();
	requireAlgs();
	requireFingerprint();
	requireSignature();
	requireErrors$1();
	var utils = requireUtils$5();
	var asn1 = requireLib$9();
	var Buffer = requireSafer().Buffer;

	/*JSSTYLED*/
	var DNS_NAME_RE = /^([*]|[a-z0-9][a-z0-9\-]{0,62})(?:\.([*]|[a-z0-9][a-z0-9\-]{0,62}))*$/i;

	var oids = {};
	oids.cn = '2.5.4.3';
	oids.o = '2.5.4.10';
	oids.ou = '2.5.4.11';
	oids.l = '2.5.4.7';
	oids.s = '2.5.4.8';
	oids.c = '2.5.4.6';
	oids.sn = '2.5.4.4';
	oids.postalCode = '2.5.4.17';
	oids.serialNumber = '2.5.4.5';
	oids.street = '2.5.4.9';
	oids.x500UniqueIdentifier = '2.5.4.45';
	oids.role = '2.5.4.72';
	oids.telephoneNumber = '2.5.4.20';
	oids.description = '2.5.4.13';
	oids.dc = '0.9.2342.19200300.100.1.25';
	oids.uid = '0.9.2342.19200300.100.1.1';
	oids.mail = '0.9.2342.19200300.100.1.3';
	oids.title = '2.5.4.12';
	oids.gn = '2.5.4.42';
	oids.initials = '2.5.4.43';
	oids.pseudonym = '2.5.4.65';
	oids.emailAddress = '1.2.840.113549.1.9.1';

	var unoids = {};
	Object.keys(oids).forEach(function (k) {
		unoids[oids[k]] = k;
	});

	function Identity(opts) {
		var self = this;
		assert.object(opts, 'options');
		assert.arrayOfObject(opts.components, 'options.components');
		this.components = opts.components;
		this.componentLookup = {};
		this.components.forEach(function (c) {
			if (c.name && !c.oid)
				c.oid = oids[c.name];
			if (c.oid && !c.name)
				c.name = unoids[c.oid];
			if (self.componentLookup[c.name] === undefined)
				self.componentLookup[c.name] = [];
			self.componentLookup[c.name].push(c);
		});
		if (this.componentLookup.cn && this.componentLookup.cn.length > 0) {
			this.cn = this.componentLookup.cn[0].value;
		}
		assert.optionalString(opts.type, 'options.type');
		if (opts.type === undefined) {
			if (this.components.length === 1 &&
			    this.componentLookup.cn &&
			    this.componentLookup.cn.length === 1 &&
			    this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
				this.type = 'host';
				this.hostname = this.componentLookup.cn[0].value;

			} else if (this.componentLookup.dc &&
			    this.components.length === this.componentLookup.dc.length) {
				this.type = 'host';
				this.hostname = this.componentLookup.dc.map(
				    function (c) {
					return (c.value);
				}).join('.');

			} else if (this.componentLookup.uid &&
			    this.components.length ===
			    this.componentLookup.uid.length) {
				this.type = 'user';
				this.uid = this.componentLookup.uid[0].value;

			} else if (this.componentLookup.cn &&
			    this.componentLookup.cn.length === 1 &&
			    this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
				this.type = 'host';
				this.hostname = this.componentLookup.cn[0].value;

			} else if (this.componentLookup.uid &&
			    this.componentLookup.uid.length === 1) {
				this.type = 'user';
				this.uid = this.componentLookup.uid[0].value;

			} else if (this.componentLookup.mail &&
			    this.componentLookup.mail.length === 1) {
				this.type = 'email';
				this.email = this.componentLookup.mail[0].value;

			} else if (this.componentLookup.cn &&
			    this.componentLookup.cn.length === 1) {
				this.type = 'user';
				this.uid = this.componentLookup.cn[0].value;

			} else {
				this.type = 'unknown';
			}
		} else {
			this.type = opts.type;
			if (this.type === 'host')
				this.hostname = opts.hostname;
			else if (this.type === 'user')
				this.uid = opts.uid;
			else if (this.type === 'email')
				this.email = opts.email;
			else
				throw (new Error('Unknown type ' + this.type));
		}
	}

	Identity.prototype.toString = function () {
		return (this.components.map(function (c) {
			var n = c.name.toUpperCase();
			/*JSSTYLED*/
			n = n.replace(/=/g, '\\=');
			var v = c.value;
			/*JSSTYLED*/
			v = v.replace(/,/g, '\\,');
			return (n + '=' + v);
		}).join(', '));
	};

	Identity.prototype.get = function (name, asArray) {
		assert.string(name, 'name');
		var arr = this.componentLookup[name];
		if (arr === undefined || arr.length === 0)
			return (undefined);
		if (!asArray && arr.length > 1)
			throw (new Error('Multiple values for attribute ' + name));
		if (!asArray)
			return (arr[0].value);
		return (arr.map(function (c) {
			return (c.value);
		}));
	};

	Identity.prototype.toArray = function (idx) {
		return (this.components.map(function (c) {
			return ({
				name: c.name,
				value: c.value
			});
		}));
	};

	/*
	 * These are from X.680 -- PrintableString allowed chars are in section 37.4
	 * table 8. Spec for IA5Strings is "1,6 + SPACE + DEL" where 1 refers to
	 * ISO IR #001 (standard ASCII control characters) and 6 refers to ISO IR #006
	 * (the basic ASCII character set).
	 */
	/* JSSTYLED */
	var NOT_PRINTABLE = /[^a-zA-Z0-9 '(),+.\/:=?-]/;
	/* JSSTYLED */
	var NOT_IA5 = /[^\x00-\x7f]/;

	Identity.prototype.toAsn1 = function (der, tag) {
		der.startSequence(tag);
		this.components.forEach(function (c) {
			der.startSequence(asn1.Ber.Constructor | asn1.Ber.Set);
			der.startSequence();
			der.writeOID(c.oid);
			/*
			 * If we fit in a PrintableString, use that. Otherwise use an
			 * IA5String or UTF8String.
			 *
			 * If this identity was parsed from a DN, use the ASN.1 types
			 * from the original representation (otherwise this might not
			 * be a full match for the original in some validators).
			 */
			if (c.asn1type === asn1.Ber.Utf8String ||
			    c.value.match(NOT_IA5)) {
				var v = Buffer.from(c.value, 'utf8');
				der.writeBuffer(v, asn1.Ber.Utf8String);

			} else if (c.asn1type === asn1.Ber.IA5String ||
			    c.value.match(NOT_PRINTABLE)) {
				der.writeString(c.value, asn1.Ber.IA5String);

			} else {
				var type = asn1.Ber.PrintableString;
				if (c.asn1type !== undefined)
					type = c.asn1type;
				der.writeString(c.value, type);
			}
			der.endSequence();
			der.endSequence();
		});
		der.endSequence();
	};

	function globMatch(a, b) {
		if (a === '**' || b === '**')
			return (true);
		var aParts = a.split('.');
		var bParts = b.split('.');
		if (aParts.length !== bParts.length)
			return (false);
		for (var i = 0; i < aParts.length; ++i) {
			if (aParts[i] === '*' || bParts[i] === '*')
				continue;
			if (aParts[i] !== bParts[i])
				return (false);
		}
		return (true);
	}

	Identity.prototype.equals = function (other) {
		if (!Identity.isIdentity(other, [1, 0]))
			return (false);
		if (other.components.length !== this.components.length)
			return (false);
		for (var i = 0; i < this.components.length; ++i) {
			if (this.components[i].oid !== other.components[i].oid)
				return (false);
			if (!globMatch(this.components[i].value,
			    other.components[i].value)) {
				return (false);
			}
		}
		return (true);
	};

	Identity.forHost = function (hostname) {
		assert.string(hostname, 'hostname');
		return (new Identity({
			type: 'host',
			hostname: hostname,
			components: [ { name: 'cn', value: hostname } ]
		}));
	};

	Identity.forUser = function (uid) {
		assert.string(uid, 'uid');
		return (new Identity({
			type: 'user',
			uid: uid,
			components: [ { name: 'uid', value: uid } ]
		}));
	};

	Identity.forEmail = function (email) {
		assert.string(email, 'email');
		return (new Identity({
			type: 'email',
			email: email,
			components: [ { name: 'mail', value: email } ]
		}));
	};

	Identity.parseDN = function (dn) {
		assert.string(dn, 'dn');
		var parts = [''];
		var idx = 0;
		var rem = dn;
		while (rem.length > 0) {
			var m;
			/*JSSTYLED*/
			if ((m = /^,/.exec(rem)) !== null) {
				parts[++idx] = '';
				rem = rem.slice(m[0].length);
			/*JSSTYLED*/
			} else if ((m = /^\\,/.exec(rem)) !== null) {
				parts[idx] += ',';
				rem = rem.slice(m[0].length);
			/*JSSTYLED*/
			} else if ((m = /^\\./.exec(rem)) !== null) {
				parts[idx] += m[0];
				rem = rem.slice(m[0].length);
			/*JSSTYLED*/
			} else if ((m = /^[^\\,]+/.exec(rem)) !== null) {
				parts[idx] += m[0];
				rem = rem.slice(m[0].length);
			} else {
				throw (new Error('Failed to parse DN'));
			}
		}
		var cmps = parts.map(function (c) {
			c = c.trim();
			var eqPos = c.indexOf('=');
			while (eqPos > 0 && c.charAt(eqPos - 1) === '\\')
				eqPos = c.indexOf('=', eqPos + 1);
			if (eqPos === -1) {
				throw (new Error('Failed to parse DN'));
			}
			/*JSSTYLED*/
			var name = c.slice(0, eqPos).toLowerCase().replace(/\\=/g, '=');
			var value = c.slice(eqPos + 1);
			return ({ name: name, value: value });
		});
		return (new Identity({ components: cmps }));
	};

	Identity.fromArray = function (components) {
		assert.arrayOfObject(components, 'components');
		components.forEach(function (cmp) {
			assert.object(cmp, 'component');
			assert.string(cmp.name, 'component.name');
			if (!Buffer.isBuffer(cmp.value) &&
			    !(typeof (cmp.value) === 'string')) {
				throw (new Error('Invalid component value'));
			}
		});
		return (new Identity({ components: components }));
	};

	Identity.parseAsn1 = function (der, top) {
		var components = [];
		der.readSequence(top);
		var end = der.offset + der.length;
		while (der.offset < end) {
			der.readSequence(asn1.Ber.Constructor | asn1.Ber.Set);
			var after = der.offset + der.length;
			der.readSequence();
			var oid = der.readOID();
			var type = der.peek();
			var value;
			switch (type) {
			case asn1.Ber.PrintableString:
			case asn1.Ber.IA5String:
			case asn1.Ber.OctetString:
			case asn1.Ber.T61String:
				value = der.readString(type);
				break;
			case asn1.Ber.Utf8String:
				value = der.readString(type, true);
				value = value.toString('utf8');
				break;
			case asn1.Ber.CharacterString:
			case asn1.Ber.BMPString:
				value = der.readString(type, true);
				value = value.toString('utf16le');
				break;
			default:
				throw (new Error('Unknown asn1 type ' + type));
			}
			components.push({ oid: oid, asn1type: type, value: value });
			der._offset = after;
		}
		der._offset = end;
		return (new Identity({
			components: components
		}));
	};

	Identity.isIdentity = function (obj, ver) {
		return (utils.isCompatible(obj, Identity, ver));
	};

	/*
	 * API versions for Identity:
	 * [1,0] -- initial ver
	 */
	Identity.prototype._sshpkApiVersion = [1, 0];

	Identity._oldVersionDetect = function (obj) {
		return ([1, 0]);
	};
	return identity;
}

var opensshCert;
var hasRequiredOpensshCert;

function requireOpensshCert () {
	if (hasRequiredOpensshCert) return opensshCert;
	hasRequiredOpensshCert = 1;
	// Copyright 2017 Joyent, Inc.

	opensshCert = {
		read: read,
		verify: verify,
		sign: sign,
		signAsync: signAsync,
		write: write,

		/* Internal private API */
		fromBuffer: fromBuffer,
		toBuffer: toBuffer
	};

	var assert = requireAssert();
	var SSHBuffer = requireSshBuffer();
	var crypto = require$$0$5;
	var Buffer = requireSafer().Buffer;
	var algs = requireAlgs();
	var Key = requireKey();
	requirePrivateKey();
	var Identity = requireIdentity();
	var rfc4253 = requireRfc4253();
	var Signature = requireSignature();
	var utils = requireUtils$5();
	var Certificate = requireCertificate();

	function verify(cert, key) {
		/*
		 * We always give an issuerKey, so if our verify() is being called then
		 * there was no signature. Return false.
		 */
		return (false);
	}

	var TYPES = {
		'user': 1,
		'host': 2
	};
	Object.keys(TYPES).forEach(function (k) { TYPES[TYPES[k]] = k; });

	var ECDSA_ALGO = /^ecdsa-sha2-([^@-]+)-cert-v01@openssh.com$/;

	function read(buf, options) {
		if (Buffer.isBuffer(buf))
			buf = buf.toString('ascii');
		var parts = buf.trim().split(/[ \t\n]+/g);
		if (parts.length < 2 || parts.length > 3)
			throw (new Error('Not a valid SSH certificate line'));

		var algo = parts[0];
		var data = parts[1];

		data = Buffer.from(data, 'base64');
		return (fromBuffer(data, algo));
	}

	function fromBuffer(data, algo, partial) {
		var sshbuf = new SSHBuffer({ buffer: data });
		var innerAlgo = sshbuf.readString();
		if (algo !== undefined && innerAlgo !== algo)
			throw (new Error('SSH certificate algorithm mismatch'));
		if (algo === undefined)
			algo = innerAlgo;

		var cert = {};
		cert.signatures = {};
		cert.signatures.openssh = {};

		cert.signatures.openssh.nonce = sshbuf.readBuffer();

		var key = {};
		var parts = (key.parts = []);
		key.type = getAlg(algo);

		var partCount = algs.info[key.type].parts.length;
		while (parts.length < partCount)
			parts.push(sshbuf.readPart());
		assert.ok(parts.length >= 1, 'key must have at least one part');

		var algInfo = algs.info[key.type];
		if (key.type === 'ecdsa') {
			var res = ECDSA_ALGO.exec(algo);
			assert.ok(res !== null);
			assert.strictEqual(res[1], parts[0].data.toString());
		}

		for (var i = 0; i < algInfo.parts.length; ++i) {
			parts[i].name = algInfo.parts[i];
			if (parts[i].name !== 'curve' &&
			    algInfo.normalize !== false) {
				var p = parts[i];
				p.data = utils.mpNormalize(p.data);
			}
		}

		cert.subjectKey = new Key(key);

		cert.serial = sshbuf.readInt64();

		var type = TYPES[sshbuf.readInt()];
		assert.string(type, 'valid cert type');

		cert.signatures.openssh.keyId = sshbuf.readString();

		var principals = [];
		var pbuf = sshbuf.readBuffer();
		var psshbuf = new SSHBuffer({ buffer: pbuf });
		while (!psshbuf.atEnd())
			principals.push(psshbuf.readString());
		if (principals.length === 0)
			principals = ['*'];

		cert.subjects = principals.map(function (pr) {
			if (type === 'user')
				return (Identity.forUser(pr));
			else if (type === 'host')
				return (Identity.forHost(pr));
			throw (new Error('Unknown identity type ' + type));
		});

		cert.validFrom = int64ToDate(sshbuf.readInt64());
		cert.validUntil = int64ToDate(sshbuf.readInt64());

		var exts = [];
		var extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });
		var ext;
		while (!extbuf.atEnd()) {
			ext = { critical: true };
			ext.name = extbuf.readString();
			ext.data = extbuf.readBuffer();
			exts.push(ext);
		}
		extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });
		while (!extbuf.atEnd()) {
			ext = { critical: false };
			ext.name = extbuf.readString();
			ext.data = extbuf.readBuffer();
			exts.push(ext);
		}
		cert.signatures.openssh.exts = exts;

		/* reserved */
		sshbuf.readBuffer();

		var signingKeyBuf = sshbuf.readBuffer();
		cert.issuerKey = rfc4253.read(signingKeyBuf);

		/*
		 * OpenSSH certs don't give the identity of the issuer, just their
		 * public key. So, we use an Identity that matches anything. The
		 * isSignedBy() function will later tell you if the key matches.
		 */
		cert.issuer = Identity.forHost('**');

		var sigBuf = sshbuf.readBuffer();
		cert.signatures.openssh.signature =
		    Signature.parse(sigBuf, cert.issuerKey.type, 'ssh');

		if (partial !== undefined) {
			partial.remainder = sshbuf.remainder();
			partial.consumed = sshbuf._offset;
		}

		return (new Certificate(cert));
	}

	function int64ToDate(buf) {
		var i = buf.readUInt32BE(0) * 4294967296;
		i += buf.readUInt32BE(4);
		var d = new Date();
		d.setTime(i * 1000);
		d.sourceInt64 = buf;
		return (d);
	}

	function dateToInt64(date) {
		if (date.sourceInt64 !== undefined)
			return (date.sourceInt64);
		var i = Math.round(date.getTime() / 1000);
		var upper = Math.floor(i / 4294967296);
		var lower = Math.floor(i % 4294967296);
		var buf = Buffer.alloc(8);
		buf.writeUInt32BE(upper, 0);
		buf.writeUInt32BE(lower, 4);
		return (buf);
	}

	function sign(cert, key) {
		if (cert.signatures.openssh === undefined)
			cert.signatures.openssh = {};
		try {
			var blob = toBuffer(cert, true);
		} catch (e) {
			delete (cert.signatures.openssh);
			return (false);
		}
		var sig = cert.signatures.openssh;
		var hashAlgo = undefined;
		if (key.type === 'rsa' || key.type === 'dsa')
			hashAlgo = 'sha1';
		var signer = key.createSign(hashAlgo);
		signer.write(blob);
		sig.signature = signer.sign();
		return (true);
	}

	function signAsync(cert, signer, done) {
		if (cert.signatures.openssh === undefined)
			cert.signatures.openssh = {};
		try {
			var blob = toBuffer(cert, true);
		} catch (e) {
			delete (cert.signatures.openssh);
			done(e);
			return;
		}
		var sig = cert.signatures.openssh;

		signer(blob, function (err, signature) {
			if (err) {
				done(err);
				return;
			}
			try {
				/*
				 * This will throw if the signature isn't of a
				 * type/algo that can be used for SSH.
				 */
				signature.toBuffer('ssh');
			} catch (e) {
				done(e);
				return;
			}
			sig.signature = signature;
			done();
		});
	}

	function write(cert, options) {
		if (options === undefined)
			options = {};

		var blob = toBuffer(cert);
		var out = getCertType(cert.subjectKey) + ' ' + blob.toString('base64');
		if (options.comment)
			out = out + ' ' + options.comment;
		return (out);
	}


	function toBuffer(cert, noSig) {
		assert.object(cert.signatures.openssh, 'signature for openssh format');
		var sig = cert.signatures.openssh;

		if (sig.nonce === undefined)
			sig.nonce = crypto.randomBytes(16);
		var buf = new SSHBuffer({});
		buf.writeString(getCertType(cert.subjectKey));
		buf.writeBuffer(sig.nonce);

		var key = cert.subjectKey;
		var algInfo = algs.info[key.type];
		algInfo.parts.forEach(function (part) {
			buf.writePart(key.part[part]);
		});

		buf.writeInt64(cert.serial);

		var type = cert.subjects[0].type;
		assert.notStrictEqual(type, 'unknown');
		cert.subjects.forEach(function (id) {
			assert.strictEqual(id.type, type);
		});
		type = TYPES[type];
		buf.writeInt(type);

		if (sig.keyId === undefined) {
			sig.keyId = cert.subjects[0].type + '_' +
			    (cert.subjects[0].uid || cert.subjects[0].hostname);
		}
		buf.writeString(sig.keyId);

		var sub = new SSHBuffer({});
		cert.subjects.forEach(function (id) {
			if (type === TYPES.host)
				sub.writeString(id.hostname);
			else if (type === TYPES.user)
				sub.writeString(id.uid);
		});
		buf.writeBuffer(sub.toBuffer());

		buf.writeInt64(dateToInt64(cert.validFrom));
		buf.writeInt64(dateToInt64(cert.validUntil));

		var exts = sig.exts;
		if (exts === undefined)
			exts = [];

		var extbuf = new SSHBuffer({});
		exts.forEach(function (ext) {
			if (ext.critical !== true)
				return;
			extbuf.writeString(ext.name);
			extbuf.writeBuffer(ext.data);
		});
		buf.writeBuffer(extbuf.toBuffer());

		extbuf = new SSHBuffer({});
		exts.forEach(function (ext) {
			if (ext.critical === true)
				return;
			extbuf.writeString(ext.name);
			extbuf.writeBuffer(ext.data);
		});
		buf.writeBuffer(extbuf.toBuffer());

		/* reserved */
		buf.writeBuffer(Buffer.alloc(0));

		sub = rfc4253.write(cert.issuerKey);
		buf.writeBuffer(sub);

		if (!noSig)
			buf.writeBuffer(sig.signature.toBuffer('ssh'));

		return (buf.toBuffer());
	}

	function getAlg(certType) {
		if (certType === 'ssh-rsa-cert-v01@openssh.com')
			return ('rsa');
		if (certType === 'ssh-dss-cert-v01@openssh.com')
			return ('dsa');
		if (certType.match(ECDSA_ALGO))
			return ('ecdsa');
		if (certType === 'ssh-ed25519-cert-v01@openssh.com')
			return ('ed25519');
		throw (new Error('Unsupported cert type ' + certType));
	}

	function getCertType(key) {
		if (key.type === 'rsa')
			return ('ssh-rsa-cert-v01@openssh.com');
		if (key.type === 'dsa')
			return ('ssh-dss-cert-v01@openssh.com');
		if (key.type === 'ecdsa')
			return ('ecdsa-sha2-' + key.curve + '-cert-v01@openssh.com');
		if (key.type === 'ed25519')
			return ('ssh-ed25519-cert-v01@openssh.com');
		throw (new Error('Unsupported key type ' + key.type));
	}
	return opensshCert;
}

var x509;
var hasRequiredX509;

function requireX509 () {
	if (hasRequiredX509) return x509;
	hasRequiredX509 = 1;
	// Copyright 2017 Joyent, Inc.

	x509 = {
		read: read,
		verify: verify,
		sign: sign,
		signAsync: signAsync,
		write: write
	};

	var assert = requireAssert();
	var asn1 = requireLib$9();
	var Buffer = requireSafer().Buffer;
	requireAlgs();
	var utils = requireUtils$5();
	requireKey();
	requirePrivateKey();
	requirePem();
	var Identity = requireIdentity();
	var Signature = requireSignature();
	var Certificate = requireCertificate();
	var pkcs8 = requirePkcs8();

	/*
	 * This file is based on RFC5280 (X.509).
	 */

	/* Helper to read in a single mpint */
	function readMPInt(der, nm) {
		assert.strictEqual(der.peek(), asn1.Ber.Integer,
		    nm + ' is not an Integer');
		return (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));
	}

	function verify(cert, key) {
		var sig = cert.signatures.x509;
		assert.object(sig, 'x509 signature');

		var algParts = sig.algo.split('-');
		if (algParts[0] !== key.type)
			return (false);

		var blob = sig.cache;
		if (blob === undefined) {
			var der = new asn1.BerWriter();
			writeTBSCert(cert, der);
			blob = der.buffer;
		}

		var verifier = key.createVerify(algParts[1]);
		verifier.write(blob);
		return (verifier.verify(sig.signature));
	}

	function Local(i) {
		return (asn1.Ber.Context | asn1.Ber.Constructor | i);
	}

	function Context(i) {
		return (asn1.Ber.Context | i);
	}

	var SIGN_ALGS = {
		'rsa-md5': '1.2.840.113549.1.1.4',
		'rsa-sha1': '1.2.840.113549.1.1.5',
		'rsa-sha256': '1.2.840.113549.1.1.11',
		'rsa-sha384': '1.2.840.113549.1.1.12',
		'rsa-sha512': '1.2.840.113549.1.1.13',
		'dsa-sha1': '1.2.840.10040.4.3',
		'dsa-sha256': '2.16.840.1.101.3.4.3.2',
		'ecdsa-sha1': '1.2.840.10045.4.1',
		'ecdsa-sha256': '1.2.840.10045.4.3.2',
		'ecdsa-sha384': '1.2.840.10045.4.3.3',
		'ecdsa-sha512': '1.2.840.10045.4.3.4',
		'ed25519-sha512': '1.3.101.112'
	};
	Object.keys(SIGN_ALGS).forEach(function (k) {
		SIGN_ALGS[SIGN_ALGS[k]] = k;
	});
	SIGN_ALGS['1.3.14.3.2.3'] = 'rsa-md5';
	SIGN_ALGS['1.3.14.3.2.29'] = 'rsa-sha1';

	var EXTS = {
		'issuerKeyId': '2.5.29.35',
		'altName': '2.5.29.17',
		'basicConstraints': '2.5.29.19',
		'keyUsage': '2.5.29.15',
		'extKeyUsage': '2.5.29.37'
	};

	function read(buf, options) {
		if (typeof (buf) === 'string') {
			buf = Buffer.from(buf, 'binary');
		}
		assert.buffer(buf, 'buf');

		var der = new asn1.BerReader(buf);

		der.readSequence();
		if (Math.abs(der.length - der.remain) > 1) {
			throw (new Error('DER sequence does not contain whole byte ' +
			    'stream'));
		}

		var tbsStart = der.offset;
		der.readSequence();
		var sigOffset = der.offset + der.length;
		var tbsEnd = sigOffset;

		if (der.peek() === Local(0)) {
			der.readSequence(Local(0));
			var version = der.readInt();
			assert.ok(version <= 3,
			    'only x.509 versions up to v3 supported');
		}

		var cert = {};
		cert.signatures = {};
		var sig = (cert.signatures.x509 = {});
		sig.extras = {};

		cert.serial = readMPInt(der, 'serial');

		der.readSequence();
		var after = der.offset + der.length;
		var certAlgOid = der.readOID();
		var certAlg = SIGN_ALGS[certAlgOid];
		if (certAlg === undefined)
			throw (new Error('unknown signature algorithm ' + certAlgOid));

		der._offset = after;
		cert.issuer = Identity.parseAsn1(der);

		der.readSequence();
		cert.validFrom = readDate(der);
		cert.validUntil = readDate(der);

		cert.subjects = [Identity.parseAsn1(der)];

		der.readSequence();
		after = der.offset + der.length;
		cert.subjectKey = pkcs8.readPkcs8(undefined, 'public', der);
		der._offset = after;

		/* issuerUniqueID */
		if (der.peek() === Local(1)) {
			der.readSequence(Local(1));
			sig.extras.issuerUniqueID =
			    buf.slice(der.offset, der.offset + der.length);
			der._offset += der.length;
		}

		/* subjectUniqueID */
		if (der.peek() === Local(2)) {
			der.readSequence(Local(2));
			sig.extras.subjectUniqueID =
			    buf.slice(der.offset, der.offset + der.length);
			der._offset += der.length;
		}

		/* extensions */
		if (der.peek() === Local(3)) {
			der.readSequence(Local(3));
			var extEnd = der.offset + der.length;
			der.readSequence();

			while (der.offset < extEnd)
				readExtension(cert, buf, der);

			assert.strictEqual(der.offset, extEnd);
		}

		assert.strictEqual(der.offset, sigOffset);

		der.readSequence();
		after = der.offset + der.length;
		var sigAlgOid = der.readOID();
		var sigAlg = SIGN_ALGS[sigAlgOid];
		if (sigAlg === undefined)
			throw (new Error('unknown signature algorithm ' + sigAlgOid));
		der._offset = after;

		var sigData = der.readString(asn1.Ber.BitString, true);
		if (sigData[0] === 0)
			sigData = sigData.slice(1);
		var algParts = sigAlg.split('-');

		sig.signature = Signature.parse(sigData, algParts[0], 'asn1');
		sig.signature.hashAlgorithm = algParts[1];
		sig.algo = sigAlg;
		sig.cache = buf.slice(tbsStart, tbsEnd);

		return (new Certificate(cert));
	}

	function readDate(der) {
		if (der.peek() === asn1.Ber.UTCTime) {
			return (utcTimeToDate(der.readString(asn1.Ber.UTCTime)));
		} else if (der.peek() === asn1.Ber.GeneralizedTime) {
			return (gTimeToDate(der.readString(asn1.Ber.GeneralizedTime)));
		} else {
			throw (new Error('Unsupported date format'));
		}
	}

	function writeDate(der, date) {
		if (date.getUTCFullYear() >= 2050 || date.getUTCFullYear() < 1950) {
			der.writeString(dateToGTime(date), asn1.Ber.GeneralizedTime);
		} else {
			der.writeString(dateToUTCTime(date), asn1.Ber.UTCTime);
		}
	}

	/* RFC5280, section 4.2.1.6 (GeneralName type) */
	var ALTNAME = {
		OtherName: Local(0),
		RFC822Name: Context(1),
		DNSName: Context(2),
		X400Address: Local(3),
		DirectoryName: Local(4),
		EDIPartyName: Local(5),
		URI: Context(6),
		IPAddress: Context(7),
		OID: Context(8)
	};

	/* RFC5280, section 4.2.1.12 (KeyPurposeId) */
	var EXTPURPOSE = {
		'serverAuth': '1.3.6.1.5.5.7.3.1',
		'clientAuth': '1.3.6.1.5.5.7.3.2',
		'codeSigning': '1.3.6.1.5.5.7.3.3',

		/* See https://github.com/joyent/oid-docs/blob/master/root.md */
		'joyentDocker': '1.3.6.1.4.1.38678.1.4.1',
		'joyentCmon': '1.3.6.1.4.1.38678.1.4.2'
	};
	var EXTPURPOSE_REV = {};
	Object.keys(EXTPURPOSE).forEach(function (k) {
		EXTPURPOSE_REV[EXTPURPOSE[k]] = k;
	});

	var KEYUSEBITS = [
		'signature', 'identity', 'keyEncryption',
		'encryption', 'keyAgreement', 'ca', 'crl'
	];

	function readExtension(cert, buf, der) {
		der.readSequence();
		var after = der.offset + der.length;
		var extId = der.readOID();
		var id;
		var sig = cert.signatures.x509;
		if (!sig.extras.exts)
			sig.extras.exts = [];

		var critical;
		if (der.peek() === asn1.Ber.Boolean)
			critical = der.readBoolean();

		switch (extId) {
		case (EXTS.basicConstraints):
			der.readSequence(asn1.Ber.OctetString);
			der.readSequence();
			var bcEnd = der.offset + der.length;
			var ca = false;
			if (der.peek() === asn1.Ber.Boolean)
				ca = der.readBoolean();
			if (cert.purposes === undefined)
				cert.purposes = [];
			if (ca === true)
				cert.purposes.push('ca');
			var bc = { oid: extId, critical: critical };
			if (der.offset < bcEnd && der.peek() === asn1.Ber.Integer)
				bc.pathLen = der.readInt();
			sig.extras.exts.push(bc);
			break;
		case (EXTS.extKeyUsage):
			der.readSequence(asn1.Ber.OctetString);
			der.readSequence();
			if (cert.purposes === undefined)
				cert.purposes = [];
			var ekEnd = der.offset + der.length;
			while (der.offset < ekEnd) {
				var oid = der.readOID();
				cert.purposes.push(EXTPURPOSE_REV[oid] || oid);
			}
			/*
			 * This is a bit of a hack: in the case where we have a cert
			 * that's only allowed to do serverAuth or clientAuth (and not
			 * the other), we want to make sure all our Subjects are of
			 * the right type. But we already parsed our Subjects and
			 * decided if they were hosts or users earlier (since it appears
			 * first in the cert).
			 *
			 * So we go through and mutate them into the right kind here if
			 * it doesn't match. This might not be hugely beneficial, as it
			 * seems that single-purpose certs are not often seen in the
			 * wild.
			 */
			if (cert.purposes.indexOf('serverAuth') !== -1 &&
			    cert.purposes.indexOf('clientAuth') === -1) {
				cert.subjects.forEach(function (ide) {
					if (ide.type !== 'host') {
						ide.type = 'host';
						ide.hostname = ide.uid ||
						    ide.email ||
						    ide.components[0].value;
					}
				});
			} else if (cert.purposes.indexOf('clientAuth') !== -1 &&
			    cert.purposes.indexOf('serverAuth') === -1) {
				cert.subjects.forEach(function (ide) {
					if (ide.type !== 'user') {
						ide.type = 'user';
						ide.uid = ide.hostname ||
						    ide.email ||
						    ide.components[0].value;
					}
				});
			}
			sig.extras.exts.push({ oid: extId, critical: critical });
			break;
		case (EXTS.keyUsage):
			der.readSequence(asn1.Ber.OctetString);
			var bits = der.readString(asn1.Ber.BitString, true);
			var setBits = readBitField(bits, KEYUSEBITS);
			setBits.forEach(function (bit) {
				if (cert.purposes === undefined)
					cert.purposes = [];
				if (cert.purposes.indexOf(bit) === -1)
					cert.purposes.push(bit);
			});
			sig.extras.exts.push({ oid: extId, critical: critical,
			    bits: bits });
			break;
		case (EXTS.altName):
			der.readSequence(asn1.Ber.OctetString);
			der.readSequence();
			var aeEnd = der.offset + der.length;
			while (der.offset < aeEnd) {
				switch (der.peek()) {
				case ALTNAME.OtherName:
				case ALTNAME.EDIPartyName:
					der.readSequence();
					der._offset += der.length;
					break;
				case ALTNAME.OID:
					der.readOID(ALTNAME.OID);
					break;
				case ALTNAME.RFC822Name:
					/* RFC822 specifies email addresses */
					var email = der.readString(ALTNAME.RFC822Name);
					id = Identity.forEmail(email);
					if (!cert.subjects[0].equals(id))
						cert.subjects.push(id);
					break;
				case ALTNAME.DirectoryName:
					der.readSequence(ALTNAME.DirectoryName);
					id = Identity.parseAsn1(der);
					if (!cert.subjects[0].equals(id))
						cert.subjects.push(id);
					break;
				case ALTNAME.DNSName:
					var host = der.readString(
					    ALTNAME.DNSName);
					id = Identity.forHost(host);
					if (!cert.subjects[0].equals(id))
						cert.subjects.push(id);
					break;
				default:
					der.readString(der.peek());
					break;
				}
			}
			sig.extras.exts.push({ oid: extId, critical: critical });
			break;
		default:
			sig.extras.exts.push({
				oid: extId,
				critical: critical,
				data: der.readString(asn1.Ber.OctetString, true)
			});
			break;
		}

		der._offset = after;
	}

	var UTCTIME_RE =
	    /^([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
	function utcTimeToDate(t) {
		var m = t.match(UTCTIME_RE);
		assert.ok(m, 'timestamps must be in UTC');
		var d = new Date();

		var thisYear = d.getUTCFullYear();
		var century = Math.floor(thisYear / 100) * 100;

		var year = parseInt(m[1], 10);
		if (thisYear % 100 < 50 && year >= 60)
			year += (century - 1);
		else
			year += century;
		d.setUTCFullYear(year, parseInt(m[2], 10) - 1, parseInt(m[3], 10));
		d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
		if (m[6] && m[6].length > 0)
			d.setUTCSeconds(parseInt(m[6], 10));
		return (d);
	}

	var GTIME_RE =
	    /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
	function gTimeToDate(t) {
		var m = t.match(GTIME_RE);
		assert.ok(m);
		var d = new Date();

		d.setUTCFullYear(parseInt(m[1], 10), parseInt(m[2], 10) - 1,
		    parseInt(m[3], 10));
		d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
		if (m[6] && m[6].length > 0)
			d.setUTCSeconds(parseInt(m[6], 10));
		return (d);
	}

	function zeroPad(n, m) {
		if (m === undefined)
			m = 2;
		var s = '' + n;
		while (s.length < m)
			s = '0' + s;
		return (s);
	}

	function dateToUTCTime(d) {
		var s = '';
		s += zeroPad(d.getUTCFullYear() % 100);
		s += zeroPad(d.getUTCMonth() + 1);
		s += zeroPad(d.getUTCDate());
		s += zeroPad(d.getUTCHours());
		s += zeroPad(d.getUTCMinutes());
		s += zeroPad(d.getUTCSeconds());
		s += 'Z';
		return (s);
	}

	function dateToGTime(d) {
		var s = '';
		s += zeroPad(d.getUTCFullYear(), 4);
		s += zeroPad(d.getUTCMonth() + 1);
		s += zeroPad(d.getUTCDate());
		s += zeroPad(d.getUTCHours());
		s += zeroPad(d.getUTCMinutes());
		s += zeroPad(d.getUTCSeconds());
		s += 'Z';
		return (s);
	}

	function sign(cert, key) {
		if (cert.signatures.x509 === undefined)
			cert.signatures.x509 = {};
		var sig = cert.signatures.x509;

		sig.algo = key.type + '-' + key.defaultHashAlgorithm();
		if (SIGN_ALGS[sig.algo] === undefined)
			return (false);

		var der = new asn1.BerWriter();
		writeTBSCert(cert, der);
		var blob = der.buffer;
		sig.cache = blob;

		var signer = key.createSign();
		signer.write(blob);
		cert.signatures.x509.signature = signer.sign();

		return (true);
	}

	function signAsync(cert, signer, done) {
		if (cert.signatures.x509 === undefined)
			cert.signatures.x509 = {};
		var sig = cert.signatures.x509;

		var der = new asn1.BerWriter();
		writeTBSCert(cert, der);
		var blob = der.buffer;
		sig.cache = blob;

		signer(blob, function (err, signature) {
			if (err) {
				done(err);
				return;
			}
			sig.algo = signature.type + '-' + signature.hashAlgorithm;
			if (SIGN_ALGS[sig.algo] === undefined) {
				done(new Error('Invalid signing algorithm "' +
				    sig.algo + '"'));
				return;
			}
			sig.signature = signature;
			done();
		});
	}

	function write(cert, options) {
		var sig = cert.signatures.x509;
		assert.object(sig, 'x509 signature');

		var der = new asn1.BerWriter();
		der.startSequence();
		if (sig.cache) {
			der._ensure(sig.cache.length);
			sig.cache.copy(der._buf, der._offset);
			der._offset += sig.cache.length;
		} else {
			writeTBSCert(cert, der);
		}

		der.startSequence();
		der.writeOID(SIGN_ALGS[sig.algo]);
		if (sig.algo.match(/^rsa-/))
			der.writeNull();
		der.endSequence();

		var sigData = sig.signature.toBuffer('asn1');
		var data = Buffer.alloc(sigData.length + 1);
		data[0] = 0;
		sigData.copy(data, 1);
		der.writeBuffer(data, asn1.Ber.BitString);
		der.endSequence();

		return (der.buffer);
	}

	function writeTBSCert(cert, der) {
		var sig = cert.signatures.x509;
		assert.object(sig, 'x509 signature');

		der.startSequence();

		der.startSequence(Local(0));
		der.writeInt(2);
		der.endSequence();

		der.writeBuffer(utils.mpNormalize(cert.serial), asn1.Ber.Integer);

		der.startSequence();
		der.writeOID(SIGN_ALGS[sig.algo]);
		if (sig.algo.match(/^rsa-/))
			der.writeNull();
		der.endSequence();

		cert.issuer.toAsn1(der);

		der.startSequence();
		writeDate(der, cert.validFrom);
		writeDate(der, cert.validUntil);
		der.endSequence();

		var subject = cert.subjects[0];
		var altNames = cert.subjects.slice(1);
		subject.toAsn1(der);

		pkcs8.writePkcs8(der, cert.subjectKey);

		if (sig.extras && sig.extras.issuerUniqueID) {
			der.writeBuffer(sig.extras.issuerUniqueID, Local(1));
		}

		if (sig.extras && sig.extras.subjectUniqueID) {
			der.writeBuffer(sig.extras.subjectUniqueID, Local(2));
		}

		if (altNames.length > 0 || subject.type === 'host' ||
		    (cert.purposes !== undefined && cert.purposes.length > 0) ||
		    (sig.extras && sig.extras.exts)) {
			der.startSequence(Local(3));
			der.startSequence();

			var exts = [];
			if (cert.purposes !== undefined && cert.purposes.length > 0) {
				exts.push({
					oid: EXTS.basicConstraints,
					critical: true
				});
				exts.push({
					oid: EXTS.keyUsage,
					critical: true
				});
				exts.push({
					oid: EXTS.extKeyUsage,
					critical: true
				});
			}
			exts.push({ oid: EXTS.altName });
			if (sig.extras && sig.extras.exts)
				exts = sig.extras.exts;

			for (var i = 0; i < exts.length; ++i) {
				der.startSequence();
				der.writeOID(exts[i].oid);

				if (exts[i].critical !== undefined)
					der.writeBoolean(exts[i].critical);

				if (exts[i].oid === EXTS.altName) {
					der.startSequence(asn1.Ber.OctetString);
					der.startSequence();
					if (subject.type === 'host') {
						der.writeString(subject.hostname,
						    Context(2));
					}
					for (var j = 0; j < altNames.length; ++j) {
						if (altNames[j].type === 'host') {
							der.writeString(
							    altNames[j].hostname,
							    ALTNAME.DNSName);
						} else if (altNames[j].type ===
						    'email') {
							der.writeString(
							    altNames[j].email,
							    ALTNAME.RFC822Name);
						} else {
							/*
							 * Encode anything else as a
							 * DN style name for now.
							 */
							der.startSequence(
							    ALTNAME.DirectoryName);
							altNames[j].toAsn1(der);
							der.endSequence();
						}
					}
					der.endSequence();
					der.endSequence();
				} else if (exts[i].oid === EXTS.basicConstraints) {
					der.startSequence(asn1.Ber.OctetString);
					der.startSequence();
					var ca = (cert.purposes.indexOf('ca') !== -1);
					var pathLen = exts[i].pathLen;
					der.writeBoolean(ca);
					if (pathLen !== undefined)
						der.writeInt(pathLen);
					der.endSequence();
					der.endSequence();
				} else if (exts[i].oid === EXTS.extKeyUsage) {
					der.startSequence(asn1.Ber.OctetString);
					der.startSequence();
					cert.purposes.forEach(function (purpose) {
						if (purpose === 'ca')
							return;
						if (KEYUSEBITS.indexOf(purpose) !== -1)
							return;
						var oid = purpose;
						if (EXTPURPOSE[purpose] !== undefined)
							oid = EXTPURPOSE[purpose];
						der.writeOID(oid);
					});
					der.endSequence();
					der.endSequence();
				} else if (exts[i].oid === EXTS.keyUsage) {
					der.startSequence(asn1.Ber.OctetString);
					/*
					 * If we parsed this certificate from a byte
					 * stream (i.e. we didn't generate it in sshpk)
					 * then we'll have a ".bits" property on the
					 * ext with the original raw byte contents.
					 *
					 * If we have this, use it here instead of
					 * regenerating it. This guarantees we output
					 * the same data we parsed, so signatures still
					 * validate.
					 */
					if (exts[i].bits !== undefined) {
						der.writeBuffer(exts[i].bits,
						    asn1.Ber.BitString);
					} else {
						var bits = writeBitField(cert.purposes,
						    KEYUSEBITS);
						der.writeBuffer(bits,
						    asn1.Ber.BitString);
					}
					der.endSequence();
				} else {
					der.writeBuffer(exts[i].data,
					    asn1.Ber.OctetString);
				}

				der.endSequence();
			}

			der.endSequence();
			der.endSequence();
		}

		der.endSequence();
	}

	/*
	 * Reads an ASN.1 BER bitfield out of the Buffer produced by doing
	 * `BerReader#readString(asn1.Ber.BitString)`. That function gives us the raw
	 * contents of the BitString tag, which is a count of unused bits followed by
	 * the bits as a right-padded byte string.
	 *
	 * `bits` is the Buffer, `bitIndex` should contain an array of string names
	 * for the bits in the string, ordered starting with bit #0 in the ASN.1 spec.
	 *
	 * Returns an array of Strings, the names of the bits that were set to 1.
	 */
	function readBitField(bits, bitIndex) {
		var bitLen = 8 * (bits.length - 1) - bits[0];
		var setBits = {};
		for (var i = 0; i < bitLen; ++i) {
			var byteN = 1 + Math.floor(i / 8);
			var bit = 7 - (i % 8);
			var mask = 1 << bit;
			var bitVal = ((bits[byteN] & mask) !== 0);
			var name = bitIndex[i];
			if (bitVal && typeof (name) === 'string') {
				setBits[name] = true;
			}
		}
		return (Object.keys(setBits));
	}

	/*
	 * `setBits` is an array of strings, containing the names for each bit that
	 * sould be set to 1. `bitIndex` is same as in `readBitField()`.
	 *
	 * Returns a Buffer, ready to be written out with `BerWriter#writeString()`.
	 */
	function writeBitField(setBits, bitIndex) {
		var bitLen = bitIndex.length;
		var blen = Math.ceil(bitLen / 8);
		var unused = blen * 8 - bitLen;
		var bits = Buffer.alloc(1 + blen); // zero-filled
		bits[0] = unused;
		for (var i = 0; i < bitLen; ++i) {
			var byteN = 1 + Math.floor(i / 8);
			var bit = 7 - (i % 8);
			var mask = 1 << bit;
			var name = bitIndex[i];
			if (name === undefined)
				continue;
			var bitVal = (setBits.indexOf(name) !== -1);
			if (bitVal) {
				bits[byteN] |= mask;
			}
		}
		return (bits);
	}
	return x509;
}

var x509Pem;
var hasRequiredX509Pem;

function requireX509Pem () {
	if (hasRequiredX509Pem) return x509Pem;
	hasRequiredX509Pem = 1;
	// Copyright 2016 Joyent, Inc.

	var x509 = requireX509();

	x509Pem = {
		read: read,
		verify: x509.verify,
		sign: x509.sign,
		write: write
	};

	var assert = requireAssert();
	requireLib$9();
	var Buffer = requireSafer().Buffer;
	requireAlgs();
	requireUtils$5();
	requireKey();
	requirePrivateKey();
	requirePem();
	requireIdentity();
	requireSignature();
	requireCertificate();

	function read(buf, options) {
		if (typeof (buf) !== 'string') {
			assert.buffer(buf, 'buf');
			buf = buf.toString('ascii');
		}

		var lines = buf.trim().split(/[\r\n]+/g);

		var m;
		var si = -1;
		while (!m && si < lines.length) {
			m = lines[++si].match(/*JSSTYLED*/
			    /[-]+[ ]*BEGIN CERTIFICATE[ ]*[-]+/);
		}
		assert.ok(m, 'invalid PEM header');

		var m2;
		var ei = lines.length;
		while (!m2 && ei > 0) {
			m2 = lines[--ei].match(/*JSSTYLED*/
			    /[-]+[ ]*END CERTIFICATE[ ]*[-]+/);
		}
		assert.ok(m2, 'invalid PEM footer');

		lines = lines.slice(si, ei + 1);

		var headers = {};
		while (true) {
			lines = lines.slice(1);
			m = lines[0].match(/*JSSTYLED*/
			    /^([A-Za-z0-9-]+): (.+)$/);
			if (!m)
				break;
			headers[m[1].toLowerCase()] = m[2];
		}

		/* Chop off the first and last lines */
		lines = lines.slice(0, -1).join('');
		buf = Buffer.from(lines, 'base64');

		return (x509.read(buf, options));
	}

	function write(cert, options) {
		var dbuf = x509.write(cert, options);

		var header = 'CERTIFICATE';
		var tmp = dbuf.toString('base64');
		var len = tmp.length + (tmp.length / 64) +
		    18 + 16 + header.length*2 + 10;
		var buf = Buffer.alloc(len);
		var o = 0;
		o += buf.write('-----BEGIN ' + header + '-----\n', o);
		for (var i = 0; i < tmp.length; ) {
			var limit = i + 64;
			if (limit > tmp.length)
				limit = tmp.length;
			o += buf.write(tmp.slice(i, limit), o);
			buf[o++] = 10;
			i = limit;
		}
		o += buf.write('-----END ' + header + '-----\n', o);

		return (buf.slice(0, o));
	}
	return x509Pem;
}

var certificate;
var hasRequiredCertificate;

function requireCertificate () {
	if (hasRequiredCertificate) return certificate;
	hasRequiredCertificate = 1;
	// Copyright 2016 Joyent, Inc.

	certificate = Certificate;

	var assert = requireAssert();
	var Buffer = requireSafer().Buffer;
	var algs = requireAlgs();
	var crypto = require$$0$5;
	var Fingerprint = requireFingerprint();
	requireSignature();
	var errs = requireErrors$1();
	var utils = requireUtils$5();
	var Key = requireKey();
	var PrivateKey = requirePrivateKey();
	var Identity = requireIdentity();

	var formats = {};
	formats['openssh'] = requireOpensshCert();
	formats['x509'] = requireX509();
	formats['pem'] = requireX509Pem();

	var CertificateParseError = errs.CertificateParseError;
	var InvalidAlgorithmError = errs.InvalidAlgorithmError;

	function Certificate(opts) {
		assert.object(opts, 'options');
		assert.arrayOfObject(opts.subjects, 'options.subjects');
		utils.assertCompatible(opts.subjects[0], Identity, [1, 0],
		    'options.subjects');
		utils.assertCompatible(opts.subjectKey, Key, [1, 0],
		    'options.subjectKey');
		utils.assertCompatible(opts.issuer, Identity, [1, 0], 'options.issuer');
		if (opts.issuerKey !== undefined) {
			utils.assertCompatible(opts.issuerKey, Key, [1, 0],
			    'options.issuerKey');
		}
		assert.object(opts.signatures, 'options.signatures');
		assert.buffer(opts.serial, 'options.serial');
		assert.date(opts.validFrom, 'options.validFrom');
		assert.date(opts.validUntil, 'optons.validUntil');

		assert.optionalArrayOfString(opts.purposes, 'options.purposes');

		this._hashCache = {};

		this.subjects = opts.subjects;
		this.issuer = opts.issuer;
		this.subjectKey = opts.subjectKey;
		this.issuerKey = opts.issuerKey;
		this.signatures = opts.signatures;
		this.serial = opts.serial;
		this.validFrom = opts.validFrom;
		this.validUntil = opts.validUntil;
		this.purposes = opts.purposes;
	}

	Certificate.formats = formats;

	Certificate.prototype.toBuffer = function (format, options) {
		if (format === undefined)
			format = 'x509';
		assert.string(format, 'format');
		assert.object(formats[format], 'formats[format]');
		assert.optionalObject(options, 'options');

		return (formats[format].write(this, options));
	};

	Certificate.prototype.toString = function (format, options) {
		if (format === undefined)
			format = 'pem';
		return (this.toBuffer(format, options).toString());
	};

	Certificate.prototype.fingerprint = function (algo) {
		if (algo === undefined)
			algo = 'sha256';
		assert.string(algo, 'algorithm');
		var opts = {
			type: 'certificate',
			hash: this.hash(algo),
			algorithm: algo
		};
		return (new Fingerprint(opts));
	};

	Certificate.prototype.hash = function (algo) {
		assert.string(algo, 'algorithm');
		algo = algo.toLowerCase();
		if (algs.hashAlgs[algo] === undefined)
			throw (new InvalidAlgorithmError(algo));

		if (this._hashCache[algo])
			return (this._hashCache[algo]);

		var hash = crypto.createHash(algo).
		    update(this.toBuffer('x509')).digest();
		this._hashCache[algo] = hash;
		return (hash);
	};

	Certificate.prototype.isExpired = function (when) {
		if (when === undefined)
			when = new Date();
		return (!((when.getTime() >= this.validFrom.getTime()) &&
			(when.getTime() < this.validUntil.getTime())));
	};

	Certificate.prototype.isSignedBy = function (issuerCert) {
		utils.assertCompatible(issuerCert, Certificate, [1, 0], 'issuer');

		if (!this.issuer.equals(issuerCert.subjects[0]))
			return (false);
		if (this.issuer.purposes && this.issuer.purposes.length > 0 &&
		    this.issuer.purposes.indexOf('ca') === -1) {
			return (false);
		}

		return (this.isSignedByKey(issuerCert.subjectKey));
	};

	Certificate.prototype.getExtension = function (keyOrOid) {
		assert.string(keyOrOid, 'keyOrOid');
		var ext = this.getExtensions().filter(function (maybeExt) {
			if (maybeExt.format === 'x509')
				return (maybeExt.oid === keyOrOid);
			if (maybeExt.format === 'openssh')
				return (maybeExt.name === keyOrOid);
			return (false);
		})[0];
		return (ext);
	};

	Certificate.prototype.getExtensions = function () {
		var exts = [];
		var x509 = this.signatures.x509;
		if (x509 && x509.extras && x509.extras.exts) {
			x509.extras.exts.forEach(function (ext) {
				ext.format = 'x509';
				exts.push(ext);
			});
		}
		var openssh = this.signatures.openssh;
		if (openssh && openssh.exts) {
			openssh.exts.forEach(function (ext) {
				ext.format = 'openssh';
				exts.push(ext);
			});
		}
		return (exts);
	};

	Certificate.prototype.isSignedByKey = function (issuerKey) {
		utils.assertCompatible(issuerKey, Key, [1, 2], 'issuerKey');

		if (this.issuerKey !== undefined) {
			return (this.issuerKey.
			    fingerprint('sha512').matches(issuerKey));
		}

		var fmt = Object.keys(this.signatures)[0];
		var valid = formats[fmt].verify(this, issuerKey);
		if (valid)
			this.issuerKey = issuerKey;
		return (valid);
	};

	Certificate.prototype.signWith = function (key) {
		utils.assertCompatible(key, PrivateKey, [1, 2], 'key');
		var fmts = Object.keys(formats);
		var didOne = false;
		for (var i = 0; i < fmts.length; ++i) {
			if (fmts[i] !== 'pem') {
				var ret = formats[fmts[i]].sign(this, key);
				if (ret === true)
					didOne = true;
			}
		}
		if (!didOne) {
			throw (new Error('Failed to sign the certificate for any ' +
			    'available certificate formats'));
		}
	};

	Certificate.createSelfSigned = function (subjectOrSubjects, key, options) {
		var subjects;
		if (Array.isArray(subjectOrSubjects))
			subjects = subjectOrSubjects;
		else
			subjects = [subjectOrSubjects];

		assert.arrayOfObject(subjects);
		subjects.forEach(function (subject) {
			utils.assertCompatible(subject, Identity, [1, 0], 'subject');
		});

		utils.assertCompatible(key, PrivateKey, [1, 2], 'private key');

		assert.optionalObject(options, 'options');
		if (options === undefined)
			options = {};
		assert.optionalObject(options.validFrom, 'options.validFrom');
		assert.optionalObject(options.validUntil, 'options.validUntil');
		var validFrom = options.validFrom;
		var validUntil = options.validUntil;
		if (validFrom === undefined)
			validFrom = new Date();
		if (validUntil === undefined) {
			assert.optionalNumber(options.lifetime, 'options.lifetime');
			var lifetime = options.lifetime;
			if (lifetime === undefined)
				lifetime = 10*365*24*3600;
			validUntil = new Date();
			validUntil.setTime(validUntil.getTime() + lifetime*1000);
		}
		assert.optionalBuffer(options.serial, 'options.serial');
		var serial = options.serial;
		if (serial === undefined)
			serial = Buffer.from('0000000000000001', 'hex');

		var purposes = options.purposes;
		if (purposes === undefined)
			purposes = [];

		if (purposes.indexOf('signature') === -1)
			purposes.push('signature');

		/* Self-signed certs are always CAs. */
		if (purposes.indexOf('ca') === -1)
			purposes.push('ca');
		if (purposes.indexOf('crl') === -1)
			purposes.push('crl');

		/*
		 * If we weren't explicitly given any other purposes, do the sensible
		 * thing and add some basic ones depending on the subject type.
		 */
		if (purposes.length <= 3) {
			var hostSubjects = subjects.filter(function (subject) {
				return (subject.type === 'host');
			});
			var userSubjects = subjects.filter(function (subject) {
				return (subject.type === 'user');
			});
			if (hostSubjects.length > 0) {
				if (purposes.indexOf('serverAuth') === -1)
					purposes.push('serverAuth');
			}
			if (userSubjects.length > 0) {
				if (purposes.indexOf('clientAuth') === -1)
					purposes.push('clientAuth');
			}
			if (userSubjects.length > 0 || hostSubjects.length > 0) {
				if (purposes.indexOf('keyAgreement') === -1)
					purposes.push('keyAgreement');
				if (key.type === 'rsa' &&
				    purposes.indexOf('encryption') === -1)
					purposes.push('encryption');
			}
		}

		var cert = new Certificate({
			subjects: subjects,
			issuer: subjects[0],
			subjectKey: key.toPublic(),
			issuerKey: key.toPublic(),
			signatures: {},
			serial: serial,
			validFrom: validFrom,
			validUntil: validUntil,
			purposes: purposes
		});
		cert.signWith(key);

		return (cert);
	};

	Certificate.create =
	    function (subjectOrSubjects, key, issuer, issuerKey, options) {
		var subjects;
		if (Array.isArray(subjectOrSubjects))
			subjects = subjectOrSubjects;
		else
			subjects = [subjectOrSubjects];

		assert.arrayOfObject(subjects);
		subjects.forEach(function (subject) {
			utils.assertCompatible(subject, Identity, [1, 0], 'subject');
		});

		utils.assertCompatible(key, Key, [1, 0], 'key');
		if (PrivateKey.isPrivateKey(key))
			key = key.toPublic();
		utils.assertCompatible(issuer, Identity, [1, 0], 'issuer');
		utils.assertCompatible(issuerKey, PrivateKey, [1, 2], 'issuer key');

		assert.optionalObject(options, 'options');
		if (options === undefined)
			options = {};
		assert.optionalObject(options.validFrom, 'options.validFrom');
		assert.optionalObject(options.validUntil, 'options.validUntil');
		var validFrom = options.validFrom;
		var validUntil = options.validUntil;
		if (validFrom === undefined)
			validFrom = new Date();
		if (validUntil === undefined) {
			assert.optionalNumber(options.lifetime, 'options.lifetime');
			var lifetime = options.lifetime;
			if (lifetime === undefined)
				lifetime = 10*365*24*3600;
			validUntil = new Date();
			validUntil.setTime(validUntil.getTime() + lifetime*1000);
		}
		assert.optionalBuffer(options.serial, 'options.serial');
		var serial = options.serial;
		if (serial === undefined)
			serial = Buffer.from('0000000000000001', 'hex');

		var purposes = options.purposes;
		if (purposes === undefined)
			purposes = [];

		if (purposes.indexOf('signature') === -1)
			purposes.push('signature');

		if (options.ca === true) {
			if (purposes.indexOf('ca') === -1)
				purposes.push('ca');
			if (purposes.indexOf('crl') === -1)
				purposes.push('crl');
		}

		var hostSubjects = subjects.filter(function (subject) {
			return (subject.type === 'host');
		});
		var userSubjects = subjects.filter(function (subject) {
			return (subject.type === 'user');
		});
		if (hostSubjects.length > 0) {
			if (purposes.indexOf('serverAuth') === -1)
				purposes.push('serverAuth');
		}
		if (userSubjects.length > 0) {
			if (purposes.indexOf('clientAuth') === -1)
				purposes.push('clientAuth');
		}
		if (userSubjects.length > 0 || hostSubjects.length > 0) {
			if (purposes.indexOf('keyAgreement') === -1)
				purposes.push('keyAgreement');
			if (key.type === 'rsa' &&
			    purposes.indexOf('encryption') === -1)
				purposes.push('encryption');
		}

		var cert = new Certificate({
			subjects: subjects,
			issuer: issuer,
			subjectKey: key,
			issuerKey: issuerKey.toPublic(),
			signatures: {},
			serial: serial,
			validFrom: validFrom,
			validUntil: validUntil,
			purposes: purposes
		});
		cert.signWith(issuerKey);

		return (cert);
	};

	Certificate.parse = function (data, format, options) {
		if (typeof (data) !== 'string')
			assert.buffer(data, 'data');
		if (format === undefined)
			format = 'auto';
		assert.string(format, 'format');
		if (typeof (options) === 'string')
			options = { filename: options };
		assert.optionalObject(options, 'options');
		if (options === undefined)
			options = {};
		assert.optionalString(options.filename, 'options.filename');
		if (options.filename === undefined)
			options.filename = '(unnamed)';

		assert.object(formats[format], 'formats[format]');

		try {
			var k = formats[format].read(data, options);
			return (k);
		} catch (e) {
			throw (new CertificateParseError(options.filename, format, e));
		}
	};

	Certificate.isCertificate = function (obj, ver) {
		return (utils.isCompatible(obj, Certificate, ver));
	};

	/*
	 * API versions for Certificate:
	 * [1,0] -- initial ver
	 * [1,1] -- openssh format now unpacks extensions
	 */
	Certificate.prototype._sshpkApiVersion = [1, 1];

	Certificate._oldVersionDetect = function (obj) {
		return ([1, 0]);
	};
	return certificate;
}

var fingerprint;
var hasRequiredFingerprint;

function requireFingerprint () {
	if (hasRequiredFingerprint) return fingerprint;
	hasRequiredFingerprint = 1;
	// Copyright 2018 Joyent, Inc.

	fingerprint = Fingerprint;

	var assert = requireAssert();
	var Buffer = requireSafer().Buffer;
	var algs = requireAlgs();
	var crypto = require$$0$5;
	var errs = requireErrors$1();
	var Key = requireKey();
	var PrivateKey = requirePrivateKey();
	var Certificate = requireCertificate();
	var utils = requireUtils$5();

	var FingerprintFormatError = errs.FingerprintFormatError;
	var InvalidAlgorithmError = errs.InvalidAlgorithmError;

	function Fingerprint(opts) {
		assert.object(opts, 'options');
		assert.string(opts.type, 'options.type');
		assert.buffer(opts.hash, 'options.hash');
		assert.string(opts.algorithm, 'options.algorithm');

		this.algorithm = opts.algorithm.toLowerCase();
		if (algs.hashAlgs[this.algorithm] !== true)
			throw (new InvalidAlgorithmError(this.algorithm));

		this.hash = opts.hash;
		this.type = opts.type;
		this.hashType = opts.hashType;
	}

	Fingerprint.prototype.toString = function (format) {
		if (format === undefined) {
			if (this.algorithm === 'md5' || this.hashType === 'spki')
				format = 'hex';
			else
				format = 'base64';
		}
		assert.string(format);

		switch (format) {
		case 'hex':
			if (this.hashType === 'spki')
				return (this.hash.toString('hex'));
			return (addColons(this.hash.toString('hex')));
		case 'base64':
			if (this.hashType === 'spki')
				return (this.hash.toString('base64'));
			return (sshBase64Format(this.algorithm,
			    this.hash.toString('base64')));
		default:
			throw (new FingerprintFormatError(undefined, format));
		}
	};

	Fingerprint.prototype.matches = function (other) {
		assert.object(other, 'key or certificate');
		if (this.type === 'key' && this.hashType !== 'ssh') {
			utils.assertCompatible(other, Key, [1, 7], 'key with spki');
			if (PrivateKey.isPrivateKey(other)) {
				utils.assertCompatible(other, PrivateKey, [1, 6],
				    'privatekey with spki support');
			}
		} else if (this.type === 'key') {
			utils.assertCompatible(other, Key, [1, 0], 'key');
		} else {
			utils.assertCompatible(other, Certificate, [1, 0],
			    'certificate');
		}

		var theirHash = other.hash(this.algorithm, this.hashType);
		var theirHash2 = crypto.createHash(this.algorithm).
		    update(theirHash).digest('base64');

		if (this.hash2 === undefined)
			this.hash2 = crypto.createHash(this.algorithm).
			    update(this.hash).digest('base64');

		return (this.hash2 === theirHash2);
	};

	/*JSSTYLED*/
	var base64RE = /^[A-Za-z0-9+\/=]+$/;
	/*JSSTYLED*/
	var hexRE = /^[a-fA-F0-9]+$/;

	Fingerprint.parse = function (fp, options) {
		assert.string(fp, 'fingerprint');

		var alg, hash, enAlgs;
		if (Array.isArray(options)) {
			enAlgs = options;
			options = {};
		}
		assert.optionalObject(options, 'options');
		if (options === undefined)
			options = {};
		if (options.enAlgs !== undefined)
			enAlgs = options.enAlgs;
		if (options.algorithms !== undefined)
			enAlgs = options.algorithms;
		assert.optionalArrayOfString(enAlgs, 'algorithms');

		var hashType = 'ssh';
		if (options.hashType !== undefined)
			hashType = options.hashType;
		assert.string(hashType, 'options.hashType');

		var parts = fp.split(':');
		if (parts.length == 2) {
			alg = parts[0].toLowerCase();
			if (!base64RE.test(parts[1]))
				throw (new FingerprintFormatError(fp));
			try {
				hash = Buffer.from(parts[1], 'base64');
			} catch (e) {
				throw (new FingerprintFormatError(fp));
			}
		} else if (parts.length > 2) {
			alg = 'md5';
			if (parts[0].toLowerCase() === 'md5')
				parts = parts.slice(1);
			parts = parts.map(function (p) {
				while (p.length < 2)
					p = '0' + p;
				if (p.length > 2)
					throw (new FingerprintFormatError(fp));
				return (p);
			});
			parts = parts.join('');
			if (!hexRE.test(parts) || parts.length % 2 !== 0)
				throw (new FingerprintFormatError(fp));
			try {
				hash = Buffer.from(parts, 'hex');
			} catch (e) {
				throw (new FingerprintFormatError(fp));
			}
		} else {
			if (hexRE.test(fp)) {
				hash = Buffer.from(fp, 'hex');
			} else if (base64RE.test(fp)) {
				hash = Buffer.from(fp, 'base64');
			} else {
				throw (new FingerprintFormatError(fp));
			}

			switch (hash.length) {
			case 32:
				alg = 'sha256';
				break;
			case 16:
				alg = 'md5';
				break;
			case 20:
				alg = 'sha1';
				break;
			case 64:
				alg = 'sha512';
				break;
			default:
				throw (new FingerprintFormatError(fp));
			}

			/* Plain hex/base64: guess it's probably SPKI unless told. */
			if (options.hashType === undefined)
				hashType = 'spki';
		}

		if (alg === undefined)
			throw (new FingerprintFormatError(fp));

		if (algs.hashAlgs[alg] === undefined)
			throw (new InvalidAlgorithmError(alg));

		if (enAlgs !== undefined) {
			enAlgs = enAlgs.map(function (a) { return a.toLowerCase(); });
			if (enAlgs.indexOf(alg) === -1)
				throw (new InvalidAlgorithmError(alg));
		}

		return (new Fingerprint({
			algorithm: alg,
			hash: hash,
			type: options.type || 'key',
			hashType: hashType
		}));
	};

	function addColons(s) {
		/*JSSTYLED*/
		return (s.replace(/(.{2})(?=.)/g, '$1:'));
	}

	function base64Strip(s) {
		/*JSSTYLED*/
		return (s.replace(/=*$/, ''));
	}

	function sshBase64Format(alg, h) {
		return (alg.toUpperCase() + ':' + base64Strip(h));
	}

	Fingerprint.isFingerprint = function (obj, ver) {
		return (utils.isCompatible(obj, Fingerprint, ver));
	};

	/*
	 * API versions for Fingerprint:
	 * [1,0] -- initial ver
	 * [1,1] -- first tagged ver
	 * [1,2] -- hashType and spki support
	 */
	Fingerprint.prototype._sshpkApiVersion = [1, 2];

	Fingerprint._oldVersionDetect = function (obj) {
		assert.func(obj.toString);
		assert.func(obj.matches);
		return ([1, 0]);
	};
	return fingerprint;
}

var key;
var hasRequiredKey;

function requireKey () {
	if (hasRequiredKey) return key;
	hasRequiredKey = 1;
	// Copyright 2018 Joyent, Inc.

	key = Key;

	var assert = requireAssert();
	var algs = requireAlgs();
	var crypto = require$$0$5;
	var Fingerprint = requireFingerprint();
	var Signature = requireSignature();
	var DiffieHellman = requireDhe().DiffieHellman;
	var errs = requireErrors$1();
	var utils = requireUtils$5();
	var PrivateKey = requirePrivateKey();
	var edCompat;

	try {
		edCompat = requireEdCompat();
	} catch (e) {
		/* Just continue through, and bail out if we try to use it. */
	}

	var InvalidAlgorithmError = errs.InvalidAlgorithmError;
	var KeyParseError = errs.KeyParseError;

	var formats = {};
	formats['auto'] = requireAuto();
	formats['pem'] = requirePem();
	formats['pkcs1'] = requirePkcs1();
	formats['pkcs8'] = requirePkcs8();
	formats['rfc4253'] = requireRfc4253();
	formats['ssh'] = requireSsh();
	formats['ssh-private'] = requireSshPrivate();
	formats['openssh'] = formats['ssh-private'];
	formats['dnssec'] = requireDnssec();
	formats['putty'] = requirePutty();
	formats['ppk'] = formats['putty'];

	function Key(opts) {
		assert.object(opts, 'options');
		assert.arrayOfObject(opts.parts, 'options.parts');
		assert.string(opts.type, 'options.type');
		assert.optionalString(opts.comment, 'options.comment');

		var algInfo = algs.info[opts.type];
		if (typeof (algInfo) !== 'object')
			throw (new InvalidAlgorithmError(opts.type));

		var partLookup = {};
		for (var i = 0; i < opts.parts.length; ++i) {
			var part = opts.parts[i];
			partLookup[part.name] = part;
		}

		this.type = opts.type;
		this.parts = opts.parts;
		this.part = partLookup;
		this.comment = undefined;
		this.source = opts.source;

		/* for speeding up hashing/fingerprint operations */
		this._rfc4253Cache = opts._rfc4253Cache;
		this._hashCache = {};

		var sz;
		this.curve = undefined;
		if (this.type === 'ecdsa') {
			var curve = this.part.curve.data.toString();
			this.curve = curve;
			sz = algs.curves[curve].size;
		} else if (this.type === 'ed25519' || this.type === 'curve25519') {
			sz = 256;
			this.curve = 'curve25519';
		} else {
			var szPart = this.part[algInfo.sizePart];
			sz = szPart.data.length;
			sz = sz * 8 - utils.countZeros(szPart.data);
		}
		this.size = sz;
	}

	Key.formats = formats;

	Key.prototype.toBuffer = function (format, options) {
		if (format === undefined)
			format = 'ssh';
		assert.string(format, 'format');
		assert.object(formats[format], 'formats[format]');
		assert.optionalObject(options, 'options');

		if (format === 'rfc4253') {
			if (this._rfc4253Cache === undefined)
				this._rfc4253Cache = formats['rfc4253'].write(this);
			return (this._rfc4253Cache);
		}

		return (formats[format].write(this, options));
	};

	Key.prototype.toString = function (format, options) {
		return (this.toBuffer(format, options).toString());
	};

	Key.prototype.hash = function (algo, type) {
		assert.string(algo, 'algorithm');
		assert.optionalString(type, 'type');
		if (type === undefined)
			type = 'ssh';
		algo = algo.toLowerCase();
		if (algs.hashAlgs[algo] === undefined)
			throw (new InvalidAlgorithmError(algo));

		var cacheKey = algo + '||' + type;
		if (this._hashCache[cacheKey])
			return (this._hashCache[cacheKey]);

		var buf;
		if (type === 'ssh') {
			buf = this.toBuffer('rfc4253');
		} else if (type === 'spki') {
			buf = formats.pkcs8.pkcs8ToBuffer(this);
		} else {
			throw (new Error('Hash type ' + type + ' not supported'));
		}
		var hash = crypto.createHash(algo).update(buf).digest();
		this._hashCache[cacheKey] = hash;
		return (hash);
	};

	Key.prototype.fingerprint = function (algo, type) {
		if (algo === undefined)
			algo = 'sha256';
		if (type === undefined)
			type = 'ssh';
		assert.string(algo, 'algorithm');
		assert.string(type, 'type');
		var opts = {
			type: 'key',
			hash: this.hash(algo, type),
			algorithm: algo,
			hashType: type
		};
		return (new Fingerprint(opts));
	};

	Key.prototype.defaultHashAlgorithm = function () {
		var hashAlgo = 'sha1';
		if (this.type === 'rsa')
			hashAlgo = 'sha256';
		if (this.type === 'dsa' && this.size > 1024)
			hashAlgo = 'sha256';
		if (this.type === 'ed25519')
			hashAlgo = 'sha512';
		if (this.type === 'ecdsa') {
			if (this.size <= 256)
				hashAlgo = 'sha256';
			else if (this.size <= 384)
				hashAlgo = 'sha384';
			else
				hashAlgo = 'sha512';
		}
		return (hashAlgo);
	};

	Key.prototype.createVerify = function (hashAlgo) {
		if (hashAlgo === undefined)
			hashAlgo = this.defaultHashAlgorithm();
		assert.string(hashAlgo, 'hash algorithm');

		/* ED25519 is not supported by OpenSSL, use a javascript impl. */
		if (this.type === 'ed25519' && edCompat !== undefined)
			return (new edCompat.Verifier(this, hashAlgo));
		if (this.type === 'curve25519')
			throw (new Error('Curve25519 keys are not suitable for ' +
			    'signing or verification'));

		var v, nm, err;
		try {
			nm = hashAlgo.toUpperCase();
			v = crypto.createVerify(nm);
		} catch (e) {
			err = e;
		}
		if (v === undefined || (err instanceof Error &&
		    err.message.match(/Unknown message digest/))) {
			nm = 'RSA-';
			nm += hashAlgo.toUpperCase();
			v = crypto.createVerify(nm);
		}
		assert.ok(v, 'failed to create verifier');
		var oldVerify = v.verify.bind(v);
		var key = this.toBuffer('pkcs8');
		var curve = this.curve;
		var self = this;
		v.verify = function (signature, fmt) {
			if (Signature.isSignature(signature, [2, 0])) {
				if (signature.type !== self.type)
					return (false);
				if (signature.hashAlgorithm &&
				    signature.hashAlgorithm !== hashAlgo)
					return (false);
				if (signature.curve && self.type === 'ecdsa' &&
				    signature.curve !== curve)
					return (false);
				return (oldVerify(key, signature.toBuffer('asn1')));

			} else if (typeof (signature) === 'string' ||
			    Buffer.isBuffer(signature)) {
				return (oldVerify(key, signature, fmt));

			/*
			 * Avoid doing this on valid arguments, walking the prototype
			 * chain can be quite slow.
			 */
			} else if (Signature.isSignature(signature, [1, 0])) {
				throw (new Error('signature was created by too old ' +
				    'a version of sshpk and cannot be verified'));

			} else {
				throw (new TypeError('signature must be a string, ' +
				    'Buffer, or Signature object'));
			}
		};
		return (v);
	};

	Key.prototype.createDiffieHellman = function () {
		if (this.type === 'rsa')
			throw (new Error('RSA keys do not support Diffie-Hellman'));

		return (new DiffieHellman(this));
	};
	Key.prototype.createDH = Key.prototype.createDiffieHellman;

	Key.parse = function (data, format, options) {
		if (typeof (data) !== 'string')
			assert.buffer(data, 'data');
		if (format === undefined)
			format = 'auto';
		assert.string(format, 'format');
		if (typeof (options) === 'string')
			options = { filename: options };
		assert.optionalObject(options, 'options');
		if (options === undefined)
			options = {};
		assert.optionalString(options.filename, 'options.filename');
		if (options.filename === undefined)
			options.filename = '(unnamed)';

		assert.object(formats[format], 'formats[format]');

		try {
			var k = formats[format].read(data, options);
			if (k instanceof PrivateKey)
				k = k.toPublic();
			if (!k.comment)
				k.comment = options.filename;
			return (k);
		} catch (e) {
			if (e.name === 'KeyEncryptedError')
				throw (e);
			throw (new KeyParseError(options.filename, format, e));
		}
	};

	Key.isKey = function (obj, ver) {
		return (utils.isCompatible(obj, Key, ver));
	};

	/*
	 * API versions for Key:
	 * [1,0] -- initial ver, may take Signature for createVerify or may not
	 * [1,1] -- added pkcs1, pkcs8 formats
	 * [1,2] -- added auto, ssh-private, openssh formats
	 * [1,3] -- added defaultHashAlgorithm
	 * [1,4] -- added ed support, createDH
	 * [1,5] -- first explicitly tagged version
	 * [1,6] -- changed ed25519 part names
	 * [1,7] -- spki hash types
	 */
	Key.prototype._sshpkApiVersion = [1, 7];

	Key._oldVersionDetect = function (obj) {
		assert.func(obj.toBuffer);
		assert.func(obj.fingerprint);
		if (obj.createDH)
			return ([1, 4]);
		if (obj.defaultHashAlgorithm)
			return ([1, 3]);
		if (obj.formats['auto'])
			return ([1, 2]);
		if (obj.formats['pkcs1'])
			return ([1, 1]);
		return ([1, 0]);
	};
	return key;
}

var lib$8;
var hasRequiredLib$8;

function requireLib$8 () {
	if (hasRequiredLib$8) return lib$8;
	hasRequiredLib$8 = 1;
	// Copyright 2015 Joyent, Inc.

	var Key = requireKey();
	var Fingerprint = requireFingerprint();
	var Signature = requireSignature();
	var PrivateKey = requirePrivateKey();
	var Certificate = requireCertificate();
	var Identity = requireIdentity();
	var errs = requireErrors$1();

	lib$8 = {
		/* top-level classes */
		Key: Key,
		parseKey: Key.parse,
		Fingerprint: Fingerprint,
		parseFingerprint: Fingerprint.parse,
		Signature: Signature,
		parseSignature: Signature.parse,
		PrivateKey: PrivateKey,
		parsePrivateKey: PrivateKey.parse,
		generatePrivateKey: PrivateKey.generate,
		Certificate: Certificate,
		parseCertificate: Certificate.parse,
		createSelfSignedCertificate: Certificate.createSelfSigned,
		createCertificate: Certificate.create,
		Identity: Identity,
		identityFromDN: Identity.parseDN,
		identityForHost: Identity.forHost,
		identityForUser: Identity.forUser,
		identityForEmail: Identity.forEmail,
		identityFromArray: Identity.fromArray,

		/* errors */
		FingerprintFormatError: errs.FingerprintFormatError,
		InvalidAlgorithmError: errs.InvalidAlgorithmError,
		KeyParseError: errs.KeyParseError,
		SignatureParseError: errs.SignatureParseError,
		KeyEncryptedError: errs.KeyEncryptedError,
		CertificateParseError: errs.CertificateParseError
	};
	return lib$8;
}

var utils$4;
var hasRequiredUtils$4;

function requireUtils$4 () {
	if (hasRequiredUtils$4) return utils$4;
	hasRequiredUtils$4 = 1;
	// Copyright 2012 Joyent, Inc.  All rights reserved.

	var assert = requireAssert();
	var sshpk = requireLib$8();
	var util = require$$1$2;

	var HASH_ALGOS = {
	  'sha1': true,
	  'sha256': true,
	  'sha512': true
	};

	var PK_ALGOS = {
	  'rsa': true,
	  'dsa': true,
	  'ecdsa': true
	};

	function HttpSignatureError(message, caller) {
	  if (Error.captureStackTrace)
	    Error.captureStackTrace(this, caller || HttpSignatureError);

	  this.message = message;
	  this.name = caller.name;
	}
	util.inherits(HttpSignatureError, Error);

	function InvalidAlgorithmError(message) {
	  HttpSignatureError.call(this, message, InvalidAlgorithmError);
	}
	util.inherits(InvalidAlgorithmError, HttpSignatureError);

	function validateAlgorithm(algorithm) {
	  var alg = algorithm.toLowerCase().split('-');

	  if (alg.length !== 2) {
	    throw (new InvalidAlgorithmError(alg[0].toUpperCase() + ' is not a ' +
	      'valid algorithm'));
	  }

	  if (alg[0] !== 'hmac' && !PK_ALGOS[alg[0]]) {
	    throw (new InvalidAlgorithmError(alg[0].toUpperCase() + ' type keys ' +
	      'are not supported'));
	  }

	  if (!HASH_ALGOS[alg[1]]) {
	    throw (new InvalidAlgorithmError(alg[1].toUpperCase() + ' is not a ' +
	      'supported hash algorithm'));
	  }

	  return (alg);
	}

	///--- API

	utils$4 = {

	  HASH_ALGOS: HASH_ALGOS,
	  PK_ALGOS: PK_ALGOS,

	  HttpSignatureError: HttpSignatureError,
	  InvalidAlgorithmError: InvalidAlgorithmError,

	  validateAlgorithm: validateAlgorithm,

	  /**
	   * Converts an OpenSSH public key (rsa only) to a PKCS#8 PEM file.
	   *
	   * The intent of this module is to interoperate with OpenSSL only,
	   * specifically the node crypto module's `verify` method.
	   *
	   * @param {String} key an OpenSSH public key.
	   * @return {String} PEM encoded form of the RSA public key.
	   * @throws {TypeError} on bad input.
	   * @throws {Error} on invalid ssh key formatted data.
	   */
	  sshKeyToPEM: function sshKeyToPEM(key) {
	    assert.string(key, 'ssh_key');

	    var k = sshpk.parseKey(key, 'ssh');
	    return (k.toString('pem'));
	  },


	  /**
	   * Generates an OpenSSH fingerprint from an ssh public key.
	   *
	   * @param {String} key an OpenSSH public key.
	   * @return {String} key fingerprint.
	   * @throws {TypeError} on bad input.
	   * @throws {Error} if what you passed doesn't look like an ssh public key.
	   */
	  fingerprint: function fingerprint(key) {
	    assert.string(key, 'ssh_key');

	    var k = sshpk.parseKey(key, 'ssh');
	    return (k.fingerprint('md5').toString('hex'));
	  },

	  /**
	   * Converts a PKGCS#8 PEM file to an OpenSSH public key (rsa)
	   *
	   * The reverse of the above function.
	   */
	  pemToRsaSSHKey: function pemToRsaSSHKey(pem, comment) {
	    assert.equal('string', typeof (pem), 'typeof pem');

	    var k = sshpk.parseKey(pem, 'pem');
	    k.comment = comment;
	    return (k.toString('ssh'));
	  }
	};
	return utils$4;
}

var parser;
var hasRequiredParser;

function requireParser () {
	if (hasRequiredParser) return parser;
	hasRequiredParser = 1;
	// Copyright 2012 Joyent, Inc.  All rights reserved.

	var assert = requireAssert();
	var util = require$$1$2;
	var utils = requireUtils$4();



	///--- Globals

	utils.HASH_ALGOS;
	utils.PK_ALGOS;
	var HttpSignatureError = utils.HttpSignatureError;
	var InvalidAlgorithmError = utils.InvalidAlgorithmError;
	var validateAlgorithm = utils.validateAlgorithm;

	var State = {
	  New: 0,
	  Params: 1
	};

	var ParamsState = {
	  Name: 0,
	  Quote: 1,
	  Value: 2,
	  Comma: 3
	};


	///--- Specific Errors


	function ExpiredRequestError(message) {
	  HttpSignatureError.call(this, message, ExpiredRequestError);
	}
	util.inherits(ExpiredRequestError, HttpSignatureError);


	function InvalidHeaderError(message) {
	  HttpSignatureError.call(this, message, InvalidHeaderError);
	}
	util.inherits(InvalidHeaderError, HttpSignatureError);


	function InvalidParamsError(message) {
	  HttpSignatureError.call(this, message, InvalidParamsError);
	}
	util.inherits(InvalidParamsError, HttpSignatureError);


	function MissingHeaderError(message) {
	  HttpSignatureError.call(this, message, MissingHeaderError);
	}
	util.inherits(MissingHeaderError, HttpSignatureError);

	function StrictParsingError(message) {
	  HttpSignatureError.call(this, message, StrictParsingError);
	}
	util.inherits(StrictParsingError, HttpSignatureError);

	///--- Exported API

	parser = {

	  /**
	   * Parses the 'Authorization' header out of an http.ServerRequest object.
	   *
	   * Note that this API will fully validate the Authorization header, and throw
	   * on any error.  It will not however check the signature, or the keyId format
	   * as those are specific to your environment.  You can use the options object
	   * to pass in extra constraints.
	   *
	   * As a response object you can expect this:
	   *
	   *     {
	   *       "scheme": "Signature",
	   *       "params": {
	   *         "keyId": "foo",
	   *         "algorithm": "rsa-sha256",
	   *         "headers": [
	   *           "date" or "x-date",
	   *           "digest"
	   *         ],
	   *         "signature": "base64"
	   *       },
	   *       "signingString": "ready to be passed to crypto.verify()"
	   *     }
	   *
	   * @param {Object} request an http.ServerRequest.
	   * @param {Object} options an optional options object with:
	   *                   - clockSkew: allowed clock skew in seconds (default 300).
	   *                   - headers: required header names (def: date or x-date)
	   *                   - algorithms: algorithms to support (default: all).
	   *                   - strict: should enforce latest spec parsing
	   *                             (default: false).
	   * @return {Object} parsed out object (see above).
	   * @throws {TypeError} on invalid input.
	   * @throws {InvalidHeaderError} on an invalid Authorization header error.
	   * @throws {InvalidParamsError} if the params in the scheme are invalid.
	   * @throws {MissingHeaderError} if the params indicate a header not present,
	   *                              either in the request headers from the params,
	   *                              or not in the params from a required header
	   *                              in options.
	   * @throws {StrictParsingError} if old attributes are used in strict parsing
	   *                              mode.
	   * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.
	   */
	  parseRequest: function parseRequest(request, options) {
	    assert.object(request, 'request');
	    assert.object(request.headers, 'request.headers');
	    if (options === undefined) {
	      options = {};
	    }
	    if (options.headers === undefined) {
	      options.headers = [request.headers['x-date'] ? 'x-date' : 'date'];
	    }
	    assert.object(options, 'options');
	    assert.arrayOfString(options.headers, 'options.headers');
	    assert.optionalFinite(options.clockSkew, 'options.clockSkew');

	    var authzHeaderName = options.authorizationHeaderName || 'authorization';

	    if (!request.headers[authzHeaderName]) {
	      throw new MissingHeaderError('no ' + authzHeaderName + ' header ' +
	                                   'present in the request');
	    }

	    options.clockSkew = options.clockSkew || 300;


	    var i = 0;
	    var state = State.New;
	    var substate = ParamsState.Name;
	    var tmpName = '';
	    var tmpValue = '';

	    var parsed = {
	      scheme: '',
	      params: {},
	      signingString: ''
	    };

	    var authz = request.headers[authzHeaderName];
	    for (i = 0; i < authz.length; i++) {
	      var c = authz.charAt(i);

	      switch (Number(state)) {

	      case State.New:
	        if (c !== ' ') parsed.scheme += c;
	        else state = State.Params;
	        break;

	      case State.Params:
	        switch (Number(substate)) {

	        case ParamsState.Name:
	          var code = c.charCodeAt(0);
	          // restricted name of A-Z / a-z
	          if ((code >= 0x41 && code <= 0x5a) || // A-Z
	              (code >= 0x61 && code <= 0x7a)) { // a-z
	            tmpName += c;
	          } else if (c === '=') {
	            if (tmpName.length === 0)
	              throw new InvalidHeaderError('bad param format');
	            substate = ParamsState.Quote;
	          } else {
	            throw new InvalidHeaderError('bad param format');
	          }
	          break;

	        case ParamsState.Quote:
	          if (c === '"') {
	            tmpValue = '';
	            substate = ParamsState.Value;
	          } else {
	            throw new InvalidHeaderError('bad param format');
	          }
	          break;

	        case ParamsState.Value:
	          if (c === '"') {
	            parsed.params[tmpName] = tmpValue;
	            substate = ParamsState.Comma;
	          } else {
	            tmpValue += c;
	          }
	          break;

	        case ParamsState.Comma:
	          if (c === ',') {
	            tmpName = '';
	            substate = ParamsState.Name;
	          } else {
	            throw new InvalidHeaderError('bad param format');
	          }
	          break;

	        default:
	          throw new Error('Invalid substate');
	        }
	        break;

	      default:
	        throw new Error('Invalid substate');
	      }

	    }

	    if (!parsed.params.headers || parsed.params.headers === '') {
	      if (request.headers['x-date']) {
	        parsed.params.headers = ['x-date'];
	      } else {
	        parsed.params.headers = ['date'];
	      }
	    } else {
	      parsed.params.headers = parsed.params.headers.split(' ');
	    }

	    // Minimally validate the parsed object
	    if (!parsed.scheme || parsed.scheme !== 'Signature')
	      throw new InvalidHeaderError('scheme was not "Signature"');

	    if (!parsed.params.keyId)
	      throw new InvalidHeaderError('keyId was not specified');

	    if (!parsed.params.algorithm)
	      throw new InvalidHeaderError('algorithm was not specified');

	    if (!parsed.params.signature)
	      throw new InvalidHeaderError('signature was not specified');

	    // Check the algorithm against the official list
	    parsed.params.algorithm = parsed.params.algorithm.toLowerCase();
	    try {
	      validateAlgorithm(parsed.params.algorithm);
	    } catch (e) {
	      if (e instanceof InvalidAlgorithmError)
	        throw (new InvalidParamsError(parsed.params.algorithm + ' is not ' +
	          'supported'));
	      else
	        throw (e);
	    }

	    // Build the signingString
	    for (i = 0; i < parsed.params.headers.length; i++) {
	      var h = parsed.params.headers[i].toLowerCase();
	      parsed.params.headers[i] = h;

	      if (h === 'request-line') {
	        if (!options.strict) {
	          /*
	           * We allow headers from the older spec drafts if strict parsing isn't
	           * specified in options.
	           */
	          parsed.signingString +=
	            request.method + ' ' + request.url + ' HTTP/' + request.httpVersion;
	        } else {
	          /* Strict parsing doesn't allow older draft headers. */
	          throw (new StrictParsingError('request-line is not a valid header ' +
	            'with strict parsing enabled.'));
	        }
	      } else if (h === '(request-target)') {
	        parsed.signingString +=
	          '(request-target): ' + request.method.toLowerCase() + ' ' +
	          request.url;
	      } else {
	        var value = request.headers[h];
	        if (value === undefined)
	          throw new MissingHeaderError(h + ' was not in the request');
	        parsed.signingString += h + ': ' + value;
	      }

	      if ((i + 1) < parsed.params.headers.length)
	        parsed.signingString += '\n';
	    }

	    // Check against the constraints
	    var date;
	    if (request.headers.date || request.headers['x-date']) {
	        if (request.headers['x-date']) {
	          date = new Date(request.headers['x-date']);
	        } else {
	          date = new Date(request.headers.date);
	        }
	      var now = new Date();
	      var skew = Math.abs(now.getTime() - date.getTime());

	      if (skew > options.clockSkew * 1000) {
	        throw new ExpiredRequestError('clock skew of ' +
	                                      (skew / 1000) +
	                                      's was greater than ' +
	                                      options.clockSkew + 's');
	      }
	    }

	    options.headers.forEach(function (hdr) {
	      // Remember that we already checked any headers in the params
	      // were in the request, so if this passes we're good.
	      if (parsed.params.headers.indexOf(hdr.toLowerCase()) < 0)
	        throw new MissingHeaderError(hdr + ' was not a signed header');
	    });

	    if (options.algorithms) {
	      if (options.algorithms.indexOf(parsed.params.algorithm) === -1)
	        throw new InvalidParamsError(parsed.params.algorithm +
	                                     ' is not a supported algorithm');
	    }

	    parsed.algorithm = parsed.params.algorithm.toUpperCase();
	    parsed.keyId = parsed.params.keyId;
	    return parsed;
	  }

	};
	return parser;
}

var jsprim = {};

var extsprintf = {};

/*
 * extsprintf.js: extended POSIX-style sprintf
 */

var hasRequiredExtsprintf;

function requireExtsprintf () {
	if (hasRequiredExtsprintf) return extsprintf;
	hasRequiredExtsprintf = 1;
	var mod_assert = require$$0$7;
	var mod_util = require$$1$2;

	/*
	 * Public interface
	 */
	extsprintf.sprintf = jsSprintf;
	extsprintf.printf = jsPrintf;
	extsprintf.fprintf = jsFprintf;

	/*
	 * Stripped down version of s[n]printf(3c).  We make a best effort to throw an
	 * exception when given a format string we don't understand, rather than
	 * ignoring it, so that we won't break existing programs if/when we go implement
	 * the rest of this.
	 *
	 * This implementation currently supports specifying
	 *	- field alignment ('-' flag),
	 * 	- zero-pad ('0' flag)
	 *	- always show numeric sign ('+' flag),
	 *	- field width
	 *	- conversions for strings, decimal integers, and floats (numbers).
	 *	- argument size specifiers.  These are all accepted but ignored, since
	 *	  Javascript has no notion of the physical size of an argument.
	 *
	 * Everything else is currently unsupported, most notably precision, unsigned
	 * numbers, non-decimal numbers, and characters.
	 */
	function jsSprintf(fmt)
	{
		var regex = [
		    '([^%]*)',				/* normal text */
		    '%',				/* start of format */
		    '([\'\\-+ #0]*?)',			/* flags (optional) */
		    '([1-9]\\d*)?',			/* width (optional) */
		    '(\\.([1-9]\\d*))?',		/* precision (optional) */
		    '[lhjztL]*?',			/* length mods (ignored) */
		    '([diouxXfFeEgGaAcCsSp%jr])'	/* conversion */
		].join('');

		var re = new RegExp(regex);
		var args = Array.prototype.slice.call(arguments, 1);
		var flags, width, precision, conversion;
		var left, pad, sign, arg, match;
		var ret = '';
		var argn = 1;

		mod_assert.equal('string', typeof (fmt));

		while ((match = re.exec(fmt)) !== null) {
			ret += match[1];
			fmt = fmt.substring(match[0].length);

			flags = match[2] || '';
			width = match[3] || 0;
			precision = match[4] || '';
			conversion = match[6];
			left = false;
			sign = false;
			pad = ' ';

			if (conversion == '%') {
				ret += '%';
				continue;
			}

			if (args.length === 0)
				throw (new Error('too few args to sprintf'));

			arg = args.shift();
			argn++;

			if (flags.match(/[\' #]/))
				throw (new Error(
				    'unsupported flags: ' + flags));

			if (precision.length > 0)
				throw (new Error(
				    'non-zero precision not supported'));

			if (flags.match(/-/))
				left = true;

			if (flags.match(/0/))
				pad = '0';

			if (flags.match(/\+/))
				sign = true;

			switch (conversion) {
			case 's':
				if (arg === undefined || arg === null)
					throw (new Error('argument ' + argn +
					    ': attempted to print undefined or null ' +
					    'as a string'));
				ret += doPad(pad, width, left, arg.toString());
				break;

			case 'd':
				arg = Math.floor(arg);
				/*jsl:fallthru*/
			case 'f':
				sign = sign && arg > 0 ? '+' : '';
				ret += sign + doPad(pad, width, left,
				    arg.toString());
				break;

			case 'x':
				ret += doPad(pad, width, left, arg.toString(16));
				break;

			case 'j': /* non-standard */
				if (width === 0)
					width = 10;
				ret += mod_util.inspect(arg, false, width);
				break;

			case 'r': /* non-standard */
				ret += dumpException(arg);
				break;

			default:
				throw (new Error('unsupported conversion: ' +
				    conversion));
			}
		}

		ret += fmt;
		return (ret);
	}

	function jsPrintf() {
		var args = Array.prototype.slice.call(arguments);
		args.unshift(process.stdout);
		jsFprintf.apply(null, args);
	}

	function jsFprintf(stream) {
		var args = Array.prototype.slice.call(arguments, 1);
		return (stream.write(jsSprintf.apply(this, args)));
	}

	function doPad(chr, width, left, str)
	{
		var ret = str;

		while (ret.length < width) {
			if (left)
				ret += chr;
			else
				ret = chr + ret;
		}

		return (ret);
	}

	/*
	 * This function dumps long stack traces for exceptions having a cause() method.
	 * See node-verror for an example.
	 */
	function dumpException(ex)
	{
		var ret;

		if (!(ex instanceof Error))
			throw (new Error(jsSprintf('invalid type for %%r: %j', ex)));

		/* Note that V8 prepends "ex.stack" with ex.toString(). */
		ret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;

		if (ex.cause && typeof (ex.cause) === 'function') {
			var cex = ex.cause();
			if (cex) {
				ret += '\nCaused by: ' + dumpException(cex);
			}
		}

		return (ret);
	}
	return extsprintf;
}

var util$2 = {};

var hasRequiredUtil$2;

function requireUtil$2 () {
	if (hasRequiredUtil$2) return util$2;
	hasRequiredUtil$2 = 1;
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.

	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	util$2.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	util$2.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	util$2.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	util$2.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	util$2.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	util$2.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	util$2.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	util$2.isUndefined = isUndefined;

	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	util$2.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	util$2.isObject = isObject;

	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	util$2.isDate = isDate;

	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	util$2.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	util$2.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	util$2.isPrimitive = isPrimitive;

	util$2.isBuffer = Buffer.isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	return util$2;
}

/*
 * verror.js: richer JavaScript errors
 */

var verror;
var hasRequiredVerror;

function requireVerror () {
	if (hasRequiredVerror) return verror;
	hasRequiredVerror = 1;
	var mod_assertplus = requireAssert();
	var mod_util = require$$1$2;

	var mod_extsprintf = requireExtsprintf();
	var mod_isError = requireUtil$2().isError;
	var sprintf = mod_extsprintf.sprintf;

	/*
	 * Public interface
	 */

	/* So you can 'var VError = require('verror')' */
	verror = VError;
	/* For compatibility */
	VError.VError = VError;
	/* Other exported classes */
	VError.SError = SError;
	VError.WError = WError;
	VError.MultiError = MultiError;

	/*
	 * Common function used to parse constructor arguments for VError, WError, and
	 * SError.  Named arguments to this function:
	 *
	 *     strict		force strict interpretation of sprintf arguments, even
	 *     			if the options in "argv" don't say so
	 *
	 *     argv		error's constructor arguments, which are to be
	 *     			interpreted as described in README.md.  For quick
	 *     			reference, "argv" has one of the following forms:
	 *
	 *          [ sprintf_args... ]           (argv[0] is a string)
	 *          [ cause, sprintf_args... ]    (argv[0] is an Error)
	 *          [ options, sprintf_args... ]  (argv[0] is an object)
	 *
	 * This function normalizes these forms, producing an object with the following
	 * properties:
	 *
	 *    options           equivalent to "options" in third form.  This will never
	 *    			be a direct reference to what the caller passed in
	 *    			(i.e., it may be a shallow copy), so it can be freely
	 *    			modified.
	 *
	 *    shortmessage      result of sprintf(sprintf_args), taking options.strict
	 *    			into account as described in README.md.
	 */
	function parseConstructorArguments(args)
	{
		var argv, options, sprintf_args, shortmessage, k;

		mod_assertplus.object(args, 'args');
		mod_assertplus.bool(args.strict, 'args.strict');
		mod_assertplus.array(args.argv, 'args.argv');
		argv = args.argv;

		/*
		 * First, figure out which form of invocation we've been given.
		 */
		if (argv.length === 0) {
			options = {};
			sprintf_args = [];
		} else if (mod_isError(argv[0])) {
			options = { 'cause': argv[0] };
			sprintf_args = argv.slice(1);
		} else if (typeof (argv[0]) === 'object') {
			options = {};
			for (k in argv[0]) {
				options[k] = argv[0][k];
			}
			sprintf_args = argv.slice(1);
		} else {
			mod_assertplus.string(argv[0],
			    'first argument to VError, SError, or WError ' +
			    'constructor must be a string, object, or Error');
			options = {};
			sprintf_args = argv;
		}

		/*
		 * Now construct the error's message.
		 *
		 * extsprintf (which we invoke here with our caller's arguments in order
		 * to construct this Error's message) is strict in its interpretation of
		 * values to be processed by the "%s" specifier.  The value passed to
		 * extsprintf must actually be a string or something convertible to a
		 * String using .toString().  Passing other values (notably "null" and
		 * "undefined") is considered a programmer error.  The assumption is
		 * that if you actually want to print the string "null" or "undefined",
		 * then that's easy to do that when you're calling extsprintf; on the
		 * other hand, if you did NOT want that (i.e., there's actually a bug
		 * where the program assumes some variable is non-null and tries to
		 * print it, which might happen when constructing a packet or file in
		 * some specific format), then it's better to stop immediately than
		 * produce bogus output.
		 *
		 * However, sometimes the bug is only in the code calling VError, and a
		 * programmer might prefer to have the error message contain "null" or
		 * "undefined" rather than have the bug in the error path crash the
		 * program (making the first bug harder to identify).  For that reason,
		 * by default VError converts "null" or "undefined" arguments to their
		 * string representations and passes those to extsprintf.  Programmers
		 * desiring the strict behavior can use the SError class or pass the
		 * "strict" option to the VError constructor.
		 */
		mod_assertplus.object(options);
		if (!options.strict && !args.strict) {
			sprintf_args = sprintf_args.map(function (a) {
				return (a === null ? 'null' :
				    a === undefined ? 'undefined' : a);
			});
		}

		if (sprintf_args.length === 0) {
			shortmessage = '';
		} else {
			shortmessage = sprintf.apply(null, sprintf_args);
		}

		return ({
		    'options': options,
		    'shortmessage': shortmessage
		});
	}

	/*
	 * See README.md for reference documentation.
	 */
	function VError()
	{
		var args, obj, parsed, cause, ctor, message, k;

		args = Array.prototype.slice.call(arguments, 0);

		/*
		 * This is a regrettable pattern, but JavaScript's built-in Error class
		 * is defined to work this way, so we allow the constructor to be called
		 * without "new".
		 */
		if (!(this instanceof VError)) {
			obj = Object.create(VError.prototype);
			VError.apply(obj, arguments);
			return (obj);
		}

		/*
		 * For convenience and backwards compatibility, we support several
		 * different calling forms.  Normalize them here.
		 */
		parsed = parseConstructorArguments({
		    'argv': args,
		    'strict': false
		});

		/*
		 * If we've been given a name, apply it now.
		 */
		if (parsed.options.name) {
			mod_assertplus.string(parsed.options.name,
			    'error\'s "name" must be a string');
			this.name = parsed.options.name;
		}

		/*
		 * For debugging, we keep track of the original short message (attached
		 * this Error particularly) separately from the complete message (which
		 * includes the messages of our cause chain).
		 */
		this.jse_shortmsg = parsed.shortmessage;
		message = parsed.shortmessage;

		/*
		 * If we've been given a cause, record a reference to it and update our
		 * message appropriately.
		 */
		cause = parsed.options.cause;
		if (cause) {
			mod_assertplus.ok(mod_isError(cause), 'cause is not an Error');
			this.jse_cause = cause;

			if (!parsed.options.skipCauseMessage) {
				message += ': ' + cause.message;
			}
		}

		/*
		 * If we've been given an object with properties, shallow-copy that
		 * here.  We don't want to use a deep copy in case there are non-plain
		 * objects here, but we don't want to use the original object in case
		 * the caller modifies it later.
		 */
		this.jse_info = {};
		if (parsed.options.info) {
			for (k in parsed.options.info) {
				this.jse_info[k] = parsed.options.info[k];
			}
		}

		this.message = message;
		Error.call(this, message);

		if (Error.captureStackTrace) {
			ctor = parsed.options.constructorOpt || this.constructor;
			Error.captureStackTrace(this, ctor);
		}

		return (this);
	}

	mod_util.inherits(VError, Error);
	VError.prototype.name = 'VError';

	VError.prototype.toString = function ve_toString()
	{
		var str = (this.hasOwnProperty('name') && this.name ||
			this.constructor.name || this.constructor.prototype.name);
		if (this.message)
			str += ': ' + this.message;

		return (str);
	};

	/*
	 * This method is provided for compatibility.  New callers should use
	 * VError.cause() instead.  That method also uses the saner `null` return value
	 * when there is no cause.
	 */
	VError.prototype.cause = function ve_cause()
	{
		var cause = VError.cause(this);
		return (cause === null ? undefined : cause);
	};

	/*
	 * Static methods
	 *
	 * These class-level methods are provided so that callers can use them on
	 * instances of Errors that are not VErrors.  New interfaces should be provided
	 * only using static methods to eliminate the class of programming mistake where
	 * people fail to check whether the Error object has the corresponding methods.
	 */

	VError.cause = function (err)
	{
		mod_assertplus.ok(mod_isError(err), 'err must be an Error');
		return (mod_isError(err.jse_cause) ? err.jse_cause : null);
	};

	VError.info = function (err)
	{
		var rv, cause, k;

		mod_assertplus.ok(mod_isError(err), 'err must be an Error');
		cause = VError.cause(err);
		if (cause !== null) {
			rv = VError.info(cause);
		} else {
			rv = {};
		}

		if (typeof (err.jse_info) == 'object' && err.jse_info !== null) {
			for (k in err.jse_info) {
				rv[k] = err.jse_info[k];
			}
		}

		return (rv);
	};

	VError.findCauseByName = function (err, name)
	{
		var cause;

		mod_assertplus.ok(mod_isError(err), 'err must be an Error');
		mod_assertplus.string(name, 'name');
		mod_assertplus.ok(name.length > 0, 'name cannot be empty');

		for (cause = err; cause !== null; cause = VError.cause(cause)) {
			mod_assertplus.ok(mod_isError(cause));
			if (cause.name == name) {
				return (cause);
			}
		}

		return (null);
	};

	VError.hasCauseWithName = function (err, name)
	{
		return (VError.findCauseByName(err, name) !== null);
	};

	VError.fullStack = function (err)
	{
		mod_assertplus.ok(mod_isError(err), 'err must be an Error');

		var cause = VError.cause(err);

		if (cause) {
			return (err.stack + '\ncaused by: ' + VError.fullStack(cause));
		}

		return (err.stack);
	};

	VError.errorFromList = function (errors)
	{
		mod_assertplus.arrayOfObject(errors, 'errors');

		if (errors.length === 0) {
			return (null);
		}

		errors.forEach(function (e) {
			mod_assertplus.ok(mod_isError(e));
		});

		if (errors.length == 1) {
			return (errors[0]);
		}

		return (new MultiError(errors));
	};

	VError.errorForEach = function (err, func)
	{
		mod_assertplus.ok(mod_isError(err), 'err must be an Error');
		mod_assertplus.func(func, 'func');

		if (err instanceof MultiError) {
			err.errors().forEach(function iterError(e) { func(e); });
		} else {
			func(err);
		}
	};


	/*
	 * SError is like VError, but stricter about types.  You cannot pass "null" or
	 * "undefined" as string arguments to the formatter.
	 */
	function SError()
	{
		var args, obj, parsed, options;

		args = Array.prototype.slice.call(arguments, 0);
		if (!(this instanceof SError)) {
			obj = Object.create(SError.prototype);
			SError.apply(obj, arguments);
			return (obj);
		}

		parsed = parseConstructorArguments({
		    'argv': args,
		    'strict': true
		});

		options = parsed.options;
		VError.call(this, options, '%s', parsed.shortmessage);

		return (this);
	}

	/*
	 * We don't bother setting SError.prototype.name because once constructed,
	 * SErrors are just like VErrors.
	 */
	mod_util.inherits(SError, VError);


	/*
	 * Represents a collection of errors for the purpose of consumers that generally
	 * only deal with one error.  Callers can extract the individual errors
	 * contained in this object, but may also just treat it as a normal single
	 * error, in which case a summary message will be printed.
	 */
	function MultiError(errors)
	{
		mod_assertplus.array(errors, 'list of errors');
		mod_assertplus.ok(errors.length > 0, 'must be at least one error');
		this.ase_errors = errors;

		VError.call(this, {
		    'cause': errors[0]
		}, 'first of %d error%s', errors.length, errors.length == 1 ? '' : 's');
	}

	mod_util.inherits(MultiError, VError);
	MultiError.prototype.name = 'MultiError';

	MultiError.prototype.errors = function me_errors()
	{
		return (this.ase_errors.slice(0));
	};


	/*
	 * See README.md for reference details.
	 */
	function WError()
	{
		var args, obj, parsed, options;

		args = Array.prototype.slice.call(arguments, 0);
		if (!(this instanceof WError)) {
			obj = Object.create(WError.prototype);
			WError.apply(obj, args);
			return (obj);
		}

		parsed = parseConstructorArguments({
		    'argv': args,
		    'strict': false
		});

		options = parsed.options;
		options['skipCauseMessage'] = true;
		VError.call(this, options, '%s', parsed.shortmessage);

		return (this);
	}

	mod_util.inherits(WError, VError);
	WError.prototype.name = 'WError';

	WError.prototype.toString = function we_toString()
	{
		var str = (this.hasOwnProperty('name') && this.name ||
			this.constructor.name || this.constructor.prototype.name);
		if (this.message)
			str += ': ' + this.message;
		if (this.jse_cause && this.jse_cause.message)
			str += '; caused by ' + this.jse_cause.toString();

		return (str);
	};

	/*
	 * For purely historical reasons, WError's cause() function allows you to set
	 * the cause.
	 */
	WError.prototype.cause = function we_cause(c)
	{
		if (mod_isError(c))
			this.jse_cause = c;

		return (this.jse_cause);
	};
	return verror;
}

var validate$2 = {exports: {}};

/**
 * JSONSchema Validator - Validates JavaScript objects using JSON Schemas
 *	(http://www.json.com/json-schema-proposal/)
 * Licensed under AFL-2.1 OR BSD-3-Clause
To use the validator call the validate function with an instance object and an optional schema object.
If a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),
that schema will be used to validate and the schema parameter is not necessary (if both exist,
both validations will occur).
The validate method will return an array of validation errors. If there are no errors, then an
empty list will be returned. A validation error will have two properties:
"property" which indicates which property had the error
"message" which indicates what the error was
 */
var validate$1 = validate$2.exports;

var hasRequiredValidate$1;

function requireValidate$1 () {
	if (hasRequiredValidate$1) return validate$2.exports;
	hasRequiredValidate$1 = 1;
	(function (module) {
		(function (root, factory) {
		    if (module.exports) {
		        // Node. Does not work with strict CommonJS, but
		        // only CommonJS-like environments that support module.exports,
		        // like Node.
		        module.exports = factory();
		    } else {
		        // Browser globals
		        root.jsonSchema = factory();
		    }
		}(validate$1, function () {// setup primitive classes to be JSON Schema types
		var exports = validate;
		exports.Integer = {type:"integer"};
		var primitiveConstructors = {
			String: String,
			Boolean: Boolean,
			Number: Number,
			Object: Object,
			Array: Array,
			Date: Date
		};
		exports.validate = validate;
		function validate(/*Any*/instance,/*Object*/schema) {
				// Summary:
				//  	To use the validator call JSONSchema.validate with an instance object and an optional schema object.
				// 		If a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),
				// 		that schema will be used to validate and the schema parameter is not necessary (if both exist,
				// 		both validations will occur).
				// 		The validate method will return an object with two properties:
				// 			valid: A boolean indicating if the instance is valid by the schema
				// 			errors: An array of validation errors. If there are no errors, then an
				// 					empty list will be returned. A validation error will have two properties:
				// 						property: which indicates which property had the error
				// 						message: which indicates what the error was
				//
				return validate(instance, schema, {changing: false});//, coerce: false, existingOnly: false});
			}		exports.checkPropertyChange = function(/*Any*/value,/*Object*/schema, /*String*/property) {
				// Summary:
				// 		The checkPropertyChange method will check to see if an value can legally be in property with the given schema
				// 		This is slightly different than the validate method in that it will fail if the schema is readonly and it will
				// 		not check for self-validation, it is assumed that the passed in value is already internally valid.
				// 		The checkPropertyChange method will return the same object type as validate, see JSONSchema.validate for
				// 		information.
				//
				return validate(value, schema, {changing: property || "property"});
			};
		var validate = exports._validate = function(/*Any*/instance,/*Object*/schema,/*Object*/options) {

			if (!options) options = {};
			var _changing = options.changing;

			function getType(schema){
				return schema.type || (primitiveConstructors[schema.name] == schema && schema.name.toLowerCase());
			}
			var errors = [];
			// validate a value against a property definition
			function checkProp(value, schema, path,i){

				var l;
				path += path ? typeof i == 'number' ? '[' + i + ']' : typeof i == 'undefined' ? '' : '.' + i : i;
				function addError(message){
					errors.push({property:path,message:message});
				}

				if((typeof schema != 'object' || schema instanceof Array) && (path || typeof schema != 'function') && !(schema && getType(schema))){
					if(typeof schema == 'function'){
						if(!(value instanceof schema)){
							addError("is not an instance of the class/constructor " + schema.name);
						}
					}else if(schema){
						addError("Invalid schema/property definition " + schema);
					}
					return null;
				}
				if(_changing && schema.readonly){
					addError("is a readonly field, it can not be changed");
				}
				if(schema['extends']){ // if it extends another schema, it must pass that schema as well
					checkProp(value,schema['extends'],path,i);
				}
				// validate a value against a type definition
				function checkType(type,value){
					if(type){
						if(typeof type == 'string' && type != 'any' &&
								(type == 'null' ? value !== null : typeof value != type) &&
								!(value instanceof Array && type == 'array') &&
								!(value instanceof Date && type == 'date') &&
								!(type == 'integer' && value%1===0)){
							return [{property:path,message:value + " - " + (typeof value) + " value found, but a " + type + " is required"}];
						}
						if(type instanceof Array){
							var unionErrors=[];
							for(var j = 0; j < type.length; j++){ // a union type
								if(!(unionErrors=checkType(type[j],value)).length){
									break;
								}
							}
							if(unionErrors.length){
								return unionErrors;
							}
						}else if(typeof type == 'object'){
							var priorErrors = errors;
							errors = [];
							checkProp(value,type,path);
							var theseErrors = errors;
							errors = priorErrors;
							return theseErrors;
						}
					}
					return [];
				}
				if(value === undefined){
					if(schema.required){
						addError("is missing and it is required");
					}
				}else {
					errors = errors.concat(checkType(getType(schema),value));
					if(schema.disallow && !checkType(schema.disallow,value).length){
						addError(" disallowed value was matched");
					}
					if(value !== null){
						if(value instanceof Array){
							if(schema.items){
								var itemsIsArray = schema.items instanceof Array;
								var propDef = schema.items;
								for (i = 0, l = value.length; i < l; i += 1) {
									if (itemsIsArray)
										propDef = schema.items[i];
									if (options.coerce)
										value[i] = options.coerce(value[i], propDef);
									errors.concat(checkProp(value[i],propDef,path,i));
								}
							}
							if(schema.minItems && value.length < schema.minItems){
								addError("There must be a minimum of " + schema.minItems + " in the array");
							}
							if(schema.maxItems && value.length > schema.maxItems){
								addError("There must be a maximum of " + schema.maxItems + " in the array");
							}
						}else if(schema.properties || schema.additionalProperties){
							errors.concat(checkObj(value, schema.properties, path, schema.additionalProperties));
						}
						if(schema.pattern && typeof value == 'string' && !value.match(schema.pattern)){
							addError("does not match the regex pattern " + schema.pattern);
						}
						if(schema.maxLength && typeof value == 'string' && value.length > schema.maxLength){
							addError("may only be " + schema.maxLength + " characters long");
						}
						if(schema.minLength && typeof value == 'string' && value.length < schema.minLength){
							addError("must be at least " + schema.minLength + " characters long");
						}
						if(typeof schema.minimum !== 'undefined' && typeof value == typeof schema.minimum &&
								schema.minimum > value){
							addError("must have a minimum value of " + schema.minimum);
						}
						if(typeof schema.maximum !== 'undefined' && typeof value == typeof schema.maximum &&
								schema.maximum < value){
							addError("must have a maximum value of " + schema.maximum);
						}
						if(schema['enum']){
							var enumer = schema['enum'];
							l = enumer.length;
							var found;
							for(var j = 0; j < l; j++){
								if(enumer[j]===value){
									found=1;
									break;
								}
							}
							if(!found){
								addError("does not have a value in the enumeration " + enumer.join(", "));
							}
						}
						if(typeof schema.maxDecimal == 'number' &&
							(value.toString().match(new RegExp("\\.[0-9]{" + (schema.maxDecimal + 1) + ",}")))){
							addError("may only have " + schema.maxDecimal + " digits of decimal places");
						}
					}
				}
				return null;
			}
			// validate an object against a schema
			function checkObj(instance,objTypeDef,path,additionalProp){

				if(typeof objTypeDef =='object'){
					if(typeof instance != 'object' || instance instanceof Array){
						errors.push({property:path,message:"an object is required"});
					}
					
					for(var i in objTypeDef){ 
						if(objTypeDef.hasOwnProperty(i) && i != '__proto__' && i != 'constructor'){
							var value = instance.hasOwnProperty(i) ? instance[i] : undefined;
							// skip _not_ specified properties
							if (value === undefined && options.existingOnly) continue;
							var propDef = objTypeDef[i];
							// set default
							if(value === undefined && propDef["default"]){
								value = instance[i] = propDef["default"];
							}
							if(options.coerce && i in instance){
								value = instance[i] = options.coerce(value, propDef);
							}
							checkProp(value,propDef,path,i);
						}
					}
				}
				for(i in instance){
					if(instance.hasOwnProperty(i) && !(i.charAt(0) == '_' && i.charAt(1) == '_') && objTypeDef && !objTypeDef[i] && additionalProp===false){
						if (options.filter) {
							delete instance[i];
							continue;
						} else {
							errors.push({property:path,message:"The property " + i +
								" is not defined in the schema and the schema does not allow additional properties"});
						}
					}
					var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;
					if(requires && !(requires in instance)){
						errors.push({property:path,message:"the presence of the property " + i + " requires that " + requires + " also be present"});
					}
					value = instance[i];
					if(additionalProp && (!(objTypeDef && typeof objTypeDef == 'object') || !(i in objTypeDef))){
						if(options.coerce){
							value = instance[i] = options.coerce(value, additionalProp);
						}
						checkProp(value,additionalProp,path,i);
					}
					if(!_changing && value && value.$schema){
						errors = errors.concat(checkProp(value,value.$schema,path,i));
					}
				}
				return errors;
			}
			if(schema){
				checkProp(instance,schema,'',_changing || '');
			}
			if(!_changing && instance && instance.$schema){
				checkProp(instance,instance.$schema,'','');
			}
			return {valid:!errors.length,errors:errors};
		};
		exports.mustBeValid = function(result){
			//	summary:
			//		This checks to ensure that the result is valid and will throw an appropriate error message if it is not
			// result: the result returned from checkPropertyChange or validate
			if(!result.valid){
				throw new TypeError(result.errors.map(function(error){return "for property " + error.property + ': ' + error.message;}).join(", \n"));
			}
		};

		return exports;
		})); 
	} (validate$2));
	return validate$2.exports;
}

/*
 * lib/jsprim.js: utilities for primitive JavaScript types
 */

var hasRequiredJsprim;

function requireJsprim () {
	if (hasRequiredJsprim) return jsprim;
	hasRequiredJsprim = 1;
	var mod_assert = requireAssert();

	var mod_extsprintf = requireExtsprintf();
	var mod_verror = requireVerror();
	var mod_jsonschema = requireValidate$1();

	/*
	 * Public interface
	 */
	jsprim.deepCopy = deepCopy;
	jsprim.deepEqual = deepEqual;
	jsprim.isEmpty = isEmpty;
	jsprim.hasKey = hasKey;
	jsprim.forEachKey = forEachKey;
	jsprim.pluck = pluck;
	jsprim.flattenObject = flattenObject;
	jsprim.flattenIter = flattenIter;
	jsprim.validateJsonObject = validateJsonObjectJS;
	jsprim.validateJsonObjectJS = validateJsonObjectJS;
	jsprim.randElt = randElt;
	jsprim.extraProperties = extraProperties;
	jsprim.mergeObjects = mergeObjects;

	jsprim.startsWith = startsWith;
	jsprim.endsWith = endsWith;

	jsprim.parseInteger = parseInteger;

	jsprim.iso8601 = iso8601;
	jsprim.rfc1123 = rfc1123;
	jsprim.parseDateTime = parseDateTime;

	jsprim.hrtimediff = hrtimeDiff;
	jsprim.hrtimeDiff = hrtimeDiff;
	jsprim.hrtimeAccum = hrtimeAccum;
	jsprim.hrtimeAdd = hrtimeAdd;
	jsprim.hrtimeNanosec = hrtimeNanosec;
	jsprim.hrtimeMicrosec = hrtimeMicrosec;
	jsprim.hrtimeMillisec = hrtimeMillisec;


	/*
	 * Deep copy an acyclic *basic* Javascript object.  This only handles basic
	 * scalars (strings, numbers, booleans) and arbitrarily deep arrays and objects
	 * containing these.  This does *not* handle instances of other classes.
	 */
	function deepCopy(obj)
	{
		var ret, key;
		var marker = '__deepCopy';

		if (obj && obj[marker])
			throw (new Error('attempted deep copy of cyclic object'));

		if (obj && obj.constructor == Object) {
			ret = {};
			obj[marker] = true;

			for (key in obj) {
				if (key == marker)
					continue;

				ret[key] = deepCopy(obj[key]);
			}

			delete (obj[marker]);
			return (ret);
		}

		if (obj && obj.constructor == Array) {
			ret = [];
			obj[marker] = true;

			for (key = 0; key < obj.length; key++)
				ret.push(deepCopy(obj[key]));

			delete (obj[marker]);
			return (ret);
		}

		/*
		 * It must be a primitive type -- just return it.
		 */
		return (obj);
	}

	function deepEqual(obj1, obj2)
	{
		if (typeof (obj1) != typeof (obj2))
			return (false);

		if (obj1 === null || obj2 === null || typeof (obj1) != 'object')
			return (obj1 === obj2);

		if (obj1.constructor != obj2.constructor)
			return (false);

		var k;
		for (k in obj1) {
			if (!obj2.hasOwnProperty(k))
				return (false);

			if (!deepEqual(obj1[k], obj2[k]))
				return (false);
		}

		for (k in obj2) {
			if (!obj1.hasOwnProperty(k))
				return (false);
		}

		return (true);
	}

	function isEmpty(obj)
	{
		var key;
		for (key in obj)
			return (false);
		return (true);
	}

	function hasKey(obj, key)
	{
		mod_assert.equal(typeof (key), 'string');
		return (Object.prototype.hasOwnProperty.call(obj, key));
	}

	function forEachKey(obj, callback)
	{
		for (var key in obj) {
			if (hasKey(obj, key)) {
				callback(key, obj[key]);
			}
		}
	}

	function pluck(obj, key)
	{
		mod_assert.equal(typeof (key), 'string');
		return (pluckv(obj, key));
	}

	function pluckv(obj, key)
	{
		if (obj === null || typeof (obj) !== 'object')
			return (undefined);

		if (obj.hasOwnProperty(key))
			return (obj[key]);

		var i = key.indexOf('.');
		if (i == -1)
			return (undefined);

		var key1 = key.substr(0, i);
		if (!obj.hasOwnProperty(key1))
			return (undefined);

		return (pluckv(obj[key1], key.substr(i + 1)));
	}

	/*
	 * Invoke callback(row) for each entry in the array that would be returned by
	 * flattenObject(data, depth).  This is just like flattenObject(data,
	 * depth).forEach(callback), except that the intermediate array is never
	 * created.
	 */
	function flattenIter(data, depth, callback)
	{
		doFlattenIter(data, depth, [], callback);
	}

	function doFlattenIter(data, depth, accum, callback)
	{
		var each;
		var key;

		if (depth === 0) {
			each = accum.slice(0);
			each.push(data);
			callback(each);
			return;
		}

		mod_assert.ok(data !== null);
		mod_assert.equal(typeof (data), 'object');
		mod_assert.equal(typeof (depth), 'number');
		mod_assert.ok(depth >= 0);

		for (key in data) {
			each = accum.slice(0);
			each.push(key);
			doFlattenIter(data[key], depth - 1, each, callback);
		}
	}

	function flattenObject(data, depth)
	{
		if (depth === 0)
			return ([ data ]);

		mod_assert.ok(data !== null);
		mod_assert.equal(typeof (data), 'object');
		mod_assert.equal(typeof (depth), 'number');
		mod_assert.ok(depth >= 0);

		var rv = [];
		var key;

		for (key in data) {
			flattenObject(data[key], depth - 1).forEach(function (p) {
				rv.push([ key ].concat(p));
			});
		}

		return (rv);
	}

	function startsWith(str, prefix)
	{
		return (str.substr(0, prefix.length) == prefix);
	}

	function endsWith(str, suffix)
	{
		return (str.substr(
		    str.length - suffix.length, suffix.length) == suffix);
	}

	function iso8601(d)
	{
		if (typeof (d) == 'number')
			d = new Date(d);
		mod_assert.ok(d.constructor === Date);
		return (mod_extsprintf.sprintf('%4d-%02d-%02dT%02d:%02d:%02d.%03dZ',
		    d.getUTCFullYear(), d.getUTCMonth() + 1, d.getUTCDate(),
		    d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(),
		    d.getUTCMilliseconds()));
	}

	var RFC1123_MONTHS = [
	    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
	    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
	var RFC1123_DAYS = [
	    'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

	function rfc1123(date) {
		return (mod_extsprintf.sprintf('%s, %02d %s %04d %02d:%02d:%02d GMT',
		    RFC1123_DAYS[date.getUTCDay()], date.getUTCDate(),
		    RFC1123_MONTHS[date.getUTCMonth()], date.getUTCFullYear(),
		    date.getUTCHours(), date.getUTCMinutes(),
		    date.getUTCSeconds()));
	}

	/*
	 * Parses a date expressed as a string, as either a number of milliseconds since
	 * the epoch or any string format that Date accepts, giving preference to the
	 * former where these two sets overlap (e.g., small numbers).
	 */
	function parseDateTime(str)
	{
		/*
		 * This is irritatingly implicit, but significantly more concise than
		 * alternatives.  The "+str" will convert a string containing only a
		 * number directly to a Number, or NaN for other strings.  Thus, if the
		 * conversion succeeds, we use it (this is the milliseconds-since-epoch
		 * case).  Otherwise, we pass the string directly to the Date
		 * constructor to parse.
		 */
		var numeric = +str;
		if (!isNaN(numeric)) {
			return (new Date(numeric));
		} else {
			return (new Date(str));
		}
	}


	/*
	 * Number.*_SAFE_INTEGER isn't present before node v0.12, so we hardcode
	 * the ES6 definitions here, while allowing for them to someday be higher.
	 */
	var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
	var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;


	/*
	 * Default options for parseInteger().
	 */
	var PI_DEFAULTS = {
		base: 10,
		allowSign: true,
		allowPrefix: false,
		allowTrailing: false,
		allowImprecise: false,
		trimWhitespace: false,
		leadingZeroIsOctal: false
	};

	var CP_0 = 0x30;
	var CP_9 = 0x39;

	var CP_A = 0x41;
	var CP_B = 0x42;
	var CP_O = 0x4f;
	var CP_T = 0x54;
	var CP_X = 0x58;
	var CP_Z = 0x5a;

	var CP_a = 0x61;
	var CP_b = 0x62;
	var CP_o = 0x6f;
	var CP_t = 0x74;
	var CP_x = 0x78;
	var CP_z = 0x7a;

	var PI_CONV_DEC = 0x30;
	var PI_CONV_UC = 0x37;
	var PI_CONV_LC = 0x57;


	/*
	 * A stricter version of parseInt() that provides options for changing what
	 * is an acceptable string (for example, disallowing trailing characters).
	 */
	function parseInteger(str, uopts)
	{
		mod_assert.string(str, 'str');
		mod_assert.optionalObject(uopts, 'options');

		var baseOverride = false;
		var options = PI_DEFAULTS;

		if (uopts) {
			baseOverride = hasKey(uopts, 'base');
			options = mergeObjects(options, uopts);
			mod_assert.number(options.base, 'options.base');
			mod_assert.ok(options.base >= 2, 'options.base >= 2');
			mod_assert.ok(options.base <= 36, 'options.base <= 36');
			mod_assert.bool(options.allowSign, 'options.allowSign');
			mod_assert.bool(options.allowPrefix, 'options.allowPrefix');
			mod_assert.bool(options.allowTrailing,
			    'options.allowTrailing');
			mod_assert.bool(options.allowImprecise,
			    'options.allowImprecise');
			mod_assert.bool(options.trimWhitespace,
			    'options.trimWhitespace');
			mod_assert.bool(options.leadingZeroIsOctal,
			    'options.leadingZeroIsOctal');

			if (options.leadingZeroIsOctal) {
				mod_assert.ok(!baseOverride,
				    '"base" and "leadingZeroIsOctal" are ' +
				    'mutually exclusive');
			}
		}

		var c;
		var pbase = -1;
		var base = options.base;
		var start;
		var mult = 1;
		var value = 0;
		var idx = 0;
		var len = str.length;

		/* Trim any whitespace on the left side. */
		if (options.trimWhitespace) {
			while (idx < len && isSpace(str.charCodeAt(idx))) {
				++idx;
			}
		}

		/* Check the number for a leading sign. */
		if (options.allowSign) {
			if (str[idx] === '-') {
				idx += 1;
				mult = -1;
			} else if (str[idx] === '+') {
				idx += 1;
			}
		}

		/* Parse the base-indicating prefix if there is one. */
		if (str[idx] === '0') {
			if (options.allowPrefix) {
				pbase = prefixToBase(str.charCodeAt(idx + 1));
				if (pbase !== -1 && (!baseOverride || pbase === base)) {
					base = pbase;
					idx += 2;
				}
			}

			if (pbase === -1 && options.leadingZeroIsOctal) {
				base = 8;
			}
		}

		/* Parse the actual digits. */
		for (start = idx; idx < len; ++idx) {
			c = translateDigit(str.charCodeAt(idx));
			if (c !== -1 && c < base) {
				value *= base;
				value += c;
			} else {
				break;
			}
		}

		/* If we didn't parse any digits, we have an invalid number. */
		if (start === idx) {
			return (new Error('invalid number: ' + JSON.stringify(str)));
		}

		/* Trim any whitespace on the right side. */
		if (options.trimWhitespace) {
			while (idx < len && isSpace(str.charCodeAt(idx))) {
				++idx;
			}
		}

		/* Check for trailing characters. */
		if (idx < len && !options.allowTrailing) {
			return (new Error('trailing characters after number: ' +
			    JSON.stringify(str.slice(idx))));
		}

		/* If our value is 0, we return now, to avoid returning -0. */
		if (value === 0) {
			return (0);
		}

		/* Calculate our final value. */
		var result = value * mult;

		/*
		 * If the string represents a value that cannot be precisely represented
		 * by JavaScript, then we want to check that:
		 *
		 * - We never increased the value past MAX_SAFE_INTEGER
		 * - We don't make the result negative and below MIN_SAFE_INTEGER
		 *
		 * Because we only ever increment the value during parsing, there's no
		 * chance of moving past MAX_SAFE_INTEGER and then dropping below it
		 * again, losing precision in the process. This means that we only need
		 * to do our checks here, at the end.
		 */
		if (!options.allowImprecise &&
		    (value > MAX_SAFE_INTEGER || result < MIN_SAFE_INTEGER)) {
			return (new Error('number is outside of the supported range: ' +
			    JSON.stringify(str.slice(start, idx))));
		}

		return (result);
	}


	/*
	 * Interpret a character code as a base-36 digit.
	 */
	function translateDigit(d)
	{
		if (d >= CP_0 && d <= CP_9) {
			/* '0' to '9' -> 0 to 9 */
			return (d - PI_CONV_DEC);
		} else if (d >= CP_A && d <= CP_Z) {
			/* 'A' - 'Z' -> 10 to 35 */
			return (d - PI_CONV_UC);
		} else if (d >= CP_a && d <= CP_z) {
			/* 'a' - 'z' -> 10 to 35 */
			return (d - PI_CONV_LC);
		} else {
			/* Invalid character code */
			return (-1);
		}
	}


	/*
	 * Test if a value matches the ECMAScript definition of trimmable whitespace.
	 */
	function isSpace(c)
	{
		return (c === 0x20) ||
		    (c >= 0x0009 && c <= 0x000d) ||
		    (c === 0x00a0) ||
		    (c === 0x1680) ||
		    (c === 0x180e) ||
		    (c >= 0x2000 && c <= 0x200a) ||
		    (c === 0x2028) ||
		    (c === 0x2029) ||
		    (c === 0x202f) ||
		    (c === 0x205f) ||
		    (c === 0x3000) ||
		    (c === 0xfeff);
	}


	/*
	 * Determine which base a character indicates (e.g., 'x' indicates hex).
	 */
	function prefixToBase(c)
	{
		if (c === CP_b || c === CP_B) {
			/* 0b/0B (binary) */
			return (2);
		} else if (c === CP_o || c === CP_O) {
			/* 0o/0O (octal) */
			return (8);
		} else if (c === CP_t || c === CP_T) {
			/* 0t/0T (decimal) */
			return (10);
		} else if (c === CP_x || c === CP_X) {
			/* 0x/0X (hexadecimal) */
			return (16);
		} else {
			/* Not a meaningful character */
			return (-1);
		}
	}


	function validateJsonObjectJS(schema, input)
	{
		var report = mod_jsonschema.validate(input, schema);

		if (report.errors.length === 0)
			return (null);

		/* Currently, we only do anything useful with the first error. */
		var error = report.errors[0];

		/* The failed property is given by a URI with an irrelevant prefix. */
		var propname = error['property'];
		var reason = error['message'].toLowerCase();
		var i, j;

		/*
		 * There's at least one case where the property error message is
		 * confusing at best.  We work around this here.
		 */
		if ((i = reason.indexOf('the property ')) != -1 &&
		    (j = reason.indexOf(' is not defined in the schema and the ' +
		    'schema does not allow additional properties')) != -1) {
			i += 'the property '.length;
			if (propname === '')
				propname = reason.substr(i, j - i);
			else
				propname = propname + '.' + reason.substr(i, j - i);

			reason = 'unsupported property';
		}

		var rv = new mod_verror.VError('property "%s": %s', propname, reason);
		rv.jsv_details = error;
		return (rv);
	}

	function randElt(arr)
	{
		mod_assert.ok(Array.isArray(arr) && arr.length > 0,
		    'randElt argument must be a non-empty array');

		return (arr[Math.floor(Math.random() * arr.length)]);
	}

	function assertHrtime(a)
	{
		mod_assert.ok(a[0] >= 0 && a[1] >= 0,
		    'negative numbers not allowed in hrtimes');
		mod_assert.ok(a[1] < 1e9, 'nanoseconds column overflow');
	}

	/*
	 * Compute the time elapsed between hrtime readings A and B, where A is later
	 * than B.  hrtime readings come from Node's process.hrtime().  There is no
	 * defined way to represent negative deltas, so it's illegal to diff B from A
	 * where the time denoted by B is later than the time denoted by A.  If this
	 * becomes valuable, we can define a representation and extend the
	 * implementation to support it.
	 */
	function hrtimeDiff(a, b)
	{
		assertHrtime(a);
		assertHrtime(b);
		mod_assert.ok(a[0] > b[0] || (a[0] == b[0] && a[1] >= b[1]),
		    'negative differences not allowed');

		var rv = [ a[0] - b[0], 0 ];

		if (a[1] >= b[1]) {
			rv[1] = a[1] - b[1];
		} else {
			rv[0]--;
			rv[1] = 1e9 - (b[1] - a[1]);
		}

		return (rv);
	}

	/*
	 * Convert a hrtime reading from the array format returned by Node's
	 * process.hrtime() into a scalar number of nanoseconds.
	 */
	function hrtimeNanosec(a)
	{
		assertHrtime(a);

		return (Math.floor(a[0] * 1e9 + a[1]));
	}

	/*
	 * Convert a hrtime reading from the array format returned by Node's
	 * process.hrtime() into a scalar number of microseconds.
	 */
	function hrtimeMicrosec(a)
	{
		assertHrtime(a);

		return (Math.floor(a[0] * 1e6 + a[1] / 1e3));
	}

	/*
	 * Convert a hrtime reading from the array format returned by Node's
	 * process.hrtime() into a scalar number of milliseconds.
	 */
	function hrtimeMillisec(a)
	{
		assertHrtime(a);

		return (Math.floor(a[0] * 1e3 + a[1] / 1e6));
	}

	/*
	 * Add two hrtime readings A and B, overwriting A with the result of the
	 * addition.  This function is useful for accumulating several hrtime intervals
	 * into a counter.  Returns A.
	 */
	function hrtimeAccum(a, b)
	{
		assertHrtime(a);
		assertHrtime(b);

		/*
		 * Accumulate the nanosecond component.
		 */
		a[1] += b[1];
		if (a[1] >= 1e9) {
			/*
			 * The nanosecond component overflowed, so carry to the seconds
			 * field.
			 */
			a[0]++;
			a[1] -= 1e9;
		}

		/*
		 * Accumulate the seconds component.
		 */
		a[0] += b[0];

		return (a);
	}

	/*
	 * Add two hrtime readings A and B, returning the result as a new hrtime array.
	 * Does not modify either input argument.
	 */
	function hrtimeAdd(a, b)
	{
		assertHrtime(a);

		var rv = [ a[0], a[1] ];

		return (hrtimeAccum(rv, b));
	}


	/*
	 * Check an object for unexpected properties.  Accepts the object to check, and
	 * an array of allowed property names (strings).  Returns an array of key names
	 * that were found on the object, but did not appear in the list of allowed
	 * properties.  If no properties were found, the returned array will be of
	 * zero length.
	 */
	function extraProperties(obj, allowed)
	{
		mod_assert.ok(typeof (obj) === 'object' && obj !== null,
		    'obj argument must be a non-null object');
		mod_assert.ok(Array.isArray(allowed),
		    'allowed argument must be an array of strings');
		for (var i = 0; i < allowed.length; i++) {
			mod_assert.ok(typeof (allowed[i]) === 'string',
			    'allowed argument must be an array of strings');
		}

		return (Object.keys(obj).filter(function (key) {
			return (allowed.indexOf(key) === -1);
		}));
	}

	/*
	 * Given three sets of properties "provided" (may be undefined), "overrides"
	 * (required), and "defaults" (may be undefined), construct an object containing
	 * the union of these sets with "overrides" overriding "provided", and
	 * "provided" overriding "defaults".  None of the input objects are modified.
	 */
	function mergeObjects(provided, overrides, defaults)
	{
		var rv, k;

		rv = {};
		if (defaults) {
			for (k in defaults)
				rv[k] = defaults[k];
		}

		if (provided) {
			for (k in provided)
				rv[k] = provided[k];
		}

		if (overrides) {
			for (k in overrides)
				rv[k] = overrides[k];
		}

		return (rv);
	}
	return jsprim;
}

var signer;
var hasRequiredSigner;

function requireSigner () {
	if (hasRequiredSigner) return signer;
	hasRequiredSigner = 1;
	// Copyright 2012 Joyent, Inc.  All rights reserved.

	var assert = requireAssert();
	var crypto = require$$0$5;
	var util = require$$1$2;
	var sshpk = requireLib$8();
	var jsprim = requireJsprim();
	var utils = requireUtils$4();

	var sprintf = require$$1$2.format;

	var HASH_ALGOS = utils.HASH_ALGOS;
	var PK_ALGOS = utils.PK_ALGOS;
	var InvalidAlgorithmError = utils.InvalidAlgorithmError;
	var HttpSignatureError = utils.HttpSignatureError;
	var validateAlgorithm = utils.validateAlgorithm;

	///--- Globals

	var AUTHZ_FMT =
	  'Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';

	///--- Specific Errors

	function MissingHeaderError(message) {
	  HttpSignatureError.call(this, message, MissingHeaderError);
	}
	util.inherits(MissingHeaderError, HttpSignatureError);

	function StrictParsingError(message) {
	  HttpSignatureError.call(this, message, StrictParsingError);
	}
	util.inherits(StrictParsingError, HttpSignatureError);

	/* See createSigner() */
	function RequestSigner(options) {
	  assert.object(options, 'options');

	  var alg = [];
	  if (options.algorithm !== undefined) {
	    assert.string(options.algorithm, 'options.algorithm');
	    alg = validateAlgorithm(options.algorithm);
	  }
	  this.rs_alg = alg;

	  /*
	   * RequestSigners come in two varieties: ones with an rs_signFunc, and ones
	   * with an rs_signer.
	   *
	   * rs_signFunc-based RequestSigners have to build up their entire signing
	   * string within the rs_lines array and give it to rs_signFunc as a single
	   * concat'd blob. rs_signer-based RequestSigners can add a line at a time to
	   * their signing state by using rs_signer.update(), thus only needing to
	   * buffer the hash function state and one line at a time.
	   */
	  if (options.sign !== undefined) {
	    assert.func(options.sign, 'options.sign');
	    this.rs_signFunc = options.sign;

	  } else if (alg[0] === 'hmac' && options.key !== undefined) {
	    assert.string(options.keyId, 'options.keyId');
	    this.rs_keyId = options.keyId;

	    if (typeof (options.key) !== 'string' && !Buffer.isBuffer(options.key))
	      throw (new TypeError('options.key for HMAC must be a string or Buffer'));

	    /*
	     * Make an rs_signer for HMACs, not a rs_signFunc -- HMACs digest their
	     * data in chunks rather than requiring it all to be given in one go
	     * at the end, so they are more similar to signers than signFuncs.
	     */
	    this.rs_signer = crypto.createHmac(alg[1].toUpperCase(), options.key);
	    this.rs_signer.sign = function () {
	      var digest = this.digest('base64');
	      return ({
	        hashAlgorithm: alg[1],
	        toString: function () { return (digest); }
	      });
	    };

	  } else if (options.key !== undefined) {
	    var key = options.key;
	    if (typeof (key) === 'string' || Buffer.isBuffer(key))
	      key = sshpk.parsePrivateKey(key);

	    assert.ok(sshpk.PrivateKey.isPrivateKey(key, [1, 2]),
	      'options.key must be a sshpk.PrivateKey');
	    this.rs_key = key;

	    assert.string(options.keyId, 'options.keyId');
	    this.rs_keyId = options.keyId;

	    if (!PK_ALGOS[key.type]) {
	      throw (new InvalidAlgorithmError(key.type.toUpperCase() + ' type ' +
	        'keys are not supported'));
	    }

	    if (alg[0] !== undefined && key.type !== alg[0]) {
	      throw (new InvalidAlgorithmError('options.key must be a ' +
	        alg[0].toUpperCase() + ' key, was given a ' +
	        key.type.toUpperCase() + ' key instead'));
	    }

	    this.rs_signer = key.createSign(alg[1]);

	  } else {
	    throw (new TypeError('options.sign (func) or options.key is required'));
	  }

	  this.rs_headers = [];
	  this.rs_lines = [];
	}

	/**
	 * Adds a header to be signed, with its value, into this signer.
	 *
	 * @param {String} header
	 * @param {String} value
	 * @return {String} value written
	 */
	RequestSigner.prototype.writeHeader = function (header, value) {
	  assert.string(header, 'header');
	  header = header.toLowerCase();
	  assert.string(value, 'value');

	  this.rs_headers.push(header);

	  if (this.rs_signFunc) {
	    this.rs_lines.push(header + ': ' + value);

	  } else {
	    var line = header + ': ' + value;
	    if (this.rs_headers.length > 0)
	      line = '\n' + line;
	    this.rs_signer.update(line);
	  }

	  return (value);
	};

	/**
	 * Adds a default Date header, returning its value.
	 *
	 * @return {String}
	 */
	RequestSigner.prototype.writeDateHeader = function () {
	  return (this.writeHeader('date', jsprim.rfc1123(new Date())));
	};

	/**
	 * Adds the request target line to be signed.
	 *
	 * @param {String} method, HTTP method (e.g. 'get', 'post', 'put')
	 * @param {String} path
	 */
	RequestSigner.prototype.writeTarget = function (method, path) {
	  assert.string(method, 'method');
	  assert.string(path, 'path');
	  method = method.toLowerCase();
	  this.writeHeader('(request-target)', method + ' ' + path);
	};

	/**
	 * Calculate the value for the Authorization header on this request
	 * asynchronously.
	 *
	 * @param {Func} callback (err, authz)
	 */
	RequestSigner.prototype.sign = function (cb) {
	  assert.func(cb, 'callback');

	  if (this.rs_headers.length < 1)
	    throw (new Error('At least one header must be signed'));

	  var alg, authz;
	  if (this.rs_signFunc) {
	    var data = this.rs_lines.join('\n');
	    var self = this;
	    this.rs_signFunc(data, function (err, sig) {
	      if (err) {
	        cb(err);
	        return;
	      }
	      try {
	        assert.object(sig, 'signature');
	        assert.string(sig.keyId, 'signature.keyId');
	        assert.string(sig.algorithm, 'signature.algorithm');
	        assert.string(sig.signature, 'signature.signature');
	        alg = validateAlgorithm(sig.algorithm);

	        authz = sprintf(AUTHZ_FMT,
	          sig.keyId,
	          sig.algorithm,
	          self.rs_headers.join(' '),
	          sig.signature);
	      } catch (e) {
	        cb(e);
	        return;
	      }
	      cb(null, authz);
	    });

	  } else {
	    try {
	      var sigObj = this.rs_signer.sign();
	    } catch (e) {
	      cb(e);
	      return;
	    }
	    alg = (this.rs_alg[0] || this.rs_key.type) + '-' + sigObj.hashAlgorithm;
	    var signature = sigObj.toString();
	    authz = sprintf(AUTHZ_FMT,
	      this.rs_keyId,
	      alg,
	      this.rs_headers.join(' '),
	      signature);
	    cb(null, authz);
	  }
	};

	///--- Exported API

	signer = {
	  /**
	   * Identifies whether a given object is a request signer or not.
	   *
	   * @param {Object} object, the object to identify
	   * @returns {Boolean}
	   */
	  isSigner: function (obj) {
	    if (typeof (obj) === 'object' && obj instanceof RequestSigner)
	      return (true);
	    return (false);
	  },

	  /**
	   * Creates a request signer, used to asynchronously build a signature
	   * for a request (does not have to be an http.ClientRequest).
	   *
	   * @param {Object} options, either:
	   *                   - {String} keyId
	   *                   - {String|Buffer} key
	   *                   - {String} algorithm (optional, required for HMAC)
	   *                 or:
	   *                   - {Func} sign (data, cb)
	   * @return {RequestSigner}
	   */
	  createSigner: function createSigner(options) {
	    return (new RequestSigner(options));
	  },

	  /**
	   * Adds an 'Authorization' header to an http.ClientRequest object.
	   *
	   * Note that this API will add a Date header if it's not already set. Any
	   * other headers in the options.headers array MUST be present, or this
	   * will throw.
	   *
	   * You shouldn't need to check the return type; it's just there if you want
	   * to be pedantic.
	   *
	   * The optional flag indicates whether parsing should use strict enforcement
	   * of the version draft-cavage-http-signatures-04 of the spec or beyond.
	   * The default is to be loose and support
	   * older versions for compatibility.
	   *
	   * @param {Object} request an instance of http.ClientRequest.
	   * @param {Object} options signing parameters object:
	   *                   - {String} keyId required.
	   *                   - {String} key required (either a PEM or HMAC key).
	   *                   - {Array} headers optional; defaults to ['date'].
	   *                   - {String} algorithm optional (unless key is HMAC);
	   *                              default is the same as the sshpk default
	   *                              signing algorithm for the type of key given
	   *                   - {String} httpVersion optional; defaults to '1.1'.
	   *                   - {Boolean} strict optional; defaults to 'false'.
	   * @return {Boolean} true if Authorization (and optionally Date) were added.
	   * @throws {TypeError} on bad parameter types (input).
	   * @throws {InvalidAlgorithmError} if algorithm was bad or incompatible with
	   *                                 the given key.
	   * @throws {sshpk.KeyParseError} if key was bad.
	   * @throws {MissingHeaderError} if a header to be signed was specified but
	   *                              was not present.
	   */
	  signRequest: function signRequest(request, options) {
	    assert.object(request, 'request');
	    assert.object(options, 'options');
	    assert.optionalString(options.algorithm, 'options.algorithm');
	    assert.string(options.keyId, 'options.keyId');
	    assert.optionalArrayOfString(options.headers, 'options.headers');
	    assert.optionalString(options.httpVersion, 'options.httpVersion');

	    if (!request.getHeader('Date'))
	      request.setHeader('Date', jsprim.rfc1123(new Date()));
	    if (!options.headers)
	      options.headers = ['date'];
	    if (!options.httpVersion)
	      options.httpVersion = '1.1';

	    var alg = [];
	    if (options.algorithm) {
	      options.algorithm = options.algorithm.toLowerCase();
	      alg = validateAlgorithm(options.algorithm);
	    }

	    var i;
	    var stringToSign = '';
	    for (i = 0; i < options.headers.length; i++) {
	      if (typeof (options.headers[i]) !== 'string')
	        throw new TypeError('options.headers must be an array of Strings');

	      var h = options.headers[i].toLowerCase();

	      if (h === 'request-line') {
	        if (!options.strict) {
	          /**
	           * We allow headers from the older spec drafts if strict parsing isn't
	           * specified in options.
	           */
	          stringToSign +=
	            request.method + ' ' + request.path + ' HTTP/' +
	            options.httpVersion;
	        } else {
	          /* Strict parsing doesn't allow older draft headers. */
	          throw (new StrictParsingError('request-line is not a valid header ' +
	            'with strict parsing enabled.'));
	        }
	      } else if (h === '(request-target)') {
	        stringToSign +=
	          '(request-target): ' + request.method.toLowerCase() + ' ' +
	          request.path;
	      } else {
	        var value = request.getHeader(h);
	        if (value === undefined || value === '') {
	          throw new MissingHeaderError(h + ' was not in the request');
	        }
	        stringToSign += h + ': ' + value;
	      }

	      if ((i + 1) < options.headers.length)
	        stringToSign += '\n';
	    }

	    /* This is just for unit tests. */
	    if (request.hasOwnProperty('_stringToSign')) {
	      request._stringToSign = stringToSign;
	    }

	    var signature;
	    if (alg[0] === 'hmac') {
	      if (typeof (options.key) !== 'string' && !Buffer.isBuffer(options.key))
	        throw (new TypeError('options.key must be a string or Buffer'));

	      var hmac = crypto.createHmac(alg[1].toUpperCase(), options.key);
	      hmac.update(stringToSign);
	      signature = hmac.digest('base64');

	    } else {
	      var key = options.key;
	      if (typeof (key) === 'string' || Buffer.isBuffer(key))
	        key = sshpk.parsePrivateKey(options.key);

	      assert.ok(sshpk.PrivateKey.isPrivateKey(key, [1, 2]),
	        'options.key must be a sshpk.PrivateKey');

	      if (!PK_ALGOS[key.type]) {
	        throw (new InvalidAlgorithmError(key.type.toUpperCase() + ' type ' +
	          'keys are not supported'));
	      }

	      if (alg[0] !== undefined && key.type !== alg[0]) {
	        throw (new InvalidAlgorithmError('options.key must be a ' +
	          alg[0].toUpperCase() + ' key, was given a ' +
	          key.type.toUpperCase() + ' key instead'));
	      }

	      var signer = key.createSign(alg[1]);
	      signer.update(stringToSign);
	      var sigObj = signer.sign();
	      if (!HASH_ALGOS[sigObj.hashAlgorithm]) {
	        throw (new InvalidAlgorithmError(sigObj.hashAlgorithm.toUpperCase() +
	          ' is not a supported hash algorithm'));
	      }
	      options.algorithm = key.type + '-' + sigObj.hashAlgorithm;
	      signature = sigObj.toString();
	      assert.notStrictEqual(signature, '', 'empty signature produced');
	    }

	    var authzHeaderName = options.authorizationHeaderName || 'Authorization';

	    request.setHeader(authzHeaderName, sprintf(AUTHZ_FMT,
	                                               options.keyId,
	                                               options.algorithm,
	                                               options.headers.join(' '),
	                                               signature));

	    return true;
	  }

	};
	return signer;
}

var verify;
var hasRequiredVerify;

function requireVerify () {
	if (hasRequiredVerify) return verify;
	hasRequiredVerify = 1;
	// Copyright 2015 Joyent, Inc.

	var assert = requireAssert();
	var crypto = require$$0$5;
	var sshpk = requireLib$8();
	var utils = requireUtils$4();

	utils.HASH_ALGOS;
	utils.PK_ALGOS;
	utils.InvalidAlgorithmError;
	utils.HttpSignatureError;
	var validateAlgorithm = utils.validateAlgorithm;

	///--- Exported API

	verify = {
	  /**
	   * Verify RSA/DSA signature against public key.  You are expected to pass in
	   * an object that was returned from `parse()`.
	   *
	   * @param {Object} parsedSignature the object you got from `parse`.
	   * @param {String} pubkey RSA/DSA private key PEM.
	   * @return {Boolean} true if valid, false otherwise.
	   * @throws {TypeError} if you pass in bad arguments.
	   * @throws {InvalidAlgorithmError}
	   */
	  verifySignature: function verifySignature(parsedSignature, pubkey) {
	    assert.object(parsedSignature, 'parsedSignature');
	    if (typeof (pubkey) === 'string' || Buffer.isBuffer(pubkey))
	      pubkey = sshpk.parseKey(pubkey);
	    assert.ok(sshpk.Key.isKey(pubkey, [1, 1]), 'pubkey must be a sshpk.Key');

	    var alg = validateAlgorithm(parsedSignature.algorithm);
	    if (alg[0] === 'hmac' || alg[0] !== pubkey.type)
	      return (false);

	    var v = pubkey.createVerify(alg[1]);
	    v.update(parsedSignature.signingString);
	    return (v.verify(parsedSignature.params.signature, 'base64'));
	  },

	  /**
	   * Verify HMAC against shared secret.  You are expected to pass in an object
	   * that was returned from `parse()`.
	   *
	   * @param {Object} parsedSignature the object you got from `parse`.
	   * @param {String} secret HMAC shared secret.
	   * @return {Boolean} true if valid, false otherwise.
	   * @throws {TypeError} if you pass in bad arguments.
	   * @throws {InvalidAlgorithmError}
	   */
	  verifyHMAC: function verifyHMAC(parsedSignature, secret) {
	    assert.object(parsedSignature, 'parsedHMAC');
	    assert.string(secret, 'secret');

	    var alg = validateAlgorithm(parsedSignature.algorithm);
	    if (alg[0] !== 'hmac')
	      return (false);

	    var hashAlg = alg[1].toUpperCase();

	    var hmac = crypto.createHmac(hashAlg, secret);
	    hmac.update(parsedSignature.signingString);

	    /*
	     * Now double-hash to avoid leaking timing information - there's
	     * no easy constant-time compare in JS, so we use this approach
	     * instead. See for more info:
	     * https://www.isecpartners.com/blog/2011/february/double-hmac-
	     * verification.aspx
	     */
	    var h1 = crypto.createHmac(hashAlg, secret);
	    h1.update(hmac.digest());
	    h1 = h1.digest();
	    var h2 = crypto.createHmac(hashAlg, secret);
	    h2.update(new Buffer(parsedSignature.params.signature, 'base64'));
	    h2 = h2.digest();

	    /* Node 0.8 returns strings from .digest(). */
	    if (typeof (h1) === 'string')
	      return (h1 === h2);
	    /* And node 0.10 lacks the .equals() method on Buffers. */
	    if (Buffer.isBuffer(h1) && !h1.equals)
	      return (h1.toString('binary') === h2.toString('binary'));

	    return (h1.equals(h2));
	  }
	};
	return verify;
}

var lib$7;
var hasRequiredLib$7;

function requireLib$7 () {
	if (hasRequiredLib$7) return lib$7;
	hasRequiredLib$7 = 1;
	// Copyright 2015 Joyent, Inc.

	var parser = requireParser();
	var signer = requireSigner();
	var verify = requireVerify();
	var utils = requireUtils$4();



	///--- API

	lib$7 = {

	  parse: parser.parseRequest,
	  parseRequest: parser.parseRequest,

	  sign: signer.signRequest,
	  signRequest: signer.signRequest,
	  createSigner: signer.createSigner,
	  isSigner: signer.isSigner,

	  sshKeyToPEM: utils.sshKeyToPEM,
	  sshKeyFingerprint: utils.fingerprint,
	  pemToRsaSSHKey: utils.pemToRsaSSHKey,

	  verify: verify.verifySignature,
	  verifySignature: verify.verifySignature,
	  verifyHMAC: verify.verifyHMAC
	};
	return lib$7;
}

var mimeTypes = {};

var require$$0$1 = {
	"application/1d-interleaved-parityfec": {
	source: "iana"
},
	"application/3gpdash-qoe-report+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/3gpp-ims+xml": {
	source: "iana",
	compressible: true
},
	"application/3gpphal+json": {
	source: "iana",
	compressible: true
},
	"application/3gpphalforms+json": {
	source: "iana",
	compressible: true
},
	"application/a2l": {
	source: "iana"
},
	"application/ace+cbor": {
	source: "iana"
},
	"application/activemessage": {
	source: "iana"
},
	"application/activity+json": {
	source: "iana",
	compressible: true
},
	"application/alto-costmap+json": {
	source: "iana",
	compressible: true
},
	"application/alto-costmapfilter+json": {
	source: "iana",
	compressible: true
},
	"application/alto-directory+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointcost+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointcostparams+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointprop+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointpropparams+json": {
	source: "iana",
	compressible: true
},
	"application/alto-error+json": {
	source: "iana",
	compressible: true
},
	"application/alto-networkmap+json": {
	source: "iana",
	compressible: true
},
	"application/alto-networkmapfilter+json": {
	source: "iana",
	compressible: true
},
	"application/alto-updatestreamcontrol+json": {
	source: "iana",
	compressible: true
},
	"application/alto-updatestreamparams+json": {
	source: "iana",
	compressible: true
},
	"application/aml": {
	source: "iana"
},
	"application/andrew-inset": {
	source: "iana",
	extensions: [
		"ez"
	]
},
	"application/applefile": {
	source: "iana"
},
	"application/applixware": {
	source: "apache",
	extensions: [
		"aw"
	]
},
	"application/at+jwt": {
	source: "iana"
},
	"application/atf": {
	source: "iana"
},
	"application/atfx": {
	source: "iana"
},
	"application/atom+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atom"
	]
},
	"application/atomcat+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomcat"
	]
},
	"application/atomdeleted+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomdeleted"
	]
},
	"application/atomicmail": {
	source: "iana"
},
	"application/atomsvc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomsvc"
	]
},
	"application/atsc-dwd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dwd"
	]
},
	"application/atsc-dynamic-event-message": {
	source: "iana"
},
	"application/atsc-held+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"held"
	]
},
	"application/atsc-rdt+json": {
	source: "iana",
	compressible: true
},
	"application/atsc-rsat+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rsat"
	]
},
	"application/atxml": {
	source: "iana"
},
	"application/auth-policy+xml": {
	source: "iana",
	compressible: true
},
	"application/bacnet-xdd+zip": {
	source: "iana",
	compressible: false
},
	"application/batch-smtp": {
	source: "iana"
},
	"application/bdoc": {
	compressible: false,
	extensions: [
		"bdoc"
	]
},
	"application/beep+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/calendar+json": {
	source: "iana",
	compressible: true
},
	"application/calendar+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xcs"
	]
},
	"application/call-completion": {
	source: "iana"
},
	"application/cals-1840": {
	source: "iana"
},
	"application/captive+json": {
	source: "iana",
	compressible: true
},
	"application/cbor": {
	source: "iana"
},
	"application/cbor-seq": {
	source: "iana"
},
	"application/cccex": {
	source: "iana"
},
	"application/ccmp+xml": {
	source: "iana",
	compressible: true
},
	"application/ccxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ccxml"
	]
},
	"application/cdfx+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cdfx"
	]
},
	"application/cdmi-capability": {
	source: "iana",
	extensions: [
		"cdmia"
	]
},
	"application/cdmi-container": {
	source: "iana",
	extensions: [
		"cdmic"
	]
},
	"application/cdmi-domain": {
	source: "iana",
	extensions: [
		"cdmid"
	]
},
	"application/cdmi-object": {
	source: "iana",
	extensions: [
		"cdmio"
	]
},
	"application/cdmi-queue": {
	source: "iana",
	extensions: [
		"cdmiq"
	]
},
	"application/cdni": {
	source: "iana"
},
	"application/cea": {
	source: "iana"
},
	"application/cea-2018+xml": {
	source: "iana",
	compressible: true
},
	"application/cellml+xml": {
	source: "iana",
	compressible: true
},
	"application/cfw": {
	source: "iana"
},
	"application/city+json": {
	source: "iana",
	compressible: true
},
	"application/clr": {
	source: "iana"
},
	"application/clue+xml": {
	source: "iana",
	compressible: true
},
	"application/clue_info+xml": {
	source: "iana",
	compressible: true
},
	"application/cms": {
	source: "iana"
},
	"application/cnrp+xml": {
	source: "iana",
	compressible: true
},
	"application/coap-group+json": {
	source: "iana",
	compressible: true
},
	"application/coap-payload": {
	source: "iana"
},
	"application/commonground": {
	source: "iana"
},
	"application/conference-info+xml": {
	source: "iana",
	compressible: true
},
	"application/cose": {
	source: "iana"
},
	"application/cose-key": {
	source: "iana"
},
	"application/cose-key-set": {
	source: "iana"
},
	"application/cpl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cpl"
	]
},
	"application/csrattrs": {
	source: "iana"
},
	"application/csta+xml": {
	source: "iana",
	compressible: true
},
	"application/cstadata+xml": {
	source: "iana",
	compressible: true
},
	"application/csvm+json": {
	source: "iana",
	compressible: true
},
	"application/cu-seeme": {
	source: "apache",
	extensions: [
		"cu"
	]
},
	"application/cwt": {
	source: "iana"
},
	"application/cybercash": {
	source: "iana"
},
	"application/dart": {
	compressible: true
},
	"application/dash+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpd"
	]
},
	"application/dash-patch+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpp"
	]
},
	"application/dashdelta": {
	source: "iana"
},
	"application/davmount+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"davmount"
	]
},
	"application/dca-rft": {
	source: "iana"
},
	"application/dcd": {
	source: "iana"
},
	"application/dec-dx": {
	source: "iana"
},
	"application/dialog-info+xml": {
	source: "iana",
	compressible: true
},
	"application/dicom": {
	source: "iana"
},
	"application/dicom+json": {
	source: "iana",
	compressible: true
},
	"application/dicom+xml": {
	source: "iana",
	compressible: true
},
	"application/dii": {
	source: "iana"
},
	"application/dit": {
	source: "iana"
},
	"application/dns": {
	source: "iana"
},
	"application/dns+json": {
	source: "iana",
	compressible: true
},
	"application/dns-message": {
	source: "iana"
},
	"application/docbook+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"dbk"
	]
},
	"application/dots+cbor": {
	source: "iana"
},
	"application/dskpp+xml": {
	source: "iana",
	compressible: true
},
	"application/dssc+der": {
	source: "iana",
	extensions: [
		"dssc"
	]
},
	"application/dssc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdssc"
	]
},
	"application/dvcs": {
	source: "iana"
},
	"application/ecmascript": {
	source: "iana",
	compressible: true,
	extensions: [
		"es",
		"ecma"
	]
},
	"application/edi-consent": {
	source: "iana"
},
	"application/edi-x12": {
	source: "iana",
	compressible: false
},
	"application/edifact": {
	source: "iana",
	compressible: false
},
	"application/efi": {
	source: "iana"
},
	"application/elm+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/elm+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.cap+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/emergencycalldata.comment+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.control+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.deviceinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.ecall.msd": {
	source: "iana"
},
	"application/emergencycalldata.providerinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.serviceinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.subscriberinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.veds+xml": {
	source: "iana",
	compressible: true
},
	"application/emma+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"emma"
	]
},
	"application/emotionml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"emotionml"
	]
},
	"application/encaprtp": {
	source: "iana"
},
	"application/epp+xml": {
	source: "iana",
	compressible: true
},
	"application/epub+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"epub"
	]
},
	"application/eshop": {
	source: "iana"
},
	"application/exi": {
	source: "iana",
	extensions: [
		"exi"
	]
},
	"application/expect-ct-report+json": {
	source: "iana",
	compressible: true
},
	"application/express": {
	source: "iana",
	extensions: [
		"exp"
	]
},
	"application/fastinfoset": {
	source: "iana"
},
	"application/fastsoap": {
	source: "iana"
},
	"application/fdt+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"fdt"
	]
},
	"application/fhir+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/fhir+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/fido.trusted-apps+json": {
	compressible: true
},
	"application/fits": {
	source: "iana"
},
	"application/flexfec": {
	source: "iana"
},
	"application/font-sfnt": {
	source: "iana"
},
	"application/font-tdpfr": {
	source: "iana",
	extensions: [
		"pfr"
	]
},
	"application/font-woff": {
	source: "iana",
	compressible: false
},
	"application/framework-attributes+xml": {
	source: "iana",
	compressible: true
},
	"application/geo+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"geojson"
	]
},
	"application/geo+json-seq": {
	source: "iana"
},
	"application/geopackage+sqlite3": {
	source: "iana"
},
	"application/geoxacml+xml": {
	source: "iana",
	compressible: true
},
	"application/gltf-buffer": {
	source: "iana"
},
	"application/gml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"gml"
	]
},
	"application/gpx+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"gpx"
	]
},
	"application/gxf": {
	source: "apache",
	extensions: [
		"gxf"
	]
},
	"application/gzip": {
	source: "iana",
	compressible: false,
	extensions: [
		"gz"
	]
},
	"application/h224": {
	source: "iana"
},
	"application/held+xml": {
	source: "iana",
	compressible: true
},
	"application/hjson": {
	extensions: [
		"hjson"
	]
},
	"application/http": {
	source: "iana"
},
	"application/hyperstudio": {
	source: "iana",
	extensions: [
		"stk"
	]
},
	"application/ibe-key-request+xml": {
	source: "iana",
	compressible: true
},
	"application/ibe-pkg-reply+xml": {
	source: "iana",
	compressible: true
},
	"application/ibe-pp-data": {
	source: "iana"
},
	"application/iges": {
	source: "iana"
},
	"application/im-iscomposing+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/index": {
	source: "iana"
},
	"application/index.cmd": {
	source: "iana"
},
	"application/index.obj": {
	source: "iana"
},
	"application/index.response": {
	source: "iana"
},
	"application/index.vnd": {
	source: "iana"
},
	"application/inkml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ink",
		"inkml"
	]
},
	"application/iotp": {
	source: "iana"
},
	"application/ipfix": {
	source: "iana",
	extensions: [
		"ipfix"
	]
},
	"application/ipp": {
	source: "iana"
},
	"application/isup": {
	source: "iana"
},
	"application/its+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"its"
	]
},
	"application/java-archive": {
	source: "apache",
	compressible: false,
	extensions: [
		"jar",
		"war",
		"ear"
	]
},
	"application/java-serialized-object": {
	source: "apache",
	compressible: false,
	extensions: [
		"ser"
	]
},
	"application/java-vm": {
	source: "apache",
	compressible: false,
	extensions: [
		"class"
	]
},
	"application/javascript": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"js",
		"mjs"
	]
},
	"application/jf2feed+json": {
	source: "iana",
	compressible: true
},
	"application/jose": {
	source: "iana"
},
	"application/jose+json": {
	source: "iana",
	compressible: true
},
	"application/jrd+json": {
	source: "iana",
	compressible: true
},
	"application/jscalendar+json": {
	source: "iana",
	compressible: true
},
	"application/json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"json",
		"map"
	]
},
	"application/json-patch+json": {
	source: "iana",
	compressible: true
},
	"application/json-seq": {
	source: "iana"
},
	"application/json5": {
	extensions: [
		"json5"
	]
},
	"application/jsonml+json": {
	source: "apache",
	compressible: true,
	extensions: [
		"jsonml"
	]
},
	"application/jwk+json": {
	source: "iana",
	compressible: true
},
	"application/jwk-set+json": {
	source: "iana",
	compressible: true
},
	"application/jwt": {
	source: "iana"
},
	"application/kpml-request+xml": {
	source: "iana",
	compressible: true
},
	"application/kpml-response+xml": {
	source: "iana",
	compressible: true
},
	"application/ld+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"jsonld"
	]
},
	"application/lgr+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lgr"
	]
},
	"application/link-format": {
	source: "iana"
},
	"application/load-control+xml": {
	source: "iana",
	compressible: true
},
	"application/lost+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lostxml"
	]
},
	"application/lostsync+xml": {
	source: "iana",
	compressible: true
},
	"application/lpf+zip": {
	source: "iana",
	compressible: false
},
	"application/lxf": {
	source: "iana"
},
	"application/mac-binhex40": {
	source: "iana",
	extensions: [
		"hqx"
	]
},
	"application/mac-compactpro": {
	source: "apache",
	extensions: [
		"cpt"
	]
},
	"application/macwriteii": {
	source: "iana"
},
	"application/mads+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mads"
	]
},
	"application/manifest+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"webmanifest"
	]
},
	"application/marc": {
	source: "iana",
	extensions: [
		"mrc"
	]
},
	"application/marcxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mrcx"
	]
},
	"application/mathematica": {
	source: "iana",
	extensions: [
		"ma",
		"nb",
		"mb"
	]
},
	"application/mathml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mathml"
	]
},
	"application/mathml-content+xml": {
	source: "iana",
	compressible: true
},
	"application/mathml-presentation+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-associated-procedure-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-deregister+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-envelope+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-msk+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-msk-response+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-protection-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-reception-report+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-register+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-register-response+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-schedule+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-user-service-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbox": {
	source: "iana",
	extensions: [
		"mbox"
	]
},
	"application/media-policy-dataset+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpf"
	]
},
	"application/media_control+xml": {
	source: "iana",
	compressible: true
},
	"application/mediaservercontrol+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mscml"
	]
},
	"application/merge-patch+json": {
	source: "iana",
	compressible: true
},
	"application/metalink+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"metalink"
	]
},
	"application/metalink4+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"meta4"
	]
},
	"application/mets+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mets"
	]
},
	"application/mf4": {
	source: "iana"
},
	"application/mikey": {
	source: "iana"
},
	"application/mipc": {
	source: "iana"
},
	"application/missing-blocks+cbor-seq": {
	source: "iana"
},
	"application/mmt-aei+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"maei"
	]
},
	"application/mmt-usd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"musd"
	]
},
	"application/mods+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mods"
	]
},
	"application/moss-keys": {
	source: "iana"
},
	"application/moss-signature": {
	source: "iana"
},
	"application/mosskey-data": {
	source: "iana"
},
	"application/mosskey-request": {
	source: "iana"
},
	"application/mp21": {
	source: "iana",
	extensions: [
		"m21",
		"mp21"
	]
},
	"application/mp4": {
	source: "iana",
	extensions: [
		"mp4s",
		"m4p"
	]
},
	"application/mpeg4-generic": {
	source: "iana"
},
	"application/mpeg4-iod": {
	source: "iana"
},
	"application/mpeg4-iod-xmt": {
	source: "iana"
},
	"application/mrb-consumer+xml": {
	source: "iana",
	compressible: true
},
	"application/mrb-publish+xml": {
	source: "iana",
	compressible: true
},
	"application/msc-ivr+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/msc-mixer+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/msword": {
	source: "iana",
	compressible: false,
	extensions: [
		"doc",
		"dot"
	]
},
	"application/mud+json": {
	source: "iana",
	compressible: true
},
	"application/multipart-core": {
	source: "iana"
},
	"application/mxf": {
	source: "iana",
	extensions: [
		"mxf"
	]
},
	"application/n-quads": {
	source: "iana",
	extensions: [
		"nq"
	]
},
	"application/n-triples": {
	source: "iana",
	extensions: [
		"nt"
	]
},
	"application/nasdata": {
	source: "iana"
},
	"application/news-checkgroups": {
	source: "iana",
	charset: "US-ASCII"
},
	"application/news-groupinfo": {
	source: "iana",
	charset: "US-ASCII"
},
	"application/news-transmission": {
	source: "iana"
},
	"application/nlsml+xml": {
	source: "iana",
	compressible: true
},
	"application/node": {
	source: "iana",
	extensions: [
		"cjs"
	]
},
	"application/nss": {
	source: "iana"
},
	"application/oauth-authz-req+jwt": {
	source: "iana"
},
	"application/oblivious-dns-message": {
	source: "iana"
},
	"application/ocsp-request": {
	source: "iana"
},
	"application/ocsp-response": {
	source: "iana"
},
	"application/octet-stream": {
	source: "iana",
	compressible: false,
	extensions: [
		"bin",
		"dms",
		"lrf",
		"mar",
		"so",
		"dist",
		"distz",
		"pkg",
		"bpk",
		"dump",
		"elc",
		"deploy",
		"exe",
		"dll",
		"deb",
		"dmg",
		"iso",
		"img",
		"msi",
		"msp",
		"msm",
		"buffer"
	]
},
	"application/oda": {
	source: "iana",
	extensions: [
		"oda"
	]
},
	"application/odm+xml": {
	source: "iana",
	compressible: true
},
	"application/odx": {
	source: "iana"
},
	"application/oebps-package+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"opf"
	]
},
	"application/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"ogx"
	]
},
	"application/omdoc+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"omdoc"
	]
},
	"application/onenote": {
	source: "apache",
	extensions: [
		"onetoc",
		"onetoc2",
		"onetmp",
		"onepkg"
	]
},
	"application/opc-nodeset+xml": {
	source: "iana",
	compressible: true
},
	"application/oscore": {
	source: "iana"
},
	"application/oxps": {
	source: "iana",
	extensions: [
		"oxps"
	]
},
	"application/p21": {
	source: "iana"
},
	"application/p21+zip": {
	source: "iana",
	compressible: false
},
	"application/p2p-overlay+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"relo"
	]
},
	"application/parityfec": {
	source: "iana"
},
	"application/passport": {
	source: "iana"
},
	"application/patch-ops-error+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xer"
	]
},
	"application/pdf": {
	source: "iana",
	compressible: false,
	extensions: [
		"pdf"
	]
},
	"application/pdx": {
	source: "iana"
},
	"application/pem-certificate-chain": {
	source: "iana"
},
	"application/pgp-encrypted": {
	source: "iana",
	compressible: false,
	extensions: [
		"pgp"
	]
},
	"application/pgp-keys": {
	source: "iana",
	extensions: [
		"asc"
	]
},
	"application/pgp-signature": {
	source: "iana",
	extensions: [
		"asc",
		"sig"
	]
},
	"application/pics-rules": {
	source: "apache",
	extensions: [
		"prf"
	]
},
	"application/pidf+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/pidf-diff+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/pkcs10": {
	source: "iana",
	extensions: [
		"p10"
	]
},
	"application/pkcs12": {
	source: "iana"
},
	"application/pkcs7-mime": {
	source: "iana",
	extensions: [
		"p7m",
		"p7c"
	]
},
	"application/pkcs7-signature": {
	source: "iana",
	extensions: [
		"p7s"
	]
},
	"application/pkcs8": {
	source: "iana",
	extensions: [
		"p8"
	]
},
	"application/pkcs8-encrypted": {
	source: "iana"
},
	"application/pkix-attr-cert": {
	source: "iana",
	extensions: [
		"ac"
	]
},
	"application/pkix-cert": {
	source: "iana",
	extensions: [
		"cer"
	]
},
	"application/pkix-crl": {
	source: "iana",
	extensions: [
		"crl"
	]
},
	"application/pkix-pkipath": {
	source: "iana",
	extensions: [
		"pkipath"
	]
},
	"application/pkixcmp": {
	source: "iana",
	extensions: [
		"pki"
	]
},
	"application/pls+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"pls"
	]
},
	"application/poc-settings+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/postscript": {
	source: "iana",
	compressible: true,
	extensions: [
		"ai",
		"eps",
		"ps"
	]
},
	"application/ppsp-tracker+json": {
	source: "iana",
	compressible: true
},
	"application/problem+json": {
	source: "iana",
	compressible: true
},
	"application/problem+xml": {
	source: "iana",
	compressible: true
},
	"application/provenance+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"provx"
	]
},
	"application/prs.alvestrand.titrax-sheet": {
	source: "iana"
},
	"application/prs.cww": {
	source: "iana",
	extensions: [
		"cww"
	]
},
	"application/prs.cyn": {
	source: "iana",
	charset: "7-BIT"
},
	"application/prs.hpub+zip": {
	source: "iana",
	compressible: false
},
	"application/prs.nprend": {
	source: "iana"
},
	"application/prs.plucker": {
	source: "iana"
},
	"application/prs.rdf-xml-crypt": {
	source: "iana"
},
	"application/prs.xsf+xml": {
	source: "iana",
	compressible: true
},
	"application/pskc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"pskcxml"
	]
},
	"application/pvd+json": {
	source: "iana",
	compressible: true
},
	"application/qsig": {
	source: "iana"
},
	"application/raml+yaml": {
	compressible: true,
	extensions: [
		"raml"
	]
},
	"application/raptorfec": {
	source: "iana"
},
	"application/rdap+json": {
	source: "iana",
	compressible: true
},
	"application/rdf+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rdf",
		"owl"
	]
},
	"application/reginfo+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rif"
	]
},
	"application/relax-ng-compact-syntax": {
	source: "iana",
	extensions: [
		"rnc"
	]
},
	"application/remote-printing": {
	source: "iana"
},
	"application/reputon+json": {
	source: "iana",
	compressible: true
},
	"application/resource-lists+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rl"
	]
},
	"application/resource-lists-diff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rld"
	]
},
	"application/rfc+xml": {
	source: "iana",
	compressible: true
},
	"application/riscos": {
	source: "iana"
},
	"application/rlmi+xml": {
	source: "iana",
	compressible: true
},
	"application/rls-services+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rs"
	]
},
	"application/route-apd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rapd"
	]
},
	"application/route-s-tsid+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sls"
	]
},
	"application/route-usd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rusd"
	]
},
	"application/rpki-ghostbusters": {
	source: "iana",
	extensions: [
		"gbr"
	]
},
	"application/rpki-manifest": {
	source: "iana",
	extensions: [
		"mft"
	]
},
	"application/rpki-publication": {
	source: "iana"
},
	"application/rpki-roa": {
	source: "iana",
	extensions: [
		"roa"
	]
},
	"application/rpki-updown": {
	source: "iana"
},
	"application/rsd+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"rsd"
	]
},
	"application/rss+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"rss"
	]
},
	"application/rtf": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtf"
	]
},
	"application/rtploopback": {
	source: "iana"
},
	"application/rtx": {
	source: "iana"
},
	"application/samlassertion+xml": {
	source: "iana",
	compressible: true
},
	"application/samlmetadata+xml": {
	source: "iana",
	compressible: true
},
	"application/sarif+json": {
	source: "iana",
	compressible: true
},
	"application/sarif-external-properties+json": {
	source: "iana",
	compressible: true
},
	"application/sbe": {
	source: "iana"
},
	"application/sbml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sbml"
	]
},
	"application/scaip+xml": {
	source: "iana",
	compressible: true
},
	"application/scim+json": {
	source: "iana",
	compressible: true
},
	"application/scvp-cv-request": {
	source: "iana",
	extensions: [
		"scq"
	]
},
	"application/scvp-cv-response": {
	source: "iana",
	extensions: [
		"scs"
	]
},
	"application/scvp-vp-request": {
	source: "iana",
	extensions: [
		"spq"
	]
},
	"application/scvp-vp-response": {
	source: "iana",
	extensions: [
		"spp"
	]
},
	"application/sdp": {
	source: "iana",
	extensions: [
		"sdp"
	]
},
	"application/secevent+jwt": {
	source: "iana"
},
	"application/senml+cbor": {
	source: "iana"
},
	"application/senml+json": {
	source: "iana",
	compressible: true
},
	"application/senml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"senmlx"
	]
},
	"application/senml-etch+cbor": {
	source: "iana"
},
	"application/senml-etch+json": {
	source: "iana",
	compressible: true
},
	"application/senml-exi": {
	source: "iana"
},
	"application/sensml+cbor": {
	source: "iana"
},
	"application/sensml+json": {
	source: "iana",
	compressible: true
},
	"application/sensml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sensmlx"
	]
},
	"application/sensml-exi": {
	source: "iana"
},
	"application/sep+xml": {
	source: "iana",
	compressible: true
},
	"application/sep-exi": {
	source: "iana"
},
	"application/session-info": {
	source: "iana"
},
	"application/set-payment": {
	source: "iana"
},
	"application/set-payment-initiation": {
	source: "iana",
	extensions: [
		"setpay"
	]
},
	"application/set-registration": {
	source: "iana"
},
	"application/set-registration-initiation": {
	source: "iana",
	extensions: [
		"setreg"
	]
},
	"application/sgml": {
	source: "iana"
},
	"application/sgml-open-catalog": {
	source: "iana"
},
	"application/shf+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"shf"
	]
},
	"application/sieve": {
	source: "iana",
	extensions: [
		"siv",
		"sieve"
	]
},
	"application/simple-filter+xml": {
	source: "iana",
	compressible: true
},
	"application/simple-message-summary": {
	source: "iana"
},
	"application/simplesymbolcontainer": {
	source: "iana"
},
	"application/sipc": {
	source: "iana"
},
	"application/slate": {
	source: "iana"
},
	"application/smil": {
	source: "iana"
},
	"application/smil+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"smi",
		"smil"
	]
},
	"application/smpte336m": {
	source: "iana"
},
	"application/soap+fastinfoset": {
	source: "iana"
},
	"application/soap+xml": {
	source: "iana",
	compressible: true
},
	"application/sparql-query": {
	source: "iana",
	extensions: [
		"rq"
	]
},
	"application/sparql-results+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"srx"
	]
},
	"application/spdx+json": {
	source: "iana",
	compressible: true
},
	"application/spirits-event+xml": {
	source: "iana",
	compressible: true
},
	"application/sql": {
	source: "iana"
},
	"application/srgs": {
	source: "iana",
	extensions: [
		"gram"
	]
},
	"application/srgs+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"grxml"
	]
},
	"application/sru+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sru"
	]
},
	"application/ssdl+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"ssdl"
	]
},
	"application/ssml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ssml"
	]
},
	"application/stix+json": {
	source: "iana",
	compressible: true
},
	"application/swid+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"swidtag"
	]
},
	"application/tamp-apex-update": {
	source: "iana"
},
	"application/tamp-apex-update-confirm": {
	source: "iana"
},
	"application/tamp-community-update": {
	source: "iana"
},
	"application/tamp-community-update-confirm": {
	source: "iana"
},
	"application/tamp-error": {
	source: "iana"
},
	"application/tamp-sequence-adjust": {
	source: "iana"
},
	"application/tamp-sequence-adjust-confirm": {
	source: "iana"
},
	"application/tamp-status-query": {
	source: "iana"
},
	"application/tamp-status-response": {
	source: "iana"
},
	"application/tamp-update": {
	source: "iana"
},
	"application/tamp-update-confirm": {
	source: "iana"
},
	"application/tar": {
	compressible: true
},
	"application/taxii+json": {
	source: "iana",
	compressible: true
},
	"application/td+json": {
	source: "iana",
	compressible: true
},
	"application/tei+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"tei",
		"teicorpus"
	]
},
	"application/tetra_isi": {
	source: "iana"
},
	"application/thraud+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"tfi"
	]
},
	"application/timestamp-query": {
	source: "iana"
},
	"application/timestamp-reply": {
	source: "iana"
},
	"application/timestamped-data": {
	source: "iana",
	extensions: [
		"tsd"
	]
},
	"application/tlsrpt+gzip": {
	source: "iana"
},
	"application/tlsrpt+json": {
	source: "iana",
	compressible: true
},
	"application/tnauthlist": {
	source: "iana"
},
	"application/token-introspection+jwt": {
	source: "iana"
},
	"application/toml": {
	compressible: true,
	extensions: [
		"toml"
	]
},
	"application/trickle-ice-sdpfrag": {
	source: "iana"
},
	"application/trig": {
	source: "iana",
	extensions: [
		"trig"
	]
},
	"application/ttml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ttml"
	]
},
	"application/tve-trigger": {
	source: "iana"
},
	"application/tzif": {
	source: "iana"
},
	"application/tzif-leap": {
	source: "iana"
},
	"application/ubjson": {
	compressible: false,
	extensions: [
		"ubj"
	]
},
	"application/ulpfec": {
	source: "iana"
},
	"application/urc-grpsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/urc-ressheet+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rsheet"
	]
},
	"application/urc-targetdesc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"td"
	]
},
	"application/urc-uisocketdesc+xml": {
	source: "iana",
	compressible: true
},
	"application/vcard+json": {
	source: "iana",
	compressible: true
},
	"application/vcard+xml": {
	source: "iana",
	compressible: true
},
	"application/vemmi": {
	source: "iana"
},
	"application/vividence.scriptfile": {
	source: "apache"
},
	"application/vnd.1000minds.decision-model+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"1km"
	]
},
	"application/vnd.3gpp-prose+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp-prose-pc3ch+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp-v2x-local-service-information": {
	source: "iana"
},
	"application/vnd.3gpp.5gnas": {
	source: "iana"
},
	"application/vnd.3gpp.access-transfer-events+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.bsf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.gmop+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.gtpc": {
	source: "iana"
},
	"application/vnd.3gpp.interworking-data": {
	source: "iana"
},
	"application/vnd.3gpp.lpp": {
	source: "iana"
},
	"application/vnd.3gpp.mc-signalling-ear": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-payload": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-signalling": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-floor-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-location-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-signed+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-ue-init-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-affiliation-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-location-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-transmission-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mid-call+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.ngap": {
	source: "iana"
},
	"application/vnd.3gpp.pfcp": {
	source: "iana"
},
	"application/vnd.3gpp.pic-bw-large": {
	source: "iana",
	extensions: [
		"plb"
	]
},
	"application/vnd.3gpp.pic-bw-small": {
	source: "iana",
	extensions: [
		"psb"
	]
},
	"application/vnd.3gpp.pic-bw-var": {
	source: "iana",
	extensions: [
		"pvb"
	]
},
	"application/vnd.3gpp.s1ap": {
	source: "iana"
},
	"application/vnd.3gpp.sms": {
	source: "iana"
},
	"application/vnd.3gpp.sms+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.srvcc-ext+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.srvcc-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.state-and-event-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.ussd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp2.bcmcsinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp2.sms": {
	source: "iana"
},
	"application/vnd.3gpp2.tcap": {
	source: "iana",
	extensions: [
		"tcap"
	]
},
	"application/vnd.3lightssoftware.imagescal": {
	source: "iana"
},
	"application/vnd.3m.post-it-notes": {
	source: "iana",
	extensions: [
		"pwn"
	]
},
	"application/vnd.accpac.simply.aso": {
	source: "iana",
	extensions: [
		"aso"
	]
},
	"application/vnd.accpac.simply.imp": {
	source: "iana",
	extensions: [
		"imp"
	]
},
	"application/vnd.acucobol": {
	source: "iana",
	extensions: [
		"acu"
	]
},
	"application/vnd.acucorp": {
	source: "iana",
	extensions: [
		"atc",
		"acutc"
	]
},
	"application/vnd.adobe.air-application-installer-package+zip": {
	source: "apache",
	compressible: false,
	extensions: [
		"air"
	]
},
	"application/vnd.adobe.flash.movie": {
	source: "iana"
},
	"application/vnd.adobe.formscentral.fcdt": {
	source: "iana",
	extensions: [
		"fcdt"
	]
},
	"application/vnd.adobe.fxp": {
	source: "iana",
	extensions: [
		"fxp",
		"fxpl"
	]
},
	"application/vnd.adobe.partial-upload": {
	source: "iana"
},
	"application/vnd.adobe.xdp+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdp"
	]
},
	"application/vnd.adobe.xfdf": {
	source: "iana",
	extensions: [
		"xfdf"
	]
},
	"application/vnd.aether.imp": {
	source: "iana"
},
	"application/vnd.afpc.afplinedata": {
	source: "iana"
},
	"application/vnd.afpc.afplinedata-pagedef": {
	source: "iana"
},
	"application/vnd.afpc.cmoca-cmresource": {
	source: "iana"
},
	"application/vnd.afpc.foca-charset": {
	source: "iana"
},
	"application/vnd.afpc.foca-codedfont": {
	source: "iana"
},
	"application/vnd.afpc.foca-codepage": {
	source: "iana"
},
	"application/vnd.afpc.modca": {
	source: "iana"
},
	"application/vnd.afpc.modca-cmtable": {
	source: "iana"
},
	"application/vnd.afpc.modca-formdef": {
	source: "iana"
},
	"application/vnd.afpc.modca-mediummap": {
	source: "iana"
},
	"application/vnd.afpc.modca-objectcontainer": {
	source: "iana"
},
	"application/vnd.afpc.modca-overlay": {
	source: "iana"
},
	"application/vnd.afpc.modca-pagesegment": {
	source: "iana"
},
	"application/vnd.age": {
	source: "iana",
	extensions: [
		"age"
	]
},
	"application/vnd.ah-barcode": {
	source: "iana"
},
	"application/vnd.ahead.space": {
	source: "iana",
	extensions: [
		"ahead"
	]
},
	"application/vnd.airzip.filesecure.azf": {
	source: "iana",
	extensions: [
		"azf"
	]
},
	"application/vnd.airzip.filesecure.azs": {
	source: "iana",
	extensions: [
		"azs"
	]
},
	"application/vnd.amadeus+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.amazon.ebook": {
	source: "apache",
	extensions: [
		"azw"
	]
},
	"application/vnd.amazon.mobi8-ebook": {
	source: "iana"
},
	"application/vnd.americandynamics.acc": {
	source: "iana",
	extensions: [
		"acc"
	]
},
	"application/vnd.amiga.ami": {
	source: "iana",
	extensions: [
		"ami"
	]
},
	"application/vnd.amundsen.maze+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.android.ota": {
	source: "iana"
},
	"application/vnd.android.package-archive": {
	source: "apache",
	compressible: false,
	extensions: [
		"apk"
	]
},
	"application/vnd.anki": {
	source: "iana"
},
	"application/vnd.anser-web-certificate-issue-initiation": {
	source: "iana",
	extensions: [
		"cii"
	]
},
	"application/vnd.anser-web-funds-transfer-initiation": {
	source: "apache",
	extensions: [
		"fti"
	]
},
	"application/vnd.antix.game-component": {
	source: "iana",
	extensions: [
		"atx"
	]
},
	"application/vnd.apache.arrow.file": {
	source: "iana"
},
	"application/vnd.apache.arrow.stream": {
	source: "iana"
},
	"application/vnd.apache.thrift.binary": {
	source: "iana"
},
	"application/vnd.apache.thrift.compact": {
	source: "iana"
},
	"application/vnd.apache.thrift.json": {
	source: "iana"
},
	"application/vnd.api+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.aplextor.warrp+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.apothekende.reservation+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.apple.installer+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpkg"
	]
},
	"application/vnd.apple.keynote": {
	source: "iana",
	extensions: [
		"key"
	]
},
	"application/vnd.apple.mpegurl": {
	source: "iana",
	extensions: [
		"m3u8"
	]
},
	"application/vnd.apple.numbers": {
	source: "iana",
	extensions: [
		"numbers"
	]
},
	"application/vnd.apple.pages": {
	source: "iana",
	extensions: [
		"pages"
	]
},
	"application/vnd.apple.pkpass": {
	compressible: false,
	extensions: [
		"pkpass"
	]
},
	"application/vnd.arastra.swi": {
	source: "iana"
},
	"application/vnd.aristanetworks.swi": {
	source: "iana",
	extensions: [
		"swi"
	]
},
	"application/vnd.artisan+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.artsquare": {
	source: "iana"
},
	"application/vnd.astraea-software.iota": {
	source: "iana",
	extensions: [
		"iota"
	]
},
	"application/vnd.audiograph": {
	source: "iana",
	extensions: [
		"aep"
	]
},
	"application/vnd.autopackage": {
	source: "iana"
},
	"application/vnd.avalon+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.avistar+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.balsamiq.bmml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"bmml"
	]
},
	"application/vnd.balsamiq.bmpr": {
	source: "iana"
},
	"application/vnd.banana-accounting": {
	source: "iana"
},
	"application/vnd.bbf.usp.error": {
	source: "iana"
},
	"application/vnd.bbf.usp.msg": {
	source: "iana"
},
	"application/vnd.bbf.usp.msg+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.bekitzur-stech+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.bint.med-content": {
	source: "iana"
},
	"application/vnd.biopax.rdf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.blink-idb-value-wrapper": {
	source: "iana"
},
	"application/vnd.blueice.multipass": {
	source: "iana",
	extensions: [
		"mpm"
	]
},
	"application/vnd.bluetooth.ep.oob": {
	source: "iana"
},
	"application/vnd.bluetooth.le.oob": {
	source: "iana"
},
	"application/vnd.bmi": {
	source: "iana",
	extensions: [
		"bmi"
	]
},
	"application/vnd.bpf": {
	source: "iana"
},
	"application/vnd.bpf3": {
	source: "iana"
},
	"application/vnd.businessobjects": {
	source: "iana",
	extensions: [
		"rep"
	]
},
	"application/vnd.byu.uapi+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cab-jscript": {
	source: "iana"
},
	"application/vnd.canon-cpdl": {
	source: "iana"
},
	"application/vnd.canon-lips": {
	source: "iana"
},
	"application/vnd.capasystems-pg+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cendio.thinlinc.clientconf": {
	source: "iana"
},
	"application/vnd.century-systems.tcp_stream": {
	source: "iana"
},
	"application/vnd.chemdraw+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cdxml"
	]
},
	"application/vnd.chess-pgn": {
	source: "iana"
},
	"application/vnd.chipnuts.karaoke-mmd": {
	source: "iana",
	extensions: [
		"mmd"
	]
},
	"application/vnd.ciedi": {
	source: "iana"
},
	"application/vnd.cinderella": {
	source: "iana",
	extensions: [
		"cdy"
	]
},
	"application/vnd.cirpack.isdn-ext": {
	source: "iana"
},
	"application/vnd.citationstyles.style+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"csl"
	]
},
	"application/vnd.claymore": {
	source: "iana",
	extensions: [
		"cla"
	]
},
	"application/vnd.cloanto.rp9": {
	source: "iana",
	extensions: [
		"rp9"
	]
},
	"application/vnd.clonk.c4group": {
	source: "iana",
	extensions: [
		"c4g",
		"c4d",
		"c4f",
		"c4p",
		"c4u"
	]
},
	"application/vnd.cluetrust.cartomobile-config": {
	source: "iana",
	extensions: [
		"c11amc"
	]
},
	"application/vnd.cluetrust.cartomobile-config-pkg": {
	source: "iana",
	extensions: [
		"c11amz"
	]
},
	"application/vnd.coffeescript": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.document": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.document-template": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.presentation": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.presentation-template": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.spreadsheet": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.spreadsheet-template": {
	source: "iana"
},
	"application/vnd.collection+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.collection.doc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.collection.next+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.comicbook+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.comicbook-rar": {
	source: "iana"
},
	"application/vnd.commerce-battelle": {
	source: "iana"
},
	"application/vnd.commonspace": {
	source: "iana",
	extensions: [
		"csp"
	]
},
	"application/vnd.contact.cmsg": {
	source: "iana",
	extensions: [
		"cdbcmsg"
	]
},
	"application/vnd.coreos.ignition+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cosmocaller": {
	source: "iana",
	extensions: [
		"cmc"
	]
},
	"application/vnd.crick.clicker": {
	source: "iana",
	extensions: [
		"clkx"
	]
},
	"application/vnd.crick.clicker.keyboard": {
	source: "iana",
	extensions: [
		"clkk"
	]
},
	"application/vnd.crick.clicker.palette": {
	source: "iana",
	extensions: [
		"clkp"
	]
},
	"application/vnd.crick.clicker.template": {
	source: "iana",
	extensions: [
		"clkt"
	]
},
	"application/vnd.crick.clicker.wordbank": {
	source: "iana",
	extensions: [
		"clkw"
	]
},
	"application/vnd.criticaltools.wbs+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wbs"
	]
},
	"application/vnd.cryptii.pipe+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.crypto-shade-file": {
	source: "iana"
},
	"application/vnd.cryptomator.encrypted": {
	source: "iana"
},
	"application/vnd.cryptomator.vault": {
	source: "iana"
},
	"application/vnd.ctc-posml": {
	source: "iana",
	extensions: [
		"pml"
	]
},
	"application/vnd.ctct.ws+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.cups-pdf": {
	source: "iana"
},
	"application/vnd.cups-postscript": {
	source: "iana"
},
	"application/vnd.cups-ppd": {
	source: "iana",
	extensions: [
		"ppd"
	]
},
	"application/vnd.cups-raster": {
	source: "iana"
},
	"application/vnd.cups-raw": {
	source: "iana"
},
	"application/vnd.curl": {
	source: "iana"
},
	"application/vnd.curl.car": {
	source: "apache",
	extensions: [
		"car"
	]
},
	"application/vnd.curl.pcurl": {
	source: "apache",
	extensions: [
		"pcurl"
	]
},
	"application/vnd.cyan.dean.root+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.cybank": {
	source: "iana"
},
	"application/vnd.cyclonedx+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cyclonedx+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.d2l.coursepackage1p0+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.d3m-dataset": {
	source: "iana"
},
	"application/vnd.d3m-problem": {
	source: "iana"
},
	"application/vnd.dart": {
	source: "iana",
	compressible: true,
	extensions: [
		"dart"
	]
},
	"application/vnd.data-vision.rdz": {
	source: "iana",
	extensions: [
		"rdz"
	]
},
	"application/vnd.datapackage+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dataresource+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dbf": {
	source: "iana",
	extensions: [
		"dbf"
	]
},
	"application/vnd.debian.binary-package": {
	source: "iana"
},
	"application/vnd.dece.data": {
	source: "iana",
	extensions: [
		"uvf",
		"uvvf",
		"uvd",
		"uvvd"
	]
},
	"application/vnd.dece.ttml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"uvt",
		"uvvt"
	]
},
	"application/vnd.dece.unspecified": {
	source: "iana",
	extensions: [
		"uvx",
		"uvvx"
	]
},
	"application/vnd.dece.zip": {
	source: "iana",
	extensions: [
		"uvz",
		"uvvz"
	]
},
	"application/vnd.denovo.fcselayout-link": {
	source: "iana",
	extensions: [
		"fe_launch"
	]
},
	"application/vnd.desmume.movie": {
	source: "iana"
},
	"application/vnd.dir-bi.plate-dl-nosuffix": {
	source: "iana"
},
	"application/vnd.dm.delegation+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dna": {
	source: "iana",
	extensions: [
		"dna"
	]
},
	"application/vnd.document+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dolby.mlp": {
	source: "apache",
	extensions: [
		"mlp"
	]
},
	"application/vnd.dolby.mobile.1": {
	source: "iana"
},
	"application/vnd.dolby.mobile.2": {
	source: "iana"
},
	"application/vnd.doremir.scorecloud-binary-document": {
	source: "iana"
},
	"application/vnd.dpgraph": {
	source: "iana",
	extensions: [
		"dpg"
	]
},
	"application/vnd.dreamfactory": {
	source: "iana",
	extensions: [
		"dfac"
	]
},
	"application/vnd.drive+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ds-keypoint": {
	source: "apache",
	extensions: [
		"kpxx"
	]
},
	"application/vnd.dtg.local": {
	source: "iana"
},
	"application/vnd.dtg.local.flash": {
	source: "iana"
},
	"application/vnd.dtg.local.html": {
	source: "iana"
},
	"application/vnd.dvb.ait": {
	source: "iana",
	extensions: [
		"ait"
	]
},
	"application/vnd.dvb.dvbisl+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.dvbj": {
	source: "iana"
},
	"application/vnd.dvb.esgcontainer": {
	source: "iana"
},
	"application/vnd.dvb.ipdcdftnotifaccess": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgaccess": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgaccess2": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgpdd": {
	source: "iana"
},
	"application/vnd.dvb.ipdcroaming": {
	source: "iana"
},
	"application/vnd.dvb.iptv.alfec-base": {
	source: "iana"
},
	"application/vnd.dvb.iptv.alfec-enhancement": {
	source: "iana"
},
	"application/vnd.dvb.notif-aggregate-root+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-container+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-generic+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-msglist+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-registration-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-registration-response+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-init+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.pfr": {
	source: "iana"
},
	"application/vnd.dvb.service": {
	source: "iana",
	extensions: [
		"svc"
	]
},
	"application/vnd.dxr": {
	source: "iana"
},
	"application/vnd.dynageo": {
	source: "iana",
	extensions: [
		"geo"
	]
},
	"application/vnd.dzr": {
	source: "iana"
},
	"application/vnd.easykaraoke.cdgdownload": {
	source: "iana"
},
	"application/vnd.ecdis-update": {
	source: "iana"
},
	"application/vnd.ecip.rlp": {
	source: "iana"
},
	"application/vnd.eclipse.ditto+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ecowin.chart": {
	source: "iana",
	extensions: [
		"mag"
	]
},
	"application/vnd.ecowin.filerequest": {
	source: "iana"
},
	"application/vnd.ecowin.fileupdate": {
	source: "iana"
},
	"application/vnd.ecowin.series": {
	source: "iana"
},
	"application/vnd.ecowin.seriesrequest": {
	source: "iana"
},
	"application/vnd.ecowin.seriesupdate": {
	source: "iana"
},
	"application/vnd.efi.img": {
	source: "iana"
},
	"application/vnd.efi.iso": {
	source: "iana"
},
	"application/vnd.emclient.accessrequest+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.enliven": {
	source: "iana",
	extensions: [
		"nml"
	]
},
	"application/vnd.enphase.envoy": {
	source: "iana"
},
	"application/vnd.eprints.data+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.epson.esf": {
	source: "iana",
	extensions: [
		"esf"
	]
},
	"application/vnd.epson.msf": {
	source: "iana",
	extensions: [
		"msf"
	]
},
	"application/vnd.epson.quickanime": {
	source: "iana",
	extensions: [
		"qam"
	]
},
	"application/vnd.epson.salt": {
	source: "iana",
	extensions: [
		"slt"
	]
},
	"application/vnd.epson.ssf": {
	source: "iana",
	extensions: [
		"ssf"
	]
},
	"application/vnd.ericsson.quickcall": {
	source: "iana"
},
	"application/vnd.espass-espass+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.eszigno3+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"es3",
		"et3"
	]
},
	"application/vnd.etsi.aoc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.asic-e+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.etsi.asic-s+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.etsi.cug+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvcommand+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvdiscovery+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-bc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-cod+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-npvr+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvservice+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsync+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvueprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.mcid+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.mheg5": {
	source: "iana"
},
	"application/vnd.etsi.overload-control-policy-dataset+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.pstn+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.sci+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.simservs+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.timestamp-token": {
	source: "iana"
},
	"application/vnd.etsi.tsl+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.tsl.der": {
	source: "iana"
},
	"application/vnd.eu.kasparian.car+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.eudora.data": {
	source: "iana"
},
	"application/vnd.evolv.ecig.profile": {
	source: "iana"
},
	"application/vnd.evolv.ecig.settings": {
	source: "iana"
},
	"application/vnd.evolv.ecig.theme": {
	source: "iana"
},
	"application/vnd.exstream-empower+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.exstream-package": {
	source: "iana"
},
	"application/vnd.ezpix-album": {
	source: "iana",
	extensions: [
		"ez2"
	]
},
	"application/vnd.ezpix-package": {
	source: "iana",
	extensions: [
		"ez3"
	]
},
	"application/vnd.f-secure.mobile": {
	source: "iana"
},
	"application/vnd.familysearch.gedcom+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.fastcopy-disk-image": {
	source: "iana"
},
	"application/vnd.fdf": {
	source: "iana",
	extensions: [
		"fdf"
	]
},
	"application/vnd.fdsn.mseed": {
	source: "iana",
	extensions: [
		"mseed"
	]
},
	"application/vnd.fdsn.seed": {
	source: "iana",
	extensions: [
		"seed",
		"dataless"
	]
},
	"application/vnd.ffsns": {
	source: "iana"
},
	"application/vnd.ficlab.flb+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.filmit.zfc": {
	source: "iana"
},
	"application/vnd.fints": {
	source: "iana"
},
	"application/vnd.firemonkeys.cloudcell": {
	source: "iana"
},
	"application/vnd.flographit": {
	source: "iana",
	extensions: [
		"gph"
	]
},
	"application/vnd.fluxtime.clip": {
	source: "iana",
	extensions: [
		"ftc"
	]
},
	"application/vnd.font-fontforge-sfd": {
	source: "iana"
},
	"application/vnd.framemaker": {
	source: "iana",
	extensions: [
		"fm",
		"frame",
		"maker",
		"book"
	]
},
	"application/vnd.frogans.fnc": {
	source: "iana",
	extensions: [
		"fnc"
	]
},
	"application/vnd.frogans.ltf": {
	source: "iana",
	extensions: [
		"ltf"
	]
},
	"application/vnd.fsc.weblaunch": {
	source: "iana",
	extensions: [
		"fsc"
	]
},
	"application/vnd.fujifilm.fb.docuworks": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.docuworks.binder": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.docuworks.container": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.jfi+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.fujitsu.oasys": {
	source: "iana",
	extensions: [
		"oas"
	]
},
	"application/vnd.fujitsu.oasys2": {
	source: "iana",
	extensions: [
		"oa2"
	]
},
	"application/vnd.fujitsu.oasys3": {
	source: "iana",
	extensions: [
		"oa3"
	]
},
	"application/vnd.fujitsu.oasysgp": {
	source: "iana",
	extensions: [
		"fg5"
	]
},
	"application/vnd.fujitsu.oasysprs": {
	source: "iana",
	extensions: [
		"bh2"
	]
},
	"application/vnd.fujixerox.art-ex": {
	source: "iana"
},
	"application/vnd.fujixerox.art4": {
	source: "iana"
},
	"application/vnd.fujixerox.ddd": {
	source: "iana",
	extensions: [
		"ddd"
	]
},
	"application/vnd.fujixerox.docuworks": {
	source: "iana",
	extensions: [
		"xdw"
	]
},
	"application/vnd.fujixerox.docuworks.binder": {
	source: "iana",
	extensions: [
		"xbd"
	]
},
	"application/vnd.fujixerox.docuworks.container": {
	source: "iana"
},
	"application/vnd.fujixerox.hbpl": {
	source: "iana"
},
	"application/vnd.fut-misnet": {
	source: "iana"
},
	"application/vnd.futoin+cbor": {
	source: "iana"
},
	"application/vnd.futoin+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.fuzzysheet": {
	source: "iana",
	extensions: [
		"fzs"
	]
},
	"application/vnd.genomatix.tuxedo": {
	source: "iana",
	extensions: [
		"txd"
	]
},
	"application/vnd.gentics.grd+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.geo+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.geocube+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.geogebra.file": {
	source: "iana",
	extensions: [
		"ggb"
	]
},
	"application/vnd.geogebra.slides": {
	source: "iana"
},
	"application/vnd.geogebra.tool": {
	source: "iana",
	extensions: [
		"ggt"
	]
},
	"application/vnd.geometry-explorer": {
	source: "iana",
	extensions: [
		"gex",
		"gre"
	]
},
	"application/vnd.geonext": {
	source: "iana",
	extensions: [
		"gxt"
	]
},
	"application/vnd.geoplan": {
	source: "iana",
	extensions: [
		"g2w"
	]
},
	"application/vnd.geospace": {
	source: "iana",
	extensions: [
		"g3w"
	]
},
	"application/vnd.gerber": {
	source: "iana"
},
	"application/vnd.globalplatform.card-content-mgt": {
	source: "iana"
},
	"application/vnd.globalplatform.card-content-mgt-response": {
	source: "iana"
},
	"application/vnd.gmx": {
	source: "iana",
	extensions: [
		"gmx"
	]
},
	"application/vnd.google-apps.document": {
	compressible: false,
	extensions: [
		"gdoc"
	]
},
	"application/vnd.google-apps.presentation": {
	compressible: false,
	extensions: [
		"gslides"
	]
},
	"application/vnd.google-apps.spreadsheet": {
	compressible: false,
	extensions: [
		"gsheet"
	]
},
	"application/vnd.google-earth.kml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"kml"
	]
},
	"application/vnd.google-earth.kmz": {
	source: "iana",
	compressible: false,
	extensions: [
		"kmz"
	]
},
	"application/vnd.gov.sk.e-form+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.gov.sk.e-form+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.gov.sk.xmldatacontainer+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.grafeq": {
	source: "iana",
	extensions: [
		"gqf",
		"gqs"
	]
},
	"application/vnd.gridmp": {
	source: "iana"
},
	"application/vnd.groove-account": {
	source: "iana",
	extensions: [
		"gac"
	]
},
	"application/vnd.groove-help": {
	source: "iana",
	extensions: [
		"ghf"
	]
},
	"application/vnd.groove-identity-message": {
	source: "iana",
	extensions: [
		"gim"
	]
},
	"application/vnd.groove-injector": {
	source: "iana",
	extensions: [
		"grv"
	]
},
	"application/vnd.groove-tool-message": {
	source: "iana",
	extensions: [
		"gtm"
	]
},
	"application/vnd.groove-tool-template": {
	source: "iana",
	extensions: [
		"tpl"
	]
},
	"application/vnd.groove-vcard": {
	source: "iana",
	extensions: [
		"vcg"
	]
},
	"application/vnd.hal+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hal+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"hal"
	]
},
	"application/vnd.handheld-entertainment+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"zmm"
	]
},
	"application/vnd.hbci": {
	source: "iana",
	extensions: [
		"hbci"
	]
},
	"application/vnd.hc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hcl-bireports": {
	source: "iana"
},
	"application/vnd.hdt": {
	source: "iana"
},
	"application/vnd.heroku+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hhe.lesson-player": {
	source: "iana",
	extensions: [
		"les"
	]
},
	"application/vnd.hl7cda+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.hl7v2+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.hp-hpgl": {
	source: "iana",
	extensions: [
		"hpgl"
	]
},
	"application/vnd.hp-hpid": {
	source: "iana",
	extensions: [
		"hpid"
	]
},
	"application/vnd.hp-hps": {
	source: "iana",
	extensions: [
		"hps"
	]
},
	"application/vnd.hp-jlyt": {
	source: "iana",
	extensions: [
		"jlt"
	]
},
	"application/vnd.hp-pcl": {
	source: "iana",
	extensions: [
		"pcl"
	]
},
	"application/vnd.hp-pclxl": {
	source: "iana",
	extensions: [
		"pclxl"
	]
},
	"application/vnd.httphone": {
	source: "iana"
},
	"application/vnd.hydrostatix.sof-data": {
	source: "iana",
	extensions: [
		"sfd-hdstx"
	]
},
	"application/vnd.hyper+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hyper-item+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hyperdrive+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hzn-3d-crossword": {
	source: "iana"
},
	"application/vnd.ibm.afplinedata": {
	source: "iana"
},
	"application/vnd.ibm.electronic-media": {
	source: "iana"
},
	"application/vnd.ibm.minipay": {
	source: "iana",
	extensions: [
		"mpy"
	]
},
	"application/vnd.ibm.modcap": {
	source: "iana",
	extensions: [
		"afp",
		"listafp",
		"list3820"
	]
},
	"application/vnd.ibm.rights-management": {
	source: "iana",
	extensions: [
		"irm"
	]
},
	"application/vnd.ibm.secure-container": {
	source: "iana",
	extensions: [
		"sc"
	]
},
	"application/vnd.iccprofile": {
	source: "iana",
	extensions: [
		"icc",
		"icm"
	]
},
	"application/vnd.ieee.1905": {
	source: "iana"
},
	"application/vnd.igloader": {
	source: "iana",
	extensions: [
		"igl"
	]
},
	"application/vnd.imagemeter.folder+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.imagemeter.image+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.immervision-ivp": {
	source: "iana",
	extensions: [
		"ivp"
	]
},
	"application/vnd.immervision-ivu": {
	source: "iana",
	extensions: [
		"ivu"
	]
},
	"application/vnd.ims.imsccv1p1": {
	source: "iana"
},
	"application/vnd.ims.imsccv1p2": {
	source: "iana"
},
	"application/vnd.ims.imsccv1p3": {
	source: "iana"
},
	"application/vnd.ims.lis.v2.result+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolproxy+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolproxy.id+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolsettings+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolsettings.simple+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.informedcontrol.rms+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.informix-visionary": {
	source: "iana"
},
	"application/vnd.infotech.project": {
	source: "iana"
},
	"application/vnd.infotech.project+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.innopath.wamp.notification": {
	source: "iana"
},
	"application/vnd.insors.igm": {
	source: "iana",
	extensions: [
		"igm"
	]
},
	"application/vnd.intercon.formnet": {
	source: "iana",
	extensions: [
		"xpw",
		"xpx"
	]
},
	"application/vnd.intergeo": {
	source: "iana",
	extensions: [
		"i2g"
	]
},
	"application/vnd.intertrust.digibox": {
	source: "iana"
},
	"application/vnd.intertrust.nncp": {
	source: "iana"
},
	"application/vnd.intu.qbo": {
	source: "iana",
	extensions: [
		"qbo"
	]
},
	"application/vnd.intu.qfx": {
	source: "iana",
	extensions: [
		"qfx"
	]
},
	"application/vnd.iptc.g2.catalogitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.conceptitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.knowledgeitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.newsitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.newsmessage+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.packageitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.planningitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ipunplugged.rcprofile": {
	source: "iana",
	extensions: [
		"rcprofile"
	]
},
	"application/vnd.irepository.package+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"irp"
	]
},
	"application/vnd.is-xpr": {
	source: "iana",
	extensions: [
		"xpr"
	]
},
	"application/vnd.isac.fcs": {
	source: "iana",
	extensions: [
		"fcs"
	]
},
	"application/vnd.iso11783-10+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.jam": {
	source: "iana",
	extensions: [
		"jam"
	]
},
	"application/vnd.japannet-directory-service": {
	source: "iana"
},
	"application/vnd.japannet-jpnstore-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-payment-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-registration": {
	source: "iana"
},
	"application/vnd.japannet-registration-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-setstore-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-verification": {
	source: "iana"
},
	"application/vnd.japannet-verification-wakeup": {
	source: "iana"
},
	"application/vnd.jcp.javame.midlet-rms": {
	source: "iana",
	extensions: [
		"rms"
	]
},
	"application/vnd.jisp": {
	source: "iana",
	extensions: [
		"jisp"
	]
},
	"application/vnd.joost.joda-archive": {
	source: "iana",
	extensions: [
		"joda"
	]
},
	"application/vnd.jsk.isdn-ngn": {
	source: "iana"
},
	"application/vnd.kahootz": {
	source: "iana",
	extensions: [
		"ktz",
		"ktr"
	]
},
	"application/vnd.kde.karbon": {
	source: "iana",
	extensions: [
		"karbon"
	]
},
	"application/vnd.kde.kchart": {
	source: "iana",
	extensions: [
		"chrt"
	]
},
	"application/vnd.kde.kformula": {
	source: "iana",
	extensions: [
		"kfo"
	]
},
	"application/vnd.kde.kivio": {
	source: "iana",
	extensions: [
		"flw"
	]
},
	"application/vnd.kde.kontour": {
	source: "iana",
	extensions: [
		"kon"
	]
},
	"application/vnd.kde.kpresenter": {
	source: "iana",
	extensions: [
		"kpr",
		"kpt"
	]
},
	"application/vnd.kde.kspread": {
	source: "iana",
	extensions: [
		"ksp"
	]
},
	"application/vnd.kde.kword": {
	source: "iana",
	extensions: [
		"kwd",
		"kwt"
	]
},
	"application/vnd.kenameaapp": {
	source: "iana",
	extensions: [
		"htke"
	]
},
	"application/vnd.kidspiration": {
	source: "iana",
	extensions: [
		"kia"
	]
},
	"application/vnd.kinar": {
	source: "iana",
	extensions: [
		"kne",
		"knp"
	]
},
	"application/vnd.koan": {
	source: "iana",
	extensions: [
		"skp",
		"skd",
		"skt",
		"skm"
	]
},
	"application/vnd.kodak-descriptor": {
	source: "iana",
	extensions: [
		"sse"
	]
},
	"application/vnd.las": {
	source: "iana"
},
	"application/vnd.las.las+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.las.las+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lasxml"
	]
},
	"application/vnd.laszip": {
	source: "iana"
},
	"application/vnd.leap+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.liberty-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.llamagraphics.life-balance.desktop": {
	source: "iana",
	extensions: [
		"lbd"
	]
},
	"application/vnd.llamagraphics.life-balance.exchange+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lbe"
	]
},
	"application/vnd.logipipe.circuit+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.loom": {
	source: "iana"
},
	"application/vnd.lotus-1-2-3": {
	source: "iana",
	extensions: [
		"123"
	]
},
	"application/vnd.lotus-approach": {
	source: "iana",
	extensions: [
		"apr"
	]
},
	"application/vnd.lotus-freelance": {
	source: "iana",
	extensions: [
		"pre"
	]
},
	"application/vnd.lotus-notes": {
	source: "iana",
	extensions: [
		"nsf"
	]
},
	"application/vnd.lotus-organizer": {
	source: "iana",
	extensions: [
		"org"
	]
},
	"application/vnd.lotus-screencam": {
	source: "iana",
	extensions: [
		"scm"
	]
},
	"application/vnd.lotus-wordpro": {
	source: "iana",
	extensions: [
		"lwp"
	]
},
	"application/vnd.macports.portpkg": {
	source: "iana",
	extensions: [
		"portpkg"
	]
},
	"application/vnd.mapbox-vector-tile": {
	source: "iana",
	extensions: [
		"mvt"
	]
},
	"application/vnd.marlin.drm.actiontoken+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.conftoken+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.license+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.mdcf": {
	source: "iana"
},
	"application/vnd.mason+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.maxar.archive.3tz+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.maxmind.maxmind-db": {
	source: "iana"
},
	"application/vnd.mcd": {
	source: "iana",
	extensions: [
		"mcd"
	]
},
	"application/vnd.medcalcdata": {
	source: "iana",
	extensions: [
		"mc1"
	]
},
	"application/vnd.mediastation.cdkey": {
	source: "iana",
	extensions: [
		"cdkey"
	]
},
	"application/vnd.meridian-slingshot": {
	source: "iana"
},
	"application/vnd.mfer": {
	source: "iana",
	extensions: [
		"mwf"
	]
},
	"application/vnd.mfmp": {
	source: "iana",
	extensions: [
		"mfm"
	]
},
	"application/vnd.micro+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.micrografx.flo": {
	source: "iana",
	extensions: [
		"flo"
	]
},
	"application/vnd.micrografx.igx": {
	source: "iana",
	extensions: [
		"igx"
	]
},
	"application/vnd.microsoft.portable-executable": {
	source: "iana"
},
	"application/vnd.microsoft.windows.thumbnail-cache": {
	source: "iana"
},
	"application/vnd.miele+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.mif": {
	source: "iana",
	extensions: [
		"mif"
	]
},
	"application/vnd.minisoft-hp3000-save": {
	source: "iana"
},
	"application/vnd.mitsubishi.misty-guard.trustweb": {
	source: "iana"
},
	"application/vnd.mobius.daf": {
	source: "iana",
	extensions: [
		"daf"
	]
},
	"application/vnd.mobius.dis": {
	source: "iana",
	extensions: [
		"dis"
	]
},
	"application/vnd.mobius.mbk": {
	source: "iana",
	extensions: [
		"mbk"
	]
},
	"application/vnd.mobius.mqy": {
	source: "iana",
	extensions: [
		"mqy"
	]
},
	"application/vnd.mobius.msl": {
	source: "iana",
	extensions: [
		"msl"
	]
},
	"application/vnd.mobius.plc": {
	source: "iana",
	extensions: [
		"plc"
	]
},
	"application/vnd.mobius.txf": {
	source: "iana",
	extensions: [
		"txf"
	]
},
	"application/vnd.mophun.application": {
	source: "iana",
	extensions: [
		"mpn"
	]
},
	"application/vnd.mophun.certificate": {
	source: "iana",
	extensions: [
		"mpc"
	]
},
	"application/vnd.motorola.flexsuite": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.adsi": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.fis": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.gotap": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.kmr": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.ttc": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.wem": {
	source: "iana"
},
	"application/vnd.motorola.iprm": {
	source: "iana"
},
	"application/vnd.mozilla.xul+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xul"
	]
},
	"application/vnd.ms-3mfdocument": {
	source: "iana"
},
	"application/vnd.ms-artgalry": {
	source: "iana",
	extensions: [
		"cil"
	]
},
	"application/vnd.ms-asf": {
	source: "iana"
},
	"application/vnd.ms-cab-compressed": {
	source: "iana",
	extensions: [
		"cab"
	]
},
	"application/vnd.ms-color.iccprofile": {
	source: "apache"
},
	"application/vnd.ms-excel": {
	source: "iana",
	compressible: false,
	extensions: [
		"xls",
		"xlm",
		"xla",
		"xlc",
		"xlt",
		"xlw"
	]
},
	"application/vnd.ms-excel.addin.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlam"
	]
},
	"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlsb"
	]
},
	"application/vnd.ms-excel.sheet.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlsm"
	]
},
	"application/vnd.ms-excel.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"xltm"
	]
},
	"application/vnd.ms-fontobject": {
	source: "iana",
	compressible: true,
	extensions: [
		"eot"
	]
},
	"application/vnd.ms-htmlhelp": {
	source: "iana",
	extensions: [
		"chm"
	]
},
	"application/vnd.ms-ims": {
	source: "iana",
	extensions: [
		"ims"
	]
},
	"application/vnd.ms-lrm": {
	source: "iana",
	extensions: [
		"lrm"
	]
},
	"application/vnd.ms-office.activex+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-officetheme": {
	source: "iana",
	extensions: [
		"thmx"
	]
},
	"application/vnd.ms-opentype": {
	source: "apache",
	compressible: true
},
	"application/vnd.ms-outlook": {
	compressible: false,
	extensions: [
		"msg"
	]
},
	"application/vnd.ms-package.obfuscated-opentype": {
	source: "apache"
},
	"application/vnd.ms-pki.seccat": {
	source: "apache",
	extensions: [
		"cat"
	]
},
	"application/vnd.ms-pki.stl": {
	source: "apache",
	extensions: [
		"stl"
	]
},
	"application/vnd.ms-playready.initiator+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-powerpoint": {
	source: "iana",
	compressible: false,
	extensions: [
		"ppt",
		"pps",
		"pot"
	]
},
	"application/vnd.ms-powerpoint.addin.macroenabled.12": {
	source: "iana",
	extensions: [
		"ppam"
	]
},
	"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
	source: "iana",
	extensions: [
		"pptm"
	]
},
	"application/vnd.ms-powerpoint.slide.macroenabled.12": {
	source: "iana",
	extensions: [
		"sldm"
	]
},
	"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
	source: "iana",
	extensions: [
		"ppsm"
	]
},
	"application/vnd.ms-powerpoint.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"potm"
	]
},
	"application/vnd.ms-printdevicecapabilities+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-printing.printticket+xml": {
	source: "apache",
	compressible: true
},
	"application/vnd.ms-printschematicket+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-project": {
	source: "iana",
	extensions: [
		"mpp",
		"mpt"
	]
},
	"application/vnd.ms-tnef": {
	source: "iana"
},
	"application/vnd.ms-windows.devicepairing": {
	source: "iana"
},
	"application/vnd.ms-windows.nwprinting.oob": {
	source: "iana"
},
	"application/vnd.ms-windows.printerpairing": {
	source: "iana"
},
	"application/vnd.ms-windows.wsd.oob": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.lic-chlg-req": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.lic-resp": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.meter-chlg-req": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.meter-resp": {
	source: "iana"
},
	"application/vnd.ms-word.document.macroenabled.12": {
	source: "iana",
	extensions: [
		"docm"
	]
},
	"application/vnd.ms-word.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"dotm"
	]
},
	"application/vnd.ms-works": {
	source: "iana",
	extensions: [
		"wps",
		"wks",
		"wcm",
		"wdb"
	]
},
	"application/vnd.ms-wpl": {
	source: "iana",
	extensions: [
		"wpl"
	]
},
	"application/vnd.ms-xpsdocument": {
	source: "iana",
	compressible: false,
	extensions: [
		"xps"
	]
},
	"application/vnd.msa-disk-image": {
	source: "iana"
},
	"application/vnd.mseq": {
	source: "iana",
	extensions: [
		"mseq"
	]
},
	"application/vnd.msign": {
	source: "iana"
},
	"application/vnd.multiad.creator": {
	source: "iana"
},
	"application/vnd.multiad.creator.cif": {
	source: "iana"
},
	"application/vnd.music-niff": {
	source: "iana"
},
	"application/vnd.musician": {
	source: "iana",
	extensions: [
		"mus"
	]
},
	"application/vnd.muvee.style": {
	source: "iana",
	extensions: [
		"msty"
	]
},
	"application/vnd.mynfc": {
	source: "iana",
	extensions: [
		"taglet"
	]
},
	"application/vnd.nacamar.ybrid+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ncd.control": {
	source: "iana"
},
	"application/vnd.ncd.reference": {
	source: "iana"
},
	"application/vnd.nearst.inv+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.nebumind.line": {
	source: "iana"
},
	"application/vnd.nervana": {
	source: "iana"
},
	"application/vnd.netfpx": {
	source: "iana"
},
	"application/vnd.neurolanguage.nlu": {
	source: "iana",
	extensions: [
		"nlu"
	]
},
	"application/vnd.nimn": {
	source: "iana"
},
	"application/vnd.nintendo.nitro.rom": {
	source: "iana"
},
	"application/vnd.nintendo.snes.rom": {
	source: "iana"
},
	"application/vnd.nitf": {
	source: "iana",
	extensions: [
		"ntf",
		"nitf"
	]
},
	"application/vnd.noblenet-directory": {
	source: "iana",
	extensions: [
		"nnd"
	]
},
	"application/vnd.noblenet-sealer": {
	source: "iana",
	extensions: [
		"nns"
	]
},
	"application/vnd.noblenet-web": {
	source: "iana",
	extensions: [
		"nnw"
	]
},
	"application/vnd.nokia.catalogs": {
	source: "iana"
},
	"application/vnd.nokia.conml+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.conml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.iptv.config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.isds-radio-presets": {
	source: "iana"
},
	"application/vnd.nokia.landmark+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.landmark+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.landmarkcollection+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.n-gage.ac+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ac"
	]
},
	"application/vnd.nokia.n-gage.data": {
	source: "iana",
	extensions: [
		"ngdat"
	]
},
	"application/vnd.nokia.n-gage.symbian.install": {
	source: "iana",
	extensions: [
		"n-gage"
	]
},
	"application/vnd.nokia.ncd": {
	source: "iana"
},
	"application/vnd.nokia.pcd+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.pcd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.radio-preset": {
	source: "iana",
	extensions: [
		"rpst"
	]
},
	"application/vnd.nokia.radio-presets": {
	source: "iana",
	extensions: [
		"rpss"
	]
},
	"application/vnd.novadigm.edm": {
	source: "iana",
	extensions: [
		"edm"
	]
},
	"application/vnd.novadigm.edx": {
	source: "iana",
	extensions: [
		"edx"
	]
},
	"application/vnd.novadigm.ext": {
	source: "iana",
	extensions: [
		"ext"
	]
},
	"application/vnd.ntt-local.content-share": {
	source: "iana"
},
	"application/vnd.ntt-local.file-transfer": {
	source: "iana"
},
	"application/vnd.ntt-local.ogw_remote-access": {
	source: "iana"
},
	"application/vnd.ntt-local.sip-ta_remote": {
	source: "iana"
},
	"application/vnd.ntt-local.sip-ta_tcp_stream": {
	source: "iana"
},
	"application/vnd.oasis.opendocument.chart": {
	source: "iana",
	extensions: [
		"odc"
	]
},
	"application/vnd.oasis.opendocument.chart-template": {
	source: "iana",
	extensions: [
		"otc"
	]
},
	"application/vnd.oasis.opendocument.database": {
	source: "iana",
	extensions: [
		"odb"
	]
},
	"application/vnd.oasis.opendocument.formula": {
	source: "iana",
	extensions: [
		"odf"
	]
},
	"application/vnd.oasis.opendocument.formula-template": {
	source: "iana",
	extensions: [
		"odft"
	]
},
	"application/vnd.oasis.opendocument.graphics": {
	source: "iana",
	compressible: false,
	extensions: [
		"odg"
	]
},
	"application/vnd.oasis.opendocument.graphics-template": {
	source: "iana",
	extensions: [
		"otg"
	]
},
	"application/vnd.oasis.opendocument.image": {
	source: "iana",
	extensions: [
		"odi"
	]
},
	"application/vnd.oasis.opendocument.image-template": {
	source: "iana",
	extensions: [
		"oti"
	]
},
	"application/vnd.oasis.opendocument.presentation": {
	source: "iana",
	compressible: false,
	extensions: [
		"odp"
	]
},
	"application/vnd.oasis.opendocument.presentation-template": {
	source: "iana",
	extensions: [
		"otp"
	]
},
	"application/vnd.oasis.opendocument.spreadsheet": {
	source: "iana",
	compressible: false,
	extensions: [
		"ods"
	]
},
	"application/vnd.oasis.opendocument.spreadsheet-template": {
	source: "iana",
	extensions: [
		"ots"
	]
},
	"application/vnd.oasis.opendocument.text": {
	source: "iana",
	compressible: false,
	extensions: [
		"odt"
	]
},
	"application/vnd.oasis.opendocument.text-master": {
	source: "iana",
	extensions: [
		"odm"
	]
},
	"application/vnd.oasis.opendocument.text-template": {
	source: "iana",
	extensions: [
		"ott"
	]
},
	"application/vnd.oasis.opendocument.text-web": {
	source: "iana",
	extensions: [
		"oth"
	]
},
	"application/vnd.obn": {
	source: "iana"
},
	"application/vnd.ocf+cbor": {
	source: "iana"
},
	"application/vnd.oci.image.manifest.v1+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oftn.l10n+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.contentaccessdownload+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.contentaccessstreaming+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.cspg-hexbinary": {
	source: "iana"
},
	"application/vnd.oipf.dae.svg+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.dae.xhtml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.mippvcontrolmessage+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.pae.gem": {
	source: "iana"
},
	"application/vnd.oipf.spdiscovery+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.spdlist+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.ueprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.userprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.olpc-sugar": {
	source: "iana",
	extensions: [
		"xo"
	]
},
	"application/vnd.oma-scws-config": {
	source: "iana"
},
	"application/vnd.oma-scws-http-request": {
	source: "iana"
},
	"application/vnd.oma-scws-http-response": {
	source: "iana"
},
	"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.drm-trigger+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.imd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.ltkm": {
	source: "iana"
},
	"application/vnd.oma.bcast.notification+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.provisioningtrigger": {
	source: "iana"
},
	"application/vnd.oma.bcast.sgboot": {
	source: "iana"
},
	"application/vnd.oma.bcast.sgdd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.sgdu": {
	source: "iana"
},
	"application/vnd.oma.bcast.simple-symbol-container": {
	source: "iana"
},
	"application/vnd.oma.bcast.smartcard-trigger+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.sprov+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.stkm": {
	source: "iana"
},
	"application/vnd.oma.cab-address-book+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-feature-handler+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-pcc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-subs-invite+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-user-prefs+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.dcd": {
	source: "iana"
},
	"application/vnd.oma.dcdc": {
	source: "iana"
},
	"application/vnd.oma.dd2+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dd2"
	]
},
	"application/vnd.oma.drm.risd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.group-usage-list+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.lwm2m+cbor": {
	source: "iana"
},
	"application/vnd.oma.lwm2m+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.lwm2m+tlv": {
	source: "iana"
},
	"application/vnd.oma.pal+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.detailed-progress-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.final-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.groups+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.invocation-descriptor+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.optimized-progress-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.push": {
	source: "iana"
},
	"application/vnd.oma.scidm.messages+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.xcap-directory+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.omads-email+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omads-file+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omads-folder+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omaloc-supl-init": {
	source: "iana"
},
	"application/vnd.onepager": {
	source: "iana"
},
	"application/vnd.onepagertamp": {
	source: "iana"
},
	"application/vnd.onepagertamx": {
	source: "iana"
},
	"application/vnd.onepagertat": {
	source: "iana"
},
	"application/vnd.onepagertatp": {
	source: "iana"
},
	"application/vnd.onepagertatx": {
	source: "iana"
},
	"application/vnd.openblox.game+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"obgx"
	]
},
	"application/vnd.openblox.game-binary": {
	source: "iana"
},
	"application/vnd.openeye.oeb": {
	source: "iana"
},
	"application/vnd.openofficeorg.extension": {
	source: "apache",
	extensions: [
		"oxt"
	]
},
	"application/vnd.openstreetmap.data+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"osm"
	]
},
	"application/vnd.opentimestamps.ots": {
	source: "iana"
},
	"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawing+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
	source: "iana",
	compressible: false,
	extensions: [
		"pptx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slide": {
	source: "iana",
	extensions: [
		"sldx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
	source: "iana",
	extensions: [
		"ppsx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.template": {
	source: "iana",
	extensions: [
		"potx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
	source: "iana",
	compressible: false,
	extensions: [
		"xlsx"
	]
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
	source: "iana",
	extensions: [
		"xltx"
	]
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.theme+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.vmldrawing": {
	source: "iana"
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
	source: "iana",
	compressible: false,
	extensions: [
		"docx"
	]
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
	source: "iana",
	extensions: [
		"dotx"
	]
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.core-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.relationships+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oracle.resource+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.orange.indata": {
	source: "iana"
},
	"application/vnd.osa.netdeploy": {
	source: "iana"
},
	"application/vnd.osgeo.mapguide.package": {
	source: "iana",
	extensions: [
		"mgp"
	]
},
	"application/vnd.osgi.bundle": {
	source: "iana"
},
	"application/vnd.osgi.dp": {
	source: "iana",
	extensions: [
		"dp"
	]
},
	"application/vnd.osgi.subsystem": {
	source: "iana",
	extensions: [
		"esa"
	]
},
	"application/vnd.otps.ct-kip+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oxli.countgraph": {
	source: "iana"
},
	"application/vnd.pagerduty+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.palm": {
	source: "iana",
	extensions: [
		"pdb",
		"pqa",
		"oprc"
	]
},
	"application/vnd.panoply": {
	source: "iana"
},
	"application/vnd.paos.xml": {
	source: "iana"
},
	"application/vnd.patentdive": {
	source: "iana"
},
	"application/vnd.patientecommsdoc": {
	source: "iana"
},
	"application/vnd.pawaafile": {
	source: "iana",
	extensions: [
		"paw"
	]
},
	"application/vnd.pcos": {
	source: "iana"
},
	"application/vnd.pg.format": {
	source: "iana",
	extensions: [
		"str"
	]
},
	"application/vnd.pg.osasli": {
	source: "iana",
	extensions: [
		"ei6"
	]
},
	"application/vnd.piaccess.application-licence": {
	source: "iana"
},
	"application/vnd.picsel": {
	source: "iana",
	extensions: [
		"efif"
	]
},
	"application/vnd.pmi.widget": {
	source: "iana",
	extensions: [
		"wg"
	]
},
	"application/vnd.poc.group-advertisement+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.pocketlearn": {
	source: "iana",
	extensions: [
		"plf"
	]
},
	"application/vnd.powerbuilder6": {
	source: "iana",
	extensions: [
		"pbd"
	]
},
	"application/vnd.powerbuilder6-s": {
	source: "iana"
},
	"application/vnd.powerbuilder7": {
	source: "iana"
},
	"application/vnd.powerbuilder7-s": {
	source: "iana"
},
	"application/vnd.powerbuilder75": {
	source: "iana"
},
	"application/vnd.powerbuilder75-s": {
	source: "iana"
},
	"application/vnd.preminet": {
	source: "iana"
},
	"application/vnd.previewsystems.box": {
	source: "iana",
	extensions: [
		"box"
	]
},
	"application/vnd.proteus.magazine": {
	source: "iana",
	extensions: [
		"mgz"
	]
},
	"application/vnd.psfs": {
	source: "iana"
},
	"application/vnd.publishare-delta-tree": {
	source: "iana",
	extensions: [
		"qps"
	]
},
	"application/vnd.pvi.ptid1": {
	source: "iana",
	extensions: [
		"ptid"
	]
},
	"application/vnd.pwg-multiplexed": {
	source: "iana"
},
	"application/vnd.pwg-xhtml-print+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.qualcomm.brew-app-res": {
	source: "iana"
},
	"application/vnd.quarantainenet": {
	source: "iana"
},
	"application/vnd.quark.quarkxpress": {
	source: "iana",
	extensions: [
		"qxd",
		"qxt",
		"qwd",
		"qwt",
		"qxl",
		"qxb"
	]
},
	"application/vnd.quobject-quoxdocument": {
	source: "iana"
},
	"application/vnd.radisys.moml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-conf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-conn+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-dialog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-stream+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-conf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-base+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-fax-detect+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-group+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-speech+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-transform+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.rainstor.data": {
	source: "iana"
},
	"application/vnd.rapid": {
	source: "iana"
},
	"application/vnd.rar": {
	source: "iana",
	extensions: [
		"rar"
	]
},
	"application/vnd.realvnc.bed": {
	source: "iana",
	extensions: [
		"bed"
	]
},
	"application/vnd.recordare.musicxml": {
	source: "iana",
	extensions: [
		"mxl"
	]
},
	"application/vnd.recordare.musicxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"musicxml"
	]
},
	"application/vnd.renlearn.rlprint": {
	source: "iana"
},
	"application/vnd.resilient.logic": {
	source: "iana"
},
	"application/vnd.restful+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.rig.cryptonote": {
	source: "iana",
	extensions: [
		"cryptonote"
	]
},
	"application/vnd.rim.cod": {
	source: "apache",
	extensions: [
		"cod"
	]
},
	"application/vnd.rn-realmedia": {
	source: "apache",
	extensions: [
		"rm"
	]
},
	"application/vnd.rn-realmedia-vbr": {
	source: "apache",
	extensions: [
		"rmvb"
	]
},
	"application/vnd.route66.link66+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"link66"
	]
},
	"application/vnd.rs-274x": {
	source: "iana"
},
	"application/vnd.ruckus.download": {
	source: "iana"
},
	"application/vnd.s3sms": {
	source: "iana"
},
	"application/vnd.sailingtracker.track": {
	source: "iana",
	extensions: [
		"st"
	]
},
	"application/vnd.sar": {
	source: "iana"
},
	"application/vnd.sbm.cid": {
	source: "iana"
},
	"application/vnd.sbm.mid2": {
	source: "iana"
},
	"application/vnd.scribus": {
	source: "iana"
},
	"application/vnd.sealed.3df": {
	source: "iana"
},
	"application/vnd.sealed.csf": {
	source: "iana"
},
	"application/vnd.sealed.doc": {
	source: "iana"
},
	"application/vnd.sealed.eml": {
	source: "iana"
},
	"application/vnd.sealed.mht": {
	source: "iana"
},
	"application/vnd.sealed.net": {
	source: "iana"
},
	"application/vnd.sealed.ppt": {
	source: "iana"
},
	"application/vnd.sealed.tiff": {
	source: "iana"
},
	"application/vnd.sealed.xls": {
	source: "iana"
},
	"application/vnd.sealedmedia.softseal.html": {
	source: "iana"
},
	"application/vnd.sealedmedia.softseal.pdf": {
	source: "iana"
},
	"application/vnd.seemail": {
	source: "iana",
	extensions: [
		"see"
	]
},
	"application/vnd.seis+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.sema": {
	source: "iana",
	extensions: [
		"sema"
	]
},
	"application/vnd.semd": {
	source: "iana",
	extensions: [
		"semd"
	]
},
	"application/vnd.semf": {
	source: "iana",
	extensions: [
		"semf"
	]
},
	"application/vnd.shade-save-file": {
	source: "iana"
},
	"application/vnd.shana.informed.formdata": {
	source: "iana",
	extensions: [
		"ifm"
	]
},
	"application/vnd.shana.informed.formtemplate": {
	source: "iana",
	extensions: [
		"itp"
	]
},
	"application/vnd.shana.informed.interchange": {
	source: "iana",
	extensions: [
		"iif"
	]
},
	"application/vnd.shana.informed.package": {
	source: "iana",
	extensions: [
		"ipk"
	]
},
	"application/vnd.shootproof+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.shopkick+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.shp": {
	source: "iana"
},
	"application/vnd.shx": {
	source: "iana"
},
	"application/vnd.sigrok.session": {
	source: "iana"
},
	"application/vnd.simtech-mindmapper": {
	source: "iana",
	extensions: [
		"twd",
		"twds"
	]
},
	"application/vnd.siren+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.smaf": {
	source: "iana",
	extensions: [
		"mmf"
	]
},
	"application/vnd.smart.notebook": {
	source: "iana"
},
	"application/vnd.smart.teacher": {
	source: "iana",
	extensions: [
		"teacher"
	]
},
	"application/vnd.snesdev-page-table": {
	source: "iana"
},
	"application/vnd.software602.filler.form+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"fo"
	]
},
	"application/vnd.software602.filler.form-xml-zip": {
	source: "iana"
},
	"application/vnd.solent.sdkm+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sdkm",
		"sdkd"
	]
},
	"application/vnd.spotfire.dxp": {
	source: "iana",
	extensions: [
		"dxp"
	]
},
	"application/vnd.spotfire.sfs": {
	source: "iana",
	extensions: [
		"sfs"
	]
},
	"application/vnd.sqlite3": {
	source: "iana"
},
	"application/vnd.sss-cod": {
	source: "iana"
},
	"application/vnd.sss-dtf": {
	source: "iana"
},
	"application/vnd.sss-ntf": {
	source: "iana"
},
	"application/vnd.stardivision.calc": {
	source: "apache",
	extensions: [
		"sdc"
	]
},
	"application/vnd.stardivision.draw": {
	source: "apache",
	extensions: [
		"sda"
	]
},
	"application/vnd.stardivision.impress": {
	source: "apache",
	extensions: [
		"sdd"
	]
},
	"application/vnd.stardivision.math": {
	source: "apache",
	extensions: [
		"smf"
	]
},
	"application/vnd.stardivision.writer": {
	source: "apache",
	extensions: [
		"sdw",
		"vor"
	]
},
	"application/vnd.stardivision.writer-global": {
	source: "apache",
	extensions: [
		"sgl"
	]
},
	"application/vnd.stepmania.package": {
	source: "iana",
	extensions: [
		"smzip"
	]
},
	"application/vnd.stepmania.stepchart": {
	source: "iana",
	extensions: [
		"sm"
	]
},
	"application/vnd.street-stream": {
	source: "iana"
},
	"application/vnd.sun.wadl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wadl"
	]
},
	"application/vnd.sun.xml.calc": {
	source: "apache",
	extensions: [
		"sxc"
	]
},
	"application/vnd.sun.xml.calc.template": {
	source: "apache",
	extensions: [
		"stc"
	]
},
	"application/vnd.sun.xml.draw": {
	source: "apache",
	extensions: [
		"sxd"
	]
},
	"application/vnd.sun.xml.draw.template": {
	source: "apache",
	extensions: [
		"std"
	]
},
	"application/vnd.sun.xml.impress": {
	source: "apache",
	extensions: [
		"sxi"
	]
},
	"application/vnd.sun.xml.impress.template": {
	source: "apache",
	extensions: [
		"sti"
	]
},
	"application/vnd.sun.xml.math": {
	source: "apache",
	extensions: [
		"sxm"
	]
},
	"application/vnd.sun.xml.writer": {
	source: "apache",
	extensions: [
		"sxw"
	]
},
	"application/vnd.sun.xml.writer.global": {
	source: "apache",
	extensions: [
		"sxg"
	]
},
	"application/vnd.sun.xml.writer.template": {
	source: "apache",
	extensions: [
		"stw"
	]
},
	"application/vnd.sus-calendar": {
	source: "iana",
	extensions: [
		"sus",
		"susp"
	]
},
	"application/vnd.svd": {
	source: "iana",
	extensions: [
		"svd"
	]
},
	"application/vnd.swiftview-ics": {
	source: "iana"
},
	"application/vnd.sycle+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.syft+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.symbian.install": {
	source: "apache",
	extensions: [
		"sis",
		"sisx"
	]
},
	"application/vnd.syncml+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"xsm"
	]
},
	"application/vnd.syncml.dm+wbxml": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"bdm"
	]
},
	"application/vnd.syncml.dm+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"xdm"
	]
},
	"application/vnd.syncml.dm.notification": {
	source: "iana"
},
	"application/vnd.syncml.dmddf+wbxml": {
	source: "iana"
},
	"application/vnd.syncml.dmddf+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"ddf"
	]
},
	"application/vnd.syncml.dmtnds+wbxml": {
	source: "iana"
},
	"application/vnd.syncml.dmtnds+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.syncml.ds.notification": {
	source: "iana"
},
	"application/vnd.tableschema+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.tao.intent-module-archive": {
	source: "iana",
	extensions: [
		"tao"
	]
},
	"application/vnd.tcpdump.pcap": {
	source: "iana",
	extensions: [
		"pcap",
		"cap",
		"dmp"
	]
},
	"application/vnd.think-cell.ppttc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.tmd.mediaflex.api+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.tml": {
	source: "iana"
},
	"application/vnd.tmobile-livetv": {
	source: "iana",
	extensions: [
		"tmo"
	]
},
	"application/vnd.tri.onesource": {
	source: "iana"
},
	"application/vnd.trid.tpt": {
	source: "iana",
	extensions: [
		"tpt"
	]
},
	"application/vnd.triscape.mxs": {
	source: "iana",
	extensions: [
		"mxs"
	]
},
	"application/vnd.trueapp": {
	source: "iana",
	extensions: [
		"tra"
	]
},
	"application/vnd.truedoc": {
	source: "iana"
},
	"application/vnd.ubisoft.webplayer": {
	source: "iana"
},
	"application/vnd.ufdl": {
	source: "iana",
	extensions: [
		"ufd",
		"ufdl"
	]
},
	"application/vnd.uiq.theme": {
	source: "iana",
	extensions: [
		"utz"
	]
},
	"application/vnd.umajin": {
	source: "iana",
	extensions: [
		"umj"
	]
},
	"application/vnd.unity": {
	source: "iana",
	extensions: [
		"unityweb"
	]
},
	"application/vnd.uoml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"uoml"
	]
},
	"application/vnd.uplanet.alert": {
	source: "iana"
},
	"application/vnd.uplanet.alert-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.bearer-choice": {
	source: "iana"
},
	"application/vnd.uplanet.bearer-choice-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.cacheop": {
	source: "iana"
},
	"application/vnd.uplanet.cacheop-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.channel": {
	source: "iana"
},
	"application/vnd.uplanet.channel-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.list": {
	source: "iana"
},
	"application/vnd.uplanet.list-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.listcmd": {
	source: "iana"
},
	"application/vnd.uplanet.listcmd-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.signal": {
	source: "iana"
},
	"application/vnd.uri-map": {
	source: "iana"
},
	"application/vnd.valve.source.material": {
	source: "iana"
},
	"application/vnd.vcx": {
	source: "iana",
	extensions: [
		"vcx"
	]
},
	"application/vnd.vd-study": {
	source: "iana"
},
	"application/vnd.vectorworks": {
	source: "iana"
},
	"application/vnd.vel+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.verimatrix.vcas": {
	source: "iana"
},
	"application/vnd.veritone.aion+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.veryant.thin": {
	source: "iana"
},
	"application/vnd.ves.encrypted": {
	source: "iana"
},
	"application/vnd.vidsoft.vidconference": {
	source: "iana"
},
	"application/vnd.visio": {
	source: "iana",
	extensions: [
		"vsd",
		"vst",
		"vss",
		"vsw"
	]
},
	"application/vnd.visionary": {
	source: "iana",
	extensions: [
		"vis"
	]
},
	"application/vnd.vividence.scriptfile": {
	source: "iana"
},
	"application/vnd.vsf": {
	source: "iana",
	extensions: [
		"vsf"
	]
},
	"application/vnd.wap.sic": {
	source: "iana"
},
	"application/vnd.wap.slc": {
	source: "iana"
},
	"application/vnd.wap.wbxml": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"wbxml"
	]
},
	"application/vnd.wap.wmlc": {
	source: "iana",
	extensions: [
		"wmlc"
	]
},
	"application/vnd.wap.wmlscriptc": {
	source: "iana",
	extensions: [
		"wmlsc"
	]
},
	"application/vnd.webturbo": {
	source: "iana",
	extensions: [
		"wtb"
	]
},
	"application/vnd.wfa.dpp": {
	source: "iana"
},
	"application/vnd.wfa.p2p": {
	source: "iana"
},
	"application/vnd.wfa.wsc": {
	source: "iana"
},
	"application/vnd.windows.devicepairing": {
	source: "iana"
},
	"application/vnd.wmc": {
	source: "iana"
},
	"application/vnd.wmf.bootstrap": {
	source: "iana"
},
	"application/vnd.wolfram.mathematica": {
	source: "iana"
},
	"application/vnd.wolfram.mathematica.package": {
	source: "iana"
},
	"application/vnd.wolfram.player": {
	source: "iana",
	extensions: [
		"nbp"
	]
},
	"application/vnd.wordperfect": {
	source: "iana",
	extensions: [
		"wpd"
	]
},
	"application/vnd.wqd": {
	source: "iana",
	extensions: [
		"wqd"
	]
},
	"application/vnd.wrq-hp3000-labelled": {
	source: "iana"
},
	"application/vnd.wt.stf": {
	source: "iana",
	extensions: [
		"stf"
	]
},
	"application/vnd.wv.csp+wbxml": {
	source: "iana"
},
	"application/vnd.wv.csp+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.wv.ssp+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.xacml+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.xara": {
	source: "iana",
	extensions: [
		"xar"
	]
},
	"application/vnd.xfdl": {
	source: "iana",
	extensions: [
		"xfdl"
	]
},
	"application/vnd.xfdl.webform": {
	source: "iana"
},
	"application/vnd.xmi+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.xmpie.cpkg": {
	source: "iana"
},
	"application/vnd.xmpie.dpkg": {
	source: "iana"
},
	"application/vnd.xmpie.plan": {
	source: "iana"
},
	"application/vnd.xmpie.ppkg": {
	source: "iana"
},
	"application/vnd.xmpie.xlim": {
	source: "iana"
},
	"application/vnd.yamaha.hv-dic": {
	source: "iana",
	extensions: [
		"hvd"
	]
},
	"application/vnd.yamaha.hv-script": {
	source: "iana",
	extensions: [
		"hvs"
	]
},
	"application/vnd.yamaha.hv-voice": {
	source: "iana",
	extensions: [
		"hvp"
	]
},
	"application/vnd.yamaha.openscoreformat": {
	source: "iana",
	extensions: [
		"osf"
	]
},
	"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"osfpvg"
	]
},
	"application/vnd.yamaha.remote-setup": {
	source: "iana"
},
	"application/vnd.yamaha.smaf-audio": {
	source: "iana",
	extensions: [
		"saf"
	]
},
	"application/vnd.yamaha.smaf-phrase": {
	source: "iana",
	extensions: [
		"spf"
	]
},
	"application/vnd.yamaha.through-ngn": {
	source: "iana"
},
	"application/vnd.yamaha.tunnel-udpencap": {
	source: "iana"
},
	"application/vnd.yaoweme": {
	source: "iana"
},
	"application/vnd.yellowriver-custom-menu": {
	source: "iana",
	extensions: [
		"cmp"
	]
},
	"application/vnd.youtube.yt": {
	source: "iana"
},
	"application/vnd.zul": {
	source: "iana",
	extensions: [
		"zir",
		"zirz"
	]
},
	"application/vnd.zzazz.deck+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"zaz"
	]
},
	"application/voicexml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"vxml"
	]
},
	"application/voucher-cms+json": {
	source: "iana",
	compressible: true
},
	"application/vq-rtcpxr": {
	source: "iana"
},
	"application/wasm": {
	source: "iana",
	compressible: true,
	extensions: [
		"wasm"
	]
},
	"application/watcherinfo+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wif"
	]
},
	"application/webpush-options+json": {
	source: "iana",
	compressible: true
},
	"application/whoispp-query": {
	source: "iana"
},
	"application/whoispp-response": {
	source: "iana"
},
	"application/widget": {
	source: "iana",
	extensions: [
		"wgt"
	]
},
	"application/winhlp": {
	source: "apache",
	extensions: [
		"hlp"
	]
},
	"application/wita": {
	source: "iana"
},
	"application/wordperfect5.1": {
	source: "iana"
},
	"application/wsdl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wsdl"
	]
},
	"application/wspolicy+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wspolicy"
	]
},
	"application/x-7z-compressed": {
	source: "apache",
	compressible: false,
	extensions: [
		"7z"
	]
},
	"application/x-abiword": {
	source: "apache",
	extensions: [
		"abw"
	]
},
	"application/x-ace-compressed": {
	source: "apache",
	extensions: [
		"ace"
	]
},
	"application/x-amf": {
	source: "apache"
},
	"application/x-apple-diskimage": {
	source: "apache",
	extensions: [
		"dmg"
	]
},
	"application/x-arj": {
	compressible: false,
	extensions: [
		"arj"
	]
},
	"application/x-authorware-bin": {
	source: "apache",
	extensions: [
		"aab",
		"x32",
		"u32",
		"vox"
	]
},
	"application/x-authorware-map": {
	source: "apache",
	extensions: [
		"aam"
	]
},
	"application/x-authorware-seg": {
	source: "apache",
	extensions: [
		"aas"
	]
},
	"application/x-bcpio": {
	source: "apache",
	extensions: [
		"bcpio"
	]
},
	"application/x-bdoc": {
	compressible: false,
	extensions: [
		"bdoc"
	]
},
	"application/x-bittorrent": {
	source: "apache",
	extensions: [
		"torrent"
	]
},
	"application/x-blorb": {
	source: "apache",
	extensions: [
		"blb",
		"blorb"
	]
},
	"application/x-bzip": {
	source: "apache",
	compressible: false,
	extensions: [
		"bz"
	]
},
	"application/x-bzip2": {
	source: "apache",
	compressible: false,
	extensions: [
		"bz2",
		"boz"
	]
},
	"application/x-cbr": {
	source: "apache",
	extensions: [
		"cbr",
		"cba",
		"cbt",
		"cbz",
		"cb7"
	]
},
	"application/x-cdlink": {
	source: "apache",
	extensions: [
		"vcd"
	]
},
	"application/x-cfs-compressed": {
	source: "apache",
	extensions: [
		"cfs"
	]
},
	"application/x-chat": {
	source: "apache",
	extensions: [
		"chat"
	]
},
	"application/x-chess-pgn": {
	source: "apache",
	extensions: [
		"pgn"
	]
},
	"application/x-chrome-extension": {
	extensions: [
		"crx"
	]
},
	"application/x-cocoa": {
	source: "nginx",
	extensions: [
		"cco"
	]
},
	"application/x-compress": {
	source: "apache"
},
	"application/x-conference": {
	source: "apache",
	extensions: [
		"nsc"
	]
},
	"application/x-cpio": {
	source: "apache",
	extensions: [
		"cpio"
	]
},
	"application/x-csh": {
	source: "apache",
	extensions: [
		"csh"
	]
},
	"application/x-deb": {
	compressible: false
},
	"application/x-debian-package": {
	source: "apache",
	extensions: [
		"deb",
		"udeb"
	]
},
	"application/x-dgc-compressed": {
	source: "apache",
	extensions: [
		"dgc"
	]
},
	"application/x-director": {
	source: "apache",
	extensions: [
		"dir",
		"dcr",
		"dxr",
		"cst",
		"cct",
		"cxt",
		"w3d",
		"fgd",
		"swa"
	]
},
	"application/x-doom": {
	source: "apache",
	extensions: [
		"wad"
	]
},
	"application/x-dtbncx+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"ncx"
	]
},
	"application/x-dtbook+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"dtb"
	]
},
	"application/x-dtbresource+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"res"
	]
},
	"application/x-dvi": {
	source: "apache",
	compressible: false,
	extensions: [
		"dvi"
	]
},
	"application/x-envoy": {
	source: "apache",
	extensions: [
		"evy"
	]
},
	"application/x-eva": {
	source: "apache",
	extensions: [
		"eva"
	]
},
	"application/x-font-bdf": {
	source: "apache",
	extensions: [
		"bdf"
	]
},
	"application/x-font-dos": {
	source: "apache"
},
	"application/x-font-framemaker": {
	source: "apache"
},
	"application/x-font-ghostscript": {
	source: "apache",
	extensions: [
		"gsf"
	]
},
	"application/x-font-libgrx": {
	source: "apache"
},
	"application/x-font-linux-psf": {
	source: "apache",
	extensions: [
		"psf"
	]
},
	"application/x-font-pcf": {
	source: "apache",
	extensions: [
		"pcf"
	]
},
	"application/x-font-snf": {
	source: "apache",
	extensions: [
		"snf"
	]
},
	"application/x-font-speedo": {
	source: "apache"
},
	"application/x-font-sunos-news": {
	source: "apache"
},
	"application/x-font-type1": {
	source: "apache",
	extensions: [
		"pfa",
		"pfb",
		"pfm",
		"afm"
	]
},
	"application/x-font-vfont": {
	source: "apache"
},
	"application/x-freearc": {
	source: "apache",
	extensions: [
		"arc"
	]
},
	"application/x-futuresplash": {
	source: "apache",
	extensions: [
		"spl"
	]
},
	"application/x-gca-compressed": {
	source: "apache",
	extensions: [
		"gca"
	]
},
	"application/x-glulx": {
	source: "apache",
	extensions: [
		"ulx"
	]
},
	"application/x-gnumeric": {
	source: "apache",
	extensions: [
		"gnumeric"
	]
},
	"application/x-gramps-xml": {
	source: "apache",
	extensions: [
		"gramps"
	]
},
	"application/x-gtar": {
	source: "apache",
	extensions: [
		"gtar"
	]
},
	"application/x-gzip": {
	source: "apache"
},
	"application/x-hdf": {
	source: "apache",
	extensions: [
		"hdf"
	]
},
	"application/x-httpd-php": {
	compressible: true,
	extensions: [
		"php"
	]
},
	"application/x-install-instructions": {
	source: "apache",
	extensions: [
		"install"
	]
},
	"application/x-iso9660-image": {
	source: "apache",
	extensions: [
		"iso"
	]
},
	"application/x-iwork-keynote-sffkey": {
	extensions: [
		"key"
	]
},
	"application/x-iwork-numbers-sffnumbers": {
	extensions: [
		"numbers"
	]
},
	"application/x-iwork-pages-sffpages": {
	extensions: [
		"pages"
	]
},
	"application/x-java-archive-diff": {
	source: "nginx",
	extensions: [
		"jardiff"
	]
},
	"application/x-java-jnlp-file": {
	source: "apache",
	compressible: false,
	extensions: [
		"jnlp"
	]
},
	"application/x-javascript": {
	compressible: true
},
	"application/x-keepass2": {
	extensions: [
		"kdbx"
	]
},
	"application/x-latex": {
	source: "apache",
	compressible: false,
	extensions: [
		"latex"
	]
},
	"application/x-lua-bytecode": {
	extensions: [
		"luac"
	]
},
	"application/x-lzh-compressed": {
	source: "apache",
	extensions: [
		"lzh",
		"lha"
	]
},
	"application/x-makeself": {
	source: "nginx",
	extensions: [
		"run"
	]
},
	"application/x-mie": {
	source: "apache",
	extensions: [
		"mie"
	]
},
	"application/x-mobipocket-ebook": {
	source: "apache",
	extensions: [
		"prc",
		"mobi"
	]
},
	"application/x-mpegurl": {
	compressible: false
},
	"application/x-ms-application": {
	source: "apache",
	extensions: [
		"application"
	]
},
	"application/x-ms-shortcut": {
	source: "apache",
	extensions: [
		"lnk"
	]
},
	"application/x-ms-wmd": {
	source: "apache",
	extensions: [
		"wmd"
	]
},
	"application/x-ms-wmz": {
	source: "apache",
	extensions: [
		"wmz"
	]
},
	"application/x-ms-xbap": {
	source: "apache",
	extensions: [
		"xbap"
	]
},
	"application/x-msaccess": {
	source: "apache",
	extensions: [
		"mdb"
	]
},
	"application/x-msbinder": {
	source: "apache",
	extensions: [
		"obd"
	]
},
	"application/x-mscardfile": {
	source: "apache",
	extensions: [
		"crd"
	]
},
	"application/x-msclip": {
	source: "apache",
	extensions: [
		"clp"
	]
},
	"application/x-msdos-program": {
	extensions: [
		"exe"
	]
},
	"application/x-msdownload": {
	source: "apache",
	extensions: [
		"exe",
		"dll",
		"com",
		"bat",
		"msi"
	]
},
	"application/x-msmediaview": {
	source: "apache",
	extensions: [
		"mvb",
		"m13",
		"m14"
	]
},
	"application/x-msmetafile": {
	source: "apache",
	extensions: [
		"wmf",
		"wmz",
		"emf",
		"emz"
	]
},
	"application/x-msmoney": {
	source: "apache",
	extensions: [
		"mny"
	]
},
	"application/x-mspublisher": {
	source: "apache",
	extensions: [
		"pub"
	]
},
	"application/x-msschedule": {
	source: "apache",
	extensions: [
		"scd"
	]
},
	"application/x-msterminal": {
	source: "apache",
	extensions: [
		"trm"
	]
},
	"application/x-mswrite": {
	source: "apache",
	extensions: [
		"wri"
	]
},
	"application/x-netcdf": {
	source: "apache",
	extensions: [
		"nc",
		"cdf"
	]
},
	"application/x-ns-proxy-autoconfig": {
	compressible: true,
	extensions: [
		"pac"
	]
},
	"application/x-nzb": {
	source: "apache",
	extensions: [
		"nzb"
	]
},
	"application/x-perl": {
	source: "nginx",
	extensions: [
		"pl",
		"pm"
	]
},
	"application/x-pilot": {
	source: "nginx",
	extensions: [
		"prc",
		"pdb"
	]
},
	"application/x-pkcs12": {
	source: "apache",
	compressible: false,
	extensions: [
		"p12",
		"pfx"
	]
},
	"application/x-pkcs7-certificates": {
	source: "apache",
	extensions: [
		"p7b",
		"spc"
	]
},
	"application/x-pkcs7-certreqresp": {
	source: "apache",
	extensions: [
		"p7r"
	]
},
	"application/x-pki-message": {
	source: "iana"
},
	"application/x-rar-compressed": {
	source: "apache",
	compressible: false,
	extensions: [
		"rar"
	]
},
	"application/x-redhat-package-manager": {
	source: "nginx",
	extensions: [
		"rpm"
	]
},
	"application/x-research-info-systems": {
	source: "apache",
	extensions: [
		"ris"
	]
},
	"application/x-sea": {
	source: "nginx",
	extensions: [
		"sea"
	]
},
	"application/x-sh": {
	source: "apache",
	compressible: true,
	extensions: [
		"sh"
	]
},
	"application/x-shar": {
	source: "apache",
	extensions: [
		"shar"
	]
},
	"application/x-shockwave-flash": {
	source: "apache",
	compressible: false,
	extensions: [
		"swf"
	]
},
	"application/x-silverlight-app": {
	source: "apache",
	extensions: [
		"xap"
	]
},
	"application/x-sql": {
	source: "apache",
	extensions: [
		"sql"
	]
},
	"application/x-stuffit": {
	source: "apache",
	compressible: false,
	extensions: [
		"sit"
	]
},
	"application/x-stuffitx": {
	source: "apache",
	extensions: [
		"sitx"
	]
},
	"application/x-subrip": {
	source: "apache",
	extensions: [
		"srt"
	]
},
	"application/x-sv4cpio": {
	source: "apache",
	extensions: [
		"sv4cpio"
	]
},
	"application/x-sv4crc": {
	source: "apache",
	extensions: [
		"sv4crc"
	]
},
	"application/x-t3vm-image": {
	source: "apache",
	extensions: [
		"t3"
	]
},
	"application/x-tads": {
	source: "apache",
	extensions: [
		"gam"
	]
},
	"application/x-tar": {
	source: "apache",
	compressible: true,
	extensions: [
		"tar"
	]
},
	"application/x-tcl": {
	source: "apache",
	extensions: [
		"tcl",
		"tk"
	]
},
	"application/x-tex": {
	source: "apache",
	extensions: [
		"tex"
	]
},
	"application/x-tex-tfm": {
	source: "apache",
	extensions: [
		"tfm"
	]
},
	"application/x-texinfo": {
	source: "apache",
	extensions: [
		"texinfo",
		"texi"
	]
},
	"application/x-tgif": {
	source: "apache",
	extensions: [
		"obj"
	]
},
	"application/x-ustar": {
	source: "apache",
	extensions: [
		"ustar"
	]
},
	"application/x-virtualbox-hdd": {
	compressible: true,
	extensions: [
		"hdd"
	]
},
	"application/x-virtualbox-ova": {
	compressible: true,
	extensions: [
		"ova"
	]
},
	"application/x-virtualbox-ovf": {
	compressible: true,
	extensions: [
		"ovf"
	]
},
	"application/x-virtualbox-vbox": {
	compressible: true,
	extensions: [
		"vbox"
	]
},
	"application/x-virtualbox-vbox-extpack": {
	compressible: false,
	extensions: [
		"vbox-extpack"
	]
},
	"application/x-virtualbox-vdi": {
	compressible: true,
	extensions: [
		"vdi"
	]
},
	"application/x-virtualbox-vhd": {
	compressible: true,
	extensions: [
		"vhd"
	]
},
	"application/x-virtualbox-vmdk": {
	compressible: true,
	extensions: [
		"vmdk"
	]
},
	"application/x-wais-source": {
	source: "apache",
	extensions: [
		"src"
	]
},
	"application/x-web-app-manifest+json": {
	compressible: true,
	extensions: [
		"webapp"
	]
},
	"application/x-www-form-urlencoded": {
	source: "iana",
	compressible: true
},
	"application/x-x509-ca-cert": {
	source: "iana",
	extensions: [
		"der",
		"crt",
		"pem"
	]
},
	"application/x-x509-ca-ra-cert": {
	source: "iana"
},
	"application/x-x509-next-ca-cert": {
	source: "iana"
},
	"application/x-xfig": {
	source: "apache",
	extensions: [
		"fig"
	]
},
	"application/x-xliff+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xlf"
	]
},
	"application/x-xpinstall": {
	source: "apache",
	compressible: false,
	extensions: [
		"xpi"
	]
},
	"application/x-xz": {
	source: "apache",
	extensions: [
		"xz"
	]
},
	"application/x-zmachine": {
	source: "apache",
	extensions: [
		"z1",
		"z2",
		"z3",
		"z4",
		"z5",
		"z6",
		"z7",
		"z8"
	]
},
	"application/x400-bp": {
	source: "iana"
},
	"application/xacml+xml": {
	source: "iana",
	compressible: true
},
	"application/xaml+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xaml"
	]
},
	"application/xcap-att+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xav"
	]
},
	"application/xcap-caps+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xca"
	]
},
	"application/xcap-diff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdf"
	]
},
	"application/xcap-el+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xel"
	]
},
	"application/xcap-error+xml": {
	source: "iana",
	compressible: true
},
	"application/xcap-ns+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xns"
	]
},
	"application/xcon-conference-info+xml": {
	source: "iana",
	compressible: true
},
	"application/xcon-conference-info-diff+xml": {
	source: "iana",
	compressible: true
},
	"application/xenc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xenc"
	]
},
	"application/xhtml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xhtml",
		"xht"
	]
},
	"application/xhtml-voice+xml": {
	source: "apache",
	compressible: true
},
	"application/xliff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xlf"
	]
},
	"application/xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xml",
		"xsl",
		"xsd",
		"rng"
	]
},
	"application/xml-dtd": {
	source: "iana",
	compressible: true,
	extensions: [
		"dtd"
	]
},
	"application/xml-external-parsed-entity": {
	source: "iana"
},
	"application/xml-patch+xml": {
	source: "iana",
	compressible: true
},
	"application/xmpp+xml": {
	source: "iana",
	compressible: true
},
	"application/xop+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xop"
	]
},
	"application/xproc+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xpl"
	]
},
	"application/xslt+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xsl",
		"xslt"
	]
},
	"application/xspf+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xspf"
	]
},
	"application/xv+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mxml",
		"xhvml",
		"xvml",
		"xvm"
	]
},
	"application/yang": {
	source: "iana",
	extensions: [
		"yang"
	]
},
	"application/yang-data+json": {
	source: "iana",
	compressible: true
},
	"application/yang-data+xml": {
	source: "iana",
	compressible: true
},
	"application/yang-patch+json": {
	source: "iana",
	compressible: true
},
	"application/yang-patch+xml": {
	source: "iana",
	compressible: true
},
	"application/yin+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"yin"
	]
},
	"application/zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"zip"
	]
},
	"application/zlib": {
	source: "iana"
},
	"application/zstd": {
	source: "iana"
},
	"audio/1d-interleaved-parityfec": {
	source: "iana"
},
	"audio/32kadpcm": {
	source: "iana"
},
	"audio/3gpp": {
	source: "iana",
	compressible: false,
	extensions: [
		"3gpp"
	]
},
	"audio/3gpp2": {
	source: "iana"
},
	"audio/aac": {
	source: "iana"
},
	"audio/ac3": {
	source: "iana"
},
	"audio/adpcm": {
	source: "apache",
	extensions: [
		"adp"
	]
},
	"audio/amr": {
	source: "iana",
	extensions: [
		"amr"
	]
},
	"audio/amr-wb": {
	source: "iana"
},
	"audio/amr-wb+": {
	source: "iana"
},
	"audio/aptx": {
	source: "iana"
},
	"audio/asc": {
	source: "iana"
},
	"audio/atrac-advanced-lossless": {
	source: "iana"
},
	"audio/atrac-x": {
	source: "iana"
},
	"audio/atrac3": {
	source: "iana"
},
	"audio/basic": {
	source: "iana",
	compressible: false,
	extensions: [
		"au",
		"snd"
	]
},
	"audio/bv16": {
	source: "iana"
},
	"audio/bv32": {
	source: "iana"
},
	"audio/clearmode": {
	source: "iana"
},
	"audio/cn": {
	source: "iana"
},
	"audio/dat12": {
	source: "iana"
},
	"audio/dls": {
	source: "iana"
},
	"audio/dsr-es201108": {
	source: "iana"
},
	"audio/dsr-es202050": {
	source: "iana"
},
	"audio/dsr-es202211": {
	source: "iana"
},
	"audio/dsr-es202212": {
	source: "iana"
},
	"audio/dv": {
	source: "iana"
},
	"audio/dvi4": {
	source: "iana"
},
	"audio/eac3": {
	source: "iana"
},
	"audio/encaprtp": {
	source: "iana"
},
	"audio/evrc": {
	source: "iana"
},
	"audio/evrc-qcp": {
	source: "iana"
},
	"audio/evrc0": {
	source: "iana"
},
	"audio/evrc1": {
	source: "iana"
},
	"audio/evrcb": {
	source: "iana"
},
	"audio/evrcb0": {
	source: "iana"
},
	"audio/evrcb1": {
	source: "iana"
},
	"audio/evrcnw": {
	source: "iana"
},
	"audio/evrcnw0": {
	source: "iana"
},
	"audio/evrcnw1": {
	source: "iana"
},
	"audio/evrcwb": {
	source: "iana"
},
	"audio/evrcwb0": {
	source: "iana"
},
	"audio/evrcwb1": {
	source: "iana"
},
	"audio/evs": {
	source: "iana"
},
	"audio/flexfec": {
	source: "iana"
},
	"audio/fwdred": {
	source: "iana"
},
	"audio/g711-0": {
	source: "iana"
},
	"audio/g719": {
	source: "iana"
},
	"audio/g722": {
	source: "iana"
},
	"audio/g7221": {
	source: "iana"
},
	"audio/g723": {
	source: "iana"
},
	"audio/g726-16": {
	source: "iana"
},
	"audio/g726-24": {
	source: "iana"
},
	"audio/g726-32": {
	source: "iana"
},
	"audio/g726-40": {
	source: "iana"
},
	"audio/g728": {
	source: "iana"
},
	"audio/g729": {
	source: "iana"
},
	"audio/g7291": {
	source: "iana"
},
	"audio/g729d": {
	source: "iana"
},
	"audio/g729e": {
	source: "iana"
},
	"audio/gsm": {
	source: "iana"
},
	"audio/gsm-efr": {
	source: "iana"
},
	"audio/gsm-hr-08": {
	source: "iana"
},
	"audio/ilbc": {
	source: "iana"
},
	"audio/ip-mr_v2.5": {
	source: "iana"
},
	"audio/isac": {
	source: "apache"
},
	"audio/l16": {
	source: "iana"
},
	"audio/l20": {
	source: "iana"
},
	"audio/l24": {
	source: "iana",
	compressible: false
},
	"audio/l8": {
	source: "iana"
},
	"audio/lpc": {
	source: "iana"
},
	"audio/melp": {
	source: "iana"
},
	"audio/melp1200": {
	source: "iana"
},
	"audio/melp2400": {
	source: "iana"
},
	"audio/melp600": {
	source: "iana"
},
	"audio/mhas": {
	source: "iana"
},
	"audio/midi": {
	source: "apache",
	extensions: [
		"mid",
		"midi",
		"kar",
		"rmi"
	]
},
	"audio/mobile-xmf": {
	source: "iana",
	extensions: [
		"mxmf"
	]
},
	"audio/mp3": {
	compressible: false,
	extensions: [
		"mp3"
	]
},
	"audio/mp4": {
	source: "iana",
	compressible: false,
	extensions: [
		"m4a",
		"mp4a"
	]
},
	"audio/mp4a-latm": {
	source: "iana"
},
	"audio/mpa": {
	source: "iana"
},
	"audio/mpa-robust": {
	source: "iana"
},
	"audio/mpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"mpga",
		"mp2",
		"mp2a",
		"mp3",
		"m2a",
		"m3a"
	]
},
	"audio/mpeg4-generic": {
	source: "iana"
},
	"audio/musepack": {
	source: "apache"
},
	"audio/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"oga",
		"ogg",
		"spx",
		"opus"
	]
},
	"audio/opus": {
	source: "iana"
},
	"audio/parityfec": {
	source: "iana"
},
	"audio/pcma": {
	source: "iana"
},
	"audio/pcma-wb": {
	source: "iana"
},
	"audio/pcmu": {
	source: "iana"
},
	"audio/pcmu-wb": {
	source: "iana"
},
	"audio/prs.sid": {
	source: "iana"
},
	"audio/qcelp": {
	source: "iana"
},
	"audio/raptorfec": {
	source: "iana"
},
	"audio/red": {
	source: "iana"
},
	"audio/rtp-enc-aescm128": {
	source: "iana"
},
	"audio/rtp-midi": {
	source: "iana"
},
	"audio/rtploopback": {
	source: "iana"
},
	"audio/rtx": {
	source: "iana"
},
	"audio/s3m": {
	source: "apache",
	extensions: [
		"s3m"
	]
},
	"audio/scip": {
	source: "iana"
},
	"audio/silk": {
	source: "apache",
	extensions: [
		"sil"
	]
},
	"audio/smv": {
	source: "iana"
},
	"audio/smv-qcp": {
	source: "iana"
},
	"audio/smv0": {
	source: "iana"
},
	"audio/sofa": {
	source: "iana"
},
	"audio/sp-midi": {
	source: "iana"
},
	"audio/speex": {
	source: "iana"
},
	"audio/t140c": {
	source: "iana"
},
	"audio/t38": {
	source: "iana"
},
	"audio/telephone-event": {
	source: "iana"
},
	"audio/tetra_acelp": {
	source: "iana"
},
	"audio/tetra_acelp_bb": {
	source: "iana"
},
	"audio/tone": {
	source: "iana"
},
	"audio/tsvcis": {
	source: "iana"
},
	"audio/uemclip": {
	source: "iana"
},
	"audio/ulpfec": {
	source: "iana"
},
	"audio/usac": {
	source: "iana"
},
	"audio/vdvi": {
	source: "iana"
},
	"audio/vmr-wb": {
	source: "iana"
},
	"audio/vnd.3gpp.iufp": {
	source: "iana"
},
	"audio/vnd.4sb": {
	source: "iana"
},
	"audio/vnd.audiokoz": {
	source: "iana"
},
	"audio/vnd.celp": {
	source: "iana"
},
	"audio/vnd.cisco.nse": {
	source: "iana"
},
	"audio/vnd.cmles.radio-events": {
	source: "iana"
},
	"audio/vnd.cns.anp1": {
	source: "iana"
},
	"audio/vnd.cns.inf1": {
	source: "iana"
},
	"audio/vnd.dece.audio": {
	source: "iana",
	extensions: [
		"uva",
		"uvva"
	]
},
	"audio/vnd.digital-winds": {
	source: "iana",
	extensions: [
		"eol"
	]
},
	"audio/vnd.dlna.adts": {
	source: "iana"
},
	"audio/vnd.dolby.heaac.1": {
	source: "iana"
},
	"audio/vnd.dolby.heaac.2": {
	source: "iana"
},
	"audio/vnd.dolby.mlp": {
	source: "iana"
},
	"audio/vnd.dolby.mps": {
	source: "iana"
},
	"audio/vnd.dolby.pl2": {
	source: "iana"
},
	"audio/vnd.dolby.pl2x": {
	source: "iana"
},
	"audio/vnd.dolby.pl2z": {
	source: "iana"
},
	"audio/vnd.dolby.pulse.1": {
	source: "iana"
},
	"audio/vnd.dra": {
	source: "iana",
	extensions: [
		"dra"
	]
},
	"audio/vnd.dts": {
	source: "iana",
	extensions: [
		"dts"
	]
},
	"audio/vnd.dts.hd": {
	source: "iana",
	extensions: [
		"dtshd"
	]
},
	"audio/vnd.dts.uhd": {
	source: "iana"
},
	"audio/vnd.dvb.file": {
	source: "iana"
},
	"audio/vnd.everad.plj": {
	source: "iana"
},
	"audio/vnd.hns.audio": {
	source: "iana"
},
	"audio/vnd.lucent.voice": {
	source: "iana",
	extensions: [
		"lvp"
	]
},
	"audio/vnd.ms-playready.media.pya": {
	source: "iana",
	extensions: [
		"pya"
	]
},
	"audio/vnd.nokia.mobile-xmf": {
	source: "iana"
},
	"audio/vnd.nortel.vbk": {
	source: "iana"
},
	"audio/vnd.nuera.ecelp4800": {
	source: "iana",
	extensions: [
		"ecelp4800"
	]
},
	"audio/vnd.nuera.ecelp7470": {
	source: "iana",
	extensions: [
		"ecelp7470"
	]
},
	"audio/vnd.nuera.ecelp9600": {
	source: "iana",
	extensions: [
		"ecelp9600"
	]
},
	"audio/vnd.octel.sbc": {
	source: "iana"
},
	"audio/vnd.presonus.multitrack": {
	source: "iana"
},
	"audio/vnd.qcelp": {
	source: "iana"
},
	"audio/vnd.rhetorex.32kadpcm": {
	source: "iana"
},
	"audio/vnd.rip": {
	source: "iana",
	extensions: [
		"rip"
	]
},
	"audio/vnd.rn-realaudio": {
	compressible: false
},
	"audio/vnd.sealedmedia.softseal.mpeg": {
	source: "iana"
},
	"audio/vnd.vmx.cvsd": {
	source: "iana"
},
	"audio/vnd.wave": {
	compressible: false
},
	"audio/vorbis": {
	source: "iana",
	compressible: false
},
	"audio/vorbis-config": {
	source: "iana"
},
	"audio/wav": {
	compressible: false,
	extensions: [
		"wav"
	]
},
	"audio/wave": {
	compressible: false,
	extensions: [
		"wav"
	]
},
	"audio/webm": {
	source: "apache",
	compressible: false,
	extensions: [
		"weba"
	]
},
	"audio/x-aac": {
	source: "apache",
	compressible: false,
	extensions: [
		"aac"
	]
},
	"audio/x-aiff": {
	source: "apache",
	extensions: [
		"aif",
		"aiff",
		"aifc"
	]
},
	"audio/x-caf": {
	source: "apache",
	compressible: false,
	extensions: [
		"caf"
	]
},
	"audio/x-flac": {
	source: "apache",
	extensions: [
		"flac"
	]
},
	"audio/x-m4a": {
	source: "nginx",
	extensions: [
		"m4a"
	]
},
	"audio/x-matroska": {
	source: "apache",
	extensions: [
		"mka"
	]
},
	"audio/x-mpegurl": {
	source: "apache",
	extensions: [
		"m3u"
	]
},
	"audio/x-ms-wax": {
	source: "apache",
	extensions: [
		"wax"
	]
},
	"audio/x-ms-wma": {
	source: "apache",
	extensions: [
		"wma"
	]
},
	"audio/x-pn-realaudio": {
	source: "apache",
	extensions: [
		"ram",
		"ra"
	]
},
	"audio/x-pn-realaudio-plugin": {
	source: "apache",
	extensions: [
		"rmp"
	]
},
	"audio/x-realaudio": {
	source: "nginx",
	extensions: [
		"ra"
	]
},
	"audio/x-tta": {
	source: "apache"
},
	"audio/x-wav": {
	source: "apache",
	extensions: [
		"wav"
	]
},
	"audio/xm": {
	source: "apache",
	extensions: [
		"xm"
	]
},
	"chemical/x-cdx": {
	source: "apache",
	extensions: [
		"cdx"
	]
},
	"chemical/x-cif": {
	source: "apache",
	extensions: [
		"cif"
	]
},
	"chemical/x-cmdf": {
	source: "apache",
	extensions: [
		"cmdf"
	]
},
	"chemical/x-cml": {
	source: "apache",
	extensions: [
		"cml"
	]
},
	"chemical/x-csml": {
	source: "apache",
	extensions: [
		"csml"
	]
},
	"chemical/x-pdb": {
	source: "apache"
},
	"chemical/x-xyz": {
	source: "apache",
	extensions: [
		"xyz"
	]
},
	"font/collection": {
	source: "iana",
	extensions: [
		"ttc"
	]
},
	"font/otf": {
	source: "iana",
	compressible: true,
	extensions: [
		"otf"
	]
},
	"font/sfnt": {
	source: "iana"
},
	"font/ttf": {
	source: "iana",
	compressible: true,
	extensions: [
		"ttf"
	]
},
	"font/woff": {
	source: "iana",
	extensions: [
		"woff"
	]
},
	"font/woff2": {
	source: "iana",
	extensions: [
		"woff2"
	]
},
	"image/aces": {
	source: "iana",
	extensions: [
		"exr"
	]
},
	"image/apng": {
	compressible: false,
	extensions: [
		"apng"
	]
},
	"image/avci": {
	source: "iana",
	extensions: [
		"avci"
	]
},
	"image/avcs": {
	source: "iana",
	extensions: [
		"avcs"
	]
},
	"image/avif": {
	source: "iana",
	compressible: false,
	extensions: [
		"avif"
	]
},
	"image/bmp": {
	source: "iana",
	compressible: true,
	extensions: [
		"bmp"
	]
},
	"image/cgm": {
	source: "iana",
	extensions: [
		"cgm"
	]
},
	"image/dicom-rle": {
	source: "iana",
	extensions: [
		"drle"
	]
},
	"image/emf": {
	source: "iana",
	extensions: [
		"emf"
	]
},
	"image/fits": {
	source: "iana",
	extensions: [
		"fits"
	]
},
	"image/g3fax": {
	source: "iana",
	extensions: [
		"g3"
	]
},
	"image/gif": {
	source: "iana",
	compressible: false,
	extensions: [
		"gif"
	]
},
	"image/heic": {
	source: "iana",
	extensions: [
		"heic"
	]
},
	"image/heic-sequence": {
	source: "iana",
	extensions: [
		"heics"
	]
},
	"image/heif": {
	source: "iana",
	extensions: [
		"heif"
	]
},
	"image/heif-sequence": {
	source: "iana",
	extensions: [
		"heifs"
	]
},
	"image/hej2k": {
	source: "iana",
	extensions: [
		"hej2"
	]
},
	"image/hsj2": {
	source: "iana",
	extensions: [
		"hsj2"
	]
},
	"image/ief": {
	source: "iana",
	extensions: [
		"ief"
	]
},
	"image/jls": {
	source: "iana",
	extensions: [
		"jls"
	]
},
	"image/jp2": {
	source: "iana",
	compressible: false,
	extensions: [
		"jp2",
		"jpg2"
	]
},
	"image/jpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpeg",
		"jpg",
		"jpe"
	]
},
	"image/jph": {
	source: "iana",
	extensions: [
		"jph"
	]
},
	"image/jphc": {
	source: "iana",
	extensions: [
		"jhc"
	]
},
	"image/jpm": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpm"
	]
},
	"image/jpx": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpx",
		"jpf"
	]
},
	"image/jxr": {
	source: "iana",
	extensions: [
		"jxr"
	]
},
	"image/jxra": {
	source: "iana",
	extensions: [
		"jxra"
	]
},
	"image/jxrs": {
	source: "iana",
	extensions: [
		"jxrs"
	]
},
	"image/jxs": {
	source: "iana",
	extensions: [
		"jxs"
	]
},
	"image/jxsc": {
	source: "iana",
	extensions: [
		"jxsc"
	]
},
	"image/jxsi": {
	source: "iana",
	extensions: [
		"jxsi"
	]
},
	"image/jxss": {
	source: "iana",
	extensions: [
		"jxss"
	]
},
	"image/ktx": {
	source: "iana",
	extensions: [
		"ktx"
	]
},
	"image/ktx2": {
	source: "iana",
	extensions: [
		"ktx2"
	]
},
	"image/naplps": {
	source: "iana"
},
	"image/pjpeg": {
	compressible: false
},
	"image/png": {
	source: "iana",
	compressible: false,
	extensions: [
		"png"
	]
},
	"image/prs.btif": {
	source: "iana",
	extensions: [
		"btif"
	]
},
	"image/prs.pti": {
	source: "iana",
	extensions: [
		"pti"
	]
},
	"image/pwg-raster": {
	source: "iana"
},
	"image/sgi": {
	source: "apache",
	extensions: [
		"sgi"
	]
},
	"image/svg+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"svg",
		"svgz"
	]
},
	"image/t38": {
	source: "iana",
	extensions: [
		"t38"
	]
},
	"image/tiff": {
	source: "iana",
	compressible: false,
	extensions: [
		"tif",
		"tiff"
	]
},
	"image/tiff-fx": {
	source: "iana",
	extensions: [
		"tfx"
	]
},
	"image/vnd.adobe.photoshop": {
	source: "iana",
	compressible: true,
	extensions: [
		"psd"
	]
},
	"image/vnd.airzip.accelerator.azv": {
	source: "iana",
	extensions: [
		"azv"
	]
},
	"image/vnd.cns.inf2": {
	source: "iana"
},
	"image/vnd.dece.graphic": {
	source: "iana",
	extensions: [
		"uvi",
		"uvvi",
		"uvg",
		"uvvg"
	]
},
	"image/vnd.djvu": {
	source: "iana",
	extensions: [
		"djvu",
		"djv"
	]
},
	"image/vnd.dvb.subtitle": {
	source: "iana",
	extensions: [
		"sub"
	]
},
	"image/vnd.dwg": {
	source: "iana",
	extensions: [
		"dwg"
	]
},
	"image/vnd.dxf": {
	source: "iana",
	extensions: [
		"dxf"
	]
},
	"image/vnd.fastbidsheet": {
	source: "iana",
	extensions: [
		"fbs"
	]
},
	"image/vnd.fpx": {
	source: "iana",
	extensions: [
		"fpx"
	]
},
	"image/vnd.fst": {
	source: "iana",
	extensions: [
		"fst"
	]
},
	"image/vnd.fujixerox.edmics-mmr": {
	source: "iana",
	extensions: [
		"mmr"
	]
},
	"image/vnd.fujixerox.edmics-rlc": {
	source: "iana",
	extensions: [
		"rlc"
	]
},
	"image/vnd.globalgraphics.pgb": {
	source: "iana"
},
	"image/vnd.microsoft.icon": {
	source: "iana",
	compressible: true,
	extensions: [
		"ico"
	]
},
	"image/vnd.mix": {
	source: "iana"
},
	"image/vnd.mozilla.apng": {
	source: "iana"
},
	"image/vnd.ms-dds": {
	compressible: true,
	extensions: [
		"dds"
	]
},
	"image/vnd.ms-modi": {
	source: "iana",
	extensions: [
		"mdi"
	]
},
	"image/vnd.ms-photo": {
	source: "apache",
	extensions: [
		"wdp"
	]
},
	"image/vnd.net-fpx": {
	source: "iana",
	extensions: [
		"npx"
	]
},
	"image/vnd.pco.b16": {
	source: "iana",
	extensions: [
		"b16"
	]
},
	"image/vnd.radiance": {
	source: "iana"
},
	"image/vnd.sealed.png": {
	source: "iana"
},
	"image/vnd.sealedmedia.softseal.gif": {
	source: "iana"
},
	"image/vnd.sealedmedia.softseal.jpg": {
	source: "iana"
},
	"image/vnd.svf": {
	source: "iana"
},
	"image/vnd.tencent.tap": {
	source: "iana",
	extensions: [
		"tap"
	]
},
	"image/vnd.valve.source.texture": {
	source: "iana",
	extensions: [
		"vtf"
	]
},
	"image/vnd.wap.wbmp": {
	source: "iana",
	extensions: [
		"wbmp"
	]
},
	"image/vnd.xiff": {
	source: "iana",
	extensions: [
		"xif"
	]
},
	"image/vnd.zbrush.pcx": {
	source: "iana",
	extensions: [
		"pcx"
	]
},
	"image/webp": {
	source: "apache",
	extensions: [
		"webp"
	]
},
	"image/wmf": {
	source: "iana",
	extensions: [
		"wmf"
	]
},
	"image/x-3ds": {
	source: "apache",
	extensions: [
		"3ds"
	]
},
	"image/x-cmu-raster": {
	source: "apache",
	extensions: [
		"ras"
	]
},
	"image/x-cmx": {
	source: "apache",
	extensions: [
		"cmx"
	]
},
	"image/x-freehand": {
	source: "apache",
	extensions: [
		"fh",
		"fhc",
		"fh4",
		"fh5",
		"fh7"
	]
},
	"image/x-icon": {
	source: "apache",
	compressible: true,
	extensions: [
		"ico"
	]
},
	"image/x-jng": {
	source: "nginx",
	extensions: [
		"jng"
	]
},
	"image/x-mrsid-image": {
	source: "apache",
	extensions: [
		"sid"
	]
},
	"image/x-ms-bmp": {
	source: "nginx",
	compressible: true,
	extensions: [
		"bmp"
	]
},
	"image/x-pcx": {
	source: "apache",
	extensions: [
		"pcx"
	]
},
	"image/x-pict": {
	source: "apache",
	extensions: [
		"pic",
		"pct"
	]
},
	"image/x-portable-anymap": {
	source: "apache",
	extensions: [
		"pnm"
	]
},
	"image/x-portable-bitmap": {
	source: "apache",
	extensions: [
		"pbm"
	]
},
	"image/x-portable-graymap": {
	source: "apache",
	extensions: [
		"pgm"
	]
},
	"image/x-portable-pixmap": {
	source: "apache",
	extensions: [
		"ppm"
	]
},
	"image/x-rgb": {
	source: "apache",
	extensions: [
		"rgb"
	]
},
	"image/x-tga": {
	source: "apache",
	extensions: [
		"tga"
	]
},
	"image/x-xbitmap": {
	source: "apache",
	extensions: [
		"xbm"
	]
},
	"image/x-xcf": {
	compressible: false
},
	"image/x-xpixmap": {
	source: "apache",
	extensions: [
		"xpm"
	]
},
	"image/x-xwindowdump": {
	source: "apache",
	extensions: [
		"xwd"
	]
},
	"message/cpim": {
	source: "iana"
},
	"message/delivery-status": {
	source: "iana"
},
	"message/disposition-notification": {
	source: "iana",
	extensions: [
		"disposition-notification"
	]
},
	"message/external-body": {
	source: "iana"
},
	"message/feedback-report": {
	source: "iana"
},
	"message/global": {
	source: "iana",
	extensions: [
		"u8msg"
	]
},
	"message/global-delivery-status": {
	source: "iana",
	extensions: [
		"u8dsn"
	]
},
	"message/global-disposition-notification": {
	source: "iana",
	extensions: [
		"u8mdn"
	]
},
	"message/global-headers": {
	source: "iana",
	extensions: [
		"u8hdr"
	]
},
	"message/http": {
	source: "iana",
	compressible: false
},
	"message/imdn+xml": {
	source: "iana",
	compressible: true
},
	"message/news": {
	source: "iana"
},
	"message/partial": {
	source: "iana",
	compressible: false
},
	"message/rfc822": {
	source: "iana",
	compressible: true,
	extensions: [
		"eml",
		"mime"
	]
},
	"message/s-http": {
	source: "iana"
},
	"message/sip": {
	source: "iana"
},
	"message/sipfrag": {
	source: "iana"
},
	"message/tracking-status": {
	source: "iana"
},
	"message/vnd.si.simp": {
	source: "iana"
},
	"message/vnd.wfa.wsc": {
	source: "iana",
	extensions: [
		"wsc"
	]
},
	"model/3mf": {
	source: "iana",
	extensions: [
		"3mf"
	]
},
	"model/e57": {
	source: "iana"
},
	"model/gltf+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"gltf"
	]
},
	"model/gltf-binary": {
	source: "iana",
	compressible: true,
	extensions: [
		"glb"
	]
},
	"model/iges": {
	source: "iana",
	compressible: false,
	extensions: [
		"igs",
		"iges"
	]
},
	"model/mesh": {
	source: "iana",
	compressible: false,
	extensions: [
		"msh",
		"mesh",
		"silo"
	]
},
	"model/mtl": {
	source: "iana",
	extensions: [
		"mtl"
	]
},
	"model/obj": {
	source: "iana",
	extensions: [
		"obj"
	]
},
	"model/step": {
	source: "iana"
},
	"model/step+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"stpx"
	]
},
	"model/step+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"stpz"
	]
},
	"model/step-xml+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"stpxz"
	]
},
	"model/stl": {
	source: "iana",
	extensions: [
		"stl"
	]
},
	"model/vnd.collada+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dae"
	]
},
	"model/vnd.dwf": {
	source: "iana",
	extensions: [
		"dwf"
	]
},
	"model/vnd.flatland.3dml": {
	source: "iana"
},
	"model/vnd.gdl": {
	source: "iana",
	extensions: [
		"gdl"
	]
},
	"model/vnd.gs-gdl": {
	source: "apache"
},
	"model/vnd.gs.gdl": {
	source: "iana"
},
	"model/vnd.gtw": {
	source: "iana",
	extensions: [
		"gtw"
	]
},
	"model/vnd.moml+xml": {
	source: "iana",
	compressible: true
},
	"model/vnd.mts": {
	source: "iana",
	extensions: [
		"mts"
	]
},
	"model/vnd.opengex": {
	source: "iana",
	extensions: [
		"ogex"
	]
},
	"model/vnd.parasolid.transmit.binary": {
	source: "iana",
	extensions: [
		"x_b"
	]
},
	"model/vnd.parasolid.transmit.text": {
	source: "iana",
	extensions: [
		"x_t"
	]
},
	"model/vnd.pytha.pyox": {
	source: "iana"
},
	"model/vnd.rosette.annotated-data-model": {
	source: "iana"
},
	"model/vnd.sap.vds": {
	source: "iana",
	extensions: [
		"vds"
	]
},
	"model/vnd.usdz+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"usdz"
	]
},
	"model/vnd.valve.source.compiled-map": {
	source: "iana",
	extensions: [
		"bsp"
	]
},
	"model/vnd.vtu": {
	source: "iana",
	extensions: [
		"vtu"
	]
},
	"model/vrml": {
	source: "iana",
	compressible: false,
	extensions: [
		"wrl",
		"vrml"
	]
},
	"model/x3d+binary": {
	source: "apache",
	compressible: false,
	extensions: [
		"x3db",
		"x3dbz"
	]
},
	"model/x3d+fastinfoset": {
	source: "iana",
	extensions: [
		"x3db"
	]
},
	"model/x3d+vrml": {
	source: "apache",
	compressible: false,
	extensions: [
		"x3dv",
		"x3dvz"
	]
},
	"model/x3d+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"x3d",
		"x3dz"
	]
},
	"model/x3d-vrml": {
	source: "iana",
	extensions: [
		"x3dv"
	]
},
	"multipart/alternative": {
	source: "iana",
	compressible: false
},
	"multipart/appledouble": {
	source: "iana"
},
	"multipart/byteranges": {
	source: "iana"
},
	"multipart/digest": {
	source: "iana"
},
	"multipart/encrypted": {
	source: "iana",
	compressible: false
},
	"multipart/form-data": {
	source: "iana",
	compressible: false
},
	"multipart/header-set": {
	source: "iana"
},
	"multipart/mixed": {
	source: "iana"
},
	"multipart/multilingual": {
	source: "iana"
},
	"multipart/parallel": {
	source: "iana"
},
	"multipart/related": {
	source: "iana",
	compressible: false
},
	"multipart/report": {
	source: "iana"
},
	"multipart/signed": {
	source: "iana",
	compressible: false
},
	"multipart/vnd.bint.med-plus": {
	source: "iana"
},
	"multipart/voice-message": {
	source: "iana"
},
	"multipart/x-mixed-replace": {
	source: "iana"
},
	"text/1d-interleaved-parityfec": {
	source: "iana"
},
	"text/cache-manifest": {
	source: "iana",
	compressible: true,
	extensions: [
		"appcache",
		"manifest"
	]
},
	"text/calendar": {
	source: "iana",
	extensions: [
		"ics",
		"ifb"
	]
},
	"text/calender": {
	compressible: true
},
	"text/cmd": {
	compressible: true
},
	"text/coffeescript": {
	extensions: [
		"coffee",
		"litcoffee"
	]
},
	"text/cql": {
	source: "iana"
},
	"text/cql-expression": {
	source: "iana"
},
	"text/cql-identifier": {
	source: "iana"
},
	"text/css": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"css"
	]
},
	"text/csv": {
	source: "iana",
	compressible: true,
	extensions: [
		"csv"
	]
},
	"text/csv-schema": {
	source: "iana"
},
	"text/directory": {
	source: "iana"
},
	"text/dns": {
	source: "iana"
},
	"text/ecmascript": {
	source: "iana"
},
	"text/encaprtp": {
	source: "iana"
},
	"text/enriched": {
	source: "iana"
},
	"text/fhirpath": {
	source: "iana"
},
	"text/flexfec": {
	source: "iana"
},
	"text/fwdred": {
	source: "iana"
},
	"text/gff3": {
	source: "iana"
},
	"text/grammar-ref-list": {
	source: "iana"
},
	"text/html": {
	source: "iana",
	compressible: true,
	extensions: [
		"html",
		"htm",
		"shtml"
	]
},
	"text/jade": {
	extensions: [
		"jade"
	]
},
	"text/javascript": {
	source: "iana",
	compressible: true
},
	"text/jcr-cnd": {
	source: "iana"
},
	"text/jsx": {
	compressible: true,
	extensions: [
		"jsx"
	]
},
	"text/less": {
	compressible: true,
	extensions: [
		"less"
	]
},
	"text/markdown": {
	source: "iana",
	compressible: true,
	extensions: [
		"markdown",
		"md"
	]
},
	"text/mathml": {
	source: "nginx",
	extensions: [
		"mml"
	]
},
	"text/mdx": {
	compressible: true,
	extensions: [
		"mdx"
	]
},
	"text/mizar": {
	source: "iana"
},
	"text/n3": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"n3"
	]
},
	"text/parameters": {
	source: "iana",
	charset: "UTF-8"
},
	"text/parityfec": {
	source: "iana"
},
	"text/plain": {
	source: "iana",
	compressible: true,
	extensions: [
		"txt",
		"text",
		"conf",
		"def",
		"list",
		"log",
		"in",
		"ini"
	]
},
	"text/provenance-notation": {
	source: "iana",
	charset: "UTF-8"
},
	"text/prs.fallenstein.rst": {
	source: "iana"
},
	"text/prs.lines.tag": {
	source: "iana",
	extensions: [
		"dsc"
	]
},
	"text/prs.prop.logic": {
	source: "iana"
},
	"text/raptorfec": {
	source: "iana"
},
	"text/red": {
	source: "iana"
},
	"text/rfc822-headers": {
	source: "iana"
},
	"text/richtext": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtx"
	]
},
	"text/rtf": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtf"
	]
},
	"text/rtp-enc-aescm128": {
	source: "iana"
},
	"text/rtploopback": {
	source: "iana"
},
	"text/rtx": {
	source: "iana"
},
	"text/sgml": {
	source: "iana",
	extensions: [
		"sgml",
		"sgm"
	]
},
	"text/shaclc": {
	source: "iana"
},
	"text/shex": {
	source: "iana",
	extensions: [
		"shex"
	]
},
	"text/slim": {
	extensions: [
		"slim",
		"slm"
	]
},
	"text/spdx": {
	source: "iana",
	extensions: [
		"spdx"
	]
},
	"text/strings": {
	source: "iana"
},
	"text/stylus": {
	extensions: [
		"stylus",
		"styl"
	]
},
	"text/t140": {
	source: "iana"
},
	"text/tab-separated-values": {
	source: "iana",
	compressible: true,
	extensions: [
		"tsv"
	]
},
	"text/troff": {
	source: "iana",
	extensions: [
		"t",
		"tr",
		"roff",
		"man",
		"me",
		"ms"
	]
},
	"text/turtle": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"ttl"
	]
},
	"text/ulpfec": {
	source: "iana"
},
	"text/uri-list": {
	source: "iana",
	compressible: true,
	extensions: [
		"uri",
		"uris",
		"urls"
	]
},
	"text/vcard": {
	source: "iana",
	compressible: true,
	extensions: [
		"vcard"
	]
},
	"text/vnd.a": {
	source: "iana"
},
	"text/vnd.abc": {
	source: "iana"
},
	"text/vnd.ascii-art": {
	source: "iana"
},
	"text/vnd.curl": {
	source: "iana",
	extensions: [
		"curl"
	]
},
	"text/vnd.curl.dcurl": {
	source: "apache",
	extensions: [
		"dcurl"
	]
},
	"text/vnd.curl.mcurl": {
	source: "apache",
	extensions: [
		"mcurl"
	]
},
	"text/vnd.curl.scurl": {
	source: "apache",
	extensions: [
		"scurl"
	]
},
	"text/vnd.debian.copyright": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.dmclientscript": {
	source: "iana"
},
	"text/vnd.dvb.subtitle": {
	source: "iana",
	extensions: [
		"sub"
	]
},
	"text/vnd.esmertec.theme-descriptor": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.familysearch.gedcom": {
	source: "iana",
	extensions: [
		"ged"
	]
},
	"text/vnd.ficlab.flt": {
	source: "iana"
},
	"text/vnd.fly": {
	source: "iana",
	extensions: [
		"fly"
	]
},
	"text/vnd.fmi.flexstor": {
	source: "iana",
	extensions: [
		"flx"
	]
},
	"text/vnd.gml": {
	source: "iana"
},
	"text/vnd.graphviz": {
	source: "iana",
	extensions: [
		"gv"
	]
},
	"text/vnd.hans": {
	source: "iana"
},
	"text/vnd.hgl": {
	source: "iana"
},
	"text/vnd.in3d.3dml": {
	source: "iana",
	extensions: [
		"3dml"
	]
},
	"text/vnd.in3d.spot": {
	source: "iana",
	extensions: [
		"spot"
	]
},
	"text/vnd.iptc.newsml": {
	source: "iana"
},
	"text/vnd.iptc.nitf": {
	source: "iana"
},
	"text/vnd.latex-z": {
	source: "iana"
},
	"text/vnd.motorola.reflex": {
	source: "iana"
},
	"text/vnd.ms-mediapackage": {
	source: "iana"
},
	"text/vnd.net2phone.commcenter.command": {
	source: "iana"
},
	"text/vnd.radisys.msml-basic-layout": {
	source: "iana"
},
	"text/vnd.senx.warpscript": {
	source: "iana"
},
	"text/vnd.si.uricatalogue": {
	source: "iana"
},
	"text/vnd.sosi": {
	source: "iana"
},
	"text/vnd.sun.j2me.app-descriptor": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"jad"
	]
},
	"text/vnd.trolltech.linguist": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.wap.si": {
	source: "iana"
},
	"text/vnd.wap.sl": {
	source: "iana"
},
	"text/vnd.wap.wml": {
	source: "iana",
	extensions: [
		"wml"
	]
},
	"text/vnd.wap.wmlscript": {
	source: "iana",
	extensions: [
		"wmls"
	]
},
	"text/vtt": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"vtt"
	]
},
	"text/x-asm": {
	source: "apache",
	extensions: [
		"s",
		"asm"
	]
},
	"text/x-c": {
	source: "apache",
	extensions: [
		"c",
		"cc",
		"cxx",
		"cpp",
		"h",
		"hh",
		"dic"
	]
},
	"text/x-component": {
	source: "nginx",
	extensions: [
		"htc"
	]
},
	"text/x-fortran": {
	source: "apache",
	extensions: [
		"f",
		"for",
		"f77",
		"f90"
	]
},
	"text/x-gwt-rpc": {
	compressible: true
},
	"text/x-handlebars-template": {
	extensions: [
		"hbs"
	]
},
	"text/x-java-source": {
	source: "apache",
	extensions: [
		"java"
	]
},
	"text/x-jquery-tmpl": {
	compressible: true
},
	"text/x-lua": {
	extensions: [
		"lua"
	]
},
	"text/x-markdown": {
	compressible: true,
	extensions: [
		"mkd"
	]
},
	"text/x-nfo": {
	source: "apache",
	extensions: [
		"nfo"
	]
},
	"text/x-opml": {
	source: "apache",
	extensions: [
		"opml"
	]
},
	"text/x-org": {
	compressible: true,
	extensions: [
		"org"
	]
},
	"text/x-pascal": {
	source: "apache",
	extensions: [
		"p",
		"pas"
	]
},
	"text/x-processing": {
	compressible: true,
	extensions: [
		"pde"
	]
},
	"text/x-sass": {
	extensions: [
		"sass"
	]
},
	"text/x-scss": {
	extensions: [
		"scss"
	]
},
	"text/x-setext": {
	source: "apache",
	extensions: [
		"etx"
	]
},
	"text/x-sfv": {
	source: "apache",
	extensions: [
		"sfv"
	]
},
	"text/x-suse-ymp": {
	compressible: true,
	extensions: [
		"ymp"
	]
},
	"text/x-uuencode": {
	source: "apache",
	extensions: [
		"uu"
	]
},
	"text/x-vcalendar": {
	source: "apache",
	extensions: [
		"vcs"
	]
},
	"text/x-vcard": {
	source: "apache",
	extensions: [
		"vcf"
	]
},
	"text/xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xml"
	]
},
	"text/xml-external-parsed-entity": {
	source: "iana"
},
	"text/yaml": {
	compressible: true,
	extensions: [
		"yaml",
		"yml"
	]
},
	"video/1d-interleaved-parityfec": {
	source: "iana"
},
	"video/3gpp": {
	source: "iana",
	extensions: [
		"3gp",
		"3gpp"
	]
},
	"video/3gpp-tt": {
	source: "iana"
},
	"video/3gpp2": {
	source: "iana",
	extensions: [
		"3g2"
	]
},
	"video/av1": {
	source: "iana"
},
	"video/bmpeg": {
	source: "iana"
},
	"video/bt656": {
	source: "iana"
},
	"video/celb": {
	source: "iana"
},
	"video/dv": {
	source: "iana"
},
	"video/encaprtp": {
	source: "iana"
},
	"video/ffv1": {
	source: "iana"
},
	"video/flexfec": {
	source: "iana"
},
	"video/h261": {
	source: "iana",
	extensions: [
		"h261"
	]
},
	"video/h263": {
	source: "iana",
	extensions: [
		"h263"
	]
},
	"video/h263-1998": {
	source: "iana"
},
	"video/h263-2000": {
	source: "iana"
},
	"video/h264": {
	source: "iana",
	extensions: [
		"h264"
	]
},
	"video/h264-rcdo": {
	source: "iana"
},
	"video/h264-svc": {
	source: "iana"
},
	"video/h265": {
	source: "iana"
},
	"video/iso.segment": {
	source: "iana",
	extensions: [
		"m4s"
	]
},
	"video/jpeg": {
	source: "iana",
	extensions: [
		"jpgv"
	]
},
	"video/jpeg2000": {
	source: "iana"
},
	"video/jpm": {
	source: "apache",
	extensions: [
		"jpm",
		"jpgm"
	]
},
	"video/jxsv": {
	source: "iana"
},
	"video/mj2": {
	source: "iana",
	extensions: [
		"mj2",
		"mjp2"
	]
},
	"video/mp1s": {
	source: "iana"
},
	"video/mp2p": {
	source: "iana"
},
	"video/mp2t": {
	source: "iana",
	extensions: [
		"ts"
	]
},
	"video/mp4": {
	source: "iana",
	compressible: false,
	extensions: [
		"mp4",
		"mp4v",
		"mpg4"
	]
},
	"video/mp4v-es": {
	source: "iana"
},
	"video/mpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"mpeg",
		"mpg",
		"mpe",
		"m1v",
		"m2v"
	]
},
	"video/mpeg4-generic": {
	source: "iana"
},
	"video/mpv": {
	source: "iana"
},
	"video/nv": {
	source: "iana"
},
	"video/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"ogv"
	]
},
	"video/parityfec": {
	source: "iana"
},
	"video/pointer": {
	source: "iana"
},
	"video/quicktime": {
	source: "iana",
	compressible: false,
	extensions: [
		"qt",
		"mov"
	]
},
	"video/raptorfec": {
	source: "iana"
},
	"video/raw": {
	source: "iana"
},
	"video/rtp-enc-aescm128": {
	source: "iana"
},
	"video/rtploopback": {
	source: "iana"
},
	"video/rtx": {
	source: "iana"
},
	"video/scip": {
	source: "iana"
},
	"video/smpte291": {
	source: "iana"
},
	"video/smpte292m": {
	source: "iana"
},
	"video/ulpfec": {
	source: "iana"
},
	"video/vc1": {
	source: "iana"
},
	"video/vc2": {
	source: "iana"
},
	"video/vnd.cctv": {
	source: "iana"
},
	"video/vnd.dece.hd": {
	source: "iana",
	extensions: [
		"uvh",
		"uvvh"
	]
},
	"video/vnd.dece.mobile": {
	source: "iana",
	extensions: [
		"uvm",
		"uvvm"
	]
},
	"video/vnd.dece.mp4": {
	source: "iana"
},
	"video/vnd.dece.pd": {
	source: "iana",
	extensions: [
		"uvp",
		"uvvp"
	]
},
	"video/vnd.dece.sd": {
	source: "iana",
	extensions: [
		"uvs",
		"uvvs"
	]
},
	"video/vnd.dece.video": {
	source: "iana",
	extensions: [
		"uvv",
		"uvvv"
	]
},
	"video/vnd.directv.mpeg": {
	source: "iana"
},
	"video/vnd.directv.mpeg-tts": {
	source: "iana"
},
	"video/vnd.dlna.mpeg-tts": {
	source: "iana"
},
	"video/vnd.dvb.file": {
	source: "iana",
	extensions: [
		"dvb"
	]
},
	"video/vnd.fvt": {
	source: "iana",
	extensions: [
		"fvt"
	]
},
	"video/vnd.hns.video": {
	source: "iana"
},
	"video/vnd.iptvforum.1dparityfec-1010": {
	source: "iana"
},
	"video/vnd.iptvforum.1dparityfec-2005": {
	source: "iana"
},
	"video/vnd.iptvforum.2dparityfec-1010": {
	source: "iana"
},
	"video/vnd.iptvforum.2dparityfec-2005": {
	source: "iana"
},
	"video/vnd.iptvforum.ttsavc": {
	source: "iana"
},
	"video/vnd.iptvforum.ttsmpeg2": {
	source: "iana"
},
	"video/vnd.motorola.video": {
	source: "iana"
},
	"video/vnd.motorola.videop": {
	source: "iana"
},
	"video/vnd.mpegurl": {
	source: "iana",
	extensions: [
		"mxu",
		"m4u"
	]
},
	"video/vnd.ms-playready.media.pyv": {
	source: "iana",
	extensions: [
		"pyv"
	]
},
	"video/vnd.nokia.interleaved-multimedia": {
	source: "iana"
},
	"video/vnd.nokia.mp4vr": {
	source: "iana"
},
	"video/vnd.nokia.videovoip": {
	source: "iana"
},
	"video/vnd.objectvideo": {
	source: "iana"
},
	"video/vnd.radgamettools.bink": {
	source: "iana"
},
	"video/vnd.radgamettools.smacker": {
	source: "iana"
},
	"video/vnd.sealed.mpeg1": {
	source: "iana"
},
	"video/vnd.sealed.mpeg4": {
	source: "iana"
},
	"video/vnd.sealed.swf": {
	source: "iana"
},
	"video/vnd.sealedmedia.softseal.mov": {
	source: "iana"
},
	"video/vnd.uvvu.mp4": {
	source: "iana",
	extensions: [
		"uvu",
		"uvvu"
	]
},
	"video/vnd.vivo": {
	source: "iana",
	extensions: [
		"viv"
	]
},
	"video/vnd.youtube.yt": {
	source: "iana"
},
	"video/vp8": {
	source: "iana"
},
	"video/vp9": {
	source: "iana"
},
	"video/webm": {
	source: "apache",
	compressible: false,
	extensions: [
		"webm"
	]
},
	"video/x-f4v": {
	source: "apache",
	extensions: [
		"f4v"
	]
},
	"video/x-fli": {
	source: "apache",
	extensions: [
		"fli"
	]
},
	"video/x-flv": {
	source: "apache",
	compressible: false,
	extensions: [
		"flv"
	]
},
	"video/x-m4v": {
	source: "apache",
	extensions: [
		"m4v"
	]
},
	"video/x-matroska": {
	source: "apache",
	compressible: false,
	extensions: [
		"mkv",
		"mk3d",
		"mks"
	]
},
	"video/x-mng": {
	source: "apache",
	extensions: [
		"mng"
	]
},
	"video/x-ms-asf": {
	source: "apache",
	extensions: [
		"asf",
		"asx"
	]
},
	"video/x-ms-vob": {
	source: "apache",
	extensions: [
		"vob"
	]
},
	"video/x-ms-wm": {
	source: "apache",
	extensions: [
		"wm"
	]
},
	"video/x-ms-wmv": {
	source: "apache",
	compressible: false,
	extensions: [
		"wmv"
	]
},
	"video/x-ms-wmx": {
	source: "apache",
	extensions: [
		"wmx"
	]
},
	"video/x-ms-wvx": {
	source: "apache",
	extensions: [
		"wvx"
	]
},
	"video/x-msvideo": {
	source: "apache",
	extensions: [
		"avi"
	]
},
	"video/x-sgi-movie": {
	source: "apache",
	extensions: [
		"movie"
	]
},
	"video/x-smv": {
	source: "apache",
	extensions: [
		"smv"
	]
},
	"x-conference/x-cooltalk": {
	source: "apache",
	extensions: [
		"ice"
	]
},
	"x-shader/x-fragment": {
	compressible: true
},
	"x-shader/x-vertex": {
	compressible: true
}
};

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

var mimeDb;
var hasRequiredMimeDb;

function requireMimeDb () {
	if (hasRequiredMimeDb) return mimeDb;
	hasRequiredMimeDb = 1;
	/**
	 * Module exports.
	 */

	mimeDb = require$$0$1;
	return mimeDb;
}

/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredMimeTypes;

function requireMimeTypes () {
	if (hasRequiredMimeTypes) return mimeTypes;
	hasRequiredMimeTypes = 1;
	(function (exports) {

		/**
		 * Module dependencies.
		 * @private
		 */

		var db = requireMimeDb();
		var extname = require$$1$4.extname;

		/**
		 * Module variables.
		 * @private
		 */

		var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
		var TEXT_TYPE_REGEXP = /^text\//i;

		/**
		 * Module exports.
		 * @public
		 */

		exports.charset = charset;
		exports.charsets = { lookup: charset };
		exports.contentType = contentType;
		exports.extension = extension;
		exports.extensions = Object.create(null);
		exports.lookup = lookup;
		exports.types = Object.create(null);

		// Populate the extensions/types maps
		populateMaps(exports.extensions, exports.types);

		/**
		 * Get the default charset for a MIME type.
		 *
		 * @param {string} type
		 * @return {boolean|string}
		 */

		function charset (type) {
		  if (!type || typeof type !== 'string') {
		    return false
		  }

		  // TODO: use media-typer
		  var match = EXTRACT_TYPE_REGEXP.exec(type);
		  var mime = match && db[match[1].toLowerCase()];

		  if (mime && mime.charset) {
		    return mime.charset
		  }

		  // default text/* to utf-8
		  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
		    return 'UTF-8'
		  }

		  return false
		}

		/**
		 * Create a full Content-Type header given a MIME type or extension.
		 *
		 * @param {string} str
		 * @return {boolean|string}
		 */

		function contentType (str) {
		  // TODO: should this even be in this module?
		  if (!str || typeof str !== 'string') {
		    return false
		  }

		  var mime = str.indexOf('/') === -1
		    ? exports.lookup(str)
		    : str;

		  if (!mime) {
		    return false
		  }

		  // TODO: use content-type or other module
		  if (mime.indexOf('charset') === -1) {
		    var charset = exports.charset(mime);
		    if (charset) mime += '; charset=' + charset.toLowerCase();
		  }

		  return mime
		}

		/**
		 * Get the default extension for a MIME type.
		 *
		 * @param {string} type
		 * @return {boolean|string}
		 */

		function extension (type) {
		  if (!type || typeof type !== 'string') {
		    return false
		  }

		  // TODO: use media-typer
		  var match = EXTRACT_TYPE_REGEXP.exec(type);

		  // get extensions
		  var exts = match && exports.extensions[match[1].toLowerCase()];

		  if (!exts || !exts.length) {
		    return false
		  }

		  return exts[0]
		}

		/**
		 * Lookup the MIME type for a file path/extension.
		 *
		 * @param {string} path
		 * @return {boolean|string}
		 */

		function lookup (path) {
		  if (!path || typeof path !== 'string') {
		    return false
		  }

		  // get the extension ("ext" or ".ext" or full path)
		  var extension = extname('x.' + path)
		    .toLowerCase()
		    .substr(1);

		  if (!extension) {
		    return false
		  }

		  return exports.types[extension] || false
		}

		/**
		 * Populate the extensions and types maps.
		 * @private
		 */

		function populateMaps (extensions, types) {
		  // source preference (least -> most)
		  var preference = ['nginx', 'apache', undefined, 'iana'];

		  Object.keys(db).forEach(function forEachMimeType (type) {
		    var mime = db[type];
		    var exts = mime.extensions;

		    if (!exts || !exts.length) {
		      return
		    }

		    // mime -> extensions
		    extensions[type] = exts;

		    // extension -> mime
		    for (var i = 0; i < exts.length; i++) {
		      var extension = exts[i];

		      if (types[extension]) {
		        var from = preference.indexOf(db[types[extension]].source);
		        var to = preference.indexOf(mime.source);

		        if (types[extension] !== 'application/octet-stream' &&
		          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
		          // skip the remapping
		          continue
		        }
		      }

		      // set the extension -> mime
		      types[extension] = type;
		    }
		  });
		} 
	} (mimeTypes));
	return mimeTypes;
}

var caseless = {exports: {}};

var hasRequiredCaseless;

function requireCaseless () {
	if (hasRequiredCaseless) return caseless.exports;
	hasRequiredCaseless = 1;
	function Caseless (dict) {
	  this.dict = dict || {};
	}
	Caseless.prototype.set = function (name, value, clobber) {
	  if (typeof name === 'object') {
	    for (var i in name) {
	      this.set(i, name[i], value);
	    }
	  } else {
	    if (typeof clobber === 'undefined') clobber = true;
	    var has = this.has(name);

	    if (!clobber && has) this.dict[has] = this.dict[has] + ',' + value;
	    else this.dict[has || name] = value;
	    return has
	  }
	};
	Caseless.prototype.has = function (name) {
	  var keys = Object.keys(this.dict)
	    , name = name.toLowerCase()
	    ;
	  for (var i=0;i<keys.length;i++) {
	    if (keys[i].toLowerCase() === name) return keys[i]
	  }
	  return false
	};
	Caseless.prototype.get = function (name) {
	  name = name.toLowerCase();
	  var result, _key;
	  var headers = this.dict;
	  Object.keys(headers).forEach(function (key) {
	    _key = key.toLowerCase();
	    if (name === _key) result = headers[key];
	  });
	  return result
	};
	Caseless.prototype.swap = function (name) {
	  var has = this.has(name);
	  if (has === name) return
	  if (!has) throw new Error('There is no header than matches "'+name+'"')
	  this.dict[name] = this.dict[has];
	  delete this.dict[has];
	};
	Caseless.prototype.del = function (name) {
	  var has = this.has(name);
	  return delete this.dict[has || name]
	};

	caseless.exports = function (dict) {return new Caseless(dict)};
	caseless.exports.httpify = function (resp, headers) {
	  var c = new Caseless(headers);
	  resp.setHeader = function (key, value, clobber) {
	    if (typeof value === 'undefined') return
	    return c.set(key, value, clobber)
	  };
	  resp.hasHeader = function (key) {
	    return c.has(key)
	  };
	  resp.getHeader = function (key) {
	    return c.get(key)
	  };
	  resp.removeHeader = function (key) {
	    return c.del(key)
	  };
	  resp.headers = c.dict;
	  return c
	};
	return caseless.exports;
}

var foreverAgent;
var hasRequiredForeverAgent;

function requireForeverAgent () {
	if (hasRequiredForeverAgent) return foreverAgent;
	hasRequiredForeverAgent = 1;
	foreverAgent = ForeverAgent;
	ForeverAgent.SSL = ForeverAgentSSL;

	var util = require$$1$2
	  , Agent = require$$2$1.Agent
	  , net = require$$0$3
	  , tls = require$$3$4
	  , AgentSSL = require$$4$1.Agent;
	  
	function getConnectionName(host, port) {  
	  var name = '';
	  if (typeof host === 'string') {
	    name = host + ':' + port;
	  } else {
	    // For node.js v012.0 and iojs-v1.5.1, host is an object. And any existing localAddress is part of the connection name.
	    name = host.host + ':' + host.port + ':' + (host.localAddress ? (host.localAddress + ':') : ':');
	  }
	  return name
	}    

	function ForeverAgent(options) {
	  var self = this;
	  self.options = options || {};
	  self.requests = {};
	  self.sockets = {};
	  self.freeSockets = {};
	  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets;
	  self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets;
	  self.on('free', function(socket, host, port) {
	    var name = getConnectionName(host, port);

	    if (self.requests[name] && self.requests[name].length) {
	      self.requests[name].shift().onSocket(socket);
	    } else if (self.sockets[name].length < self.minSockets) {
	      if (!self.freeSockets[name]) self.freeSockets[name] = [];
	      self.freeSockets[name].push(socket);
	      
	      // if an error happens while we don't use the socket anyway, meh, throw the socket away
	      var onIdleError = function() {
	        socket.destroy();
	      };
	      socket._onIdleError = onIdleError;
	      socket.on('error', onIdleError);
	    } else {
	      // If there are no pending requests just destroy the
	      // socket and it will get removed from the pool. This
	      // gets us out of timeout issues and allows us to
	      // default to Connection:keep-alive.
	      socket.destroy();
	    }
	  });

	}
	util.inherits(ForeverAgent, Agent);

	ForeverAgent.defaultMinSockets = 5;


	ForeverAgent.prototype.createConnection = net.createConnection;
	ForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest;
	ForeverAgent.prototype.addRequest = function(req, host, port) {
	  var name = getConnectionName(host, port);
	  
	  if (typeof host !== 'string') {
	    var options = host;
	    port = options.port;
	    host = options.host;
	  }

	  if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {
	    var idleSocket = this.freeSockets[name].pop();
	    idleSocket.removeListener('error', idleSocket._onIdleError);
	    delete idleSocket._onIdleError;
	    req._reusedSocket = true;
	    req.onSocket(idleSocket);
	  } else {
	    this.addRequestNoreuse(req, host, port);
	  }
	};

	ForeverAgent.prototype.removeSocket = function(s, name, host, port) {
	  if (this.sockets[name]) {
	    var index = this.sockets[name].indexOf(s);
	    if (index !== -1) {
	      this.sockets[name].splice(index, 1);
	    }
	  } else if (this.sockets[name] && this.sockets[name].length === 0) {
	    // don't leak
	    delete this.sockets[name];
	    delete this.requests[name];
	  }
	  
	  if (this.freeSockets[name]) {
	    var index = this.freeSockets[name].indexOf(s);
	    if (index !== -1) {
	      this.freeSockets[name].splice(index, 1);
	      if (this.freeSockets[name].length === 0) {
	        delete this.freeSockets[name];
	      }
	    }
	  }

	  if (this.requests[name] && this.requests[name].length) {
	    // If we have pending requests and a socket gets closed a new one
	    // needs to be created to take over in the pool for the one that closed.
	    this.createSocket(name, host, port).emit('free');
	  }
	};

	function ForeverAgentSSL (options) {
	  ForeverAgent.call(this, options);
	}
	util.inherits(ForeverAgentSSL, ForeverAgent);

	ForeverAgentSSL.prototype.createConnection = createConnectionSSL;
	ForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest;

	function createConnectionSSL (port, host, options) {
	  if (typeof port === 'object') {
	    options = port;
	  } else if (typeof host === 'object') {
	    options = host;
	  } else if (typeof options === 'object') {
	    options = options;
	  } else {
	    options = {};
	  }

	  if (typeof port === 'number') {
	    options.port = port;
	  }

	  if (typeof host === 'string') {
	    options.host = host;
	  }

	  return tls.connect(options);
	}
	return foreverAgent;
}

var delayed_stream;
var hasRequiredDelayed_stream;

function requireDelayed_stream () {
	if (hasRequiredDelayed_stream) return delayed_stream;
	hasRequiredDelayed_stream = 1;
	var Stream = require$$0$6.Stream;
	var util = require$$1$2;

	delayed_stream = DelayedStream;
	function DelayedStream() {
	  this.source = null;
	  this.dataSize = 0;
	  this.maxDataSize = 1024 * 1024;
	  this.pauseStream = true;

	  this._maxDataSizeExceeded = false;
	  this._released = false;
	  this._bufferedEvents = [];
	}
	util.inherits(DelayedStream, Stream);

	DelayedStream.create = function(source, options) {
	  var delayedStream = new this();

	  options = options || {};
	  for (var option in options) {
	    delayedStream[option] = options[option];
	  }

	  delayedStream.source = source;

	  var realEmit = source.emit;
	  source.emit = function() {
	    delayedStream._handleEmit(arguments);
	    return realEmit.apply(source, arguments);
	  };

	  source.on('error', function() {});
	  if (delayedStream.pauseStream) {
	    source.pause();
	  }

	  return delayedStream;
	};

	Object.defineProperty(DelayedStream.prototype, 'readable', {
	  configurable: true,
	  enumerable: true,
	  get: function() {
	    return this.source.readable;
	  }
	});

	DelayedStream.prototype.setEncoding = function() {
	  return this.source.setEncoding.apply(this.source, arguments);
	};

	DelayedStream.prototype.resume = function() {
	  if (!this._released) {
	    this.release();
	  }

	  this.source.resume();
	};

	DelayedStream.prototype.pause = function() {
	  this.source.pause();
	};

	DelayedStream.prototype.release = function() {
	  this._released = true;

	  this._bufferedEvents.forEach(function(args) {
	    this.emit.apply(this, args);
	  }.bind(this));
	  this._bufferedEvents = [];
	};

	DelayedStream.prototype.pipe = function() {
	  var r = Stream.prototype.pipe.apply(this, arguments);
	  this.resume();
	  return r;
	};

	DelayedStream.prototype._handleEmit = function(args) {
	  if (this._released) {
	    this.emit.apply(this, args);
	    return;
	  }

	  if (args[0] === 'data') {
	    this.dataSize += args[1].length;
	    this._checkIfMaxDataSizeExceeded();
	  }

	  this._bufferedEvents.push(args);
	};

	DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
	  if (this._maxDataSizeExceeded) {
	    return;
	  }

	  if (this.dataSize <= this.maxDataSize) {
	    return;
	  }

	  this._maxDataSizeExceeded = true;
	  var message =
	    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
	  this.emit('error', new Error(message));
	};
	return delayed_stream;
}

var combined_stream;
var hasRequiredCombined_stream;

function requireCombined_stream () {
	if (hasRequiredCombined_stream) return combined_stream;
	hasRequiredCombined_stream = 1;
	var util = require$$1$2;
	var Stream = require$$0$6.Stream;
	var DelayedStream = requireDelayed_stream();

	combined_stream = CombinedStream;
	function CombinedStream() {
	  this.writable = false;
	  this.readable = true;
	  this.dataSize = 0;
	  this.maxDataSize = 2 * 1024 * 1024;
	  this.pauseStreams = true;

	  this._released = false;
	  this._streams = [];
	  this._currentStream = null;
	  this._insideLoop = false;
	  this._pendingNext = false;
	}
	util.inherits(CombinedStream, Stream);

	CombinedStream.create = function(options) {
	  var combinedStream = new this();

	  options = options || {};
	  for (var option in options) {
	    combinedStream[option] = options[option];
	  }

	  return combinedStream;
	};

	CombinedStream.isStreamLike = function(stream) {
	  return (typeof stream !== 'function')
	    && (typeof stream !== 'string')
	    && (typeof stream !== 'boolean')
	    && (typeof stream !== 'number')
	    && (!Buffer.isBuffer(stream));
	};

	CombinedStream.prototype.append = function(stream) {
	  var isStreamLike = CombinedStream.isStreamLike(stream);

	  if (isStreamLike) {
	    if (!(stream instanceof DelayedStream)) {
	      var newStream = DelayedStream.create(stream, {
	        maxDataSize: Infinity,
	        pauseStream: this.pauseStreams,
	      });
	      stream.on('data', this._checkDataSize.bind(this));
	      stream = newStream;
	    }

	    this._handleErrors(stream);

	    if (this.pauseStreams) {
	      stream.pause();
	    }
	  }

	  this._streams.push(stream);
	  return this;
	};

	CombinedStream.prototype.pipe = function(dest, options) {
	  Stream.prototype.pipe.call(this, dest, options);
	  this.resume();
	  return dest;
	};

	CombinedStream.prototype._getNext = function() {
	  this._currentStream = null;

	  if (this._insideLoop) {
	    this._pendingNext = true;
	    return; // defer call
	  }

	  this._insideLoop = true;
	  try {
	    do {
	      this._pendingNext = false;
	      this._realGetNext();
	    } while (this._pendingNext);
	  } finally {
	    this._insideLoop = false;
	  }
	};

	CombinedStream.prototype._realGetNext = function() {
	  var stream = this._streams.shift();


	  if (typeof stream == 'undefined') {
	    this.end();
	    return;
	  }

	  if (typeof stream !== 'function') {
	    this._pipeNext(stream);
	    return;
	  }

	  var getStream = stream;
	  getStream(function(stream) {
	    var isStreamLike = CombinedStream.isStreamLike(stream);
	    if (isStreamLike) {
	      stream.on('data', this._checkDataSize.bind(this));
	      this._handleErrors(stream);
	    }

	    this._pipeNext(stream);
	  }.bind(this));
	};

	CombinedStream.prototype._pipeNext = function(stream) {
	  this._currentStream = stream;

	  var isStreamLike = CombinedStream.isStreamLike(stream);
	  if (isStreamLike) {
	    stream.on('end', this._getNext.bind(this));
	    stream.pipe(this, {end: false});
	    return;
	  }

	  var value = stream;
	  this.write(value);
	  this._getNext();
	};

	CombinedStream.prototype._handleErrors = function(stream) {
	  var self = this;
	  stream.on('error', function(err) {
	    self._emitError(err);
	  });
	};

	CombinedStream.prototype.write = function(data) {
	  this.emit('data', data);
	};

	CombinedStream.prototype.pause = function() {
	  if (!this.pauseStreams) {
	    return;
	  }

	  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
	  this.emit('pause');
	};

	CombinedStream.prototype.resume = function() {
	  if (!this._released) {
	    this._released = true;
	    this.writable = true;
	    this._getNext();
	  }

	  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
	  this.emit('resume');
	};

	CombinedStream.prototype.end = function() {
	  this._reset();
	  this.emit('end');
	};

	CombinedStream.prototype.destroy = function() {
	  this._reset();
	  this.emit('close');
	};

	CombinedStream.prototype._reset = function() {
	  this.writable = false;
	  this._streams = [];
	  this._currentStream = null;
	};

	CombinedStream.prototype._checkDataSize = function() {
	  this._updateDataSize();
	  if (this.dataSize <= this.maxDataSize) {
	    return;
	  }

	  var message =
	    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
	  this._emitError(new Error(message));
	};

	CombinedStream.prototype._updateDataSize = function() {
	  this.dataSize = 0;

	  var self = this;
	  this._streams.forEach(function(stream) {
	    if (!stream.dataSize) {
	      return;
	    }

	    self.dataSize += stream.dataSize;
	  });

	  if (this._currentStream && this._currentStream.dataSize) {
	    this.dataSize += this._currentStream.dataSize;
	  }
	};

	CombinedStream.prototype._emitError = function(err) {
	  this._reset();
	  this.emit('error', err);
	};
	return combined_stream;
}

var defer_1;
var hasRequiredDefer;

function requireDefer () {
	if (hasRequiredDefer) return defer_1;
	hasRequiredDefer = 1;
	defer_1 = defer;

	/**
	 * Runs provided function on next iteration of the event loop
	 *
	 * @param {function} fn - function to run
	 */
	function defer(fn)
	{
	  var nextTick = typeof setImmediate == 'function'
	    ? setImmediate
	    : (
	      typeof process == 'object' && typeof process.nextTick == 'function'
	      ? process.nextTick
	      : null
	    );

	  if (nextTick)
	  {
	    nextTick(fn);
	  }
	  else
	  {
	    setTimeout(fn, 0);
	  }
	}
	return defer_1;
}

var async_1;
var hasRequiredAsync$1;

function requireAsync$1 () {
	if (hasRequiredAsync$1) return async_1;
	hasRequiredAsync$1 = 1;
	var defer = requireDefer();

	// API
	async_1 = async;

	/**
	 * Runs provided callback asynchronously
	 * even if callback itself is not
	 *
	 * @param   {function} callback - callback to invoke
	 * @returns {function} - augmented callback
	 */
	function async(callback)
	{
	  var isAsync = false;

	  // check if async happened
	  defer(function() { isAsync = true; });

	  return function async_callback(err, result)
	  {
	    if (isAsync)
	    {
	      callback(err, result);
	    }
	    else
	    {
	      defer(function nextTick_callback()
	      {
	        callback(err, result);
	      });
	    }
	  };
	}
	return async_1;
}

var abort_1;
var hasRequiredAbort;

function requireAbort () {
	if (hasRequiredAbort) return abort_1;
	hasRequiredAbort = 1;
	// API
	abort_1 = abort;

	/**
	 * Aborts leftover active jobs
	 *
	 * @param {object} state - current state object
	 */
	function abort(state)
	{
	  Object.keys(state.jobs).forEach(clean.bind(state));

	  // reset leftover jobs
	  state.jobs = {};
	}

	/**
	 * Cleans up leftover job by invoking abort function for the provided job id
	 *
	 * @this  state
	 * @param {string|number} key - job id to abort
	 */
	function clean(key)
	{
	  if (typeof this.jobs[key] == 'function')
	  {
	    this.jobs[key]();
	  }
	}
	return abort_1;
}

var iterate_1;
var hasRequiredIterate;

function requireIterate () {
	if (hasRequiredIterate) return iterate_1;
	hasRequiredIterate = 1;
	var async = requireAsync$1()
	  , abort = requireAbort()
	  ;

	// API
	iterate_1 = iterate;

	/**
	 * Iterates over each job object
	 *
	 * @param {array|object} list - array or object (named list) to iterate over
	 * @param {function} iterator - iterator to run
	 * @param {object} state - current job status
	 * @param {function} callback - invoked when all elements processed
	 */
	function iterate(list, iterator, state, callback)
	{
	  // store current index
	  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;

	  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)
	  {
	    // don't repeat yourself
	    // skip secondary callbacks
	    if (!(key in state.jobs))
	    {
	      return;
	    }

	    // clean up jobs
	    delete state.jobs[key];

	    if (error)
	    {
	      // don't process rest of the results
	      // stop still active jobs
	      // and reset the list
	      abort(state);
	    }
	    else
	    {
	      state.results[key] = output;
	    }

	    // return salvaged results
	    callback(error, state.results);
	  });
	}

	/**
	 * Runs iterator over provided job element
	 *
	 * @param   {function} iterator - iterator to invoke
	 * @param   {string|number} key - key/index of the element in the list of jobs
	 * @param   {mixed} item - job description
	 * @param   {function} callback - invoked after iterator is done with the job
	 * @returns {function|mixed} - job abort function or something else
	 */
	function runJob(iterator, key, item, callback)
	{
	  var aborter;

	  // allow shortcut if iterator expects only two arguments
	  if (iterator.length == 2)
	  {
	    aborter = iterator(item, async(callback));
	  }
	  // otherwise go with full three arguments
	  else
	  {
	    aborter = iterator(item, key, async(callback));
	  }

	  return aborter;
	}
	return iterate_1;
}

var state_1;
var hasRequiredState;

function requireState () {
	if (hasRequiredState) return state_1;
	hasRequiredState = 1;
	// API
	state_1 = state;

	/**
	 * Creates initial state object
	 * for iteration over list
	 *
	 * @param   {array|object} list - list to iterate over
	 * @param   {function|null} sortMethod - function to use for keys sort,
	 *                                     or `null` to keep them as is
	 * @returns {object} - initial state object
	 */
	function state(list, sortMethod)
	{
	  var isNamedList = !Array.isArray(list)
	    , initState =
	    {
	      index    : 0,
	      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
	      jobs     : {},
	      results  : isNamedList ? {} : [],
	      size     : isNamedList ? Object.keys(list).length : list.length
	    }
	    ;

	  if (sortMethod)
	  {
	    // sort array keys based on it's values
	    // sort object's keys just on own merit
	    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b)
	    {
	      return sortMethod(list[a], list[b]);
	    });
	  }

	  return initState;
	}
	return state_1;
}

var terminator_1;
var hasRequiredTerminator;

function requireTerminator () {
	if (hasRequiredTerminator) return terminator_1;
	hasRequiredTerminator = 1;
	var abort = requireAbort()
	  , async = requireAsync$1()
	  ;

	// API
	terminator_1 = terminator;

	/**
	 * Terminates jobs in the attached state context
	 *
	 * @this  AsyncKitState#
	 * @param {function} callback - final callback to invoke after termination
	 */
	function terminator(callback)
	{
	  if (!Object.keys(this.jobs).length)
	  {
	    return;
	  }

	  // fast forward iteration index
	  this.index = this.size;

	  // abort jobs
	  abort(this);

	  // send back results we have so far
	  async(callback)(null, this.results);
	}
	return terminator_1;
}

var parallel_1;
var hasRequiredParallel;

function requireParallel () {
	if (hasRequiredParallel) return parallel_1;
	hasRequiredParallel = 1;
	var iterate    = requireIterate()
	  , initState  = requireState()
	  , terminator = requireTerminator()
	  ;

	// Public API
	parallel_1 = parallel;

	/**
	 * Runs iterator over provided array elements in parallel
	 *
	 * @param   {array|object} list - array or object (named list) to iterate over
	 * @param   {function} iterator - iterator to run
	 * @param   {function} callback - invoked when all elements processed
	 * @returns {function} - jobs terminator
	 */
	function parallel(list, iterator, callback)
	{
	  var state = initState(list);

	  while (state.index < (state['keyedList'] || list).length)
	  {
	    iterate(list, iterator, state, function(error, result)
	    {
	      if (error)
	      {
	        callback(error, result);
	        return;
	      }

	      // looks like it's the last one
	      if (Object.keys(state.jobs).length === 0)
	      {
	        callback(null, state.results);
	        return;
	      }
	    });

	    state.index++;
	  }

	  return terminator.bind(state, callback);
	}
	return parallel_1;
}

var serialOrdered = {exports: {}};

var hasRequiredSerialOrdered;

function requireSerialOrdered () {
	if (hasRequiredSerialOrdered) return serialOrdered.exports;
	hasRequiredSerialOrdered = 1;
	var iterate    = requireIterate()
	  , initState  = requireState()
	  , terminator = requireTerminator()
	  ;

	// Public API
	serialOrdered.exports = serialOrdered$1;
	// sorting helpers
	serialOrdered.exports.ascending  = ascending;
	serialOrdered.exports.descending = descending;

	/**
	 * Runs iterator over provided sorted array elements in series
	 *
	 * @param   {array|object} list - array or object (named list) to iterate over
	 * @param   {function} iterator - iterator to run
	 * @param   {function} sortMethod - custom sort function
	 * @param   {function} callback - invoked when all elements processed
	 * @returns {function} - jobs terminator
	 */
	function serialOrdered$1(list, iterator, sortMethod, callback)
	{
	  var state = initState(list, sortMethod);

	  iterate(list, iterator, state, function iteratorHandler(error, result)
	  {
	    if (error)
	    {
	      callback(error, result);
	      return;
	    }

	    state.index++;

	    // are we there yet?
	    if (state.index < (state['keyedList'] || list).length)
	    {
	      iterate(list, iterator, state, iteratorHandler);
	      return;
	    }

	    // done here
	    callback(null, state.results);
	  });

	  return terminator.bind(state, callback);
	}

	/*
	 * -- Sort methods
	 */

	/**
	 * sort helper to sort array elements in ascending order
	 *
	 * @param   {mixed} a - an item to compare
	 * @param   {mixed} b - an item to compare
	 * @returns {number} - comparison result
	 */
	function ascending(a, b)
	{
	  return a < b ? -1 : a > b ? 1 : 0;
	}

	/**
	 * sort helper to sort array elements in descending order
	 *
	 * @param   {mixed} a - an item to compare
	 * @param   {mixed} b - an item to compare
	 * @returns {number} - comparison result
	 */
	function descending(a, b)
	{
	  return -1 * ascending(a, b);
	}
	return serialOrdered.exports;
}

var serial_1;
var hasRequiredSerial;

function requireSerial () {
	if (hasRequiredSerial) return serial_1;
	hasRequiredSerial = 1;
	var serialOrdered = requireSerialOrdered();

	// Public API
	serial_1 = serial;

	/**
	 * Runs iterator over provided array elements in series
	 *
	 * @param   {array|object} list - array or object (named list) to iterate over
	 * @param   {function} iterator - iterator to run
	 * @param   {function} callback - invoked when all elements processed
	 * @returns {function} - jobs terminator
	 */
	function serial(list, iterator, callback)
	{
	  return serialOrdered(list, iterator, null, callback);
	}
	return serial_1;
}

var asynckit;
var hasRequiredAsynckit;

function requireAsynckit () {
	if (hasRequiredAsynckit) return asynckit;
	hasRequiredAsynckit = 1;
	asynckit =
	{
	  parallel      : requireParallel(),
	  serial        : requireSerial(),
	  serialOrdered : requireSerialOrdered()
	};
	return asynckit;
}

var populate;
var hasRequiredPopulate;

function requirePopulate () {
	if (hasRequiredPopulate) return populate;
	hasRequiredPopulate = 1;
	// populates missing values
	populate = function(dst, src) {

	  Object.keys(src).forEach(function(prop)
	  {
	    dst[prop] = dst[prop] || src[prop];
	  });

	  return dst;
	};
	return populate;
}

var form_data;
var hasRequiredForm_data;

function requireForm_data () {
	if (hasRequiredForm_data) return form_data;
	hasRequiredForm_data = 1;
	var CombinedStream = requireCombined_stream();
	var util = require$$1$2;
	var path = require$$1$4;
	var http = require$$2$1;
	var https = require$$4$1;
	var parseUrl = require$$0$2.parse;
	var fs = require$$0$8;
	var mime = requireMimeTypes();
	var asynckit = requireAsynckit();
	var populate = requirePopulate();

	// Public API
	form_data = FormData;

	// make it a Stream
	util.inherits(FormData, CombinedStream);

	/**
	 * Create readable "multipart/form-data" streams.
	 * Can be used to submit forms
	 * and file uploads to other web applications.
	 *
	 * @constructor
	 * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
	 */
	function FormData(options) {
	  if (!(this instanceof FormData)) {
	    return new FormData();
	  }

	  this._overheadLength = 0;
	  this._valueLength = 0;
	  this._valuesToMeasure = [];

	  CombinedStream.call(this);

	  options = options || {};
	  for (var option in options) {
	    this[option] = options[option];
	  }
	}

	FormData.LINE_BREAK = '\r\n';
	FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

	FormData.prototype.append = function(field, value, options) {

	  options = options || {};

	  // allow filename as single option
	  if (typeof options == 'string') {
	    options = {filename: options};
	  }

	  var append = CombinedStream.prototype.append.bind(this);

	  // all that streamy business can't handle numbers
	  if (typeof value == 'number') {
	    value = '' + value;
	  }

	  // https://github.com/felixge/node-form-data/issues/38
	  if (util.isArray(value)) {
	    // Please convert your array into string
	    // the way web server expects it
	    this._error(new Error('Arrays are not supported.'));
	    return;
	  }

	  var header = this._multiPartHeader(field, value, options);
	  var footer = this._multiPartFooter();

	  append(header);
	  append(value);
	  append(footer);

	  // pass along options.knownLength
	  this._trackLength(header, value, options);
	};

	FormData.prototype._trackLength = function(header, value, options) {
	  var valueLength = 0;

	  // used w/ getLengthSync(), when length is known.
	  // e.g. for streaming directly from a remote server,
	  // w/ a known file a size, and not wanting to wait for
	  // incoming file to finish to get its size.
	  if (options.knownLength != null) {
	    valueLength += +options.knownLength;
	  } else if (Buffer.isBuffer(value)) {
	    valueLength = value.length;
	  } else if (typeof value === 'string') {
	    valueLength = Buffer.byteLength(value);
	  }

	  this._valueLength += valueLength;

	  // @check why add CRLF? does this account for custom/multiple CRLFs?
	  this._overheadLength +=
	    Buffer.byteLength(header) +
	    FormData.LINE_BREAK.length;

	  // empty or either doesn't have path or not an http response
	  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) )) {
	    return;
	  }

	  // no need to bother with the length
	  if (!options.knownLength) {
	    this._valuesToMeasure.push(value);
	  }
	};

	FormData.prototype._lengthRetriever = function(value, callback) {

	  if (value.hasOwnProperty('fd')) {

	    // take read range into a account
	    // `end` = Infinity –> read file till the end
	    //
	    // TODO: Looks like there is bug in Node fs.createReadStream
	    // it doesn't respect `end` options without `start` options
	    // Fix it when node fixes it.
	    // https://github.com/joyent/node/issues/7819
	    if (value.end != undefined && value.end != Infinity && value.start != undefined) {

	      // when end specified
	      // no need to calculate range
	      // inclusive, starts with 0
	      callback(null, value.end + 1 - (value.start ? value.start : 0));

	    // not that fast snoopy
	    } else {
	      // still need to fetch file size from fs
	      fs.stat(value.path, function(err, stat) {

	        var fileSize;

	        if (err) {
	          callback(err);
	          return;
	        }

	        // update final size based on the range options
	        fileSize = stat.size - (value.start ? value.start : 0);
	        callback(null, fileSize);
	      });
	    }

	  // or http response
	  } else if (value.hasOwnProperty('httpVersion')) {
	    callback(null, +value.headers['content-length']);

	  // or request stream http://github.com/mikeal/request
	  } else if (value.hasOwnProperty('httpModule')) {
	    // wait till response come back
	    value.on('response', function(response) {
	      value.pause();
	      callback(null, +response.headers['content-length']);
	    });
	    value.resume();

	  // something else
	  } else {
	    callback('Unknown stream');
	  }
	};

	FormData.prototype._multiPartHeader = function(field, value, options) {
	  // custom header specified (as string)?
	  // it becomes responsible for boundary
	  // (e.g. to handle extra CRLFs on .NET servers)
	  if (typeof options.header == 'string') {
	    return options.header;
	  }

	  var contentDisposition = this._getContentDisposition(value, options);
	  var contentType = this._getContentType(value, options);

	  var contents = '';
	  var headers  = {
	    // add custom disposition as third element or keep it two elements if not
	    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
	    // if no content type. allow it to be empty array
	    'Content-Type': [].concat(contentType || [])
	  };

	  // allow custom headers.
	  if (typeof options.header == 'object') {
	    populate(headers, options.header);
	  }

	  var header;
	  for (var prop in headers) {
	    if (!headers.hasOwnProperty(prop)) continue;
	    header = headers[prop];

	    // skip nullish headers.
	    if (header == null) {
	      continue;
	    }

	    // convert all headers to arrays.
	    if (!Array.isArray(header)) {
	      header = [header];
	    }

	    // add non-empty headers.
	    if (header.length) {
	      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
	    }
	  }

	  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
	};

	FormData.prototype._getContentDisposition = function(value, options) {

	  var filename
	    , contentDisposition
	    ;

	  if (typeof options.filepath === 'string') {
	    // custom filepath for relative paths
	    filename = path.normalize(options.filepath).replace(/\\/g, '/');
	  } else if (options.filename || value.name || value.path) {
	    // custom filename take precedence
	    // formidable and the browser add a name property
	    // fs- and request- streams have path property
	    filename = path.basename(options.filename || value.name || value.path);
	  } else if (value.readable && value.hasOwnProperty('httpVersion')) {
	    // or try http response
	    filename = path.basename(value.client._httpMessage.path);
	  }

	  if (filename) {
	    contentDisposition = 'filename="' + filename + '"';
	  }

	  return contentDisposition;
	};

	FormData.prototype._getContentType = function(value, options) {

	  // use custom content-type above all
	  var contentType = options.contentType;

	  // or try `name` from formidable, browser
	  if (!contentType && value.name) {
	    contentType = mime.lookup(value.name);
	  }

	  // or try `path` from fs-, request- streams
	  if (!contentType && value.path) {
	    contentType = mime.lookup(value.path);
	  }

	  // or if it's http-reponse
	  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {
	    contentType = value.headers['content-type'];
	  }

	  // or guess it from the filepath or filename
	  if (!contentType && (options.filepath || options.filename)) {
	    contentType = mime.lookup(options.filepath || options.filename);
	  }

	  // fallback to the default content type if `value` is not simple value
	  if (!contentType && typeof value == 'object') {
	    contentType = FormData.DEFAULT_CONTENT_TYPE;
	  }

	  return contentType;
	};

	FormData.prototype._multiPartFooter = function() {
	  return function(next) {
	    var footer = FormData.LINE_BREAK;

	    var lastPart = (this._streams.length === 0);
	    if (lastPart) {
	      footer += this._lastBoundary();
	    }

	    next(footer);
	  }.bind(this);
	};

	FormData.prototype._lastBoundary = function() {
	  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
	};

	FormData.prototype.getHeaders = function(userHeaders) {
	  var header;
	  var formHeaders = {
	    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
	  };

	  for (header in userHeaders) {
	    if (userHeaders.hasOwnProperty(header)) {
	      formHeaders[header.toLowerCase()] = userHeaders[header];
	    }
	  }

	  return formHeaders;
	};

	FormData.prototype.getBoundary = function() {
	  if (!this._boundary) {
	    this._generateBoundary();
	  }

	  return this._boundary;
	};

	FormData.prototype._generateBoundary = function() {
	  // This generates a 50 character boundary similar to those used by Firefox.
	  // They are optimized for boyer-moore parsing.
	  var boundary = '--------------------------';
	  for (var i = 0; i < 24; i++) {
	    boundary += Math.floor(Math.random() * 10).toString(16);
	  }

	  this._boundary = boundary;
	};

	// Note: getLengthSync DOESN'T calculate streams length
	// As workaround one can calculate file size manually
	// and add it as knownLength option
	FormData.prototype.getLengthSync = function() {
	  var knownLength = this._overheadLength + this._valueLength;

	  // Don't get confused, there are 3 "internal" streams for each keyval pair
	  // so it basically checks if there is any value added to the form
	  if (this._streams.length) {
	    knownLength += this._lastBoundary().length;
	  }

	  // https://github.com/form-data/form-data/issues/40
	  if (!this.hasKnownLength()) {
	    // Some async length retrievers are present
	    // therefore synchronous length calculation is false.
	    // Please use getLength(callback) to get proper length
	    this._error(new Error('Cannot calculate proper length in synchronous way.'));
	  }

	  return knownLength;
	};

	// Public API to check if length of added values is known
	// https://github.com/form-data/form-data/issues/196
	// https://github.com/form-data/form-data/issues/262
	FormData.prototype.hasKnownLength = function() {
	  var hasKnownLength = true;

	  if (this._valuesToMeasure.length) {
	    hasKnownLength = false;
	  }

	  return hasKnownLength;
	};

	FormData.prototype.getLength = function(cb) {
	  var knownLength = this._overheadLength + this._valueLength;

	  if (this._streams.length) {
	    knownLength += this._lastBoundary().length;
	  }

	  if (!this._valuesToMeasure.length) {
	    process.nextTick(cb.bind(this, null, knownLength));
	    return;
	  }

	  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
	    if (err) {
	      cb(err);
	      return;
	    }

	    values.forEach(function(length) {
	      knownLength += length;
	    });

	    cb(null, knownLength);
	  });
	};

	FormData.prototype.submit = function(params, cb) {
	  var request
	    , options
	    , defaults = {method: 'post'}
	    ;

	  // parse provided url if it's string
	  // or treat it as options object
	  if (typeof params == 'string') {

	    params = parseUrl(params);
	    options = populate({
	      port: params.port,
	      path: params.pathname,
	      host: params.hostname,
	      protocol: params.protocol
	    }, defaults);

	  // use custom params
	  } else {

	    options = populate(params, defaults);
	    // if no port provided use default one
	    if (!options.port) {
	      options.port = options.protocol == 'https:' ? 443 : 80;
	    }
	  }

	  // put that good code in getHeaders to some use
	  options.headers = this.getHeaders(params.headers);

	  // https if specified, fallback to http in any other case
	  if (options.protocol == 'https:') {
	    request = https.request(options);
	  } else {
	    request = http.request(options);
	  }

	  // get content length and fire away
	  this.getLength(function(err, length) {
	    if (err) {
	      this._error(err);
	      return;
	    }

	    // add content length
	    request.setHeader('Content-Length', length);

	    this.pipe(request);
	    if (cb) {
	      request.on('error', cb);
	      request.on('response', cb.bind(this, null));
	    }
	  }.bind(this));

	  return request;
	};

	FormData.prototype._error = function(err) {
	  if (!this.error) {
	    this.error = err;
	    this.pause();
	    this.emit('error', err);
	  }
	};

	FormData.prototype.toString = function () {
	  return '[object FormData]';
	};
	return form_data;
}

var isstream = {exports: {}};

var hasRequiredIsstream;

function requireIsstream () {
	if (hasRequiredIsstream) return isstream.exports;
	hasRequiredIsstream = 1;
	var stream = require$$0$6;


	function isStream (obj) {
	  return obj instanceof stream.Stream
	}


	function isReadable (obj) {
	  return isStream(obj) && typeof obj._read == 'function' && typeof obj._readableState == 'object'
	}


	function isWritable (obj) {
	  return isStream(obj) && typeof obj._write == 'function' && typeof obj._writableState == 'object'
	}


	function isDuplex (obj) {
	  return isReadable(obj) && isWritable(obj)
	}


	isstream.exports            = isStream;
	isstream.exports.isReadable = isReadable;
	isstream.exports.isWritable = isWritable;
	isstream.exports.isDuplex   = isDuplex;
	return isstream.exports;
}

var isTypedarray;
var hasRequiredIsTypedarray;

function requireIsTypedarray () {
	if (hasRequiredIsTypedarray) return isTypedarray;
	hasRequiredIsTypedarray = 1;
	isTypedarray      = isTypedArray;
	isTypedArray.strict = isStrictTypedArray;
	isTypedArray.loose  = isLooseTypedArray;

	var toString = Object.prototype.toString;
	var names = {
	    '[object Int8Array]': true
	  , '[object Int16Array]': true
	  , '[object Int32Array]': true
	  , '[object Uint8Array]': true
	  , '[object Uint8ClampedArray]': true
	  , '[object Uint16Array]': true
	  , '[object Uint32Array]': true
	  , '[object Float32Array]': true
	  , '[object Float64Array]': true
	};

	function isTypedArray(arr) {
	  return (
	       isStrictTypedArray(arr)
	    || isLooseTypedArray(arr)
	  )
	}

	function isStrictTypedArray(arr) {
	  return (
	       arr instanceof Int8Array
	    || arr instanceof Int16Array
	    || arr instanceof Int32Array
	    || arr instanceof Uint8Array
	    || arr instanceof Uint8ClampedArray
	    || arr instanceof Uint16Array
	    || arr instanceof Uint32Array
	    || arr instanceof Float32Array
	    || arr instanceof Float64Array
	  )
	}

	function isLooseTypedArray(arr) {
	  return names[toString.call(arr)]
	}
	return isTypedarray;
}

var getProxyFromURI_1;
var hasRequiredGetProxyFromURI;

function requireGetProxyFromURI () {
	if (hasRequiredGetProxyFromURI) return getProxyFromURI_1;
	hasRequiredGetProxyFromURI = 1;

	function formatHostname (hostname) {
	  // canonicalize the hostname, so that 'oogle.com' won't match 'google.com'
	  return hostname.replace(/^\.*/, '.').toLowerCase()
	}

	function parseNoProxyZone (zone) {
	  zone = zone.trim().toLowerCase();

	  var zoneParts = zone.split(':', 2);
	  var zoneHost = formatHostname(zoneParts[0]);
	  var zonePort = zoneParts[1];
	  var hasPort = zone.indexOf(':') > -1;

	  return {hostname: zoneHost, port: zonePort, hasPort: hasPort}
	}

	function uriInNoProxy (uri, noProxy) {
	  var port = uri.port || (uri.protocol === 'https:' ? '443' : '80');
	  var hostname = formatHostname(uri.hostname);
	  var noProxyList = noProxy.split(',');

	  // iterate through the noProxyList until it finds a match.
	  return noProxyList.map(parseNoProxyZone).some(function (noProxyZone) {
	    var isMatchedAt = hostname.indexOf(noProxyZone.hostname);
	    var hostnameMatched = (
	      isMatchedAt > -1 &&
	        (isMatchedAt === hostname.length - noProxyZone.hostname.length)
	    );

	    if (noProxyZone.hasPort) {
	      return (port === noProxyZone.port) && hostnameMatched
	    }

	    return hostnameMatched
	  })
	}

	function getProxyFromURI (uri) {
	  // Decide the proper request proxy to use based on the request URI object and the
	  // environmental variables (NO_PROXY, HTTP_PROXY, etc.)
	  // respect NO_PROXY environment variables (see: https://lynx.invisible-island.net/lynx2.8.7/breakout/lynx_help/keystrokes/environments.html)

	  var noProxy = process.env.NO_PROXY || process.env.no_proxy || '';

	  // if the noProxy is a wildcard then return null

	  if (noProxy === '*') {
	    return null
	  }

	  // if the noProxy is not empty and the uri is found return null

	  if (noProxy !== '' && uriInNoProxy(uri, noProxy)) {
	    return null
	  }

	  // Check for HTTP or HTTPS Proxy in environment Else default to null

	  if (uri.protocol === 'http:') {
	    return process.env.HTTP_PROXY ||
	      process.env.http_proxy || null
	  }

	  if (uri.protocol === 'https:') {
	    return process.env.HTTPS_PROXY ||
	      process.env.https_proxy ||
	      process.env.HTTP_PROXY ||
	      process.env.http_proxy || null
	  }

	  // if none of that works, return null
	  // (What uri protocol are you using then?)

	  return null
	}

	getProxyFromURI_1 = getProxyFromURI;
	return getProxyFromURI_1;
}

var querystring = {};

var utils$3;
var hasRequiredUtils$3;

function requireUtils$3 () {
	if (hasRequiredUtils$3) return utils$3;
	hasRequiredUtils$3 = 1;

	var has = Object.prototype.hasOwnProperty;

	var hexTable = (function () {
	    var array = [];
	    for (var i = 0; i < 256; ++i) {
	        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
	    }

	    return array;
	}());

	var compactQueue = function compactQueue(queue) {
	    var obj;

	    while (queue.length) {
	        var item = queue.pop();
	        obj = item.obj[item.prop];

	        if (Array.isArray(obj)) {
	            var compacted = [];

	            for (var j = 0; j < obj.length; ++j) {
	                if (typeof obj[j] !== 'undefined') {
	                    compacted.push(obj[j]);
	                }
	            }

	            item.obj[item.prop] = compacted;
	        }
	    }

	    return obj;
	};

	var arrayToObject = function arrayToObject(source, options) {
	    var obj = options && options.plainObjects ? Object.create(null) : {};
	    for (var i = 0; i < source.length; ++i) {
	        if (typeof source[i] !== 'undefined') {
	            obj[i] = source[i];
	        }
	    }

	    return obj;
	};

	var merge = function merge(target, source, options) {
	    if (!source) {
	        return target;
	    }

	    if (typeof source !== 'object') {
	        if (Array.isArray(target)) {
	            target.push(source);
	        } else if (target && typeof target === 'object') {
	            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
	                target[source] = true;
	            }
	        } else {
	            return [target, source];
	        }

	        return target;
	    }

	    if (!target || typeof target !== 'object') {
	        return [target].concat(source);
	    }

	    var mergeTarget = target;
	    if (Array.isArray(target) && !Array.isArray(source)) {
	        mergeTarget = arrayToObject(target, options);
	    }

	    if (Array.isArray(target) && Array.isArray(source)) {
	        source.forEach(function (item, i) {
	            if (has.call(target, i)) {
	                var targetItem = target[i];
	                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
	                    target[i] = merge(targetItem, item, options);
	                } else {
	                    target.push(item);
	                }
	            } else {
	                target[i] = item;
	            }
	        });
	        return target;
	    }

	    return Object.keys(source).reduce(function (acc, key) {
	        var value = source[key];

	        if (has.call(acc, key)) {
	            acc[key] = merge(acc[key], value, options);
	        } else {
	            acc[key] = value;
	        }
	        return acc;
	    }, mergeTarget);
	};

	var assign = function assignSingleSource(target, source) {
	    return Object.keys(source).reduce(function (acc, key) {
	        acc[key] = source[key];
	        return acc;
	    }, target);
	};

	var decode = function (str) {
	    try {
	        return decodeURIComponent(str.replace(/\+/g, ' '));
	    } catch (e) {
	        return str;
	    }
	};

	var encode = function encode(str) {
	    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
	    // It has been adapted here for stricter adherence to RFC 3986
	    if (str.length === 0) {
	        return str;
	    }

	    var string = typeof str === 'string' ? str : String(str);

	    var out = '';
	    for (var i = 0; i < string.length; ++i) {
	        var c = string.charCodeAt(i);

	        if (
	            c === 0x2D // -
	            || c === 0x2E // .
	            || c === 0x5F // _
	            || c === 0x7E // ~
	            || (c >= 0x30 && c <= 0x39) // 0-9
	            || (c >= 0x41 && c <= 0x5A) // a-z
	            || (c >= 0x61 && c <= 0x7A) // A-Z
	        ) {
	            out += string.charAt(i);
	            continue;
	        }

	        if (c < 0x80) {
	            out = out + hexTable[c];
	            continue;
	        }

	        if (c < 0x800) {
	            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
	            continue;
	        }

	        if (c < 0xD800 || c >= 0xE000) {
	            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
	            continue;
	        }

	        i += 1;
	        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
	        /* eslint operator-linebreak: [2, "before"] */
	        out += hexTable[0xF0 | (c >> 18)]
	            + hexTable[0x80 | ((c >> 12) & 0x3F)]
	            + hexTable[0x80 | ((c >> 6) & 0x3F)]
	            + hexTable[0x80 | (c & 0x3F)];
	    }

	    return out;
	};

	var compact = function compact(value) {
	    var queue = [{ obj: { o: value }, prop: 'o' }];
	    var refs = [];

	    for (var i = 0; i < queue.length; ++i) {
	        var item = queue[i];
	        var obj = item.obj[item.prop];

	        var keys = Object.keys(obj);
	        for (var j = 0; j < keys.length; ++j) {
	            var key = keys[j];
	            var val = obj[key];
	            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
	                queue.push({ obj: obj, prop: key });
	                refs.push(val);
	            }
	        }
	    }

	    return compactQueue(queue);
	};

	var isRegExp = function isRegExp(obj) {
	    return Object.prototype.toString.call(obj) === '[object RegExp]';
	};

	var isBuffer = function isBuffer(obj) {
	    if (obj === null || typeof obj === 'undefined') {
	        return false;
	    }

	    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
	};

	utils$3 = {
	    arrayToObject: arrayToObject,
	    assign: assign,
	    compact: compact,
	    decode: decode,
	    encode: encode,
	    isBuffer: isBuffer,
	    isRegExp: isRegExp,
	    merge: merge
	};
	return utils$3;
}

var formats;
var hasRequiredFormats$1;

function requireFormats$1 () {
	if (hasRequiredFormats$1) return formats;
	hasRequiredFormats$1 = 1;

	var replace = String.prototype.replace;
	var percentTwenties = /%20/g;

	formats = {
	    'default': 'RFC3986',
	    formatters: {
	        RFC1738: function (value) {
	            return replace.call(value, percentTwenties, '+');
	        },
	        RFC3986: function (value) {
	            return String(value);
	        }
	    },
	    RFC1738: 'RFC1738',
	    RFC3986: 'RFC3986'
	};
	return formats;
}

var stringify_1;
var hasRequiredStringify;

function requireStringify () {
	if (hasRequiredStringify) return stringify_1;
	hasRequiredStringify = 1;

	var utils = requireUtils$3();
	var formats = requireFormats$1();

	var arrayPrefixGenerators = {
	    brackets: function brackets(prefix) {
	        return prefix + '[]';
	    },
	    indices: function indices(prefix, key) {
	        return prefix + '[' + key + ']';
	    },
	    repeat: function repeat(prefix) {
	        return prefix;
	    }
	};

	var isArray = Array.isArray;
	var push = Array.prototype.push;
	var pushToArray = function (arr, valueOrArray) {
	    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
	};

	var toISO = Date.prototype.toISOString;

	var defaults = {
	    delimiter: '&',
	    encode: true,
	    encoder: utils.encode,
	    encodeValuesOnly: false,
	    serializeDate: function serializeDate(date) {
	        return toISO.call(date);
	    },
	    skipNulls: false,
	    strictNullHandling: false
	};

	var stringify = function stringify(
	    object,
	    prefix,
	    generateArrayPrefix,
	    strictNullHandling,
	    skipNulls,
	    encoder,
	    filter,
	    sort,
	    allowDots,
	    serializeDate,
	    formatter,
	    encodeValuesOnly
	) {
	    var obj = object;
	    if (typeof filter === 'function') {
	        obj = filter(prefix, obj);
	    } else if (obj instanceof Date) {
	        obj = serializeDate(obj);
	    }

	    if (obj === null) {
	        if (strictNullHandling) {
	            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
	        }

	        obj = '';
	    }

	    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
	        if (encoder) {
	            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);
	            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder))];
	        }
	        return [formatter(prefix) + '=' + formatter(String(obj))];
	    }

	    var values = [];

	    if (typeof obj === 'undefined') {
	        return values;
	    }

	    var objKeys;
	    if (isArray(filter)) {
	        objKeys = filter;
	    } else {
	        var keys = Object.keys(obj);
	        objKeys = sort ? keys.sort(sort) : keys;
	    }

	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];

	        if (skipNulls && obj[key] === null) {
	            continue;
	        }

	        if (isArray(obj)) {
	            pushToArray(values, stringify(
	                obj[key],
	                generateArrayPrefix(prefix, key),
	                generateArrayPrefix,
	                strictNullHandling,
	                skipNulls,
	                encoder,
	                filter,
	                sort,
	                allowDots,
	                serializeDate,
	                formatter,
	                encodeValuesOnly
	            ));
	        } else {
	            pushToArray(values, stringify(
	                obj[key],
	                prefix + (allowDots ? '.' + key : '[' + key + ']'),
	                generateArrayPrefix,
	                strictNullHandling,
	                skipNulls,
	                encoder,
	                filter,
	                sort,
	                allowDots,
	                serializeDate,
	                formatter,
	                encodeValuesOnly
	            ));
	        }
	    }

	    return values;
	};

	stringify_1 = function (object, opts) {
	    var obj = object;
	    var options = opts ? utils.assign({}, opts) : {};

	    if (options.encoder !== null && typeof options.encoder !== 'undefined' && typeof options.encoder !== 'function') {
	        throw new TypeError('Encoder has to be a function.');
	    }

	    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
	    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
	    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
	    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
	    var encoder = typeof options.encoder === 'function' ? options.encoder : defaults.encoder;
	    var sort = typeof options.sort === 'function' ? options.sort : null;
	    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
	    var serializeDate = typeof options.serializeDate === 'function' ? options.serializeDate : defaults.serializeDate;
	    var encodeValuesOnly = typeof options.encodeValuesOnly === 'boolean' ? options.encodeValuesOnly : defaults.encodeValuesOnly;
	    if (typeof options.format === 'undefined') {
	        options.format = formats['default'];
	    } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
	        throw new TypeError('Unknown format option provided.');
	    }
	    var formatter = formats.formatters[options.format];
	    var objKeys;
	    var filter;

	    if (typeof options.filter === 'function') {
	        filter = options.filter;
	        obj = filter('', obj);
	    } else if (isArray(options.filter)) {
	        filter = options.filter;
	        objKeys = filter;
	    }

	    var keys = [];

	    if (typeof obj !== 'object' || obj === null) {
	        return '';
	    }

	    var arrayFormat;
	    if (options.arrayFormat in arrayPrefixGenerators) {
	        arrayFormat = options.arrayFormat;
	    } else if ('indices' in options) {
	        arrayFormat = options.indices ? 'indices' : 'repeat';
	    } else {
	        arrayFormat = 'indices';
	    }

	    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

	    if (!objKeys) {
	        objKeys = Object.keys(obj);
	    }

	    if (sort) {
	        objKeys.sort(sort);
	    }

	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];

	        if (skipNulls && obj[key] === null) {
	            continue;
	        }
	        pushToArray(keys, stringify(
	            obj[key],
	            key,
	            generateArrayPrefix,
	            strictNullHandling,
	            skipNulls,
	            encode ? encoder : null,
	            filter,
	            sort,
	            allowDots,
	            serializeDate,
	            formatter,
	            encodeValuesOnly
	        ));
	    }

	    var joined = keys.join(delimiter);
	    var prefix = options.addQueryPrefix === true ? '?' : '';

	    return joined.length > 0 ? prefix + joined : '';
	};
	return stringify_1;
}

var parse;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse;
	hasRequiredParse = 1;

	var utils = requireUtils$3();

	var has = Object.prototype.hasOwnProperty;

	var defaults = {
	    allowDots: false,
	    allowPrototypes: false,
	    arrayLimit: 20,
	    decoder: utils.decode,
	    delimiter: '&',
	    depth: 5,
	    parameterLimit: 1000,
	    plainObjects: false,
	    strictNullHandling: false
	};

	var parseValues = function parseQueryStringValues(str, options) {
	    var obj = {};
	    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
	    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
	    var parts = cleanStr.split(options.delimiter, limit);

	    for (var i = 0; i < parts.length; ++i) {
	        var part = parts[i];

	        var bracketEqualsPos = part.indexOf(']=');
	        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

	        var key, val;
	        if (pos === -1) {
	            key = options.decoder(part, defaults.decoder);
	            val = options.strictNullHandling ? null : '';
	        } else {
	            key = options.decoder(part.slice(0, pos), defaults.decoder);
	            val = options.decoder(part.slice(pos + 1), defaults.decoder);
	        }
	        if (has.call(obj, key)) {
	            obj[key] = [].concat(obj[key]).concat(val);
	        } else {
	            obj[key] = val;
	        }
	    }

	    return obj;
	};

	var parseObject = function (chain, val, options) {
	    var leaf = val;

	    for (var i = chain.length - 1; i >= 0; --i) {
	        var obj;
	        var root = chain[i];

	        if (root === '[]' && options.parseArrays) {
	            obj = [].concat(leaf);
	        } else {
	            obj = options.plainObjects ? Object.create(null) : {};
	            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
	            var index = parseInt(cleanRoot, 10);
	            if (!options.parseArrays && cleanRoot === '') {
	                obj = { 0: leaf };
	            } else if (
	                !isNaN(index)
	                && root !== cleanRoot
	                && String(index) === cleanRoot
	                && index >= 0
	                && (options.parseArrays && index <= options.arrayLimit)
	            ) {
	                obj = [];
	                obj[index] = leaf;
	            } else if (cleanRoot !== '__proto__') {
	                obj[cleanRoot] = leaf;
	            }
	        }

	        leaf = obj;
	    }

	    return leaf;
	};

	var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
	    if (!givenKey) {
	        return;
	    }

	    // Transform dot notation to bracket notation
	    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

	    // The regex chunks

	    var brackets = /(\[[^[\]]*])/;
	    var child = /(\[[^[\]]*])/g;

	    // Get the parent

	    var segment = brackets.exec(key);
	    var parent = segment ? key.slice(0, segment.index) : key;

	    // Stash the parent if it exists

	    var keys = [];
	    if (parent) {
	        // If we aren't using plain objects, optionally prefix keys
	        // that would overwrite object prototype properties
	        if (!options.plainObjects && has.call(Object.prototype, parent)) {
	            if (!options.allowPrototypes) {
	                return;
	            }
	        }

	        keys.push(parent);
	    }

	    // Loop through children appending to the array until we hit depth

	    var i = 0;
	    while ((segment = child.exec(key)) !== null && i < options.depth) {
	        i += 1;
	        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
	            if (!options.allowPrototypes) {
	                return;
	            }
	        }
	        keys.push(segment[1]);
	    }

	    // If there's a remainder, just add whatever is left

	    if (segment) {
	        keys.push('[' + key.slice(segment.index) + ']');
	    }

	    return parseObject(keys, val, options);
	};

	parse = function (str, opts) {
	    var options = opts ? utils.assign({}, opts) : {};

	    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
	        throw new TypeError('Decoder has to be a function.');
	    }

	    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
	    options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
	    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
	    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
	    options.parseArrays = options.parseArrays !== false;
	    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
	    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
	    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
	    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
	    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
	    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;

	    if (str === '' || str === null || typeof str === 'undefined') {
	        return options.plainObjects ? Object.create(null) : {};
	    }

	    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
	    var obj = options.plainObjects ? Object.create(null) : {};

	    // Iterate over the keys and setup the new object

	    var keys = Object.keys(tempObj);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var newObj = parseKeys(key, tempObj[key], options);
	        obj = utils.merge(obj, newObj, options);
	    }

	    return utils.compact(obj);
	};
	return parse;
}

var lib$6;
var hasRequiredLib$6;

function requireLib$6 () {
	if (hasRequiredLib$6) return lib$6;
	hasRequiredLib$6 = 1;

	var stringify = requireStringify();
	var parse = requireParse();
	var formats = requireFormats$1();

	lib$6 = {
	    formats: formats,
	    parse: parse,
	    stringify: stringify
	};
	return lib$6;
}

var hasRequiredQuerystring;

function requireQuerystring () {
	if (hasRequiredQuerystring) return querystring;
	hasRequiredQuerystring = 1;

	var qs = requireLib$6();
	var querystring$1 = require$$1$3;

	function Querystring (request) {
	  this.request = request;
	  this.lib = null;
	  this.useQuerystring = null;
	  this.parseOptions = null;
	  this.stringifyOptions = null;
	}

	Querystring.prototype.init = function (options) {
	  if (this.lib) { return }

	  this.useQuerystring = options.useQuerystring;
	  this.lib = (this.useQuerystring ? querystring$1 : qs);

	  this.parseOptions = options.qsParseOptions || {};
	  this.stringifyOptions = options.qsStringifyOptions || {};
	};

	Querystring.prototype.stringify = function (obj) {
	  return (this.useQuerystring)
	    ? this.rfc3986(this.lib.stringify(obj,
	      this.stringifyOptions.sep || null,
	      this.stringifyOptions.eq || null,
	      this.stringifyOptions))
	    : this.lib.stringify(obj, this.stringifyOptions)
	};

	Querystring.prototype.parse = function (str) {
	  return (this.useQuerystring)
	    ? this.lib.parse(str,
	      this.parseOptions.sep || null,
	      this.parseOptions.eq || null,
	      this.parseOptions)
	    : this.lib.parse(str, this.parseOptions)
	};

	Querystring.prototype.rfc3986 = function (str) {
	  return str.replace(/[!'()*]/g, function (c) {
	    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
	  })
	};

	Querystring.prototype.unescape = querystring$1.unescape;

	querystring.Querystring = Querystring;
	return querystring;
}

var har = {};

var promise$1 = {};

var uri_all$1 = {exports: {}};

/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
var uri_all = uri_all$1.exports;

var hasRequiredUri_all;

function requireUri_all () {
	if (hasRequiredUri_all) return uri_all$1.exports;
	hasRequiredUri_all = 1;
	(function (module, exports) {
		(function (global, factory) {
			factory(exports) ;
		}(uri_all, (function (exports) {
		function merge() {
		    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
		        sets[_key] = arguments[_key];
		    }

		    if (sets.length > 1) {
		        sets[0] = sets[0].slice(0, -1);
		        var xl = sets.length - 1;
		        for (var x = 1; x < xl; ++x) {
		            sets[x] = sets[x].slice(1, -1);
		        }
		        sets[xl] = sets[xl].slice(1);
		        return sets.join('');
		    } else {
		        return sets[0];
		    }
		}
		function subexp(str) {
		    return "(?:" + str + ")";
		}
		function typeOf(o) {
		    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
		}
		function toUpperCase(str) {
		    return str.toUpperCase();
		}
		function toArray(obj) {
		    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
		}
		function assign(target, source) {
		    var obj = target;
		    if (source) {
		        for (var key in source) {
		            obj[key] = source[key];
		        }
		    }
		    return obj;
		}

		function buildExps(isIRI) {
		    var ALPHA$$ = "[A-Za-z]",
		        DIGIT$$ = "[0-9]",
		        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
		        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
		        //expanded
		    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
		        SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
		        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
		        UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
		        //subset, excludes bidi control characters
		    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
		        //subset
		    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
		        subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
		        subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*");
		        var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
		        //relaxed parsing rules
		    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
		        H16$ = subexp(HEXDIG$$ + "{1,4}"),
		        LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
		        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
		        //                           6( h16 ":" ) ls32
		    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
		        //                      "::" 5( h16 ":" ) ls32
		    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
		        //[               h16 ] "::" 4( h16 ":" ) ls32
		    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
		        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
		    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
		        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
		    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
		        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
		    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
		        //[ *4( h16 ":" ) h16 ] "::"              ls32
		    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
		        //[ *5( h16 ":" ) h16 ] "::"              h16
		    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
		        //[ *6( h16 ":" ) h16 ] "::"
		    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
		        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+");
		        //RFC 6874, with relaxed parsing rules
		    subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+");
		        //RFC 6874
		    subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*");
		        var PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]"));
		        subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+");
		        subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*");
		    return {
		        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
		        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
		        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
		        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
		        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
		        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
		        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
		        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
		        UNRESERVED: new RegExp(UNRESERVED$$, "g"),
		        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
		        PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
		        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
		        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
		    };
		}
		var URI_PROTOCOL = buildExps(false);

		var IRI_PROTOCOL = buildExps(true);

		var slicedToArray = function () {
		  function sliceIterator(arr, i) {
		    var _arr = [];
		    var _n = true;
		    var _d = false;
		    var _e = undefined;

		    try {
		      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
		        _arr.push(_s.value);

		        if (i && _arr.length === i) break;
		      }
		    } catch (err) {
		      _d = true;
		      _e = err;
		    } finally {
		      try {
		        if (!_n && _i["return"]) _i["return"]();
		      } finally {
		        if (_d) throw _e;
		      }
		    }

		    return _arr;
		  }

		  return function (arr, i) {
		    if (Array.isArray(arr)) {
		      return arr;
		    } else if (Symbol.iterator in Object(arr)) {
		      return sliceIterator(arr, i);
		    } else {
		      throw new TypeError("Invalid attempt to destructure non-iterable instance");
		    }
		  };
		}();













		var toConsumableArray = function (arr) {
		  if (Array.isArray(arr)) {
		    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

		    return arr2;
		  } else {
		    return Array.from(arr);
		  }
		};

		/** Highest positive signed 32-bit float value */

		var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

		/** Bootstring parameters */
		var base = 36;
		var tMin = 1;
		var tMax = 26;
		var skew = 38;
		var damp = 700;
		var initialBias = 72;
		var initialN = 128; // 0x80
		var delimiter = '-'; // '\x2D'

		/** Regular expressions */
		var regexPunycode = /^xn--/;
		var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
		var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

		/** Error messages */
		var errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		};

		/** Convenience shortcuts */
		var baseMinusTMin = base - tMin;
		var floor = Math.floor;
		var stringFromCharCode = String.fromCharCode;

		/*--------------------------------------------------------------------------*/

		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error$1(type) {
			throw new RangeError(errors[type]);
		}

		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var result = [];
			var length = array.length;
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}

		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}

		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			while (counter < length) {
				var value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// It's a high surrogate, and there is a next character.
					var extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) {
						// Low surrogate.
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// It's an unmatched surrogate; only append this code unit, in case the
						// next code unit is the high surrogate of a surrogate pair.
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		var ucs2encode = function ucs2encode(array) {
			return String.fromCodePoint.apply(String, toConsumableArray(array));
		};

		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		var basicToDigit = function basicToDigit(codePoint) {
			if (codePoint - 0x30 < 0x0A) {
				return codePoint - 0x16;
			}
			if (codePoint - 0x41 < 0x1A) {
				return codePoint - 0x41;
			}
			if (codePoint - 0x61 < 0x1A) {
				return codePoint - 0x61;
			}
			return base;
		};

		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		var digitToBasic = function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		};

		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * https://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		var adapt = function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		};

		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		var decode = function decode(input) {
			// Don't use UCS-2.
			var output = [];
			var inputLength = input.length;
			var i = 0;
			var n = initialN;
			var bias = initialBias;

			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.

			var basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}

			for (var j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error$1('not-basic');
				}
				output.push(input.charCodeAt(j));
			}

			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.

			for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				var oldi = i;
				for (var w = 1, k = base;; /* no condition */k += base) {

					if (index >= inputLength) {
						error$1('invalid-input');
					}

					var digit = basicToDigit(input.charCodeAt(index++));

					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error$1('overflow');
					}

					i += digit * w;
					var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

					if (digit < t) {
						break;
					}

					var baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error$1('overflow');
					}

					w *= baseMinusT;
				}

				var out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);

				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error$1('overflow');
				}

				n += floor(i / out);
				i %= out;

				// Insert `n` at position `i` of the output.
				output.splice(i++, 0, n);
			}

			return String.fromCodePoint.apply(String, output);
		};

		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		var encode = function encode(input) {
			var output = [];

			// Convert the input in UCS-2 to an array of Unicode code points.
			input = ucs2decode(input);

			// Cache the length.
			var inputLength = input.length;

			// Initialize the state.
			var n = initialN;
			var delta = 0;
			var bias = initialBias;

			// Handle the basic code points.
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var _currentValue2 = _step.value;

					if (_currentValue2 < 0x80) {
						output.push(stringFromCharCode(_currentValue2));
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			var basicLength = output.length;
			var handledCPCount = basicLength;

			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.

			// Finish the basic string with a delimiter unless it's empty.
			if (basicLength) {
				output.push(delimiter);
			}

			// Main encoding loop:
			while (handledCPCount < inputLength) {

				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				var m = maxInt;
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;

				try {
					for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var currentValue = _step2.value;

						if (currentValue >= n && currentValue < m) {
							m = currentValue;
						}
					}

					// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
					// but guard against overflow.
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2.return) {
							_iterator2.return();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}

				var handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error$1('overflow');
				}

				delta += (m - n) * handledCPCountPlusOne;
				n = m;

				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = undefined;

				try {
					for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						var _currentValue = _step3.value;

						if (_currentValue < n && ++delta > maxInt) {
							error$1('overflow');
						}
						if (_currentValue == n) {
							// Represent delta as a generalized variable-length integer.
							var q = delta;
							for (var k = base;; /* no condition */k += base) {
								var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
								if (q < t) {
									break;
								}
								var qMinusT = q - t;
								var baseMinusT = base - t;
								output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
								q = floor(qMinusT / baseMinusT);
							}

							output.push(stringFromCharCode(digitToBasic(q, 0)));
							bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
							delta = 0;
							++handledCPCount;
						}
					}
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 && _iterator3.return) {
							_iterator3.return();
						}
					} finally {
						if (_didIteratorError3) {
							throw _iteratorError3;
						}
					}
				}

				++delta;
				++n;
			}
			return output.join('');
		};

		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		var toUnicode = function toUnicode(input) {
			return mapDomain(input, function (string) {
				return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
			});
		};

		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		var toASCII = function toASCII(input) {
			return mapDomain(input, function (string) {
				return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
			});
		};

		/*--------------------------------------------------------------------------*/

		/** Define the public API */
		var punycode = {
			/**
		  * A string representing the current Punycode.js version number.
		  * @memberOf punycode
		  * @type String
		  */
			'version': '2.1.0',
			/**
		  * An object of methods to convert from JavaScript's internal character
		  * representation (UCS-2) to Unicode code points, and back.
		  * @see <https://mathiasbynens.be/notes/javascript-encoding>
		  * @memberOf punycode
		  * @type Object
		  */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};

		/**
		 * URI.js
		 *
		 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
		 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
		 * @see http://github.com/garycourt/uri-js
		 */
		/**
		 * Copyright 2011 Gary Court. All rights reserved.
		 *
		 * Redistribution and use in source and binary forms, with or without modification, are
		 * permitted provided that the following conditions are met:
		 *
		 *    1. Redistributions of source code must retain the above copyright notice, this list of
		 *       conditions and the following disclaimer.
		 *
		 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
		 *       of conditions and the following disclaimer in the documentation and/or other materials
		 *       provided with the distribution.
		 *
		 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
		 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
		 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
		 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
		 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
		 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
		 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
		 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 *
		 * The views and conclusions contained in the software and documentation are those of the
		 * authors and should not be interpreted as representing official policies, either expressed
		 * or implied, of Gary Court.
		 */
		var SCHEMES = {};
		function pctEncChar(chr) {
		    var c = chr.charCodeAt(0);
		    var e = void 0;
		    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
		    return e;
		}
		function pctDecChars(str) {
		    var newStr = "";
		    var i = 0;
		    var il = str.length;
		    while (i < il) {
		        var c = parseInt(str.substr(i + 1, 2), 16);
		        if (c < 128) {
		            newStr += String.fromCharCode(c);
		            i += 3;
		        } else if (c >= 194 && c < 224) {
		            if (il - i >= 6) {
		                var c2 = parseInt(str.substr(i + 4, 2), 16);
		                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
		            } else {
		                newStr += str.substr(i, 6);
		            }
		            i += 6;
		        } else if (c >= 224) {
		            if (il - i >= 9) {
		                var _c = parseInt(str.substr(i + 4, 2), 16);
		                var c3 = parseInt(str.substr(i + 7, 2), 16);
		                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
		            } else {
		                newStr += str.substr(i, 9);
		            }
		            i += 9;
		        } else {
		            newStr += str.substr(i, 3);
		            i += 3;
		        }
		    }
		    return newStr;
		}
		function _normalizeComponentEncoding(components, protocol) {
		    function decodeUnreserved(str) {
		        var decStr = pctDecChars(str);
		        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
		    }
		    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
		    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
		    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
		    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
		    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
		    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
		    return components;
		}

		function _stripLeadingZeros(str) {
		    return str.replace(/^0*(.*)/, "$1") || "0";
		}
		function _normalizeIPv4(host, protocol) {
		    var matches = host.match(protocol.IPV4ADDRESS) || [];

		    var _matches = slicedToArray(matches, 2),
		        address = _matches[1];

		    if (address) {
		        return address.split(".").map(_stripLeadingZeros).join(".");
		    } else {
		        return host;
		    }
		}
		function _normalizeIPv6(host, protocol) {
		    var matches = host.match(protocol.IPV6ADDRESS) || [];

		    var _matches2 = slicedToArray(matches, 3),
		        address = _matches2[1],
		        zone = _matches2[2];

		    if (address) {
		        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
		            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
		            last = _address$toLowerCase$2[0],
		            first = _address$toLowerCase$2[1];

		        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
		        var lastFields = last.split(":").map(_stripLeadingZeros);
		        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
		        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
		        var lastFieldsStart = lastFields.length - fieldCount;
		        var fields = Array(fieldCount);
		        for (var x = 0; x < fieldCount; ++x) {
		            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
		        }
		        if (isLastFieldIPv4Address) {
		            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
		        }
		        var allZeroFields = fields.reduce(function (acc, field, index) {
		            if (!field || field === "0") {
		                var lastLongest = acc[acc.length - 1];
		                if (lastLongest && lastLongest.index + lastLongest.length === index) {
		                    lastLongest.length++;
		                } else {
		                    acc.push({ index: index, length: 1 });
		                }
		            }
		            return acc;
		        }, []);
		        var longestZeroFields = allZeroFields.sort(function (a, b) {
		            return b.length - a.length;
		        })[0];
		        var newHost = void 0;
		        if (longestZeroFields && longestZeroFields.length > 1) {
		            var newFirst = fields.slice(0, longestZeroFields.index);
		            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
		            newHost = newFirst.join(":") + "::" + newLast.join(":");
		        } else {
		            newHost = fields.join(":");
		        }
		        if (zone) {
		            newHost += "%" + zone;
		        }
		        return newHost;
		    } else {
		        return host;
		    }
		}
		var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
		var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
		function parse(uriString) {
		    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		    var components = {};
		    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
		    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
		    var matches = uriString.match(URI_PARSE);
		    if (matches) {
		        if (NO_MATCH_IS_UNDEFINED) {
		            //store each component
		            components.scheme = matches[1];
		            components.userinfo = matches[3];
		            components.host = matches[4];
		            components.port = parseInt(matches[5], 10);
		            components.path = matches[6] || "";
		            components.query = matches[7];
		            components.fragment = matches[8];
		            //fix port number
		            if (isNaN(components.port)) {
		                components.port = matches[5];
		            }
		        } else {
		            //IE FIX for improper RegExp matching
		            //store each component
		            components.scheme = matches[1] || undefined;
		            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
		            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
		            components.port = parseInt(matches[5], 10);
		            components.path = matches[6] || "";
		            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
		            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
		            //fix port number
		            if (isNaN(components.port)) {
		                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
		            }
		        }
		        if (components.host) {
		            //normalize IP hosts
		            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
		        }
		        //determine reference type
		        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
		            components.reference = "same-document";
		        } else if (components.scheme === undefined) {
		            components.reference = "relative";
		        } else if (components.fragment === undefined) {
		            components.reference = "absolute";
		        } else {
		            components.reference = "uri";
		        }
		        //check for reference errors
		        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
		            components.error = components.error || "URI is not a " + options.reference + " reference.";
		        }
		        //find scheme handler
		        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
		        //check if scheme can't handle IRIs
		        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
		            //if host component is a domain name
		            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
		                //convert Unicode IDN -> ASCII IDN
		                try {
		                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
		                } catch (e) {
		                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
		                }
		            }
		            //convert IRI -> URI
		            _normalizeComponentEncoding(components, URI_PROTOCOL);
		        } else {
		            //normalize encodings
		            _normalizeComponentEncoding(components, protocol);
		        }
		        //perform scheme specific parsing
		        if (schemeHandler && schemeHandler.parse) {
		            schemeHandler.parse(components, options);
		        }
		    } else {
		        components.error = components.error || "URI can not be parsed.";
		    }
		    return components;
		}

		function _recomposeAuthority(components, options) {
		    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
		    var uriTokens = [];
		    if (components.userinfo !== undefined) {
		        uriTokens.push(components.userinfo);
		        uriTokens.push("@");
		    }
		    if (components.host !== undefined) {
		        //normalize IP hosts, add brackets and escape zone separator for IPv6
		        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
		            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
		        }));
		    }
		    if (typeof components.port === "number" || typeof components.port === "string") {
		        uriTokens.push(":");
		        uriTokens.push(String(components.port));
		    }
		    return uriTokens.length ? uriTokens.join("") : undefined;
		}

		var RDS1 = /^\.\.?\//;
		var RDS2 = /^\/\.(\/|$)/;
		var RDS3 = /^\/\.\.(\/|$)/;
		var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
		function removeDotSegments(input) {
		    var output = [];
		    while (input.length) {
		        if (input.match(RDS1)) {
		            input = input.replace(RDS1, "");
		        } else if (input.match(RDS2)) {
		            input = input.replace(RDS2, "/");
		        } else if (input.match(RDS3)) {
		            input = input.replace(RDS3, "/");
		            output.pop();
		        } else if (input === "." || input === "..") {
		            input = "";
		        } else {
		            var im = input.match(RDS5);
		            if (im) {
		                var s = im[0];
		                input = input.slice(s.length);
		                output.push(s);
		            } else {
		                throw new Error("Unexpected dot segment condition");
		            }
		        }
		    }
		    return output.join("");
		}

		function serialize(components) {
		    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
		    var uriTokens = [];
		    //find scheme handler
		    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
		    //perform scheme specific serialization
		    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
		    if (components.host) {
		        //if host component is an IPv6 address
		        if (protocol.IPV6ADDRESS.test(components.host)) ;
		        //TODO: normalize IPv6 address as per RFC 5952

		        //if host component is a domain name
		        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
		                //convert IDN via punycode
		                try {
		                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
		                } catch (e) {
		                    components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
		                }
		            }
		    }
		    //normalize encoding
		    _normalizeComponentEncoding(components, protocol);
		    if (options.reference !== "suffix" && components.scheme) {
		        uriTokens.push(components.scheme);
		        uriTokens.push(":");
		    }
		    var authority = _recomposeAuthority(components, options);
		    if (authority !== undefined) {
		        if (options.reference !== "suffix") {
		            uriTokens.push("//");
		        }
		        uriTokens.push(authority);
		        if (components.path && components.path.charAt(0) !== "/") {
		            uriTokens.push("/");
		        }
		    }
		    if (components.path !== undefined) {
		        var s = components.path;
		        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
		            s = removeDotSegments(s);
		        }
		        if (authority === undefined) {
		            s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
		        }
		        uriTokens.push(s);
		    }
		    if (components.query !== undefined) {
		        uriTokens.push("?");
		        uriTokens.push(components.query);
		    }
		    if (components.fragment !== undefined) {
		        uriTokens.push("#");
		        uriTokens.push(components.fragment);
		    }
		    return uriTokens.join(""); //merge tokens into a string
		}

		function resolveComponents(base, relative) {
		    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
		    var skipNormalization = arguments[3];

		    var target = {};
		    if (!skipNormalization) {
		        base = parse(serialize(base, options), options); //normalize base components
		        relative = parse(serialize(relative, options), options); //normalize relative components
		    }
		    options = options || {};
		    if (!options.tolerant && relative.scheme) {
		        target.scheme = relative.scheme;
		        //target.authority = relative.authority;
		        target.userinfo = relative.userinfo;
		        target.host = relative.host;
		        target.port = relative.port;
		        target.path = removeDotSegments(relative.path || "");
		        target.query = relative.query;
		    } else {
		        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
		            //target.authority = relative.authority;
		            target.userinfo = relative.userinfo;
		            target.host = relative.host;
		            target.port = relative.port;
		            target.path = removeDotSegments(relative.path || "");
		            target.query = relative.query;
		        } else {
		            if (!relative.path) {
		                target.path = base.path;
		                if (relative.query !== undefined) {
		                    target.query = relative.query;
		                } else {
		                    target.query = base.query;
		                }
		            } else {
		                if (relative.path.charAt(0) === "/") {
		                    target.path = removeDotSegments(relative.path);
		                } else {
		                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
		                        target.path = "/" + relative.path;
		                    } else if (!base.path) {
		                        target.path = relative.path;
		                    } else {
		                        target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
		                    }
		                    target.path = removeDotSegments(target.path);
		                }
		                target.query = relative.query;
		            }
		            //target.authority = base.authority;
		            target.userinfo = base.userinfo;
		            target.host = base.host;
		            target.port = base.port;
		        }
		        target.scheme = base.scheme;
		    }
		    target.fragment = relative.fragment;
		    return target;
		}

		function resolve(baseURI, relativeURI, options) {
		    var schemelessOptions = assign({ scheme: 'null' }, options);
		    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
		}

		function normalize(uri, options) {
		    if (typeof uri === "string") {
		        uri = serialize(parse(uri, options), options);
		    } else if (typeOf(uri) === "object") {
		        uri = parse(serialize(uri, options), options);
		    }
		    return uri;
		}

		function equal(uriA, uriB, options) {
		    if (typeof uriA === "string") {
		        uriA = serialize(parse(uriA, options), options);
		    } else if (typeOf(uriA) === "object") {
		        uriA = serialize(uriA, options);
		    }
		    if (typeof uriB === "string") {
		        uriB = serialize(parse(uriB, options), options);
		    } else if (typeOf(uriB) === "object") {
		        uriB = serialize(uriB, options);
		    }
		    return uriA === uriB;
		}

		function escapeComponent(str, options) {
		    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
		}

		function unescapeComponent(str, options) {
		    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
		}

		var handler = {
		    scheme: "http",
		    domainHost: true,
		    parse: function parse(components, options) {
		        //report missing host
		        if (!components.host) {
		            components.error = components.error || "HTTP URIs must have a host.";
		        }
		        return components;
		    },
		    serialize: function serialize(components, options) {
		        var secure = String(components.scheme).toLowerCase() === "https";
		        //normalize the default port
		        if (components.port === (secure ? 443 : 80) || components.port === "") {
		            components.port = undefined;
		        }
		        //normalize the empty path
		        if (!components.path) {
		            components.path = "/";
		        }
		        //NOTE: We do not parse query strings for HTTP URIs
		        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
		        //and not the HTTP spec.
		        return components;
		    }
		};

		var handler$1 = {
		    scheme: "https",
		    domainHost: handler.domainHost,
		    parse: handler.parse,
		    serialize: handler.serialize
		};

		function isSecure(wsComponents) {
		    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
		}
		//RFC 6455
		var handler$2 = {
		    scheme: "ws",
		    domainHost: true,
		    parse: function parse(components, options) {
		        var wsComponents = components;
		        //indicate if the secure flag is set
		        wsComponents.secure = isSecure(wsComponents);
		        //construct resouce name
		        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');
		        wsComponents.path = undefined;
		        wsComponents.query = undefined;
		        return wsComponents;
		    },
		    serialize: function serialize(wsComponents, options) {
		        //normalize the default port
		        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
		            wsComponents.port = undefined;
		        }
		        //ensure scheme matches secure flag
		        if (typeof wsComponents.secure === 'boolean') {
		            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';
		            wsComponents.secure = undefined;
		        }
		        //reconstruct path from resource name
		        if (wsComponents.resourceName) {
		            var _wsComponents$resourc = wsComponents.resourceName.split('?'),
		                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),
		                path = _wsComponents$resourc2[0],
		                query = _wsComponents$resourc2[1];

		            wsComponents.path = path && path !== '/' ? path : undefined;
		            wsComponents.query = query;
		            wsComponents.resourceName = undefined;
		        }
		        //forbid fragment component
		        wsComponents.fragment = undefined;
		        return wsComponents;
		    }
		};

		var handler$3 = {
		    scheme: "wss",
		    domainHost: handler$2.domainHost,
		    parse: handler$2.parse,
		    serialize: handler$2.serialize
		};

		var O = {};
		//RFC 3986
		var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + ("\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" ) + "]";
		var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
		var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
		//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
		//const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
		//const WSP$$ = "[\\x20\\x09]";
		//const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
		//const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
		//const VCHAR$$ = "[\\x21-\\x7E]";
		//const WSP$$ = "[\\x20\\x09]";
		//const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
		//const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
		//const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
		//const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
		var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
		var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
		var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
		var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
		var UNRESERVED = new RegExp(UNRESERVED$$, "g");
		var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
		var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
		var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
		var NOT_HFVALUE = NOT_HFNAME;
		function decodeUnreserved(str) {
		    var decStr = pctDecChars(str);
		    return !decStr.match(UNRESERVED) ? str : decStr;
		}
		var handler$4 = {
		    scheme: "mailto",
		    parse: function parse$$1(components, options) {
		        var mailtoComponents = components;
		        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
		        mailtoComponents.path = undefined;
		        if (mailtoComponents.query) {
		            var unknownHeaders = false;
		            var headers = {};
		            var hfields = mailtoComponents.query.split("&");
		            for (var x = 0, xl = hfields.length; x < xl; ++x) {
		                var hfield = hfields[x].split("=");
		                switch (hfield[0]) {
		                    case "to":
		                        var toAddrs = hfield[1].split(",");
		                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
		                            to.push(toAddrs[_x]);
		                        }
		                        break;
		                    case "subject":
		                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
		                        break;
		                    case "body":
		                        mailtoComponents.body = unescapeComponent(hfield[1], options);
		                        break;
		                    default:
		                        unknownHeaders = true;
		                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
		                        break;
		                }
		            }
		            if (unknownHeaders) mailtoComponents.headers = headers;
		        }
		        mailtoComponents.query = undefined;
		        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
		            var addr = to[_x2].split("@");
		            addr[0] = unescapeComponent(addr[0]);
		            if (!options.unicodeSupport) {
		                //convert Unicode IDN -> ASCII IDN
		                try {
		                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
		                } catch (e) {
		                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
		                }
		            } else {
		                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
		            }
		            to[_x2] = addr.join("@");
		        }
		        return mailtoComponents;
		    },
		    serialize: function serialize$$1(mailtoComponents, options) {
		        var components = mailtoComponents;
		        var to = toArray(mailtoComponents.to);
		        if (to) {
		            for (var x = 0, xl = to.length; x < xl; ++x) {
		                var toAddr = String(to[x]);
		                var atIdx = toAddr.lastIndexOf("@");
		                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
		                var domain = toAddr.slice(atIdx + 1);
		                //convert IDN via punycode
		                try {
		                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
		                } catch (e) {
		                    components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
		                }
		                to[x] = localPart + "@" + domain;
		            }
		            components.path = to.join(",");
		        }
		        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
		        if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
		        if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
		        var fields = [];
		        for (var name in headers) {
		            if (headers[name] !== O[name]) {
		                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
		            }
		        }
		        if (fields.length) {
		            components.query = fields.join("&");
		        }
		        return components;
		    }
		};

		var URN_PARSE = /^([^\:]+)\:(.*)/;
		//RFC 2141
		var handler$5 = {
		    scheme: "urn",
		    parse: function parse$$1(components, options) {
		        var matches = components.path && components.path.match(URN_PARSE);
		        var urnComponents = components;
		        if (matches) {
		            var scheme = options.scheme || urnComponents.scheme || "urn";
		            var nid = matches[1].toLowerCase();
		            var nss = matches[2];
		            var urnScheme = scheme + ":" + (options.nid || nid);
		            var schemeHandler = SCHEMES[urnScheme];
		            urnComponents.nid = nid;
		            urnComponents.nss = nss;
		            urnComponents.path = undefined;
		            if (schemeHandler) {
		                urnComponents = schemeHandler.parse(urnComponents, options);
		            }
		        } else {
		            urnComponents.error = urnComponents.error || "URN can not be parsed.";
		        }
		        return urnComponents;
		    },
		    serialize: function serialize$$1(urnComponents, options) {
		        var scheme = options.scheme || urnComponents.scheme || "urn";
		        var nid = urnComponents.nid;
		        var urnScheme = scheme + ":" + (options.nid || nid);
		        var schemeHandler = SCHEMES[urnScheme];
		        if (schemeHandler) {
		            urnComponents = schemeHandler.serialize(urnComponents, options);
		        }
		        var uriComponents = urnComponents;
		        var nss = urnComponents.nss;
		        uriComponents.path = (nid || options.nid) + ":" + nss;
		        return uriComponents;
		    }
		};

		var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
		//RFC 4122
		var handler$6 = {
		    scheme: "urn:uuid",
		    parse: function parse(urnComponents, options) {
		        var uuidComponents = urnComponents;
		        uuidComponents.uuid = uuidComponents.nss;
		        uuidComponents.nss = undefined;
		        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
		            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
		        }
		        return uuidComponents;
		    },
		    serialize: function serialize(uuidComponents, options) {
		        var urnComponents = uuidComponents;
		        //normalize UUID
		        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
		        return urnComponents;
		    }
		};

		SCHEMES[handler.scheme] = handler;
		SCHEMES[handler$1.scheme] = handler$1;
		SCHEMES[handler$2.scheme] = handler$2;
		SCHEMES[handler$3.scheme] = handler$3;
		SCHEMES[handler$4.scheme] = handler$4;
		SCHEMES[handler$5.scheme] = handler$5;
		SCHEMES[handler$6.scheme] = handler$6;

		exports.SCHEMES = SCHEMES;
		exports.pctEncChar = pctEncChar;
		exports.pctDecChars = pctDecChars;
		exports.parse = parse;
		exports.removeDotSegments = removeDotSegments;
		exports.serialize = serialize;
		exports.resolveComponents = resolveComponents;
		exports.resolve = resolve;
		exports.normalize = normalize;
		exports.equal = equal;
		exports.escapeComponent = escapeComponent;
		exports.unescapeComponent = unescapeComponent;

		Object.defineProperty(exports, '__esModule', { value: true });

		})));
		
	} (uri_all$1, uri_all$1.exports));
	return uri_all$1.exports;
}

var fastDeepEqual;
var hasRequiredFastDeepEqual;

function requireFastDeepEqual () {
	if (hasRequiredFastDeepEqual) return fastDeepEqual;
	hasRequiredFastDeepEqual = 1;

	// do not edit .js files directly - edit src/index.jst



	fastDeepEqual = function equal(a, b) {
	  if (a === b) return true;

	  if (a && b && typeof a == 'object' && typeof b == 'object') {
	    if (a.constructor !== b.constructor) return false;

	    var length, i, keys;
	    if (Array.isArray(a)) {
	      length = a.length;
	      if (length != b.length) return false;
	      for (i = length; i-- !== 0;)
	        if (!equal(a[i], b[i])) return false;
	      return true;
	    }



	    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
	    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
	    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

	    keys = Object.keys(a);
	    length = keys.length;
	    if (length !== Object.keys(b).length) return false;

	    for (i = length; i-- !== 0;)
	      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

	    for (i = length; i-- !== 0;) {
	      var key = keys[i];

	      if (!equal(a[key], b[key])) return false;
	    }

	    return true;
	  }

	  // true if both NaN, false otherwise
	  return a!==a && b!==b;
	};
	return fastDeepEqual;
}

var ucs2length;
var hasRequiredUcs2length;

function requireUcs2length () {
	if (hasRequiredUcs2length) return ucs2length;
	hasRequiredUcs2length = 1;

	// https://mathiasbynens.be/notes/javascript-encoding
	// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
	ucs2length = function ucs2length(str) {
	  var length = 0
	    , len = str.length
	    , pos = 0
	    , value;
	  while (pos < len) {
	    length++;
	    value = str.charCodeAt(pos++);
	    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
	      // high surrogate, and there is a next character
	      value = str.charCodeAt(pos);
	      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
	    }
	  }
	  return length;
	};
	return ucs2length;
}

var util$1;
var hasRequiredUtil$1;

function requireUtil$1 () {
	if (hasRequiredUtil$1) return util$1;
	hasRequiredUtil$1 = 1;


	util$1 = {
	  copy: copy,
	  checkDataType: checkDataType,
	  checkDataTypes: checkDataTypes,
	  coerceToTypes: coerceToTypes,
	  toHash: toHash,
	  getProperty: getProperty,
	  escapeQuotes: escapeQuotes,
	  equal: requireFastDeepEqual(),
	  ucs2length: requireUcs2length(),
	  varOccurences: varOccurences,
	  varReplace: varReplace,
	  schemaHasRules: schemaHasRules,
	  schemaHasRulesExcept: schemaHasRulesExcept,
	  schemaUnknownRules: schemaUnknownRules,
	  toQuotedString: toQuotedString,
	  getPathExpr: getPathExpr,
	  getPath: getPath,
	  getData: getData,
	  unescapeFragment: unescapeFragment,
	  unescapeJsonPointer: unescapeJsonPointer,
	  escapeFragment: escapeFragment,
	  escapeJsonPointer: escapeJsonPointer
	};


	function copy(o, to) {
	  to = to || {};
	  for (var key in o) to[key] = o[key];
	  return to;
	}


	function checkDataType(dataType, data, strictNumbers, negate) {
	  var EQUAL = negate ? ' !== ' : ' === '
	    , AND = negate ? ' || ' : ' && '
	    , OK = negate ? '!' : ''
	    , NOT = negate ? '' : '!';
	  switch (dataType) {
	    case 'null': return data + EQUAL + 'null';
	    case 'array': return OK + 'Array.isArray(' + data + ')';
	    case 'object': return '(' + OK + data + AND +
	                          'typeof ' + data + EQUAL + '"object"' + AND +
	                          NOT + 'Array.isArray(' + data + '))';
	    case 'integer': return '(typeof ' + data + EQUAL + '"number"' + AND +
	                           NOT + '(' + data + ' % 1)' +
	                           AND + data + EQUAL + data +
	                           (strictNumbers ? (AND + OK + 'isFinite(' + data + ')') : '') + ')';
	    case 'number': return '(typeof ' + data + EQUAL + '"' + dataType + '"' +
	                          (strictNumbers ? (AND + OK + 'isFinite(' + data + ')') : '') + ')';
	    default: return 'typeof ' + data + EQUAL + '"' + dataType + '"';
	  }
	}


	function checkDataTypes(dataTypes, data, strictNumbers) {
	  switch (dataTypes.length) {
	    case 1: return checkDataType(dataTypes[0], data, strictNumbers, true);
	    default:
	      var code = '';
	      var types = toHash(dataTypes);
	      if (types.array && types.object) {
	        code = types.null ? '(': '(!' + data + ' || ';
	        code += 'typeof ' + data + ' !== "object")';
	        delete types.null;
	        delete types.array;
	        delete types.object;
	      }
	      if (types.number) delete types.integer;
	      for (var t in types)
	        code += (code ? ' && ' : '' ) + checkDataType(t, data, strictNumbers, true);

	      return code;
	  }
	}


	var COERCE_TO_TYPES = toHash([ 'string', 'number', 'integer', 'boolean', 'null' ]);
	function coerceToTypes(optionCoerceTypes, dataTypes) {
	  if (Array.isArray(dataTypes)) {
	    var types = [];
	    for (var i=0; i<dataTypes.length; i++) {
	      var t = dataTypes[i];
	      if (COERCE_TO_TYPES[t]) types[types.length] = t;
	      else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;
	    }
	    if (types.length) return types;
	  } else if (COERCE_TO_TYPES[dataTypes]) {
	    return [dataTypes];
	  } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {
	    return ['array'];
	  }
	}


	function toHash(arr) {
	  var hash = {};
	  for (var i=0; i<arr.length; i++) hash[arr[i]] = true;
	  return hash;
	}


	var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
	var SINGLE_QUOTE = /'|\\/g;
	function getProperty(key) {
	  return typeof key == 'number'
	          ? '[' + key + ']'
	          : IDENTIFIER.test(key)
	            ? '.' + key
	            : "['" + escapeQuotes(key) + "']";
	}


	function escapeQuotes(str) {
	  return str.replace(SINGLE_QUOTE, '\\$&')
	            .replace(/\n/g, '\\n')
	            .replace(/\r/g, '\\r')
	            .replace(/\f/g, '\\f')
	            .replace(/\t/g, '\\t');
	}


	function varOccurences(str, dataVar) {
	  dataVar += '[^0-9]';
	  var matches = str.match(new RegExp(dataVar, 'g'));
	  return matches ? matches.length : 0;
	}


	function varReplace(str, dataVar, expr) {
	  dataVar += '([^0-9])';
	  expr = expr.replace(/\$/g, '$$$$');
	  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
	}


	function schemaHasRules(schema, rules) {
	  if (typeof schema == 'boolean') return !schema;
	  for (var key in schema) if (rules[key]) return true;
	}


	function schemaHasRulesExcept(schema, rules, exceptKeyword) {
	  if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';
	  for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
	}


	function schemaUnknownRules(schema, rules) {
	  if (typeof schema == 'boolean') return;
	  for (var key in schema) if (!rules[key]) return key;
	}


	function toQuotedString(str) {
	  return '\'' + escapeQuotes(str) + '\'';
	}


	function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
	  var path = jsonPointers // false by default
	              ? '\'/\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \'~0\').replace(/\\//g, \'~1\')')
	              : (isNumber ? '\'[\' + ' + expr + ' + \']\'' : '\'[\\\'\' + ' + expr + ' + \'\\\']\'');
	  return joinPaths(currentPath, path);
	}


	function getPath(currentPath, prop, jsonPointers) {
	  var path = jsonPointers // false by default
	              ? toQuotedString('/' + escapeJsonPointer(prop))
	              : toQuotedString(getProperty(prop));
	  return joinPaths(currentPath, path);
	}


	var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
	var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
	function getData($data, lvl, paths) {
	  var up, jsonPointer, data, matches;
	  if ($data === '') return 'rootData';
	  if ($data[0] == '/') {
	    if (!JSON_POINTER.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);
	    jsonPointer = $data;
	    data = 'rootData';
	  } else {
	    matches = $data.match(RELATIVE_JSON_POINTER);
	    if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);
	    up = +matches[1];
	    jsonPointer = matches[2];
	    if (jsonPointer == '#') {
	      if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
	      return paths[lvl - up];
	    }

	    if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
	    data = 'data' + ((lvl - up) || '');
	    if (!jsonPointer) return data;
	  }

	  var expr = data;
	  var segments = jsonPointer.split('/');
	  for (var i=0; i<segments.length; i++) {
	    var segment = segments[i];
	    if (segment) {
	      data += getProperty(unescapeJsonPointer(segment));
	      expr += ' && ' + data;
	    }
	  }
	  return expr;
	}


	function joinPaths (a, b) {
	  if (a == '""') return b;
	  return (a + ' + ' + b).replace(/([^\\])' \+ '/g, '$1');
	}


	function unescapeFragment(str) {
	  return unescapeJsonPointer(decodeURIComponent(str));
	}


	function escapeFragment(str) {
	  return encodeURIComponent(escapeJsonPointer(str));
	}


	function escapeJsonPointer(str) {
	  return str.replace(/~/g, '~0').replace(/\//g, '~1');
	}


	function unescapeJsonPointer(str) {
	  return str.replace(/~1/g, '/').replace(/~0/g, '~');
	}
	return util$1;
}

var schema_obj;
var hasRequiredSchema_obj;

function requireSchema_obj () {
	if (hasRequiredSchema_obj) return schema_obj;
	hasRequiredSchema_obj = 1;

	var util = requireUtil$1();

	schema_obj = SchemaObject;

	function SchemaObject(obj) {
	  util.copy(obj, this);
	}
	return schema_obj;
}

var jsonSchemaTraverse = {exports: {}};

var hasRequiredJsonSchemaTraverse;

function requireJsonSchemaTraverse () {
	if (hasRequiredJsonSchemaTraverse) return jsonSchemaTraverse.exports;
	hasRequiredJsonSchemaTraverse = 1;

	var traverse = jsonSchemaTraverse.exports = function (schema, opts, cb) {
	  // Legacy support for v0.3.1 and earlier.
	  if (typeof opts == 'function') {
	    cb = opts;
	    opts = {};
	  }

	  cb = opts.cb || cb;
	  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
	  var post = cb.post || function() {};

	  _traverse(opts, pre, post, schema, '', schema);
	};


	traverse.keywords = {
	  additionalItems: true,
	  items: true,
	  contains: true,
	  additionalProperties: true,
	  propertyNames: true,
	  not: true
	};

	traverse.arrayKeywords = {
	  items: true,
	  allOf: true,
	  anyOf: true,
	  oneOf: true
	};

	traverse.propsKeywords = {
	  definitions: true,
	  properties: true,
	  patternProperties: true,
	  dependencies: true
	};

	traverse.skipKeywords = {
	  default: true,
	  enum: true,
	  const: true,
	  required: true,
	  maximum: true,
	  minimum: true,
	  exclusiveMaximum: true,
	  exclusiveMinimum: true,
	  multipleOf: true,
	  maxLength: true,
	  minLength: true,
	  pattern: true,
	  format: true,
	  maxItems: true,
	  minItems: true,
	  uniqueItems: true,
	  maxProperties: true,
	  minProperties: true
	};


	function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
	  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
	    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
	    for (var key in schema) {
	      var sch = schema[key];
	      if (Array.isArray(sch)) {
	        if (key in traverse.arrayKeywords) {
	          for (var i=0; i<sch.length; i++)
	            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
	        }
	      } else if (key in traverse.propsKeywords) {
	        if (sch && typeof sch == 'object') {
	          for (var prop in sch)
	            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
	        }
	      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
	        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
	      }
	    }
	    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
	  }
	}


	function escapeJsonPtr(str) {
	  return str.replace(/~/g, '~0').replace(/\//g, '~1');
	}
	return jsonSchemaTraverse.exports;
}

var resolve_1;
var hasRequiredResolve;

function requireResolve () {
	if (hasRequiredResolve) return resolve_1;
	hasRequiredResolve = 1;

	var URI = requireUri_all()
	  , equal = requireFastDeepEqual()
	  , util = requireUtil$1()
	  , SchemaObject = requireSchema_obj()
	  , traverse = requireJsonSchemaTraverse();

	resolve_1 = resolve;

	resolve.normalizeId = normalizeId;
	resolve.fullPath = getFullPath;
	resolve.url = resolveUrl;
	resolve.ids = resolveIds;
	resolve.inlineRef = inlineRef;
	resolve.schema = resolveSchema;

	/**
	 * [resolve and compile the references ($ref)]
	 * @this   Ajv
	 * @param  {Function} compile reference to schema compilation funciton (localCompile)
	 * @param  {Object} root object with information about the root schema for the current schema
	 * @param  {String} ref reference to resolve
	 * @return {Object|Function} schema object (if the schema can be inlined) or validation function
	 */
	function resolve(compile, root, ref) {
	  /* jshint validthis: true */
	  var refVal = this._refs[ref];
	  if (typeof refVal == 'string') {
	    if (this._refs[refVal]) refVal = this._refs[refVal];
	    else return resolve.call(this, compile, root, refVal);
	  }

	  refVal = refVal || this._schemas[ref];
	  if (refVal instanceof SchemaObject) {
	    return inlineRef(refVal.schema, this._opts.inlineRefs)
	            ? refVal.schema
	            : refVal.validate || this._compile(refVal);
	  }

	  var res = resolveSchema.call(this, root, ref);
	  var schema, v, baseId;
	  if (res) {
	    schema = res.schema;
	    root = res.root;
	    baseId = res.baseId;
	  }

	  if (schema instanceof SchemaObject) {
	    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
	  } else if (schema !== undefined) {
	    v = inlineRef(schema, this._opts.inlineRefs)
	        ? schema
	        : compile.call(this, schema, root, undefined, baseId);
	  }

	  return v;
	}


	/**
	 * Resolve schema, its root and baseId
	 * @this Ajv
	 * @param  {Object} root root object with properties schema, refVal, refs
	 * @param  {String} ref  reference to resolve
	 * @return {Object} object with properties schema, root, baseId
	 */
	function resolveSchema(root, ref) {
	  /* jshint validthis: true */
	  var p = URI.parse(ref)
	    , refPath = _getFullPath(p)
	    , baseId = getFullPath(this._getId(root.schema));
	  if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
	    var id = normalizeId(refPath);
	    var refVal = this._refs[id];
	    if (typeof refVal == 'string') {
	      return resolveRecursive.call(this, root, refVal, p);
	    } else if (refVal instanceof SchemaObject) {
	      if (!refVal.validate) this._compile(refVal);
	      root = refVal;
	    } else {
	      refVal = this._schemas[id];
	      if (refVal instanceof SchemaObject) {
	        if (!refVal.validate) this._compile(refVal);
	        if (id == normalizeId(ref))
	          return { schema: refVal, root: root, baseId: baseId };
	        root = refVal;
	      } else {
	        return;
	      }
	    }
	    if (!root.schema) return;
	    baseId = getFullPath(this._getId(root.schema));
	  }
	  return getJsonPointer.call(this, p, baseId, root.schema, root);
	}


	/* @this Ajv */
	function resolveRecursive(root, ref, parsedRef) {
	  /* jshint validthis: true */
	  var res = resolveSchema.call(this, root, ref);
	  if (res) {
	    var schema = res.schema;
	    var baseId = res.baseId;
	    root = res.root;
	    var id = this._getId(schema);
	    if (id) baseId = resolveUrl(baseId, id);
	    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
	  }
	}


	var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
	/* @this Ajv */
	function getJsonPointer(parsedRef, baseId, schema, root) {
	  /* jshint validthis: true */
	  parsedRef.fragment = parsedRef.fragment || '';
	  if (parsedRef.fragment.slice(0,1) != '/') return;
	  var parts = parsedRef.fragment.split('/');

	  for (var i = 1; i < parts.length; i++) {
	    var part = parts[i];
	    if (part) {
	      part = util.unescapeFragment(part);
	      schema = schema[part];
	      if (schema === undefined) break;
	      var id;
	      if (!PREVENT_SCOPE_CHANGE[part]) {
	        id = this._getId(schema);
	        if (id) baseId = resolveUrl(baseId, id);
	        if (schema.$ref) {
	          var $ref = resolveUrl(baseId, schema.$ref);
	          var res = resolveSchema.call(this, root, $ref);
	          if (res) {
	            schema = res.schema;
	            root = res.root;
	            baseId = res.baseId;
	          }
	        }
	      }
	    }
	  }
	  if (schema !== undefined && schema !== root.schema)
	    return { schema: schema, root: root, baseId: baseId };
	}


	var SIMPLE_INLINED = util.toHash([
	  'type', 'format', 'pattern',
	  'maxLength', 'minLength',
	  'maxProperties', 'minProperties',
	  'maxItems', 'minItems',
	  'maximum', 'minimum',
	  'uniqueItems', 'multipleOf',
	  'required', 'enum'
	]);
	function inlineRef(schema, limit) {
	  if (limit === false) return false;
	  if (limit === undefined || limit === true) return checkNoRef(schema);
	  else if (limit) return countKeys(schema) <= limit;
	}


	function checkNoRef(schema) {
	  var item;
	  if (Array.isArray(schema)) {
	    for (var i=0; i<schema.length; i++) {
	      item = schema[i];
	      if (typeof item == 'object' && !checkNoRef(item)) return false;
	    }
	  } else {
	    for (var key in schema) {
	      if (key == '$ref') return false;
	      item = schema[key];
	      if (typeof item == 'object' && !checkNoRef(item)) return false;
	    }
	  }
	  return true;
	}


	function countKeys(schema) {
	  var count = 0, item;
	  if (Array.isArray(schema)) {
	    for (var i=0; i<schema.length; i++) {
	      item = schema[i];
	      if (typeof item == 'object') count += countKeys(item);
	      if (count == Infinity) return Infinity;
	    }
	  } else {
	    for (var key in schema) {
	      if (key == '$ref') return Infinity;
	      if (SIMPLE_INLINED[key]) {
	        count++;
	      } else {
	        item = schema[key];
	        if (typeof item == 'object') count += countKeys(item) + 1;
	        if (count == Infinity) return Infinity;
	      }
	    }
	  }
	  return count;
	}


	function getFullPath(id, normalize) {
	  if (normalize !== false) id = normalizeId(id);
	  var p = URI.parse(id);
	  return _getFullPath(p);
	}


	function _getFullPath(p) {
	  return URI.serialize(p).split('#')[0] + '#';
	}


	var TRAILING_SLASH_HASH = /#\/?$/;
	function normalizeId(id) {
	  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
	}


	function resolveUrl(baseId, id) {
	  id = normalizeId(id);
	  return URI.resolve(baseId, id);
	}


	/* @this Ajv */
	function resolveIds(schema) {
	  var schemaId = normalizeId(this._getId(schema));
	  var baseIds = {'': schemaId};
	  var fullPaths = {'': getFullPath(schemaId, false)};
	  var localRefs = {};
	  var self = this;

	  traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
	    if (jsonPtr === '') return;
	    var id = self._getId(sch);
	    var baseId = baseIds[parentJsonPtr];
	    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;
	    if (keyIndex !== undefined)
	      fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));

	    if (typeof id == 'string') {
	      id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);

	      var refVal = self._refs[id];
	      if (typeof refVal == 'string') refVal = self._refs[refVal];
	      if (refVal && refVal.schema) {
	        if (!equal(sch, refVal.schema))
	          throw new Error('id "' + id + '" resolves to more than one schema');
	      } else if (id != normalizeId(fullPath)) {
	        if (id[0] == '#') {
	          if (localRefs[id] && !equal(sch, localRefs[id]))
	            throw new Error('id "' + id + '" resolves to more than one schema');
	          localRefs[id] = sch;
	        } else {
	          self._refs[id] = fullPath;
	        }
	      }
	    }
	    baseIds[jsonPtr] = baseId;
	    fullPaths[jsonPtr] = fullPath;
	  });

	  return localRefs;
	}
	return resolve_1;
}

var error_classes;
var hasRequiredError_classes;

function requireError_classes () {
	if (hasRequiredError_classes) return error_classes;
	hasRequiredError_classes = 1;

	var resolve = requireResolve();

	error_classes = {
	  Validation: errorSubclass(ValidationError),
	  MissingRef: errorSubclass(MissingRefError)
	};


	function ValidationError(errors) {
	  this.message = 'validation failed';
	  this.errors = errors;
	  this.ajv = this.validation = true;
	}


	MissingRefError.message = function (baseId, ref) {
	  return 'can\'t resolve reference ' + ref + ' from id ' + baseId;
	};


	function MissingRefError(baseId, ref, message) {
	  this.message = message || MissingRefError.message(baseId, ref);
	  this.missingRef = resolve.url(baseId, ref);
	  this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
	}


	function errorSubclass(Subclass) {
	  Subclass.prototype = Object.create(Error.prototype);
	  Subclass.prototype.constructor = Subclass;
	  return Subclass;
	}
	return error_classes;
}

var fastJsonStableStringify;
var hasRequiredFastJsonStableStringify;

function requireFastJsonStableStringify () {
	if (hasRequiredFastJsonStableStringify) return fastJsonStableStringify;
	hasRequiredFastJsonStableStringify = 1;

	fastJsonStableStringify = function (data, opts) {
	    if (!opts) opts = {};
	    if (typeof opts === 'function') opts = { cmp: opts };
	    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;

	    var cmp = opts.cmp && (function (f) {
	        return function (node) {
	            return function (a, b) {
	                var aobj = { key: a, value: node[a] };
	                var bobj = { key: b, value: node[b] };
	                return f(aobj, bobj);
	            };
	        };
	    })(opts.cmp);

	    var seen = [];
	    return (function stringify (node) {
	        if (node && node.toJSON && typeof node.toJSON === 'function') {
	            node = node.toJSON();
	        }

	        if (node === undefined) return;
	        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
	        if (typeof node !== 'object') return JSON.stringify(node);

	        var i, out;
	        if (Array.isArray(node)) {
	            out = '[';
	            for (i = 0; i < node.length; i++) {
	                if (i) out += ',';
	                out += stringify(node[i]) || 'null';
	            }
	            return out + ']';
	        }

	        if (node === null) return 'null';

	        if (seen.indexOf(node) !== -1) {
	            if (cycles) return JSON.stringify('__cycle__');
	            throw new TypeError('Converting circular structure to JSON');
	        }

	        var seenIndex = seen.push(node) - 1;
	        var keys = Object.keys(node).sort(cmp && cmp(node));
	        out = '';
	        for (i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            var value = stringify(node[key]);

	            if (!value) continue;
	            if (out) out += ',';
	            out += JSON.stringify(key) + ':' + value;
	        }
	        seen.splice(seenIndex, 1);
	        return '{' + out + '}';
	    })(data);
	};
	return fastJsonStableStringify;
}

var validate;
var hasRequiredValidate;

function requireValidate () {
	if (hasRequiredValidate) return validate;
	hasRequiredValidate = 1;
	validate = function generate_validate(it, $keyword, $ruleType) {
	  var out = '';
	  var $async = it.schema.$async === true,
	    $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),
	    $id = it.self._getId(it.schema);
	  if (it.opts.strictKeywords) {
	    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
	    if ($unknownKwd) {
	      var $keywordsMsg = 'unknown keyword: ' + $unknownKwd;
	      if (it.opts.strictKeywords === 'log') it.logger.warn($keywordsMsg);
	      else throw new Error($keywordsMsg);
	    }
	  }
	  if (it.isTop) {
	    out += ' var validate = ';
	    if ($async) {
	      it.async = true;
	      out += 'async ';
	    }
	    out += 'function(data, dataPath, parentData, parentDataProperty, rootData) { \'use strict\'; ';
	    if ($id && (it.opts.sourceCode || it.opts.processCode)) {
	      out += ' ' + ('/\*# sourceURL=' + $id + ' */') + ' ';
	    }
	  }
	  if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {
	    var $keyword = 'false schema';
	    var $lvl = it.level;
	    var $dataLvl = it.dataLevel;
	    var $schema = it.schema[$keyword];
	    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	    var $breakOnError = !it.opts.allErrors;
	    var $errorKeyword;
	    var $data = 'data' + ($dataLvl || '');
	    var $valid = 'valid' + $lvl;
	    if (it.schema === false) {
	      if (it.isTop) {
	        $breakOnError = true;
	      } else {
	        out += ' var ' + ($valid) + ' = false; ';
	      }
	      var $$outStack = $$outStack || [];
	      $$outStack.push(out);
	      out = ''; /* istanbul ignore else */
	      if (it.createErrors !== false) {
	        out += ' { keyword: \'' + ($errorKeyword || 'false schema') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
	        if (it.opts.messages !== false) {
	          out += ' , message: \'boolean schema is false\' ';
	        }
	        if (it.opts.verbose) {
	          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	        }
	        out += ' } ';
	      } else {
	        out += ' {} ';
	      }
	      var __err = out;
	      out = $$outStack.pop();
	      if (!it.compositeRule && $breakOnError) {
	        /* istanbul ignore if */
	        if (it.async) {
	          out += ' throw new ValidationError([' + (__err) + ']); ';
	        } else {
	          out += ' validate.errors = [' + (__err) + ']; return false; ';
	        }
	      } else {
	        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	      }
	    } else {
	      if (it.isTop) {
	        if ($async) {
	          out += ' return data; ';
	        } else {
	          out += ' validate.errors = null; return true; ';
	        }
	      } else {
	        out += ' var ' + ($valid) + ' = true; ';
	      }
	    }
	    if (it.isTop) {
	      out += ' }; return validate; ';
	    }
	    return out;
	  }
	  if (it.isTop) {
	    var $top = it.isTop,
	      $lvl = it.level = 0,
	      $dataLvl = it.dataLevel = 0,
	      $data = 'data';
	    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
	    it.baseId = it.baseId || it.rootId;
	    delete it.isTop;
	    it.dataPathArr = [""];
	    if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {
	      var $defaultMsg = 'default is ignored in the schema root';
	      if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
	      else throw new Error($defaultMsg);
	    }
	    out += ' var vErrors = null; ';
	    out += ' var errors = 0;     ';
	    out += ' if (rootData === undefined) rootData = data; ';
	  } else {
	    var $lvl = it.level,
	      $dataLvl = it.dataLevel,
	      $data = 'data' + ($dataLvl || '');
	    if ($id) it.baseId = it.resolve.url(it.baseId, $id);
	    if ($async && !it.async) throw new Error('async schema in sync schema');
	    out += ' var errs_' + ($lvl) + ' = errors;';
	  }
	  var $valid = 'valid' + $lvl,
	    $breakOnError = !it.opts.allErrors,
	    $closingBraces1 = '',
	    $closingBraces2 = '';
	  var $errorKeyword;
	  var $typeSchema = it.schema.type,
	    $typeIsArray = Array.isArray($typeSchema);
	  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
	    if ($typeIsArray) {
	      if ($typeSchema.indexOf('null') == -1) $typeSchema = $typeSchema.concat('null');
	    } else if ($typeSchema != 'null') {
	      $typeSchema = [$typeSchema, 'null'];
	      $typeIsArray = true;
	    }
	  }
	  if ($typeIsArray && $typeSchema.length == 1) {
	    $typeSchema = $typeSchema[0];
	    $typeIsArray = false;
	  }
	  if (it.schema.$ref && $refKeywords) {
	    if (it.opts.extendRefs == 'fail') {
	      throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
	    } else if (it.opts.extendRefs !== true) {
	      $refKeywords = false;
	      it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
	    }
	  }
	  if (it.schema.$comment && it.opts.$comment) {
	    out += ' ' + (it.RULES.all.$comment.code(it, '$comment'));
	  }
	  if ($typeSchema) {
	    if (it.opts.coerceTypes) {
	      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
	    }
	    var $rulesGroup = it.RULES.types[$typeSchema];
	    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {
	      var $schemaPath = it.schemaPath + '.type',
	        $errSchemaPath = it.errSchemaPath + '/type';
	      var $schemaPath = it.schemaPath + '.type',
	        $errSchemaPath = it.errSchemaPath + '/type',
	        $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
	      out += ' if (' + (it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true)) + ') { ';
	      if ($coerceToTypes) {
	        var $dataType = 'dataType' + $lvl,
	          $coerced = 'coerced' + $lvl;
	        out += ' var ' + ($dataType) + ' = typeof ' + ($data) + '; var ' + ($coerced) + ' = undefined; ';
	        if (it.opts.coerceTypes == 'array') {
	          out += ' if (' + ($dataType) + ' == \'object\' && Array.isArray(' + ($data) + ') && ' + ($data) + '.length == 1) { ' + ($data) + ' = ' + ($data) + '[0]; ' + ($dataType) + ' = typeof ' + ($data) + '; if (' + (it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers)) + ') ' + ($coerced) + ' = ' + ($data) + '; } ';
	        }
	        out += ' if (' + ($coerced) + ' !== undefined) ; ';
	        var arr1 = $coerceToTypes;
	        if (arr1) {
	          var $type, $i = -1,
	            l1 = arr1.length - 1;
	          while ($i < l1) {
	            $type = arr1[$i += 1];
	            if ($type == 'string') {
	              out += ' else if (' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\') ' + ($coerced) + ' = \'\' + ' + ($data) + '; else if (' + ($data) + ' === null) ' + ($coerced) + ' = \'\'; ';
	            } else if ($type == 'number' || $type == 'integer') {
	              out += ' else if (' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' === null || (' + ($dataType) + ' == \'string\' && ' + ($data) + ' && ' + ($data) + ' == +' + ($data) + ' ';
	              if ($type == 'integer') {
	                out += ' && !(' + ($data) + ' % 1)';
	              }
	              out += ')) ' + ($coerced) + ' = +' + ($data) + '; ';
	            } else if ($type == 'boolean') {
	              out += ' else if (' + ($data) + ' === \'false\' || ' + ($data) + ' === 0 || ' + ($data) + ' === null) ' + ($coerced) + ' = false; else if (' + ($data) + ' === \'true\' || ' + ($data) + ' === 1) ' + ($coerced) + ' = true; ';
	            } else if ($type == 'null') {
	              out += ' else if (' + ($data) + ' === \'\' || ' + ($data) + ' === 0 || ' + ($data) + ' === false) ' + ($coerced) + ' = null; ';
	            } else if (it.opts.coerceTypes == 'array' && $type == 'array') {
	              out += ' else if (' + ($dataType) + ' == \'string\' || ' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' == null) ' + ($coerced) + ' = [' + ($data) + ']; ';
	            }
	          }
	        }
	        out += ' else {   ';
	        var $$outStack = $$outStack || [];
	        $$outStack.push(out);
	        out = ''; /* istanbul ignore else */
	        if (it.createErrors !== false) {
	          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
	          if ($typeIsArray) {
	            out += '' + ($typeSchema.join(","));
	          } else {
	            out += '' + ($typeSchema);
	          }
	          out += '\' } ';
	          if (it.opts.messages !== false) {
	            out += ' , message: \'should be ';
	            if ($typeIsArray) {
	              out += '' + ($typeSchema.join(","));
	            } else {
	              out += '' + ($typeSchema);
	            }
	            out += '\' ';
	          }
	          if (it.opts.verbose) {
	            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	          }
	          out += ' } ';
	        } else {
	          out += ' {} ';
	        }
	        var __err = out;
	        out = $$outStack.pop();
	        if (!it.compositeRule && $breakOnError) {
	          /* istanbul ignore if */
	          if (it.async) {
	            out += ' throw new ValidationError([' + (__err) + ']); ';
	          } else {
	            out += ' validate.errors = [' + (__err) + ']; return false; ';
	          }
	        } else {
	          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	        }
	        out += ' } if (' + ($coerced) + ' !== undefined) {  ';
	        var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
	          $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
	        out += ' ' + ($data) + ' = ' + ($coerced) + '; ';
	        if (!$dataLvl) {
	          out += 'if (' + ($parentData) + ' !== undefined)';
	        }
	        out += ' ' + ($parentData) + '[' + ($parentDataProperty) + '] = ' + ($coerced) + '; } ';
	      } else {
	        var $$outStack = $$outStack || [];
	        $$outStack.push(out);
	        out = ''; /* istanbul ignore else */
	        if (it.createErrors !== false) {
	          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
	          if ($typeIsArray) {
	            out += '' + ($typeSchema.join(","));
	          } else {
	            out += '' + ($typeSchema);
	          }
	          out += '\' } ';
	          if (it.opts.messages !== false) {
	            out += ' , message: \'should be ';
	            if ($typeIsArray) {
	              out += '' + ($typeSchema.join(","));
	            } else {
	              out += '' + ($typeSchema);
	            }
	            out += '\' ';
	          }
	          if (it.opts.verbose) {
	            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	          }
	          out += ' } ';
	        } else {
	          out += ' {} ';
	        }
	        var __err = out;
	        out = $$outStack.pop();
	        if (!it.compositeRule && $breakOnError) {
	          /* istanbul ignore if */
	          if (it.async) {
	            out += ' throw new ValidationError([' + (__err) + ']); ';
	          } else {
	            out += ' validate.errors = [' + (__err) + ']; return false; ';
	          }
	        } else {
	          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	        }
	      }
	      out += ' } ';
	    }
	  }
	  if (it.schema.$ref && !$refKeywords) {
	    out += ' ' + (it.RULES.all.$ref.code(it, '$ref')) + ' ';
	    if ($breakOnError) {
	      out += ' } if (errors === ';
	      if ($top) {
	        out += '0';
	      } else {
	        out += 'errs_' + ($lvl);
	      }
	      out += ') { ';
	      $closingBraces2 += '}';
	    }
	  } else {
	    var arr2 = it.RULES;
	    if (arr2) {
	      var $rulesGroup, i2 = -1,
	        l2 = arr2.length - 1;
	      while (i2 < l2) {
	        $rulesGroup = arr2[i2 += 1];
	        if ($shouldUseGroup($rulesGroup)) {
	          if ($rulesGroup.type) {
	            out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers)) + ') { ';
	          }
	          if (it.opts.useDefaults) {
	            if ($rulesGroup.type == 'object' && it.schema.properties) {
	              var $schema = it.schema.properties,
	                $schemaKeys = Object.keys($schema);
	              var arr3 = $schemaKeys;
	              if (arr3) {
	                var $propertyKey, i3 = -1,
	                  l3 = arr3.length - 1;
	                while (i3 < l3) {
	                  $propertyKey = arr3[i3 += 1];
	                  var $sch = $schema[$propertyKey];
	                  if ($sch.default !== undefined) {
	                    var $passData = $data + it.util.getProperty($propertyKey);
	                    if (it.compositeRule) {
	                      if (it.opts.strictDefaults) {
	                        var $defaultMsg = 'default is ignored for: ' + $passData;
	                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
	                        else throw new Error($defaultMsg);
	                      }
	                    } else {
	                      out += ' if (' + ($passData) + ' === undefined ';
	                      if (it.opts.useDefaults == 'empty') {
	                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
	                      }
	                      out += ' ) ' + ($passData) + ' = ';
	                      if (it.opts.useDefaults == 'shared') {
	                        out += ' ' + (it.useDefault($sch.default)) + ' ';
	                      } else {
	                        out += ' ' + (JSON.stringify($sch.default)) + ' ';
	                      }
	                      out += '; ';
	                    }
	                  }
	                }
	              }
	            } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {
	              var arr4 = it.schema.items;
	              if (arr4) {
	                var $sch, $i = -1,
	                  l4 = arr4.length - 1;
	                while ($i < l4) {
	                  $sch = arr4[$i += 1];
	                  if ($sch.default !== undefined) {
	                    var $passData = $data + '[' + $i + ']';
	                    if (it.compositeRule) {
	                      if (it.opts.strictDefaults) {
	                        var $defaultMsg = 'default is ignored for: ' + $passData;
	                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
	                        else throw new Error($defaultMsg);
	                      }
	                    } else {
	                      out += ' if (' + ($passData) + ' === undefined ';
	                      if (it.opts.useDefaults == 'empty') {
	                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
	                      }
	                      out += ' ) ' + ($passData) + ' = ';
	                      if (it.opts.useDefaults == 'shared') {
	                        out += ' ' + (it.useDefault($sch.default)) + ' ';
	                      } else {
	                        out += ' ' + (JSON.stringify($sch.default)) + ' ';
	                      }
	                      out += '; ';
	                    }
	                  }
	                }
	              }
	            }
	          }
	          var arr5 = $rulesGroup.rules;
	          if (arr5) {
	            var $rule, i5 = -1,
	              l5 = arr5.length - 1;
	            while (i5 < l5) {
	              $rule = arr5[i5 += 1];
	              if ($shouldUseRule($rule)) {
	                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
	                if ($code) {
	                  out += ' ' + ($code) + ' ';
	                  if ($breakOnError) {
	                    $closingBraces1 += '}';
	                  }
	                }
	              }
	            }
	          }
	          if ($breakOnError) {
	            out += ' ' + ($closingBraces1) + ' ';
	            $closingBraces1 = '';
	          }
	          if ($rulesGroup.type) {
	            out += ' } ';
	            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
	              out += ' else { ';
	              var $schemaPath = it.schemaPath + '.type',
	                $errSchemaPath = it.errSchemaPath + '/type';
	              var $$outStack = $$outStack || [];
	              $$outStack.push(out);
	              out = ''; /* istanbul ignore else */
	              if (it.createErrors !== false) {
	                out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
	                if ($typeIsArray) {
	                  out += '' + ($typeSchema.join(","));
	                } else {
	                  out += '' + ($typeSchema);
	                }
	                out += '\' } ';
	                if (it.opts.messages !== false) {
	                  out += ' , message: \'should be ';
	                  if ($typeIsArray) {
	                    out += '' + ($typeSchema.join(","));
	                  } else {
	                    out += '' + ($typeSchema);
	                  }
	                  out += '\' ';
	                }
	                if (it.opts.verbose) {
	                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	                }
	                out += ' } ';
	              } else {
	                out += ' {} ';
	              }
	              var __err = out;
	              out = $$outStack.pop();
	              if (!it.compositeRule && $breakOnError) {
	                /* istanbul ignore if */
	                if (it.async) {
	                  out += ' throw new ValidationError([' + (__err) + ']); ';
	                } else {
	                  out += ' validate.errors = [' + (__err) + ']; return false; ';
	                }
	              } else {
	                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	              }
	              out += ' } ';
	            }
	          }
	          if ($breakOnError) {
	            out += ' if (errors === ';
	            if ($top) {
	              out += '0';
	            } else {
	              out += 'errs_' + ($lvl);
	            }
	            out += ') { ';
	            $closingBraces2 += '}';
	          }
	        }
	      }
	    }
	  }
	  if ($breakOnError) {
	    out += ' ' + ($closingBraces2) + ' ';
	  }
	  if ($top) {
	    if ($async) {
	      out += ' if (errors === 0) return data;           ';
	      out += ' else throw new ValidationError(vErrors); ';
	    } else {
	      out += ' validate.errors = vErrors; ';
	      out += ' return errors === 0;       ';
	    }
	    out += ' }; return validate;';
	  } else {
	    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';
	  }

	  function $shouldUseGroup($rulesGroup) {
	    var rules = $rulesGroup.rules;
	    for (var i = 0; i < rules.length; i++)
	      if ($shouldUseRule(rules[i])) return true;
	  }

	  function $shouldUseRule($rule) {
	    return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImplementsSomeKeyword($rule));
	  }

	  function $ruleImplementsSomeKeyword($rule) {
	    var impl = $rule.implements;
	    for (var i = 0; i < impl.length; i++)
	      if (it.schema[impl[i]] !== undefined) return true;
	  }
	  return out;
	};
	return validate;
}

var compile_1;
var hasRequiredCompile;

function requireCompile () {
	if (hasRequiredCompile) return compile_1;
	hasRequiredCompile = 1;

	var resolve = requireResolve()
	  , util = requireUtil$1()
	  , errorClasses = requireError_classes()
	  , stableStringify = requireFastJsonStableStringify();

	var validateGenerator = requireValidate();

	/**
	 * Functions below are used inside compiled validations function
	 */

	var ucs2length = util.ucs2length;
	var equal = requireFastDeepEqual();

	// this error is thrown by async schemas to return validation errors via exception
	var ValidationError = errorClasses.Validation;

	compile_1 = compile;


	/**
	 * Compiles schema to validation function
	 * @this   Ajv
	 * @param  {Object} schema schema object
	 * @param  {Object} root object with information about the root schema for this schema
	 * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
	 * @param  {String} baseId base ID for IDs in the schema
	 * @return {Function} validation function
	 */
	function compile(schema, root, localRefs, baseId) {
	  /* jshint validthis: true, evil: true */
	  /* eslint no-shadow: 0 */
	  var self = this
	    , opts = this._opts
	    , refVal = [ undefined ]
	    , refs = {}
	    , patterns = []
	    , patternsHash = {}
	    , defaults = []
	    , defaultsHash = {}
	    , customRules = [];

	  root = root || { schema: schema, refVal: refVal, refs: refs };

	  var c = checkCompiling.call(this, schema, root, baseId);
	  var compilation = this._compilations[c.index];
	  if (c.compiling) return (compilation.callValidate = callValidate);

	  var formats = this._formats;
	  var RULES = this.RULES;

	  try {
	    var v = localCompile(schema, root, localRefs, baseId);
	    compilation.validate = v;
	    var cv = compilation.callValidate;
	    if (cv) {
	      cv.schema = v.schema;
	      cv.errors = null;
	      cv.refs = v.refs;
	      cv.refVal = v.refVal;
	      cv.root = v.root;
	      cv.$async = v.$async;
	      if (opts.sourceCode) cv.source = v.source;
	    }
	    return v;
	  } finally {
	    endCompiling.call(this, schema, root, baseId);
	  }

	  /* @this   {*} - custom context, see passContext option */
	  function callValidate() {
	    /* jshint validthis: true */
	    var validate = compilation.validate;
	    var result = validate.apply(this, arguments);
	    callValidate.errors = validate.errors;
	    return result;
	  }

	  function localCompile(_schema, _root, localRefs, baseId) {
	    var isRoot = !_root || (_root && _root.schema == _schema);
	    if (_root.schema != root.schema)
	      return compile.call(self, _schema, _root, localRefs, baseId);

	    var $async = _schema.$async === true;

	    var sourceCode = validateGenerator({
	      isTop: true,
	      schema: _schema,
	      isRoot: isRoot,
	      baseId: baseId,
	      root: _root,
	      schemaPath: '',
	      errSchemaPath: '#',
	      errorPath: '""',
	      MissingRefError: errorClasses.MissingRef,
	      RULES: RULES,
	      validate: validateGenerator,
	      util: util,
	      resolve: resolve,
	      resolveRef: resolveRef,
	      usePattern: usePattern,
	      useDefault: useDefault,
	      useCustomRule: useCustomRule,
	      opts: opts,
	      formats: formats,
	      logger: self.logger,
	      self: self
	    });

	    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
	                   + vars(defaults, defaultCode) + vars(customRules, customRuleCode)
	                   + sourceCode;

	    if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);
	    // console.log('\n\n\n *** \n', JSON.stringify(sourceCode));
	    var validate;
	    try {
	      var makeValidate = new Function(
	        'self',
	        'RULES',
	        'formats',
	        'root',
	        'refVal',
	        'defaults',
	        'customRules',
	        'equal',
	        'ucs2length',
	        'ValidationError',
	        sourceCode
	      );

	      validate = makeValidate(
	        self,
	        RULES,
	        formats,
	        root,
	        refVal,
	        defaults,
	        customRules,
	        equal,
	        ucs2length,
	        ValidationError
	      );

	      refVal[0] = validate;
	    } catch(e) {
	      self.logger.error('Error compiling schema, function code:', sourceCode);
	      throw e;
	    }

	    validate.schema = _schema;
	    validate.errors = null;
	    validate.refs = refs;
	    validate.refVal = refVal;
	    validate.root = isRoot ? validate : _root;
	    if ($async) validate.$async = true;
	    if (opts.sourceCode === true) {
	      validate.source = {
	        code: sourceCode,
	        patterns: patterns,
	        defaults: defaults
	      };
	    }

	    return validate;
	  }

	  function resolveRef(baseId, ref, isRoot) {
	    ref = resolve.url(baseId, ref);
	    var refIndex = refs[ref];
	    var _refVal, refCode;
	    if (refIndex !== undefined) {
	      _refVal = refVal[refIndex];
	      refCode = 'refVal[' + refIndex + ']';
	      return resolvedRef(_refVal, refCode);
	    }
	    if (!isRoot && root.refs) {
	      var rootRefId = root.refs[ref];
	      if (rootRefId !== undefined) {
	        _refVal = root.refVal[rootRefId];
	        refCode = addLocalRef(ref, _refVal);
	        return resolvedRef(_refVal, refCode);
	      }
	    }

	    refCode = addLocalRef(ref);
	    var v = resolve.call(self, localCompile, root, ref);
	    if (v === undefined) {
	      var localSchema = localRefs && localRefs[ref];
	      if (localSchema) {
	        v = resolve.inlineRef(localSchema, opts.inlineRefs)
	            ? localSchema
	            : compile.call(self, localSchema, root, localRefs, baseId);
	      }
	    }

	    if (v === undefined) {
	      removeLocalRef(ref);
	    } else {
	      replaceLocalRef(ref, v);
	      return resolvedRef(v, refCode);
	    }
	  }

	  function addLocalRef(ref, v) {
	    var refId = refVal.length;
	    refVal[refId] = v;
	    refs[ref] = refId;
	    return 'refVal' + refId;
	  }

	  function removeLocalRef(ref) {
	    delete refs[ref];
	  }

	  function replaceLocalRef(ref, v) {
	    var refId = refs[ref];
	    refVal[refId] = v;
	  }

	  function resolvedRef(refVal, code) {
	    return typeof refVal == 'object' || typeof refVal == 'boolean'
	            ? { code: code, schema: refVal, inline: true }
	            : { code: code, $async: refVal && !!refVal.$async };
	  }

	  function usePattern(regexStr) {
	    var index = patternsHash[regexStr];
	    if (index === undefined) {
	      index = patternsHash[regexStr] = patterns.length;
	      patterns[index] = regexStr;
	    }
	    return 'pattern' + index;
	  }

	  function useDefault(value) {
	    switch (typeof value) {
	      case 'boolean':
	      case 'number':
	        return '' + value;
	      case 'string':
	        return util.toQuotedString(value);
	      case 'object':
	        if (value === null) return 'null';
	        var valueStr = stableStringify(value);
	        var index = defaultsHash[valueStr];
	        if (index === undefined) {
	          index = defaultsHash[valueStr] = defaults.length;
	          defaults[index] = value;
	        }
	        return 'default' + index;
	    }
	  }

	  function useCustomRule(rule, schema, parentSchema, it) {
	    if (self._opts.validateSchema !== false) {
	      var deps = rule.definition.dependencies;
	      if (deps && !deps.every(function(keyword) {
	        return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
	      }))
	        throw new Error('parent schema must have all required keywords: ' + deps.join(','));

	      var validateSchema = rule.definition.validateSchema;
	      if (validateSchema) {
	        var valid = validateSchema(schema);
	        if (!valid) {
	          var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
	          if (self._opts.validateSchema == 'log') self.logger.error(message);
	          else throw new Error(message);
	        }
	      }
	    }

	    var compile = rule.definition.compile
	      , inline = rule.definition.inline
	      , macro = rule.definition.macro;

	    var validate;
	    if (compile) {
	      validate = compile.call(self, schema, parentSchema, it);
	    } else if (macro) {
	      validate = macro.call(self, schema, parentSchema, it);
	      if (opts.validateSchema !== false) self.validateSchema(validate, true);
	    } else if (inline) {
	      validate = inline.call(self, it, rule.keyword, schema, parentSchema);
	    } else {
	      validate = rule.definition.validate;
	      if (!validate) return;
	    }

	    if (validate === undefined)
	      throw new Error('custom keyword "' + rule.keyword + '"failed to compile');

	    var index = customRules.length;
	    customRules[index] = validate;

	    return {
	      code: 'customRule' + index,
	      validate: validate
	    };
	  }
	}


	/**
	 * Checks if the schema is currently compiled
	 * @this   Ajv
	 * @param  {Object} schema schema to compile
	 * @param  {Object} root root object
	 * @param  {String} baseId base schema ID
	 * @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
	 */
	function checkCompiling(schema, root, baseId) {
	  /* jshint validthis: true */
	  var index = compIndex.call(this, schema, root, baseId);
	  if (index >= 0) return { index: index, compiling: true };
	  index = this._compilations.length;
	  this._compilations[index] = {
	    schema: schema,
	    root: root,
	    baseId: baseId
	  };
	  return { index: index, compiling: false };
	}


	/**
	 * Removes the schema from the currently compiled list
	 * @this   Ajv
	 * @param  {Object} schema schema to compile
	 * @param  {Object} root root object
	 * @param  {String} baseId base schema ID
	 */
	function endCompiling(schema, root, baseId) {
	  /* jshint validthis: true */
	  var i = compIndex.call(this, schema, root, baseId);
	  if (i >= 0) this._compilations.splice(i, 1);
	}


	/**
	 * Index of schema compilation in the currently compiled list
	 * @this   Ajv
	 * @param  {Object} schema schema to compile
	 * @param  {Object} root root object
	 * @param  {String} baseId base schema ID
	 * @return {Integer} compilation index
	 */
	function compIndex(schema, root, baseId) {
	  /* jshint validthis: true */
	  for (var i=0; i<this._compilations.length; i++) {
	    var c = this._compilations[i];
	    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
	  }
	  return -1;
	}


	function patternCode(i, patterns) {
	  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
	}


	function defaultCode(i) {
	  return 'var default' + i + ' = defaults[' + i + '];';
	}


	function refValCode(i, refVal) {
	  return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';
	}


	function customRuleCode(i) {
	  return 'var customRule' + i + ' = customRules[' + i + '];';
	}


	function vars(arr, statement) {
	  if (!arr.length) return '';
	  var code = '';
	  for (var i=0; i<arr.length; i++)
	    code += statement(i, arr);
	  return code;
	}
	return compile_1;
}

var cache = {exports: {}};

var hasRequiredCache;

function requireCache () {
	if (hasRequiredCache) return cache.exports;
	hasRequiredCache = 1;


	var Cache = cache.exports = function Cache() {
	  this._cache = {};
	};


	Cache.prototype.put = function Cache_put(key, value) {
	  this._cache[key] = value;
	};


	Cache.prototype.get = function Cache_get(key) {
	  return this._cache[key];
	};


	Cache.prototype.del = function Cache_del(key) {
	  delete this._cache[key];
	};


	Cache.prototype.clear = function Cache_clear() {
	  this._cache = {};
	};
	return cache.exports;
}

var formats_1;
var hasRequiredFormats;

function requireFormats () {
	if (hasRequiredFormats) return formats_1;
	hasRequiredFormats = 1;

	var util = requireUtil$1();

	var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
	var DAYS = [0,31,28,31,30,31,30,31,31,30,31,30,31];
	var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
	var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
	var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
	var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
	// uri-template: https://tools.ietf.org/html/rfc6570
	var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
	// For the source: https://gist.github.com/dperini/729294
	// For test cases: https://mathiasbynens.be/demo/url-regex
	// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
	// var URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
	var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
	var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
	var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
	var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
	var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;


	formats_1 = formats;

	function formats(mode) {
	  mode = mode == 'full' ? 'full' : 'fast';
	  return util.copy(formats[mode]);
	}


	formats.fast = {
	  // date: http://tools.ietf.org/html/rfc3339#section-5.6
	  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
	  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
	  time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
	  'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
	  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
	  uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
	  'uri-reference': /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
	  'uri-template': URITEMPLATE,
	  url: URL,
	  // email (sources from jsen validator):
	  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
	  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
	  email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
	  hostname: HOSTNAME,
	  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
	  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
	  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
	  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
	  regex: regex,
	  // uuid: http://tools.ietf.org/html/rfc4122
	  uuid: UUID,
	  // JSON-pointer: https://tools.ietf.org/html/rfc6901
	  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
	  'json-pointer': JSON_POINTER,
	  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
	  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
	  'relative-json-pointer': RELATIVE_JSON_POINTER
	};


	formats.full = {
	  date: date,
	  time: time,
	  'date-time': date_time,
	  uri: uri,
	  'uri-reference': URIREF,
	  'uri-template': URITEMPLATE,
	  url: URL,
	  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
	  hostname: HOSTNAME,
	  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
	  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
	  regex: regex,
	  uuid: UUID,
	  'json-pointer': JSON_POINTER,
	  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
	  'relative-json-pointer': RELATIVE_JSON_POINTER
	};


	function isLeapYear(year) {
	  // https://tools.ietf.org/html/rfc3339#appendix-C
	  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
	}


	function date(str) {
	  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
	  var matches = str.match(DATE);
	  if (!matches) return false;

	  var year = +matches[1];
	  var month = +matches[2];
	  var day = +matches[3];

	  return month >= 1 && month <= 12 && day >= 1 &&
	          day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
	}


	function time(str, full) {
	  var matches = str.match(TIME);
	  if (!matches) return false;

	  var hour = matches[1];
	  var minute = matches[2];
	  var second = matches[3];
	  var timeZone = matches[5];
	  return ((hour <= 23 && minute <= 59 && second <= 59) ||
	          (hour == 23 && minute == 59 && second == 60)) &&
	         (!full || timeZone);
	}


	var DATE_TIME_SEPARATOR = /t|\s/i;
	function date_time(str) {
	  // http://tools.ietf.org/html/rfc3339#section-5.6
	  var dateTime = str.split(DATE_TIME_SEPARATOR);
	  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
	}


	var NOT_URI_FRAGMENT = /\/|:/;
	function uri(str) {
	  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
	  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
	}


	var Z_ANCHOR = /[^\\]\\Z/;
	function regex(str) {
	  if (Z_ANCHOR.test(str)) return false;
	  try {
	    new RegExp(str);
	    return true;
	  } catch(e) {
	    return false;
	  }
	}
	return formats_1;
}

var ref;
var hasRequiredRef;

function requireRef () {
	if (hasRequiredRef) return ref;
	hasRequiredRef = 1;
	ref = function generate_ref(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $valid = 'valid' + $lvl;
	  var $async, $refCode;
	  if ($schema == '#' || $schema == '#/') {
	    if (it.isRoot) {
	      $async = it.async;
	      $refCode = 'validate';
	    } else {
	      $async = it.root.schema.$async === true;
	      $refCode = 'root.refVal[0]';
	    }
	  } else {
	    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
	    if ($refVal === undefined) {
	      var $message = it.MissingRefError.message(it.baseId, $schema);
	      if (it.opts.missingRefs == 'fail') {
	        it.logger.error($message);
	        var $$outStack = $$outStack || [];
	        $$outStack.push(out);
	        out = ''; /* istanbul ignore else */
	        if (it.createErrors !== false) {
	          out += ' { keyword: \'' + ('$ref') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { ref: \'' + (it.util.escapeQuotes($schema)) + '\' } ';
	          if (it.opts.messages !== false) {
	            out += ' , message: \'can\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\' ';
	          }
	          if (it.opts.verbose) {
	            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	          }
	          out += ' } ';
	        } else {
	          out += ' {} ';
	        }
	        var __err = out;
	        out = $$outStack.pop();
	        if (!it.compositeRule && $breakOnError) {
	          /* istanbul ignore if */
	          if (it.async) {
	            out += ' throw new ValidationError([' + (__err) + ']); ';
	          } else {
	            out += ' validate.errors = [' + (__err) + ']; return false; ';
	          }
	        } else {
	          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	        }
	        if ($breakOnError) {
	          out += ' if (false) { ';
	        }
	      } else if (it.opts.missingRefs == 'ignore') {
	        it.logger.warn($message);
	        if ($breakOnError) {
	          out += ' if (true) { ';
	        }
	      } else {
	        throw new it.MissingRefError(it.baseId, $schema, $message);
	      }
	    } else if ($refVal.inline) {
	      var $it = it.util.copy(it);
	      $it.level++;
	      var $nextValid = 'valid' + $it.level;
	      $it.schema = $refVal.schema;
	      $it.schemaPath = '';
	      $it.errSchemaPath = $schema;
	      var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
	      out += ' ' + ($code) + ' ';
	      if ($breakOnError) {
	        out += ' if (' + ($nextValid) + ') { ';
	      }
	    } else {
	      $async = $refVal.$async === true || (it.async && $refVal.$async !== false);
	      $refCode = $refVal.code;
	    }
	  }
	  if ($refCode) {
	    var $$outStack = $$outStack || [];
	    $$outStack.push(out);
	    out = '';
	    if (it.opts.passContext) {
	      out += ' ' + ($refCode) + '.call(this, ';
	    } else {
	      out += ' ' + ($refCode) + '( ';
	    }
	    out += ' ' + ($data) + ', (dataPath || \'\')';
	    if (it.errorPath != '""') {
	      out += ' + ' + (it.errorPath);
	    }
	    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
	      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
	    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ', rootData)  ';
	    var __callValidate = out;
	    out = $$outStack.pop();
	    if ($async) {
	      if (!it.async) throw new Error('async schema referenced by sync schema');
	      if ($breakOnError) {
	        out += ' var ' + ($valid) + '; ';
	      }
	      out += ' try { await ' + (__callValidate) + '; ';
	      if ($breakOnError) {
	        out += ' ' + ($valid) + ' = true; ';
	      }
	      out += ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';
	      if ($breakOnError) {
	        out += ' ' + ($valid) + ' = false; ';
	      }
	      out += ' } ';
	      if ($breakOnError) {
	        out += ' if (' + ($valid) + ') { ';
	      }
	    } else {
	      out += ' if (!' + (__callValidate) + ') { if (vErrors === null) vErrors = ' + ($refCode) + '.errors; else vErrors = vErrors.concat(' + ($refCode) + '.errors); errors = vErrors.length; } ';
	      if ($breakOnError) {
	        out += ' else { ';
	      }
	    }
	  }
	  return out;
	};
	return ref;
}

var allOf;
var hasRequiredAllOf;

function requireAllOf () {
	if (hasRequiredAllOf) return allOf;
	hasRequiredAllOf = 1;
	allOf = function generate_allOf(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $it = it.util.copy(it);
	  var $closingBraces = '';
	  $it.level++;
	  var $nextValid = 'valid' + $it.level;
	  var $currentBaseId = $it.baseId,
	    $allSchemasEmpty = true;
	  var arr1 = $schema;
	  if (arr1) {
	    var $sch, $i = -1,
	      l1 = arr1.length - 1;
	    while ($i < l1) {
	      $sch = arr1[$i += 1];
	      if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
	        $allSchemasEmpty = false;
	        $it.schema = $sch;
	        $it.schemaPath = $schemaPath + '[' + $i + ']';
	        $it.errSchemaPath = $errSchemaPath + '/' + $i;
	        out += '  ' + (it.validate($it)) + ' ';
	        $it.baseId = $currentBaseId;
	        if ($breakOnError) {
	          out += ' if (' + ($nextValid) + ') { ';
	          $closingBraces += '}';
	        }
	      }
	    }
	  }
	  if ($breakOnError) {
	    if ($allSchemasEmpty) {
	      out += ' if (true) { ';
	    } else {
	      out += ' ' + ($closingBraces.slice(0, -1)) + ' ';
	    }
	  }
	  return out;
	};
	return allOf;
}

var anyOf;
var hasRequiredAnyOf;

function requireAnyOf () {
	if (hasRequiredAnyOf) return anyOf;
	hasRequiredAnyOf = 1;
	anyOf = function generate_anyOf(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $valid = 'valid' + $lvl;
	  var $errs = 'errs__' + $lvl;
	  var $it = it.util.copy(it);
	  var $closingBraces = '';
	  $it.level++;
	  var $nextValid = 'valid' + $it.level;
	  var $noEmptySchema = $schema.every(function($sch) {
	    return (it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all));
	  });
	  if ($noEmptySchema) {
	    var $currentBaseId = $it.baseId;
	    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';
	    var $wasComposite = it.compositeRule;
	    it.compositeRule = $it.compositeRule = true;
	    var arr1 = $schema;
	    if (arr1) {
	      var $sch, $i = -1,
	        l1 = arr1.length - 1;
	      while ($i < l1) {
	        $sch = arr1[$i += 1];
	        $it.schema = $sch;
	        $it.schemaPath = $schemaPath + '[' + $i + ']';
	        $it.errSchemaPath = $errSchemaPath + '/' + $i;
	        out += '  ' + (it.validate($it)) + ' ';
	        $it.baseId = $currentBaseId;
	        out += ' ' + ($valid) + ' = ' + ($valid) + ' || ' + ($nextValid) + '; if (!' + ($valid) + ') { ';
	        $closingBraces += '}';
	      }
	    }
	    it.compositeRule = $it.compositeRule = $wasComposite;
	    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
	    if (it.createErrors !== false) {
	      out += ' { keyword: \'' + ('anyOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
	      if (it.opts.messages !== false) {
	        out += ' , message: \'should match some schema in anyOf\' ';
	      }
	      if (it.opts.verbose) {
	        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	      }
	      out += ' } ';
	    } else {
	      out += ' {} ';
	    }
	    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	    if (!it.compositeRule && $breakOnError) {
	      /* istanbul ignore if */
	      if (it.async) {
	        out += ' throw new ValidationError(vErrors); ';
	      } else {
	        out += ' validate.errors = vErrors; return false; ';
	      }
	    }
	    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
	    if (it.opts.allErrors) {
	      out += ' } ';
	    }
	  } else {
	    if ($breakOnError) {
	      out += ' if (true) { ';
	    }
	  }
	  return out;
	};
	return anyOf;
}

var comment;
var hasRequiredComment;

function requireComment () {
	if (hasRequiredComment) return comment;
	hasRequiredComment = 1;
	comment = function generate_comment(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $schema = it.schema[$keyword];
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  !it.opts.allErrors;
	  var $comment = it.util.toQuotedString($schema);
	  if (it.opts.$comment === true) {
	    out += ' console.log(' + ($comment) + ');';
	  } else if (typeof it.opts.$comment == 'function') {
	    out += ' self._opts.$comment(' + ($comment) + ', ' + (it.util.toQuotedString($errSchemaPath)) + ', validate.root.schema);';
	  }
	  return out;
	};
	return comment;
}

var _const;
var hasRequired_const;

function require_const () {
	if (hasRequired_const) return _const;
	hasRequired_const = 1;
	_const = function generate_const(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $valid = 'valid' + $lvl;
	  var $isData = it.opts.$data && $schema && $schema.$data;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	  }
	  if (!$isData) {
	    out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';
	  }
	  out += 'var ' + ($valid) + ' = equal(' + ($data) + ', schema' + ($lvl) + '); if (!' + ($valid) + ') {   ';
	  var $$outStack = $$outStack || [];
	  $$outStack.push(out);
	  out = ''; /* istanbul ignore else */
	  if (it.createErrors !== false) {
	    out += ' { keyword: \'' + ('const') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValue: schema' + ($lvl) + ' } ';
	    if (it.opts.messages !== false) {
	      out += ' , message: \'should be equal to constant\' ';
	    }
	    if (it.opts.verbose) {
	      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	    }
	    out += ' } ';
	  } else {
	    out += ' {} ';
	  }
	  var __err = out;
	  out = $$outStack.pop();
	  if (!it.compositeRule && $breakOnError) {
	    /* istanbul ignore if */
	    if (it.async) {
	      out += ' throw new ValidationError([' + (__err) + ']); ';
	    } else {
	      out += ' validate.errors = [' + (__err) + ']; return false; ';
	    }
	  } else {
	    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	  }
	  out += ' }';
	  if ($breakOnError) {
	    out += ' else { ';
	  }
	  return out;
	};
	return _const;
}

var contains;
var hasRequiredContains;

function requireContains () {
	if (hasRequiredContains) return contains;
	hasRequiredContains = 1;
	contains = function generate_contains(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $valid = 'valid' + $lvl;
	  var $errs = 'errs__' + $lvl;
	  var $it = it.util.copy(it);
	  var $closingBraces = '';
	  $it.level++;
	  var $nextValid = 'valid' + $it.level;
	  var $idx = 'i' + $lvl,
	    $dataNxt = $it.dataLevel = it.dataLevel + 1,
	    $nextData = 'data' + $dataNxt,
	    $currentBaseId = it.baseId,
	    $nonEmptySchema = (it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all));
	  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
	  if ($nonEmptySchema) {
	    var $wasComposite = it.compositeRule;
	    it.compositeRule = $it.compositeRule = true;
	    $it.schema = $schema;
	    $it.schemaPath = $schemaPath;
	    $it.errSchemaPath = $errSchemaPath;
	    out += ' var ' + ($nextValid) + ' = false; for (var ' + ($idx) + ' = 0; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
	    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
	    var $passData = $data + '[' + $idx + ']';
	    $it.dataPathArr[$dataNxt] = $idx;
	    var $code = it.validate($it);
	    $it.baseId = $currentBaseId;
	    if (it.util.varOccurences($code, $nextData) < 2) {
	      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
	    } else {
	      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
	    }
	    out += ' if (' + ($nextValid) + ') break; }  ';
	    it.compositeRule = $it.compositeRule = $wasComposite;
	    out += ' ' + ($closingBraces) + ' if (!' + ($nextValid) + ') {';
	  } else {
	    out += ' if (' + ($data) + '.length == 0) {';
	  }
	  var $$outStack = $$outStack || [];
	  $$outStack.push(out);
	  out = ''; /* istanbul ignore else */
	  if (it.createErrors !== false) {
	    out += ' { keyword: \'' + ('contains') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
	    if (it.opts.messages !== false) {
	      out += ' , message: \'should contain a valid item\' ';
	    }
	    if (it.opts.verbose) {
	      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	    }
	    out += ' } ';
	  } else {
	    out += ' {} ';
	  }
	  var __err = out;
	  out = $$outStack.pop();
	  if (!it.compositeRule && $breakOnError) {
	    /* istanbul ignore if */
	    if (it.async) {
	      out += ' throw new ValidationError([' + (__err) + ']); ';
	    } else {
	      out += ' validate.errors = [' + (__err) + ']; return false; ';
	    }
	  } else {
	    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	  }
	  out += ' } else { ';
	  if ($nonEmptySchema) {
	    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
	  }
	  if (it.opts.allErrors) {
	    out += ' } ';
	  }
	  return out;
	};
	return contains;
}

var dependencies$2;
var hasRequiredDependencies;

function requireDependencies () {
	if (hasRequiredDependencies) return dependencies$2;
	hasRequiredDependencies = 1;
	dependencies$2 = function generate_dependencies(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $errs = 'errs__' + $lvl;
	  var $it = it.util.copy(it);
	  var $closingBraces = '';
	  $it.level++;
	  var $nextValid = 'valid' + $it.level;
	  var $schemaDeps = {},
	    $propertyDeps = {},
	    $ownProperties = it.opts.ownProperties;
	  for ($property in $schema) {
	    if ($property == '__proto__') continue;
	    var $sch = $schema[$property];
	    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
	    $deps[$property] = $sch;
	  }
	  out += 'var ' + ($errs) + ' = errors;';
	  var $currentErrorPath = it.errorPath;
	  out += 'var missing' + ($lvl) + ';';
	  for (var $property in $propertyDeps) {
	    $deps = $propertyDeps[$property];
	    if ($deps.length) {
	      out += ' if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
	      if ($ownProperties) {
	        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
	      }
	      if ($breakOnError) {
	        out += ' && ( ';
	        var arr1 = $deps;
	        if (arr1) {
	          var $propertyKey, $i = -1,
	            l1 = arr1.length - 1;
	          while ($i < l1) {
	            $propertyKey = arr1[$i += 1];
	            if ($i) {
	              out += ' || ';
	            }
	            var $prop = it.util.getProperty($propertyKey),
	              $useData = $data + $prop;
	            out += ' ( ( ' + ($useData) + ' === undefined ';
	            if ($ownProperties) {
	              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
	            }
	            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
	          }
	        }
	        out += ')) {  ';
	        var $propertyPath = 'missing' + $lvl,
	          $missingProperty = '\' + ' + $propertyPath + ' + \'';
	        if (it.opts._errorDataPathProperty) {
	          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
	        }
	        var $$outStack = $$outStack || [];
	        $$outStack.push(out);
	        out = ''; /* istanbul ignore else */
	        if (it.createErrors !== false) {
	          out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
	          if (it.opts.messages !== false) {
	            out += ' , message: \'should have ';
	            if ($deps.length == 1) {
	              out += 'property ' + (it.util.escapeQuotes($deps[0]));
	            } else {
	              out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
	            }
	            out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
	          }
	          if (it.opts.verbose) {
	            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	          }
	          out += ' } ';
	        } else {
	          out += ' {} ';
	        }
	        var __err = out;
	        out = $$outStack.pop();
	        if (!it.compositeRule && $breakOnError) {
	          /* istanbul ignore if */
	          if (it.async) {
	            out += ' throw new ValidationError([' + (__err) + ']); ';
	          } else {
	            out += ' validate.errors = [' + (__err) + ']; return false; ';
	          }
	        } else {
	          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	        }
	      } else {
	        out += ' ) { ';
	        var arr2 = $deps;
	        if (arr2) {
	          var $propertyKey, i2 = -1,
	            l2 = arr2.length - 1;
	          while (i2 < l2) {
	            $propertyKey = arr2[i2 += 1];
	            var $prop = it.util.getProperty($propertyKey),
	              $missingProperty = it.util.escapeQuotes($propertyKey),
	              $useData = $data + $prop;
	            if (it.opts._errorDataPathProperty) {
	              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
	            }
	            out += ' if ( ' + ($useData) + ' === undefined ';
	            if ($ownProperties) {
	              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
	            }
	            out += ') {  var err =   '; /* istanbul ignore else */
	            if (it.createErrors !== false) {
	              out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
	              if (it.opts.messages !== false) {
	                out += ' , message: \'should have ';
	                if ($deps.length == 1) {
	                  out += 'property ' + (it.util.escapeQuotes($deps[0]));
	                } else {
	                  out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
	                }
	                out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
	              }
	              if (it.opts.verbose) {
	                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	              }
	              out += ' } ';
	            } else {
	              out += ' {} ';
	            }
	            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
	          }
	        }
	      }
	      out += ' }   ';
	      if ($breakOnError) {
	        $closingBraces += '}';
	        out += ' else { ';
	      }
	    }
	  }
	  it.errorPath = $currentErrorPath;
	  var $currentBaseId = $it.baseId;
	  for (var $property in $schemaDeps) {
	    var $sch = $schemaDeps[$property];
	    if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
	      out += ' ' + ($nextValid) + ' = true; if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
	      if ($ownProperties) {
	        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
	      }
	      out += ') { ';
	      $it.schema = $sch;
	      $it.schemaPath = $schemaPath + it.util.getProperty($property);
	      $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
	      out += '  ' + (it.validate($it)) + ' ';
	      $it.baseId = $currentBaseId;
	      out += ' }  ';
	      if ($breakOnError) {
	        out += ' if (' + ($nextValid) + ') { ';
	        $closingBraces += '}';
	      }
	    }
	  }
	  if ($breakOnError) {
	    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
	  }
	  return out;
	};
	return dependencies$2;
}

var _enum;
var hasRequired_enum;

function require_enum () {
	if (hasRequired_enum) return _enum;
	hasRequired_enum = 1;
	_enum = function generate_enum(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $valid = 'valid' + $lvl;
	  var $isData = it.opts.$data && $schema && $schema.$data;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	  }
	  var $i = 'i' + $lvl,
	    $vSchema = 'schema' + $lvl;
	  if (!$isData) {
	    out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + ';';
	  }
	  out += 'var ' + ($valid) + ';';
	  if ($isData) {
	    out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
	  }
	  out += '' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<' + ($vSchema) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; }';
	  if ($isData) {
	    out += '  }  ';
	  }
	  out += ' if (!' + ($valid) + ') {   ';
	  var $$outStack = $$outStack || [];
	  $$outStack.push(out);
	  out = ''; /* istanbul ignore else */
	  if (it.createErrors !== false) {
	    out += ' { keyword: \'' + ('enum') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValues: schema' + ($lvl) + ' } ';
	    if (it.opts.messages !== false) {
	      out += ' , message: \'should be equal to one of the allowed values\' ';
	    }
	    if (it.opts.verbose) {
	      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	    }
	    out += ' } ';
	  } else {
	    out += ' {} ';
	  }
	  var __err = out;
	  out = $$outStack.pop();
	  if (!it.compositeRule && $breakOnError) {
	    /* istanbul ignore if */
	    if (it.async) {
	      out += ' throw new ValidationError([' + (__err) + ']); ';
	    } else {
	      out += ' validate.errors = [' + (__err) + ']; return false; ';
	    }
	  } else {
	    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	  }
	  out += ' }';
	  if ($breakOnError) {
	    out += ' else { ';
	  }
	  return out;
	};
	return _enum;
}

var format;
var hasRequiredFormat;

function requireFormat () {
	if (hasRequiredFormat) return format;
	hasRequiredFormat = 1;
	format = function generate_format(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  if (it.opts.format === false) {
	    if ($breakOnError) {
	      out += ' if (true) { ';
	    }
	    return out;
	  }
	  var $isData = it.opts.$data && $schema && $schema.$data,
	    $schemaValue;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	    $schemaValue = 'schema' + $lvl;
	  } else {
	    $schemaValue = $schema;
	  }
	  var $unknownFormats = it.opts.unknownFormats,
	    $allowUnknown = Array.isArray($unknownFormats);
	  if ($isData) {
	    var $format = 'format' + $lvl,
	      $isObject = 'isObject' + $lvl,
	      $formatType = 'formatType' + $lvl;
	    out += ' var ' + ($format) + ' = formats[' + ($schemaValue) + ']; var ' + ($isObject) + ' = typeof ' + ($format) + ' == \'object\' && !(' + ($format) + ' instanceof RegExp) && ' + ($format) + '.validate; var ' + ($formatType) + ' = ' + ($isObject) + ' && ' + ($format) + '.type || \'string\'; if (' + ($isObject) + ') { ';
	    if (it.async) {
	      out += ' var async' + ($lvl) + ' = ' + ($format) + '.async; ';
	    }
	    out += ' ' + ($format) + ' = ' + ($format) + '.validate; } if (  ';
	    if ($isData) {
	      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
	    }
	    out += ' (';
	    if ($unknownFormats != 'ignore') {
	      out += ' (' + ($schemaValue) + ' && !' + ($format) + ' ';
	      if ($allowUnknown) {
	        out += ' && self._opts.unknownFormats.indexOf(' + ($schemaValue) + ') == -1 ';
	      }
	      out += ') || ';
	    }
	    out += ' (' + ($format) + ' && ' + ($formatType) + ' == \'' + ($ruleType) + '\' && !(typeof ' + ($format) + ' == \'function\' ? ';
	    if (it.async) {
	      out += ' (async' + ($lvl) + ' ? await ' + ($format) + '(' + ($data) + ') : ' + ($format) + '(' + ($data) + ')) ';
	    } else {
	      out += ' ' + ($format) + '(' + ($data) + ') ';
	    }
	    out += ' : ' + ($format) + '.test(' + ($data) + '))))) {';
	  } else {
	    var $format = it.formats[$schema];
	    if (!$format) {
	      if ($unknownFormats == 'ignore') {
	        it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
	        if ($breakOnError) {
	          out += ' if (true) { ';
	        }
	        return out;
	      } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
	        if ($breakOnError) {
	          out += ' if (true) { ';
	        }
	        return out;
	      } else {
	        throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
	      }
	    }
	    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;
	    var $formatType = $isObject && $format.type || 'string';
	    if ($isObject) {
	      var $async = $format.async === true;
	      $format = $format.validate;
	    }
	    if ($formatType != $ruleType) {
	      if ($breakOnError) {
	        out += ' if (true) { ';
	      }
	      return out;
	    }
	    if ($async) {
	      if (!it.async) throw new Error('async format in sync schema');
	      var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
	      out += ' if (!(await ' + ($formatRef) + '(' + ($data) + '))) { ';
	    } else {
	      out += ' if (! ';
	      var $formatRef = 'formats' + it.util.getProperty($schema);
	      if ($isObject) $formatRef += '.validate';
	      if (typeof $format == 'function') {
	        out += ' ' + ($formatRef) + '(' + ($data) + ') ';
	      } else {
	        out += ' ' + ($formatRef) + '.test(' + ($data) + ') ';
	      }
	      out += ') { ';
	    }
	  }
	  var $$outStack = $$outStack || [];
	  $$outStack.push(out);
	  out = ''; /* istanbul ignore else */
	  if (it.createErrors !== false) {
	    out += ' { keyword: \'' + ('format') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { format:  ';
	    if ($isData) {
	      out += '' + ($schemaValue);
	    } else {
	      out += '' + (it.util.toQuotedString($schema));
	    }
	    out += '  } ';
	    if (it.opts.messages !== false) {
	      out += ' , message: \'should match format "';
	      if ($isData) {
	        out += '\' + ' + ($schemaValue) + ' + \'';
	      } else {
	        out += '' + (it.util.escapeQuotes($schema));
	      }
	      out += '"\' ';
	    }
	    if (it.opts.verbose) {
	      out += ' , schema:  ';
	      if ($isData) {
	        out += 'validate.schema' + ($schemaPath);
	      } else {
	        out += '' + (it.util.toQuotedString($schema));
	      }
	      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	    }
	    out += ' } ';
	  } else {
	    out += ' {} ';
	  }
	  var __err = out;
	  out = $$outStack.pop();
	  if (!it.compositeRule && $breakOnError) {
	    /* istanbul ignore if */
	    if (it.async) {
	      out += ' throw new ValidationError([' + (__err) + ']); ';
	    } else {
	      out += ' validate.errors = [' + (__err) + ']; return false; ';
	    }
	  } else {
	    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	  }
	  out += ' } ';
	  if ($breakOnError) {
	    out += ' else { ';
	  }
	  return out;
	};
	return format;
}

var _if;
var hasRequired_if;

function require_if () {
	if (hasRequired_if) return _if;
	hasRequired_if = 1;
	_if = function generate_if(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $valid = 'valid' + $lvl;
	  var $errs = 'errs__' + $lvl;
	  var $it = it.util.copy(it);
	  $it.level++;
	  var $nextValid = 'valid' + $it.level;
	  var $thenSch = it.schema['then'],
	    $elseSch = it.schema['else'],
	    $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? (typeof $thenSch == 'object' && Object.keys($thenSch).length > 0) || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)),
	    $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? (typeof $elseSch == 'object' && Object.keys($elseSch).length > 0) || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)),
	    $currentBaseId = $it.baseId;
	  if ($thenPresent || $elsePresent) {
	    var $ifClause;
	    $it.createErrors = false;
	    $it.schema = $schema;
	    $it.schemaPath = $schemaPath;
	    $it.errSchemaPath = $errSchemaPath;
	    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = true;  ';
	    var $wasComposite = it.compositeRule;
	    it.compositeRule = $it.compositeRule = true;
	    out += '  ' + (it.validate($it)) + ' ';
	    $it.baseId = $currentBaseId;
	    $it.createErrors = true;
	    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }  ';
	    it.compositeRule = $it.compositeRule = $wasComposite;
	    if ($thenPresent) {
	      out += ' if (' + ($nextValid) + ') {  ';
	      $it.schema = it.schema['then'];
	      $it.schemaPath = it.schemaPath + '.then';
	      $it.errSchemaPath = it.errSchemaPath + '/then';
	      out += '  ' + (it.validate($it)) + ' ';
	      $it.baseId = $currentBaseId;
	      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
	      if ($thenPresent && $elsePresent) {
	        $ifClause = 'ifClause' + $lvl;
	        out += ' var ' + ($ifClause) + ' = \'then\'; ';
	      } else {
	        $ifClause = '\'then\'';
	      }
	      out += ' } ';
	      if ($elsePresent) {
	        out += ' else { ';
	      }
	    } else {
	      out += ' if (!' + ($nextValid) + ') { ';
	    }
	    if ($elsePresent) {
	      $it.schema = it.schema['else'];
	      $it.schemaPath = it.schemaPath + '.else';
	      $it.errSchemaPath = it.errSchemaPath + '/else';
	      out += '  ' + (it.validate($it)) + ' ';
	      $it.baseId = $currentBaseId;
	      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
	      if ($thenPresent && $elsePresent) {
	        $ifClause = 'ifClause' + $lvl;
	        out += ' var ' + ($ifClause) + ' = \'else\'; ';
	      } else {
	        $ifClause = '\'else\'';
	      }
	      out += ' } ';
	    }
	    out += ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
	    if (it.createErrors !== false) {
	      out += ' { keyword: \'' + ('if') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { failingKeyword: ' + ($ifClause) + ' } ';
	      if (it.opts.messages !== false) {
	        out += ' , message: \'should match "\' + ' + ($ifClause) + ' + \'" schema\' ';
	      }
	      if (it.opts.verbose) {
	        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	      }
	      out += ' } ';
	    } else {
	      out += ' {} ';
	    }
	    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	    if (!it.compositeRule && $breakOnError) {
	      /* istanbul ignore if */
	      if (it.async) {
	        out += ' throw new ValidationError(vErrors); ';
	      } else {
	        out += ' validate.errors = vErrors; return false; ';
	      }
	    }
	    out += ' }   ';
	    if ($breakOnError) {
	      out += ' else { ';
	    }
	  } else {
	    if ($breakOnError) {
	      out += ' if (true) { ';
	    }
	  }
	  return out;
	};
	return _if;
}

var items;
var hasRequiredItems;

function requireItems () {
	if (hasRequiredItems) return items;
	hasRequiredItems = 1;
	items = function generate_items(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $valid = 'valid' + $lvl;
	  var $errs = 'errs__' + $lvl;
	  var $it = it.util.copy(it);
	  var $closingBraces = '';
	  $it.level++;
	  var $nextValid = 'valid' + $it.level;
	  var $idx = 'i' + $lvl,
	    $dataNxt = $it.dataLevel = it.dataLevel + 1,
	    $nextData = 'data' + $dataNxt,
	    $currentBaseId = it.baseId;
	  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
	  if (Array.isArray($schema)) {
	    var $additionalItems = it.schema.additionalItems;
	    if ($additionalItems === false) {
	      out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + '; ';
	      var $currErrSchemaPath = $errSchemaPath;
	      $errSchemaPath = it.errSchemaPath + '/additionalItems';
	      out += '  if (!' + ($valid) + ') {   ';
	      var $$outStack = $$outStack || [];
	      $$outStack.push(out);
	      out = ''; /* istanbul ignore else */
	      if (it.createErrors !== false) {
	        out += ' { keyword: \'' + ('additionalItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schema.length) + ' } ';
	        if (it.opts.messages !== false) {
	          out += ' , message: \'should NOT have more than ' + ($schema.length) + ' items\' ';
	        }
	        if (it.opts.verbose) {
	          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	        }
	        out += ' } ';
	      } else {
	        out += ' {} ';
	      }
	      var __err = out;
	      out = $$outStack.pop();
	      if (!it.compositeRule && $breakOnError) {
	        /* istanbul ignore if */
	        if (it.async) {
	          out += ' throw new ValidationError([' + (__err) + ']); ';
	        } else {
	          out += ' validate.errors = [' + (__err) + ']; return false; ';
	        }
	      } else {
	        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	      }
	      out += ' } ';
	      $errSchemaPath = $currErrSchemaPath;
	      if ($breakOnError) {
	        $closingBraces += '}';
	        out += ' else { ';
	      }
	    }
	    var arr1 = $schema;
	    if (arr1) {
	      var $sch, $i = -1,
	        l1 = arr1.length - 1;
	      while ($i < l1) {
	        $sch = arr1[$i += 1];
	        if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
	          out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';
	          var $passData = $data + '[' + $i + ']';
	          $it.schema = $sch;
	          $it.schemaPath = $schemaPath + '[' + $i + ']';
	          $it.errSchemaPath = $errSchemaPath + '/' + $i;
	          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
	          $it.dataPathArr[$dataNxt] = $i;
	          var $code = it.validate($it);
	          $it.baseId = $currentBaseId;
	          if (it.util.varOccurences($code, $nextData) < 2) {
	            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
	          } else {
	            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
	          }
	          out += ' }  ';
	          if ($breakOnError) {
	            out += ' if (' + ($nextValid) + ') { ';
	            $closingBraces += '}';
	          }
	        }
	      }
	    }
	    if (typeof $additionalItems == 'object' && (it.opts.strictKeywords ? (typeof $additionalItems == 'object' && Object.keys($additionalItems).length > 0) || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
	      $it.schema = $additionalItems;
	      $it.schemaPath = it.schemaPath + '.additionalItems';
	      $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
	      out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var ' + ($idx) + ' = ' + ($schema.length) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
	      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
	      var $passData = $data + '[' + $idx + ']';
	      $it.dataPathArr[$dataNxt] = $idx;
	      var $code = it.validate($it);
	      $it.baseId = $currentBaseId;
	      if (it.util.varOccurences($code, $nextData) < 2) {
	        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
	      } else {
	        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
	      }
	      if ($breakOnError) {
	        out += ' if (!' + ($nextValid) + ') break; ';
	      }
	      out += ' } }  ';
	      if ($breakOnError) {
	        out += ' if (' + ($nextValid) + ') { ';
	        $closingBraces += '}';
	      }
	    }
	  } else if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {
	    $it.schema = $schema;
	    $it.schemaPath = $schemaPath;
	    $it.errSchemaPath = $errSchemaPath;
	    out += '  for (var ' + ($idx) + ' = ' + (0) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
	    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
	    var $passData = $data + '[' + $idx + ']';
	    $it.dataPathArr[$dataNxt] = $idx;
	    var $code = it.validate($it);
	    $it.baseId = $currentBaseId;
	    if (it.util.varOccurences($code, $nextData) < 2) {
	      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
	    } else {
	      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
	    }
	    if ($breakOnError) {
	      out += ' if (!' + ($nextValid) + ') break; ';
	    }
	    out += ' }';
	  }
	  if ($breakOnError) {
	    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
	  }
	  return out;
	};
	return items;
}

var _limit;
var hasRequired_limit;

function require_limit () {
	if (hasRequired_limit) return _limit;
	hasRequired_limit = 1;
	_limit = function generate__limit(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $errorKeyword;
	  var $data = 'data' + ($dataLvl || '');
	  var $isData = it.opts.$data && $schema && $schema.$data,
	    $schemaValue;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	    $schemaValue = 'schema' + $lvl;
	  } else {
	    $schemaValue = $schema;
	  }
	  var $isMax = $keyword == 'maximum',
	    $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
	    $schemaExcl = it.schema[$exclusiveKeyword],
	    $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
	    $op = $isMax ? '<' : '>',
	    $notOp = $isMax ? '>' : '<',
	    $errorKeyword = undefined;
	  if (!($isData || typeof $schema == 'number' || $schema === undefined)) {
	    throw new Error($keyword + ' must be number');
	  }
	  if (!($isDataExcl || $schemaExcl === undefined || typeof $schemaExcl == 'number' || typeof $schemaExcl == 'boolean')) {
	    throw new Error($exclusiveKeyword + ' must be number or boolean');
	  }
	  if ($isDataExcl) {
	    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
	      $exclusive = 'exclusive' + $lvl,
	      $exclType = 'exclType' + $lvl,
	      $exclIsNumber = 'exclIsNumber' + $lvl,
	      $opExpr = 'op' + $lvl,
	      $opStr = '\' + ' + $opExpr + ' + \'';
	    out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';
	    $schemaValueExcl = 'schemaExcl' + $lvl;
	    out += ' var ' + ($exclusive) + '; var ' + ($exclType) + ' = typeof ' + ($schemaValueExcl) + '; if (' + ($exclType) + ' != \'boolean\' && ' + ($exclType) + ' != \'undefined\' && ' + ($exclType) + ' != \'number\') { ';
	    var $errorKeyword = $exclusiveKeyword;
	    var $$outStack = $$outStack || [];
	    $$outStack.push(out);
	    out = ''; /* istanbul ignore else */
	    if (it.createErrors !== false) {
	      out += ' { keyword: \'' + ($errorKeyword || '_exclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
	      if (it.opts.messages !== false) {
	        out += ' , message: \'' + ($exclusiveKeyword) + ' should be boolean\' ';
	      }
	      if (it.opts.verbose) {
	        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	      }
	      out += ' } ';
	    } else {
	      out += ' {} ';
	    }
	    var __err = out;
	    out = $$outStack.pop();
	    if (!it.compositeRule && $breakOnError) {
	      /* istanbul ignore if */
	      if (it.async) {
	        out += ' throw new ValidationError([' + (__err) + ']); ';
	      } else {
	        out += ' validate.errors = [' + (__err) + ']; return false; ';
	      }
	    } else {
	      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	    }
	    out += ' } else if ( ';
	    if ($isData) {
	      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
	    }
	    out += ' ' + ($exclType) + ' == \'number\' ? ( (' + ($exclusive) + ' = ' + ($schemaValue) + ' === undefined || ' + ($schemaValueExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ') ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValueExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) : ( (' + ($exclusive) + ' = ' + ($schemaValueExcl) + ' === true) ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValue) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { var op' + ($lvl) + ' = ' + ($exclusive) + ' ? \'' + ($op) + '\' : \'' + ($op) + '=\'; ';
	    if ($schema === undefined) {
	      $errorKeyword = $exclusiveKeyword;
	      $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
	      $schemaValue = $schemaValueExcl;
	      $isData = $isDataExcl;
	    }
	  } else {
	    var $exclIsNumber = typeof $schemaExcl == 'number',
	      $opStr = $op;
	    if ($exclIsNumber && $isData) {
	      var $opExpr = '\'' + $opStr + '\'';
	      out += ' if ( ';
	      if ($isData) {
	        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
	      }
	      out += ' ( ' + ($schemaValue) + ' === undefined || ' + ($schemaExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ' ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { ';
	    } else {
	      if ($exclIsNumber && $schema === undefined) {
	        $exclusive = true;
	        $errorKeyword = $exclusiveKeyword;
	        $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
	        $schemaValue = $schemaExcl;
	        $notOp += '=';
	      } else {
	        if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);
	        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
	          $exclusive = true;
	          $errorKeyword = $exclusiveKeyword;
	          $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
	          $notOp += '=';
	        } else {
	          $exclusive = false;
	          $opStr += '=';
	        }
	      }
	      var $opExpr = '\'' + $opStr + '\'';
	      out += ' if ( ';
	      if ($isData) {
	        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
	      }
	      out += ' ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' || ' + ($data) + ' !== ' + ($data) + ') { ';
	    }
	  }
	  $errorKeyword = $errorKeyword || $keyword;
	  var $$outStack = $$outStack || [];
	  $$outStack.push(out);
	  out = ''; /* istanbul ignore else */
	  if (it.createErrors !== false) {
	    out += ' { keyword: \'' + ($errorKeyword || '_limit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit: ' + ($schemaValue) + ', exclusive: ' + ($exclusive) + ' } ';
	    if (it.opts.messages !== false) {
	      out += ' , message: \'should be ' + ($opStr) + ' ';
	      if ($isData) {
	        out += '\' + ' + ($schemaValue);
	      } else {
	        out += '' + ($schemaValue) + '\'';
	      }
	    }
	    if (it.opts.verbose) {
	      out += ' , schema:  ';
	      if ($isData) {
	        out += 'validate.schema' + ($schemaPath);
	      } else {
	        out += '' + ($schema);
	      }
	      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	    }
	    out += ' } ';
	  } else {
	    out += ' {} ';
	  }
	  var __err = out;
	  out = $$outStack.pop();
	  if (!it.compositeRule && $breakOnError) {
	    /* istanbul ignore if */
	    if (it.async) {
	      out += ' throw new ValidationError([' + (__err) + ']); ';
	    } else {
	      out += ' validate.errors = [' + (__err) + ']; return false; ';
	    }
	  } else {
	    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	  }
	  out += ' } ';
	  if ($breakOnError) {
	    out += ' else { ';
	  }
	  return out;
	};
	return _limit;
}

var _limitItems;
var hasRequired_limitItems;

function require_limitItems () {
	if (hasRequired_limitItems) return _limitItems;
	hasRequired_limitItems = 1;
	_limitItems = function generate__limitItems(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $errorKeyword;
	  var $data = 'data' + ($dataLvl || '');
	  var $isData = it.opts.$data && $schema && $schema.$data,
	    $schemaValue;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	    $schemaValue = 'schema' + $lvl;
	  } else {
	    $schemaValue = $schema;
	  }
	  if (!($isData || typeof $schema == 'number')) {
	    throw new Error($keyword + ' must be number');
	  }
	  var $op = $keyword == 'maxItems' ? '>' : '<';
	  out += 'if ( ';
	  if ($isData) {
	    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
	  }
	  out += ' ' + ($data) + '.length ' + ($op) + ' ' + ($schemaValue) + ') { ';
	  var $errorKeyword = $keyword;
	  var $$outStack = $$outStack || [];
	  $$outStack.push(out);
	  out = ''; /* istanbul ignore else */
	  if (it.createErrors !== false) {
	    out += ' { keyword: \'' + ($errorKeyword || '_limitItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
	    if (it.opts.messages !== false) {
	      out += ' , message: \'should NOT have ';
	      if ($keyword == 'maxItems') {
	        out += 'more';
	      } else {
	        out += 'fewer';
	      }
	      out += ' than ';
	      if ($isData) {
	        out += '\' + ' + ($schemaValue) + ' + \'';
	      } else {
	        out += '' + ($schema);
	      }
	      out += ' items\' ';
	    }
	    if (it.opts.verbose) {
	      out += ' , schema:  ';
	      if ($isData) {
	        out += 'validate.schema' + ($schemaPath);
	      } else {
	        out += '' + ($schema);
	      }
	      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	    }
	    out += ' } ';
	  } else {
	    out += ' {} ';
	  }
	  var __err = out;
	  out = $$outStack.pop();
	  if (!it.compositeRule && $breakOnError) {
	    /* istanbul ignore if */
	    if (it.async) {
	      out += ' throw new ValidationError([' + (__err) + ']); ';
	    } else {
	      out += ' validate.errors = [' + (__err) + ']; return false; ';
	    }
	  } else {
	    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	  }
	  out += '} ';
	  if ($breakOnError) {
	    out += ' else { ';
	  }
	  return out;
	};
	return _limitItems;
}

var _limitLength;
var hasRequired_limitLength;

function require_limitLength () {
	if (hasRequired_limitLength) return _limitLength;
	hasRequired_limitLength = 1;
	_limitLength = function generate__limitLength(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $errorKeyword;
	  var $data = 'data' + ($dataLvl || '');
	  var $isData = it.opts.$data && $schema && $schema.$data,
	    $schemaValue;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	    $schemaValue = 'schema' + $lvl;
	  } else {
	    $schemaValue = $schema;
	  }
	  if (!($isData || typeof $schema == 'number')) {
	    throw new Error($keyword + ' must be number');
	  }
	  var $op = $keyword == 'maxLength' ? '>' : '<';
	  out += 'if ( ';
	  if ($isData) {
	    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
	  }
	  if (it.opts.unicode === false) {
	    out += ' ' + ($data) + '.length ';
	  } else {
	    out += ' ucs2length(' + ($data) + ') ';
	  }
	  out += ' ' + ($op) + ' ' + ($schemaValue) + ') { ';
	  var $errorKeyword = $keyword;
	  var $$outStack = $$outStack || [];
	  $$outStack.push(out);
	  out = ''; /* istanbul ignore else */
	  if (it.createErrors !== false) {
	    out += ' { keyword: \'' + ($errorKeyword || '_limitLength') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
	    if (it.opts.messages !== false) {
	      out += ' , message: \'should NOT be ';
	      if ($keyword == 'maxLength') {
	        out += 'longer';
	      } else {
	        out += 'shorter';
	      }
	      out += ' than ';
	      if ($isData) {
	        out += '\' + ' + ($schemaValue) + ' + \'';
	      } else {
	        out += '' + ($schema);
	      }
	      out += ' characters\' ';
	    }
	    if (it.opts.verbose) {
	      out += ' , schema:  ';
	      if ($isData) {
	        out += 'validate.schema' + ($schemaPath);
	      } else {
	        out += '' + ($schema);
	      }
	      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	    }
	    out += ' } ';
	  } else {
	    out += ' {} ';
	  }
	  var __err = out;
	  out = $$outStack.pop();
	  if (!it.compositeRule && $breakOnError) {
	    /* istanbul ignore if */
	    if (it.async) {
	      out += ' throw new ValidationError([' + (__err) + ']); ';
	    } else {
	      out += ' validate.errors = [' + (__err) + ']; return false; ';
	    }
	  } else {
	    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	  }
	  out += '} ';
	  if ($breakOnError) {
	    out += ' else { ';
	  }
	  return out;
	};
	return _limitLength;
}

var _limitProperties;
var hasRequired_limitProperties;

function require_limitProperties () {
	if (hasRequired_limitProperties) return _limitProperties;
	hasRequired_limitProperties = 1;
	_limitProperties = function generate__limitProperties(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $errorKeyword;
	  var $data = 'data' + ($dataLvl || '');
	  var $isData = it.opts.$data && $schema && $schema.$data,
	    $schemaValue;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	    $schemaValue = 'schema' + $lvl;
	  } else {
	    $schemaValue = $schema;
	  }
	  if (!($isData || typeof $schema == 'number')) {
	    throw new Error($keyword + ' must be number');
	  }
	  var $op = $keyword == 'maxProperties' ? '>' : '<';
	  out += 'if ( ';
	  if ($isData) {
	    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
	  }
	  out += ' Object.keys(' + ($data) + ').length ' + ($op) + ' ' + ($schemaValue) + ') { ';
	  var $errorKeyword = $keyword;
	  var $$outStack = $$outStack || [];
	  $$outStack.push(out);
	  out = ''; /* istanbul ignore else */
	  if (it.createErrors !== false) {
	    out += ' { keyword: \'' + ($errorKeyword || '_limitProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
	    if (it.opts.messages !== false) {
	      out += ' , message: \'should NOT have ';
	      if ($keyword == 'maxProperties') {
	        out += 'more';
	      } else {
	        out += 'fewer';
	      }
	      out += ' than ';
	      if ($isData) {
	        out += '\' + ' + ($schemaValue) + ' + \'';
	      } else {
	        out += '' + ($schema);
	      }
	      out += ' properties\' ';
	    }
	    if (it.opts.verbose) {
	      out += ' , schema:  ';
	      if ($isData) {
	        out += 'validate.schema' + ($schemaPath);
	      } else {
	        out += '' + ($schema);
	      }
	      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	    }
	    out += ' } ';
	  } else {
	    out += ' {} ';
	  }
	  var __err = out;
	  out = $$outStack.pop();
	  if (!it.compositeRule && $breakOnError) {
	    /* istanbul ignore if */
	    if (it.async) {
	      out += ' throw new ValidationError([' + (__err) + ']); ';
	    } else {
	      out += ' validate.errors = [' + (__err) + ']; return false; ';
	    }
	  } else {
	    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	  }
	  out += '} ';
	  if ($breakOnError) {
	    out += ' else { ';
	  }
	  return out;
	};
	return _limitProperties;
}

var multipleOf;
var hasRequiredMultipleOf;

function requireMultipleOf () {
	if (hasRequiredMultipleOf) return multipleOf;
	hasRequiredMultipleOf = 1;
	multipleOf = function generate_multipleOf(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $isData = it.opts.$data && $schema && $schema.$data,
	    $schemaValue;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	    $schemaValue = 'schema' + $lvl;
	  } else {
	    $schemaValue = $schema;
	  }
	  if (!($isData || typeof $schema == 'number')) {
	    throw new Error($keyword + ' must be number');
	  }
	  out += 'var division' + ($lvl) + ';if (';
	  if ($isData) {
	    out += ' ' + ($schemaValue) + ' !== undefined && ( typeof ' + ($schemaValue) + ' != \'number\' || ';
	  }
	  out += ' (division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schemaValue) + ', ';
	  if (it.opts.multipleOfPrecision) {
	    out += ' Math.abs(Math.round(division' + ($lvl) + ') - division' + ($lvl) + ') > 1e-' + (it.opts.multipleOfPrecision) + ' ';
	  } else {
	    out += ' division' + ($lvl) + ' !== parseInt(division' + ($lvl) + ') ';
	  }
	  out += ' ) ';
	  if ($isData) {
	    out += '  )  ';
	  }
	  out += ' ) {   ';
	  var $$outStack = $$outStack || [];
	  $$outStack.push(out);
	  out = ''; /* istanbul ignore else */
	  if (it.createErrors !== false) {
	    out += ' { keyword: \'' + ('multipleOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { multipleOf: ' + ($schemaValue) + ' } ';
	    if (it.opts.messages !== false) {
	      out += ' , message: \'should be multiple of ';
	      if ($isData) {
	        out += '\' + ' + ($schemaValue);
	      } else {
	        out += '' + ($schemaValue) + '\'';
	      }
	    }
	    if (it.opts.verbose) {
	      out += ' , schema:  ';
	      if ($isData) {
	        out += 'validate.schema' + ($schemaPath);
	      } else {
	        out += '' + ($schema);
	      }
	      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	    }
	    out += ' } ';
	  } else {
	    out += ' {} ';
	  }
	  var __err = out;
	  out = $$outStack.pop();
	  if (!it.compositeRule && $breakOnError) {
	    /* istanbul ignore if */
	    if (it.async) {
	      out += ' throw new ValidationError([' + (__err) + ']); ';
	    } else {
	      out += ' validate.errors = [' + (__err) + ']; return false; ';
	    }
	  } else {
	    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	  }
	  out += '} ';
	  if ($breakOnError) {
	    out += ' else { ';
	  }
	  return out;
	};
	return multipleOf;
}

var not;
var hasRequiredNot;

function requireNot () {
	if (hasRequiredNot) return not;
	hasRequiredNot = 1;
	not = function generate_not(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $errs = 'errs__' + $lvl;
	  var $it = it.util.copy(it);
	  $it.level++;
	  var $nextValid = 'valid' + $it.level;
	  if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {
	    $it.schema = $schema;
	    $it.schemaPath = $schemaPath;
	    $it.errSchemaPath = $errSchemaPath;
	    out += ' var ' + ($errs) + ' = errors;  ';
	    var $wasComposite = it.compositeRule;
	    it.compositeRule = $it.compositeRule = true;
	    $it.createErrors = false;
	    var $allErrorsOption;
	    if ($it.opts.allErrors) {
	      $allErrorsOption = $it.opts.allErrors;
	      $it.opts.allErrors = false;
	    }
	    out += ' ' + (it.validate($it)) + ' ';
	    $it.createErrors = true;
	    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
	    it.compositeRule = $it.compositeRule = $wasComposite;
	    out += ' if (' + ($nextValid) + ') {   ';
	    var $$outStack = $$outStack || [];
	    $$outStack.push(out);
	    out = ''; /* istanbul ignore else */
	    if (it.createErrors !== false) {
	      out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
	      if (it.opts.messages !== false) {
	        out += ' , message: \'should NOT be valid\' ';
	      }
	      if (it.opts.verbose) {
	        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	      }
	      out += ' } ';
	    } else {
	      out += ' {} ';
	    }
	    var __err = out;
	    out = $$outStack.pop();
	    if (!it.compositeRule && $breakOnError) {
	      /* istanbul ignore if */
	      if (it.async) {
	        out += ' throw new ValidationError([' + (__err) + ']); ';
	      } else {
	        out += ' validate.errors = [' + (__err) + ']; return false; ';
	      }
	    } else {
	      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	    }
	    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
	    if (it.opts.allErrors) {
	      out += ' } ';
	    }
	  } else {
	    out += '  var err =   '; /* istanbul ignore else */
	    if (it.createErrors !== false) {
	      out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
	      if (it.opts.messages !== false) {
	        out += ' , message: \'should NOT be valid\' ';
	      }
	      if (it.opts.verbose) {
	        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	      }
	      out += ' } ';
	    } else {
	      out += ' {} ';
	    }
	    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	    if ($breakOnError) {
	      out += ' if (false) { ';
	    }
	  }
	  return out;
	};
	return not;
}

var oneOf;
var hasRequiredOneOf;

function requireOneOf () {
	if (hasRequiredOneOf) return oneOf;
	hasRequiredOneOf = 1;
	oneOf = function generate_oneOf(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $valid = 'valid' + $lvl;
	  var $errs = 'errs__' + $lvl;
	  var $it = it.util.copy(it);
	  var $closingBraces = '';
	  $it.level++;
	  var $nextValid = 'valid' + $it.level;
	  var $currentBaseId = $it.baseId,
	    $prevValid = 'prevValid' + $lvl,
	    $passingSchemas = 'passingSchemas' + $lvl;
	  out += 'var ' + ($errs) + ' = errors , ' + ($prevValid) + ' = false , ' + ($valid) + ' = false , ' + ($passingSchemas) + ' = null; ';
	  var $wasComposite = it.compositeRule;
	  it.compositeRule = $it.compositeRule = true;
	  var arr1 = $schema;
	  if (arr1) {
	    var $sch, $i = -1,
	      l1 = arr1.length - 1;
	    while ($i < l1) {
	      $sch = arr1[$i += 1];
	      if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
	        $it.schema = $sch;
	        $it.schemaPath = $schemaPath + '[' + $i + ']';
	        $it.errSchemaPath = $errSchemaPath + '/' + $i;
	        out += '  ' + (it.validate($it)) + ' ';
	        $it.baseId = $currentBaseId;
	      } else {
	        out += ' var ' + ($nextValid) + ' = true; ';
	      }
	      if ($i) {
	        out += ' if (' + ($nextValid) + ' && ' + ($prevValid) + ') { ' + ($valid) + ' = false; ' + ($passingSchemas) + ' = [' + ($passingSchemas) + ', ' + ($i) + ']; } else { ';
	        $closingBraces += '}';
	      }
	      out += ' if (' + ($nextValid) + ') { ' + ($valid) + ' = ' + ($prevValid) + ' = true; ' + ($passingSchemas) + ' = ' + ($i) + '; }';
	    }
	  }
	  it.compositeRule = $it.compositeRule = $wasComposite;
	  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
	  if (it.createErrors !== false) {
	    out += ' { keyword: \'' + ('oneOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { passingSchemas: ' + ($passingSchemas) + ' } ';
	    if (it.opts.messages !== false) {
	      out += ' , message: \'should match exactly one schema in oneOf\' ';
	    }
	    if (it.opts.verbose) {
	      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	    }
	    out += ' } ';
	  } else {
	    out += ' {} ';
	  }
	  out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	  if (!it.compositeRule && $breakOnError) {
	    /* istanbul ignore if */
	    if (it.async) {
	      out += ' throw new ValidationError(vErrors); ';
	    } else {
	      out += ' validate.errors = vErrors; return false; ';
	    }
	  }
	  out += '} else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';
	  if (it.opts.allErrors) {
	    out += ' } ';
	  }
	  return out;
	};
	return oneOf;
}

var pattern;
var hasRequiredPattern;

function requirePattern () {
	if (hasRequiredPattern) return pattern;
	hasRequiredPattern = 1;
	pattern = function generate_pattern(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $isData = it.opts.$data && $schema && $schema.$data,
	    $schemaValue;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	    $schemaValue = 'schema' + $lvl;
	  } else {
	    $schemaValue = $schema;
	  }
	  var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);
	  out += 'if ( ';
	  if ($isData) {
	    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
	  }
	  out += ' !' + ($regexp) + '.test(' + ($data) + ') ) {   ';
	  var $$outStack = $$outStack || [];
	  $$outStack.push(out);
	  out = ''; /* istanbul ignore else */
	  if (it.createErrors !== false) {
	    out += ' { keyword: \'' + ('pattern') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { pattern:  ';
	    if ($isData) {
	      out += '' + ($schemaValue);
	    } else {
	      out += '' + (it.util.toQuotedString($schema));
	    }
	    out += '  } ';
	    if (it.opts.messages !== false) {
	      out += ' , message: \'should match pattern "';
	      if ($isData) {
	        out += '\' + ' + ($schemaValue) + ' + \'';
	      } else {
	        out += '' + (it.util.escapeQuotes($schema));
	      }
	      out += '"\' ';
	    }
	    if (it.opts.verbose) {
	      out += ' , schema:  ';
	      if ($isData) {
	        out += 'validate.schema' + ($schemaPath);
	      } else {
	        out += '' + (it.util.toQuotedString($schema));
	      }
	      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	    }
	    out += ' } ';
	  } else {
	    out += ' {} ';
	  }
	  var __err = out;
	  out = $$outStack.pop();
	  if (!it.compositeRule && $breakOnError) {
	    /* istanbul ignore if */
	    if (it.async) {
	      out += ' throw new ValidationError([' + (__err) + ']); ';
	    } else {
	      out += ' validate.errors = [' + (__err) + ']; return false; ';
	    }
	  } else {
	    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	  }
	  out += '} ';
	  if ($breakOnError) {
	    out += ' else { ';
	  }
	  return out;
	};
	return pattern;
}

var properties$l;
var hasRequiredProperties;

function requireProperties () {
	if (hasRequiredProperties) return properties$l;
	hasRequiredProperties = 1;
	properties$l = function generate_properties(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $errs = 'errs__' + $lvl;
	  var $it = it.util.copy(it);
	  var $closingBraces = '';
	  $it.level++;
	  var $nextValid = 'valid' + $it.level;
	  var $key = 'key' + $lvl,
	    $idx = 'idx' + $lvl,
	    $dataNxt = $it.dataLevel = it.dataLevel + 1,
	    $nextData = 'data' + $dataNxt,
	    $dataProperties = 'dataProperties' + $lvl;
	  var $schemaKeys = Object.keys($schema || {}).filter(notProto),
	    $pProperties = it.schema.patternProperties || {},
	    $pPropertyKeys = Object.keys($pProperties).filter(notProto),
	    $aProperties = it.schema.additionalProperties,
	    $someProperties = $schemaKeys.length || $pPropertyKeys.length,
	    $noAdditional = $aProperties === false,
	    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,
	    $removeAdditional = it.opts.removeAdditional,
	    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
	    $ownProperties = it.opts.ownProperties,
	    $currentBaseId = it.baseId;
	  var $required = it.schema.required;
	  if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
	    var $requiredHash = it.util.toHash($required);
	  }

	  function notProto(p) {
	    return p !== '__proto__';
	  }
	  out += 'var ' + ($errs) + ' = errors;var ' + ($nextValid) + ' = true;';
	  if ($ownProperties) {
	    out += ' var ' + ($dataProperties) + ' = undefined;';
	  }
	  if ($checkAdditional) {
	    if ($ownProperties) {
	      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
	    } else {
	      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
	    }
	    if ($someProperties) {
	      out += ' var isAdditional' + ($lvl) + ' = !(false ';
	      if ($schemaKeys.length) {
	        if ($schemaKeys.length > 8) {
	          out += ' || validate.schema' + ($schemaPath) + '.hasOwnProperty(' + ($key) + ') ';
	        } else {
	          var arr1 = $schemaKeys;
	          if (arr1) {
	            var $propertyKey, i1 = -1,
	              l1 = arr1.length - 1;
	            while (i1 < l1) {
	              $propertyKey = arr1[i1 += 1];
	              out += ' || ' + ($key) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';
	            }
	          }
	        }
	      }
	      if ($pPropertyKeys.length) {
	        var arr2 = $pPropertyKeys;
	        if (arr2) {
	          var $pProperty, $i = -1,
	            l2 = arr2.length - 1;
	          while ($i < l2) {
	            $pProperty = arr2[$i += 1];
	            out += ' || ' + (it.usePattern($pProperty)) + '.test(' + ($key) + ') ';
	          }
	        }
	      }
	      out += ' ); if (isAdditional' + ($lvl) + ') { ';
	    }
	    if ($removeAdditional == 'all') {
	      out += ' delete ' + ($data) + '[' + ($key) + ']; ';
	    } else {
	      var $currentErrorPath = it.errorPath;
	      var $additionalProperty = '\' + ' + $key + ' + \'';
	      if (it.opts._errorDataPathProperty) {
	        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
	      }
	      if ($noAdditional) {
	        if ($removeAdditional) {
	          out += ' delete ' + ($data) + '[' + ($key) + ']; ';
	        } else {
	          out += ' ' + ($nextValid) + ' = false; ';
	          var $currErrSchemaPath = $errSchemaPath;
	          $errSchemaPath = it.errSchemaPath + '/additionalProperties';
	          var $$outStack = $$outStack || [];
	          $$outStack.push(out);
	          out = ''; /* istanbul ignore else */
	          if (it.createErrors !== false) {
	            out += ' { keyword: \'' + ('additionalProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { additionalProperty: \'' + ($additionalProperty) + '\' } ';
	            if (it.opts.messages !== false) {
	              out += ' , message: \'';
	              if (it.opts._errorDataPathProperty) {
	                out += 'is an invalid additional property';
	              } else {
	                out += 'should NOT have additional properties';
	              }
	              out += '\' ';
	            }
	            if (it.opts.verbose) {
	              out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	            }
	            out += ' } ';
	          } else {
	            out += ' {} ';
	          }
	          var __err = out;
	          out = $$outStack.pop();
	          if (!it.compositeRule && $breakOnError) {
	            /* istanbul ignore if */
	            if (it.async) {
	              out += ' throw new ValidationError([' + (__err) + ']); ';
	            } else {
	              out += ' validate.errors = [' + (__err) + ']; return false; ';
	            }
	          } else {
	            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	          }
	          $errSchemaPath = $currErrSchemaPath;
	          if ($breakOnError) {
	            out += ' break; ';
	          }
	        }
	      } else if ($additionalIsSchema) {
	        if ($removeAdditional == 'failing') {
	          out += ' var ' + ($errs) + ' = errors;  ';
	          var $wasComposite = it.compositeRule;
	          it.compositeRule = $it.compositeRule = true;
	          $it.schema = $aProperties;
	          $it.schemaPath = it.schemaPath + '.additionalProperties';
	          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
	          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
	          var $passData = $data + '[' + $key + ']';
	          $it.dataPathArr[$dataNxt] = $key;
	          var $code = it.validate($it);
	          $it.baseId = $currentBaseId;
	          if (it.util.varOccurences($code, $nextData) < 2) {
	            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
	          } else {
	            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
	          }
	          out += ' if (!' + ($nextValid) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[' + ($key) + ']; }  ';
	          it.compositeRule = $it.compositeRule = $wasComposite;
	        } else {
	          $it.schema = $aProperties;
	          $it.schemaPath = it.schemaPath + '.additionalProperties';
	          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
	          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
	          var $passData = $data + '[' + $key + ']';
	          $it.dataPathArr[$dataNxt] = $key;
	          var $code = it.validate($it);
	          $it.baseId = $currentBaseId;
	          if (it.util.varOccurences($code, $nextData) < 2) {
	            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
	          } else {
	            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
	          }
	          if ($breakOnError) {
	            out += ' if (!' + ($nextValid) + ') break; ';
	          }
	        }
	      }
	      it.errorPath = $currentErrorPath;
	    }
	    if ($someProperties) {
	      out += ' } ';
	    }
	    out += ' }  ';
	    if ($breakOnError) {
	      out += ' if (' + ($nextValid) + ') { ';
	      $closingBraces += '}';
	    }
	  }
	  var $useDefaults = it.opts.useDefaults && !it.compositeRule;
	  if ($schemaKeys.length) {
	    var arr3 = $schemaKeys;
	    if (arr3) {
	      var $propertyKey, i3 = -1,
	        l3 = arr3.length - 1;
	      while (i3 < l3) {
	        $propertyKey = arr3[i3 += 1];
	        var $sch = $schema[$propertyKey];
	        if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
	          var $prop = it.util.getProperty($propertyKey),
	            $passData = $data + $prop,
	            $hasDefault = $useDefaults && $sch.default !== undefined;
	          $it.schema = $sch;
	          $it.schemaPath = $schemaPath + $prop;
	          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
	          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
	          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
	          var $code = it.validate($it);
	          $it.baseId = $currentBaseId;
	          if (it.util.varOccurences($code, $nextData) < 2) {
	            $code = it.util.varReplace($code, $nextData, $passData);
	            var $useData = $passData;
	          } else {
	            var $useData = $nextData;
	            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';
	          }
	          if ($hasDefault) {
	            out += ' ' + ($code) + ' ';
	          } else {
	            if ($requiredHash && $requiredHash[$propertyKey]) {
	              out += ' if ( ' + ($useData) + ' === undefined ';
	              if ($ownProperties) {
	                out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
	              }
	              out += ') { ' + ($nextValid) + ' = false; ';
	              var $currentErrorPath = it.errorPath,
	                $currErrSchemaPath = $errSchemaPath,
	                $missingProperty = it.util.escapeQuotes($propertyKey);
	              if (it.opts._errorDataPathProperty) {
	                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
	              }
	              $errSchemaPath = it.errSchemaPath + '/required';
	              var $$outStack = $$outStack || [];
	              $$outStack.push(out);
	              out = ''; /* istanbul ignore else */
	              if (it.createErrors !== false) {
	                out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
	                if (it.opts.messages !== false) {
	                  out += ' , message: \'';
	                  if (it.opts._errorDataPathProperty) {
	                    out += 'is a required property';
	                  } else {
	                    out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
	                  }
	                  out += '\' ';
	                }
	                if (it.opts.verbose) {
	                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	                }
	                out += ' } ';
	              } else {
	                out += ' {} ';
	              }
	              var __err = out;
	              out = $$outStack.pop();
	              if (!it.compositeRule && $breakOnError) {
	                /* istanbul ignore if */
	                if (it.async) {
	                  out += ' throw new ValidationError([' + (__err) + ']); ';
	                } else {
	                  out += ' validate.errors = [' + (__err) + ']; return false; ';
	                }
	              } else {
	                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	              }
	              $errSchemaPath = $currErrSchemaPath;
	              it.errorPath = $currentErrorPath;
	              out += ' } else { ';
	            } else {
	              if ($breakOnError) {
	                out += ' if ( ' + ($useData) + ' === undefined ';
	                if ($ownProperties) {
	                  out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
	                }
	                out += ') { ' + ($nextValid) + ' = true; } else { ';
	              } else {
	                out += ' if (' + ($useData) + ' !== undefined ';
	                if ($ownProperties) {
	                  out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
	                }
	                out += ' ) { ';
	              }
	            }
	            out += ' ' + ($code) + ' } ';
	          }
	        }
	        if ($breakOnError) {
	          out += ' if (' + ($nextValid) + ') { ';
	          $closingBraces += '}';
	        }
	      }
	    }
	  }
	  if ($pPropertyKeys.length) {
	    var arr4 = $pPropertyKeys;
	    if (arr4) {
	      var $pProperty, i4 = -1,
	        l4 = arr4.length - 1;
	      while (i4 < l4) {
	        $pProperty = arr4[i4 += 1];
	        var $sch = $pProperties[$pProperty];
	        if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
	          $it.schema = $sch;
	          $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
	          $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);
	          if ($ownProperties) {
	            out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
	          } else {
	            out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
	          }
	          out += ' if (' + (it.usePattern($pProperty)) + '.test(' + ($key) + ')) { ';
	          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
	          var $passData = $data + '[' + $key + ']';
	          $it.dataPathArr[$dataNxt] = $key;
	          var $code = it.validate($it);
	          $it.baseId = $currentBaseId;
	          if (it.util.varOccurences($code, $nextData) < 2) {
	            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
	          } else {
	            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
	          }
	          if ($breakOnError) {
	            out += ' if (!' + ($nextValid) + ') break; ';
	          }
	          out += ' } ';
	          if ($breakOnError) {
	            out += ' else ' + ($nextValid) + ' = true; ';
	          }
	          out += ' }  ';
	          if ($breakOnError) {
	            out += ' if (' + ($nextValid) + ') { ';
	            $closingBraces += '}';
	          }
	        }
	      }
	    }
	  }
	  if ($breakOnError) {
	    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
	  }
	  return out;
	};
	return properties$l;
}

var propertyNames;
var hasRequiredPropertyNames;

function requirePropertyNames () {
	if (hasRequiredPropertyNames) return propertyNames;
	hasRequiredPropertyNames = 1;
	propertyNames = function generate_propertyNames(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $errs = 'errs__' + $lvl;
	  var $it = it.util.copy(it);
	  var $closingBraces = '';
	  $it.level++;
	  var $nextValid = 'valid' + $it.level;
	  out += 'var ' + ($errs) + ' = errors;';
	  if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {
	    $it.schema = $schema;
	    $it.schemaPath = $schemaPath;
	    $it.errSchemaPath = $errSchemaPath;
	    var $key = 'key' + $lvl,
	      $idx = 'idx' + $lvl,
	      $i = 'i' + $lvl,
	      $invalidName = '\' + ' + $key + ' + \'',
	      $dataNxt = $it.dataLevel = it.dataLevel + 1,
	      $nextData = 'data' + $dataNxt,
	      $dataProperties = 'dataProperties' + $lvl,
	      $ownProperties = it.opts.ownProperties,
	      $currentBaseId = it.baseId;
	    if ($ownProperties) {
	      out += ' var ' + ($dataProperties) + ' = undefined; ';
	    }
	    if ($ownProperties) {
	      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
	    } else {
	      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
	    }
	    out += ' var startErrs' + ($lvl) + ' = errors; ';
	    var $passData = $key;
	    var $wasComposite = it.compositeRule;
	    it.compositeRule = $it.compositeRule = true;
	    var $code = it.validate($it);
	    $it.baseId = $currentBaseId;
	    if (it.util.varOccurences($code, $nextData) < 2) {
	      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
	    } else {
	      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
	    }
	    it.compositeRule = $it.compositeRule = $wasComposite;
	    out += ' if (!' + ($nextValid) + ') { for (var ' + ($i) + '=startErrs' + ($lvl) + '; ' + ($i) + '<errors; ' + ($i) + '++) { vErrors[' + ($i) + '].propertyName = ' + ($key) + '; }   var err =   '; /* istanbul ignore else */
	    if (it.createErrors !== false) {
	      out += ' { keyword: \'' + ('propertyNames') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { propertyName: \'' + ($invalidName) + '\' } ';
	      if (it.opts.messages !== false) {
	        out += ' , message: \'property name \\\'' + ($invalidName) + '\\\' is invalid\' ';
	      }
	      if (it.opts.verbose) {
	        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	      }
	      out += ' } ';
	    } else {
	      out += ' {} ';
	    }
	    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	    if (!it.compositeRule && $breakOnError) {
	      /* istanbul ignore if */
	      if (it.async) {
	        out += ' throw new ValidationError(vErrors); ';
	      } else {
	        out += ' validate.errors = vErrors; return false; ';
	      }
	    }
	    if ($breakOnError) {
	      out += ' break; ';
	    }
	    out += ' } }';
	  }
	  if ($breakOnError) {
	    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
	  }
	  return out;
	};
	return propertyNames;
}

var required$h;
var hasRequiredRequired;

function requireRequired () {
	if (hasRequiredRequired) return required$h;
	hasRequiredRequired = 1;
	required$h = function generate_required(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $valid = 'valid' + $lvl;
	  var $isData = it.opts.$data && $schema && $schema.$data;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	  }
	  var $vSchema = 'schema' + $lvl;
	  if (!$isData) {
	    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
	      var $required = [];
	      var arr1 = $schema;
	      if (arr1) {
	        var $property, i1 = -1,
	          l1 = arr1.length - 1;
	        while (i1 < l1) {
	          $property = arr1[i1 += 1];
	          var $propertySch = it.schema.properties[$property];
	          if (!($propertySch && (it.opts.strictKeywords ? (typeof $propertySch == 'object' && Object.keys($propertySch).length > 0) || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
	            $required[$required.length] = $property;
	          }
	        }
	      }
	    } else {
	      var $required = $schema;
	    }
	  }
	  if ($isData || $required.length) {
	    var $currentErrorPath = it.errorPath,
	      $loopRequired = $isData || $required.length >= it.opts.loopRequired,
	      $ownProperties = it.opts.ownProperties;
	    if ($breakOnError) {
	      out += ' var missing' + ($lvl) + '; ';
	      if ($loopRequired) {
	        if (!$isData) {
	          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
	        }
	        var $i = 'i' + $lvl,
	          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
	          $missingProperty = '\' + ' + $propertyPath + ' + \'';
	        if (it.opts._errorDataPathProperty) {
	          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
	        }
	        out += ' var ' + ($valid) + ' = true; ';
	        if ($isData) {
	          out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
	        }
	        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { ' + ($valid) + ' = ' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] !== undefined ';
	        if ($ownProperties) {
	          out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
	        }
	        out += '; if (!' + ($valid) + ') break; } ';
	        if ($isData) {
	          out += '  }  ';
	        }
	        out += '  if (!' + ($valid) + ') {   ';
	        var $$outStack = $$outStack || [];
	        $$outStack.push(out);
	        out = ''; /* istanbul ignore else */
	        if (it.createErrors !== false) {
	          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
	          if (it.opts.messages !== false) {
	            out += ' , message: \'';
	            if (it.opts._errorDataPathProperty) {
	              out += 'is a required property';
	            } else {
	              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
	            }
	            out += '\' ';
	          }
	          if (it.opts.verbose) {
	            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	          }
	          out += ' } ';
	        } else {
	          out += ' {} ';
	        }
	        var __err = out;
	        out = $$outStack.pop();
	        if (!it.compositeRule && $breakOnError) {
	          /* istanbul ignore if */
	          if (it.async) {
	            out += ' throw new ValidationError([' + (__err) + ']); ';
	          } else {
	            out += ' validate.errors = [' + (__err) + ']; return false; ';
	          }
	        } else {
	          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	        }
	        out += ' } else { ';
	      } else {
	        out += ' if ( ';
	        var arr2 = $required;
	        if (arr2) {
	          var $propertyKey, $i = -1,
	            l2 = arr2.length - 1;
	          while ($i < l2) {
	            $propertyKey = arr2[$i += 1];
	            if ($i) {
	              out += ' || ';
	            }
	            var $prop = it.util.getProperty($propertyKey),
	              $useData = $data + $prop;
	            out += ' ( ( ' + ($useData) + ' === undefined ';
	            if ($ownProperties) {
	              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
	            }
	            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
	          }
	        }
	        out += ') {  ';
	        var $propertyPath = 'missing' + $lvl,
	          $missingProperty = '\' + ' + $propertyPath + ' + \'';
	        if (it.opts._errorDataPathProperty) {
	          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
	        }
	        var $$outStack = $$outStack || [];
	        $$outStack.push(out);
	        out = ''; /* istanbul ignore else */
	        if (it.createErrors !== false) {
	          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
	          if (it.opts.messages !== false) {
	            out += ' , message: \'';
	            if (it.opts._errorDataPathProperty) {
	              out += 'is a required property';
	            } else {
	              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
	            }
	            out += '\' ';
	          }
	          if (it.opts.verbose) {
	            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	          }
	          out += ' } ';
	        } else {
	          out += ' {} ';
	        }
	        var __err = out;
	        out = $$outStack.pop();
	        if (!it.compositeRule && $breakOnError) {
	          /* istanbul ignore if */
	          if (it.async) {
	            out += ' throw new ValidationError([' + (__err) + ']); ';
	          } else {
	            out += ' validate.errors = [' + (__err) + ']; return false; ';
	          }
	        } else {
	          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	        }
	        out += ' } else { ';
	      }
	    } else {
	      if ($loopRequired) {
	        if (!$isData) {
	          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
	        }
	        var $i = 'i' + $lvl,
	          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
	          $missingProperty = '\' + ' + $propertyPath + ' + \'';
	        if (it.opts._errorDataPathProperty) {
	          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
	        }
	        if ($isData) {
	          out += ' if (' + ($vSchema) + ' && !Array.isArray(' + ($vSchema) + ')) {  var err =   '; /* istanbul ignore else */
	          if (it.createErrors !== false) {
	            out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
	            if (it.opts.messages !== false) {
	              out += ' , message: \'';
	              if (it.opts._errorDataPathProperty) {
	                out += 'is a required property';
	              } else {
	                out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
	              }
	              out += '\' ';
	            }
	            if (it.opts.verbose) {
	              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	            }
	            out += ' } ';
	          } else {
	            out += ' {} ';
	          }
	          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + ($vSchema) + ' !== undefined) { ';
	        }
	        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { if (' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] === undefined ';
	        if ($ownProperties) {
	          out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
	        }
	        out += ') {  var err =   '; /* istanbul ignore else */
	        if (it.createErrors !== false) {
	          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
	          if (it.opts.messages !== false) {
	            out += ' , message: \'';
	            if (it.opts._errorDataPathProperty) {
	              out += 'is a required property';
	            } else {
	              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
	            }
	            out += '\' ';
	          }
	          if (it.opts.verbose) {
	            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	          }
	          out += ' } ';
	        } else {
	          out += ' {} ';
	        }
	        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';
	        if ($isData) {
	          out += '  }  ';
	        }
	      } else {
	        var arr3 = $required;
	        if (arr3) {
	          var $propertyKey, i3 = -1,
	            l3 = arr3.length - 1;
	          while (i3 < l3) {
	            $propertyKey = arr3[i3 += 1];
	            var $prop = it.util.getProperty($propertyKey),
	              $missingProperty = it.util.escapeQuotes($propertyKey),
	              $useData = $data + $prop;
	            if (it.opts._errorDataPathProperty) {
	              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
	            }
	            out += ' if ( ' + ($useData) + ' === undefined ';
	            if ($ownProperties) {
	              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
	            }
	            out += ') {  var err =   '; /* istanbul ignore else */
	            if (it.createErrors !== false) {
	              out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
	              if (it.opts.messages !== false) {
	                out += ' , message: \'';
	                if (it.opts._errorDataPathProperty) {
	                  out += 'is a required property';
	                } else {
	                  out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
	                }
	                out += '\' ';
	              }
	              if (it.opts.verbose) {
	                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	              }
	              out += ' } ';
	            } else {
	              out += ' {} ';
	            }
	            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
	          }
	        }
	      }
	    }
	    it.errorPath = $currentErrorPath;
	  } else if ($breakOnError) {
	    out += ' if (true) {';
	  }
	  return out;
	};
	return required$h;
}

var uniqueItems;
var hasRequiredUniqueItems;

function requireUniqueItems () {
	if (hasRequiredUniqueItems) return uniqueItems;
	hasRequiredUniqueItems = 1;
	uniqueItems = function generate_uniqueItems(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $valid = 'valid' + $lvl;
	  var $isData = it.opts.$data && $schema && $schema.$data,
	    $schemaValue;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	    $schemaValue = 'schema' + $lvl;
	  } else {
	    $schemaValue = $schema;
	  }
	  if (($schema || $isData) && it.opts.uniqueItems !== false) {
	    if ($isData) {
	      out += ' var ' + ($valid) + '; if (' + ($schemaValue) + ' === false || ' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'boolean\') ' + ($valid) + ' = false; else { ';
	    }
	    out += ' var i = ' + ($data) + '.length , ' + ($valid) + ' = true , j; if (i > 1) { ';
	    var $itemType = it.schema.items && it.schema.items.type,
	      $typeIsArray = Array.isArray($itemType);
	    if (!$itemType || $itemType == 'object' || $itemType == 'array' || ($typeIsArray && ($itemType.indexOf('object') >= 0 || $itemType.indexOf('array') >= 0))) {
	      out += ' outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } ';
	    } else {
	      out += ' var itemIndices = {}, item; for (;i--;) { var item = ' + ($data) + '[i]; ';
	      var $method = 'checkDataType' + ($typeIsArray ? 's' : '');
	      out += ' if (' + (it.util[$method]($itemType, 'item', it.opts.strictNumbers, true)) + ') continue; ';
	      if ($typeIsArray) {
	        out += ' if (typeof item == \'string\') item = \'"\' + item; ';
	      }
	      out += ' if (typeof itemIndices[item] == \'number\') { ' + ($valid) + ' = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ';
	    }
	    out += ' } ';
	    if ($isData) {
	      out += '  }  ';
	    }
	    out += ' if (!' + ($valid) + ') {   ';
	    var $$outStack = $$outStack || [];
	    $$outStack.push(out);
	    out = ''; /* istanbul ignore else */
	    if (it.createErrors !== false) {
	      out += ' { keyword: \'' + ('uniqueItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { i: i, j: j } ';
	      if (it.opts.messages !== false) {
	        out += ' , message: \'should NOT have duplicate items (items ## \' + j + \' and \' + i + \' are identical)\' ';
	      }
	      if (it.opts.verbose) {
	        out += ' , schema:  ';
	        if ($isData) {
	          out += 'validate.schema' + ($schemaPath);
	        } else {
	          out += '' + ($schema);
	        }
	        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	      }
	      out += ' } ';
	    } else {
	      out += ' {} ';
	    }
	    var __err = out;
	    out = $$outStack.pop();
	    if (!it.compositeRule && $breakOnError) {
	      /* istanbul ignore if */
	      if (it.async) {
	        out += ' throw new ValidationError([' + (__err) + ']); ';
	      } else {
	        out += ' validate.errors = [' + (__err) + ']; return false; ';
	      }
	    } else {
	      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	    }
	    out += ' } ';
	    if ($breakOnError) {
	      out += ' else { ';
	    }
	  } else {
	    if ($breakOnError) {
	      out += ' if (true) { ';
	    }
	  }
	  return out;
	};
	return uniqueItems;
}

var dotjs;
var hasRequiredDotjs;

function requireDotjs () {
	if (hasRequiredDotjs) return dotjs;
	hasRequiredDotjs = 1;

	//all requires must be explicit because browserify won't work with dynamic requires
	dotjs = {
	  '$ref': requireRef(),
	  allOf: requireAllOf(),
	  anyOf: requireAnyOf(),
	  '$comment': requireComment(),
	  const: require_const(),
	  contains: requireContains(),
	  dependencies: requireDependencies(),
	  'enum': require_enum(),
	  format: requireFormat(),
	  'if': require_if(),
	  items: requireItems(),
	  maximum: require_limit(),
	  minimum: require_limit(),
	  maxItems: require_limitItems(),
	  minItems: require_limitItems(),
	  maxLength: require_limitLength(),
	  minLength: require_limitLength(),
	  maxProperties: require_limitProperties(),
	  minProperties: require_limitProperties(),
	  multipleOf: requireMultipleOf(),
	  not: requireNot(),
	  oneOf: requireOneOf(),
	  pattern: requirePattern(),
	  properties: requireProperties(),
	  propertyNames: requirePropertyNames(),
	  required: requireRequired(),
	  uniqueItems: requireUniqueItems(),
	  validate: requireValidate()
	};
	return dotjs;
}

var rules;
var hasRequiredRules;

function requireRules () {
	if (hasRequiredRules) return rules;
	hasRequiredRules = 1;

	var ruleModules = requireDotjs()
	  , toHash = requireUtil$1().toHash;

	rules = function rules() {
	  var RULES = [
	    { type: 'number',
	      rules: [ { 'maximum': ['exclusiveMaximum'] },
	               { 'minimum': ['exclusiveMinimum'] }, 'multipleOf', 'format'] },
	    { type: 'string',
	      rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] },
	    { type: 'array',
	      rules: [ 'maxItems', 'minItems', 'items', 'contains', 'uniqueItems' ] },
	    { type: 'object',
	      rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames',
	               { 'properties': ['additionalProperties', 'patternProperties'] } ] },
	    { rules: [ '$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf', 'if' ] }
	  ];

	  var ALL = [ 'type', '$comment' ];
	  var KEYWORDS = [
	    '$schema', '$id', 'id', '$data', '$async', 'title',
	    'description', 'default', 'definitions',
	    'examples', 'readOnly', 'writeOnly',
	    'contentMediaType', 'contentEncoding',
	    'additionalItems', 'then', 'else'
	  ];
	  var TYPES = [ 'number', 'integer', 'string', 'array', 'object', 'boolean', 'null' ];
	  RULES.all = toHash(ALL);
	  RULES.types = toHash(TYPES);

	  RULES.forEach(function (group) {
	    group.rules = group.rules.map(function (keyword) {
	      var implKeywords;
	      if (typeof keyword == 'object') {
	        var key = Object.keys(keyword)[0];
	        implKeywords = keyword[key];
	        keyword = key;
	        implKeywords.forEach(function (k) {
	          ALL.push(k);
	          RULES.all[k] = true;
	        });
	      }
	      ALL.push(keyword);
	      var rule = RULES.all[keyword] = {
	        keyword: keyword,
	        code: ruleModules[keyword],
	        implements: implKeywords
	      };
	      return rule;
	    });

	    RULES.all.$comment = {
	      keyword: '$comment',
	      code: ruleModules.$comment
	    };

	    if (group.type) RULES.types[group.type] = group;
	  });

	  RULES.keywords = toHash(ALL.concat(KEYWORDS));
	  RULES.custom = {};

	  return RULES;
	};
	return rules;
}

var data;
var hasRequiredData;

function requireData () {
	if (hasRequiredData) return data;
	hasRequiredData = 1;

	var KEYWORDS = [
	  'multipleOf',
	  'maximum',
	  'exclusiveMaximum',
	  'minimum',
	  'exclusiveMinimum',
	  'maxLength',
	  'minLength',
	  'pattern',
	  'additionalItems',
	  'maxItems',
	  'minItems',
	  'uniqueItems',
	  'maxProperties',
	  'minProperties',
	  'required',
	  'additionalProperties',
	  'enum',
	  'format',
	  'const'
	];

	data = function (metaSchema, keywordsJsonPointers) {
	  for (var i=0; i<keywordsJsonPointers.length; i++) {
	    metaSchema = JSON.parse(JSON.stringify(metaSchema));
	    var segments = keywordsJsonPointers[i].split('/');
	    var keywords = metaSchema;
	    var j;
	    for (j=1; j<segments.length; j++)
	      keywords = keywords[segments[j]];

	    for (j=0; j<KEYWORDS.length; j++) {
	      var key = KEYWORDS[j];
	      var schema = keywords[key];
	      if (schema) {
	        keywords[key] = {
	          anyOf: [
	            schema,
	            { $ref: 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#' }
	          ]
	        };
	      }
	    }
	  }

	  return metaSchema;
	};
	return data;
}

var async;
var hasRequiredAsync;

function requireAsync () {
	if (hasRequiredAsync) return async;
	hasRequiredAsync = 1;

	var MissingRefError = requireError_classes().MissingRef;

	async = compileAsync;


	/**
	 * Creates validating function for passed schema with asynchronous loading of missing schemas.
	 * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
	 * @this  Ajv
	 * @param {Object}   schema schema object
	 * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
	 * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
	 * @return {Promise} promise that resolves with a validating function.
	 */
	function compileAsync(schema, meta, callback) {
	  /* eslint no-shadow: 0 */
	  /* global Promise */
	  /* jshint validthis: true */
	  var self = this;
	  if (typeof this._opts.loadSchema != 'function')
	    throw new Error('options.loadSchema should be a function');

	  if (typeof meta == 'function') {
	    callback = meta;
	    meta = undefined;
	  }

	  var p = loadMetaSchemaOf(schema).then(function () {
	    var schemaObj = self._addSchema(schema, undefined, meta);
	    return schemaObj.validate || _compileAsync(schemaObj);
	  });

	  if (callback) {
	    p.then(
	      function(v) { callback(null, v); },
	      callback
	    );
	  }

	  return p;


	  function loadMetaSchemaOf(sch) {
	    var $schema = sch.$schema;
	    return $schema && !self.getSchema($schema)
	            ? compileAsync.call(self, { $ref: $schema }, true)
	            : Promise.resolve();
	  }


	  function _compileAsync(schemaObj) {
	    try { return self._compile(schemaObj); }
	    catch(e) {
	      if (e instanceof MissingRefError) return loadMissingSchema(e);
	      throw e;
	    }


	    function loadMissingSchema(e) {
	      var ref = e.missingSchema;
	      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');

	      var schemaPromise = self._loadingSchemas[ref];
	      if (!schemaPromise) {
	        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
	        schemaPromise.then(removePromise, removePromise);
	      }

	      return schemaPromise.then(function (sch) {
	        if (!added(ref)) {
	          return loadMetaSchemaOf(sch).then(function () {
	            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
	          });
	        }
	      }).then(function() {
	        return _compileAsync(schemaObj);
	      });

	      function removePromise() {
	        delete self._loadingSchemas[ref];
	      }

	      function added(ref) {
	        return self._refs[ref] || self._schemas[ref];
	      }
	    }
	  }
	}
	return async;
}

var custom;
var hasRequiredCustom;

function requireCustom () {
	if (hasRequiredCustom) return custom;
	hasRequiredCustom = 1;
	custom = function generate_custom(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $errorKeyword;
	  var $data = 'data' + ($dataLvl || '');
	  var $valid = 'valid' + $lvl;
	  var $errs = 'errs__' + $lvl;
	  var $isData = it.opts.$data && $schema && $schema.$data,
	    $schemaValue;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	    $schemaValue = 'schema' + $lvl;
	  } else {
	    $schemaValue = $schema;
	  }
	  var $rule = this,
	    $definition = 'definition' + $lvl,
	    $rDef = $rule.definition,
	    $closingBraces = '';
	  var $compile, $inline, $macro, $ruleValidate, $validateCode;
	  if ($isData && $rDef.$data) {
	    $validateCode = 'keywordValidate' + $lvl;
	    var $validateSchema = $rDef.validateSchema;
	    out += ' var ' + ($definition) + ' = RULES.custom[\'' + ($keyword) + '\'].definition; var ' + ($validateCode) + ' = ' + ($definition) + '.validate;';
	  } else {
	    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
	    if (!$ruleValidate) return;
	    $schemaValue = 'validate.schema' + $schemaPath;
	    $validateCode = $ruleValidate.code;
	    $compile = $rDef.compile;
	    $inline = $rDef.inline;
	    $macro = $rDef.macro;
	  }
	  var $ruleErrs = $validateCode + '.errors',
	    $i = 'i' + $lvl,
	    $ruleErr = 'ruleErr' + $lvl,
	    $asyncKeyword = $rDef.async;
	  if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');
	  if (!($inline || $macro)) {
	    out += '' + ($ruleErrs) + ' = null;';
	  }
	  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
	  if ($isData && $rDef.$data) {
	    $closingBraces += '}';
	    out += ' if (' + ($schemaValue) + ' === undefined) { ' + ($valid) + ' = true; } else { ';
	    if ($validateSchema) {
	      $closingBraces += '}';
	      out += ' ' + ($valid) + ' = ' + ($definition) + '.validateSchema(' + ($schemaValue) + '); if (' + ($valid) + ') { ';
	    }
	  }
	  if ($inline) {
	    if ($rDef.statements) {
	      out += ' ' + ($ruleValidate.validate) + ' ';
	    } else {
	      out += ' ' + ($valid) + ' = ' + ($ruleValidate.validate) + '; ';
	    }
	  } else if ($macro) {
	    var $it = it.util.copy(it);
	    var $closingBraces = '';
	    $it.level++;
	    var $nextValid = 'valid' + $it.level;
	    $it.schema = $ruleValidate.validate;
	    $it.schemaPath = '';
	    var $wasComposite = it.compositeRule;
	    it.compositeRule = $it.compositeRule = true;
	    var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
	    it.compositeRule = $it.compositeRule = $wasComposite;
	    out += ' ' + ($code);
	  } else {
	    var $$outStack = $$outStack || [];
	    $$outStack.push(out);
	    out = '';
	    out += '  ' + ($validateCode) + '.call( ';
	    if (it.opts.passContext) {
	      out += 'this';
	    } else {
	      out += 'self';
	    }
	    if ($compile || $rDef.schema === false) {
	      out += ' , ' + ($data) + ' ';
	    } else {
	      out += ' , ' + ($schemaValue) + ' , ' + ($data) + ' , validate.schema' + (it.schemaPath) + ' ';
	    }
	    out += ' , (dataPath || \'\')';
	    if (it.errorPath != '""') {
	      out += ' + ' + (it.errorPath);
	    }
	    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
	      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
	    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ' , rootData )  ';
	    var def_callRuleValidate = out;
	    out = $$outStack.pop();
	    if ($rDef.errors === false) {
	      out += ' ' + ($valid) + ' = ';
	      if ($asyncKeyword) {
	        out += 'await ';
	      }
	      out += '' + (def_callRuleValidate) + '; ';
	    } else {
	      if ($asyncKeyword) {
	        $ruleErrs = 'customErrors' + $lvl;
	        out += ' var ' + ($ruleErrs) + ' = null; try { ' + ($valid) + ' = await ' + (def_callRuleValidate) + '; } catch (e) { ' + ($valid) + ' = false; if (e instanceof ValidationError) ' + ($ruleErrs) + ' = e.errors; else throw e; } ';
	      } else {
	        out += ' ' + ($ruleErrs) + ' = null; ' + ($valid) + ' = ' + (def_callRuleValidate) + '; ';
	      }
	    }
	  }
	  if ($rDef.modifying) {
	    out += ' if (' + ($parentData) + ') ' + ($data) + ' = ' + ($parentData) + '[' + ($parentDataProperty) + '];';
	  }
	  out += '' + ($closingBraces);
	  if ($rDef.valid) {
	    if ($breakOnError) {
	      out += ' if (true) { ';
	    }
	  } else {
	    out += ' if ( ';
	    if ($rDef.valid === undefined) {
	      out += ' !';
	      if ($macro) {
	        out += '' + ($nextValid);
	      } else {
	        out += '' + ($valid);
	      }
	    } else {
	      out += ' ' + (!$rDef.valid) + ' ';
	    }
	    out += ') { ';
	    $errorKeyword = $rule.keyword;
	    var $$outStack = $$outStack || [];
	    $$outStack.push(out);
	    out = '';
	    var $$outStack = $$outStack || [];
	    $$outStack.push(out);
	    out = ''; /* istanbul ignore else */
	    if (it.createErrors !== false) {
	      out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
	      if (it.opts.messages !== false) {
	        out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
	      }
	      if (it.opts.verbose) {
	        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	      }
	      out += ' } ';
	    } else {
	      out += ' {} ';
	    }
	    var __err = out;
	    out = $$outStack.pop();
	    if (!it.compositeRule && $breakOnError) {
	      /* istanbul ignore if */
	      if (it.async) {
	        out += ' throw new ValidationError([' + (__err) + ']); ';
	      } else {
	        out += ' validate.errors = [' + (__err) + ']; return false; ';
	      }
	    } else {
	      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	    }
	    var def_customError = out;
	    out = $$outStack.pop();
	    if ($inline) {
	      if ($rDef.errors) {
	        if ($rDef.errors != 'full') {
	          out += '  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
	          if (it.opts.verbose) {
	            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
	          }
	          out += ' } ';
	        }
	      } else {
	        if ($rDef.errors === false) {
	          out += ' ' + (def_customError) + ' ';
	        } else {
	          out += ' if (' + ($errs) + ' == errors) { ' + (def_customError) + ' } else {  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
	          if (it.opts.verbose) {
	            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
	          }
	          out += ' } } ';
	        }
	      }
	    } else if ($macro) {
	      out += '   var err =   '; /* istanbul ignore else */
	      if (it.createErrors !== false) {
	        out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
	        if (it.opts.messages !== false) {
	          out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
	        }
	        if (it.opts.verbose) {
	          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	        }
	        out += ' } ';
	      } else {
	        out += ' {} ';
	      }
	      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	      if (!it.compositeRule && $breakOnError) {
	        /* istanbul ignore if */
	        if (it.async) {
	          out += ' throw new ValidationError(vErrors); ';
	        } else {
	          out += ' validate.errors = vErrors; return false; ';
	        }
	      }
	    } else {
	      if ($rDef.errors === false) {
	        out += ' ' + (def_customError) + ' ';
	      } else {
	        out += ' if (Array.isArray(' + ($ruleErrs) + ')) { if (vErrors === null) vErrors = ' + ($ruleErrs) + '; else vErrors = vErrors.concat(' + ($ruleErrs) + '); errors = vErrors.length;  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + ';  ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '";  ';
	        if (it.opts.verbose) {
	          out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
	        }
	        out += ' } } else { ' + (def_customError) + ' } ';
	      }
	    }
	    out += ' } ';
	    if ($breakOnError) {
	      out += ' else { ';
	    }
	  }
	  return out;
	};
	return custom;
}

var $schema$k = "http://json-schema.org/draft-07/schema#";
var $id$k = "http://json-schema.org/draft-07/schema#";
var title$1 = "Core schema meta-schema";
var definitions$1 = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/nonNegativeInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	}
};
var type$i = [
	"object",
	"boolean"
];
var properties$k = {
	$id: {
		type: "string",
		format: "uri-reference"
	},
	$schema: {
		type: "string",
		format: "uri"
	},
	$ref: {
		type: "string",
		format: "uri-reference"
	},
	$comment: {
		type: "string"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": true,
	readOnly: {
		type: "boolean",
		"default": false
	},
	examples: {
		type: "array",
		items: true
	},
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		$ref: "#"
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": true
	},
	maxItems: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	contains: {
		$ref: "#"
	},
	maxProperties: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minProperties: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		$ref: "#"
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		propertyNames: {
			format: "regex"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	propertyNames: {
		$ref: "#"
	},
	"const": true,
	"enum": {
		type: "array",
		items: true,
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	contentMediaType: {
		type: "string"
	},
	contentEncoding: {
		type: "string"
	},
	"if": {
		$ref: "#"
	},
	then: {
		$ref: "#"
	},
	"else": {
		$ref: "#"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
var require$$13$1 = {
	$schema: $schema$k,
	$id: $id$k,
	title: title$1,
	definitions: definitions$1,
	type: type$i,
	properties: properties$k,
	"default": true
};

var definition_schema;
var hasRequiredDefinition_schema;

function requireDefinition_schema () {
	if (hasRequiredDefinition_schema) return definition_schema;
	hasRequiredDefinition_schema = 1;

	var metaSchema = require$$13$1;

	definition_schema = {
	  $id: 'https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js',
	  definitions: {
	    simpleTypes: metaSchema.definitions.simpleTypes
	  },
	  type: 'object',
	  dependencies: {
	    schema: ['validate'],
	    $data: ['validate'],
	    statements: ['inline'],
	    valid: {not: {required: ['macro']}}
	  },
	  properties: {
	    type: metaSchema.properties.type,
	    schema: {type: 'boolean'},
	    statements: {type: 'boolean'},
	    dependencies: {
	      type: 'array',
	      items: {type: 'string'}
	    },
	    metaSchema: {type: 'object'},
	    modifying: {type: 'boolean'},
	    valid: {type: 'boolean'},
	    $data: {type: 'boolean'},
	    async: {type: 'boolean'},
	    errors: {
	      anyOf: [
	        {type: 'boolean'},
	        {const: 'full'}
	      ]
	    }
	  }
	};
	return definition_schema;
}

var keyword;
var hasRequiredKeyword;

function requireKeyword () {
	if (hasRequiredKeyword) return keyword;
	hasRequiredKeyword = 1;

	var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
	var customRuleCode = requireCustom();
	var definitionSchema = requireDefinition_schema();

	keyword = {
	  add: addKeyword,
	  get: getKeyword,
	  remove: removeKeyword,
	  validate: validateKeyword
	};


	/**
	 * Define custom keyword
	 * @this  Ajv
	 * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
	 * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
	 * @return {Ajv} this for method chaining
	 */
	function addKeyword(keyword, definition) {
	  /* jshint validthis: true */
	  /* eslint no-shadow: 0 */
	  var RULES = this.RULES;
	  if (RULES.keywords[keyword])
	    throw new Error('Keyword ' + keyword + ' is already defined');

	  if (!IDENTIFIER.test(keyword))
	    throw new Error('Keyword ' + keyword + ' is not a valid identifier');

	  if (definition) {
	    this.validateKeyword(definition, true);

	    var dataType = definition.type;
	    if (Array.isArray(dataType)) {
	      for (var i=0; i<dataType.length; i++)
	        _addRule(keyword, dataType[i], definition);
	    } else {
	      _addRule(keyword, dataType, definition);
	    }

	    var metaSchema = definition.metaSchema;
	    if (metaSchema) {
	      if (definition.$data && this._opts.$data) {
	        metaSchema = {
	          anyOf: [
	            metaSchema,
	            { '$ref': 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#' }
	          ]
	        };
	      }
	      definition.validateSchema = this.compile(metaSchema, true);
	    }
	  }

	  RULES.keywords[keyword] = RULES.all[keyword] = true;


	  function _addRule(keyword, dataType, definition) {
	    var ruleGroup;
	    for (var i=0; i<RULES.length; i++) {
	      var rg = RULES[i];
	      if (rg.type == dataType) {
	        ruleGroup = rg;
	        break;
	      }
	    }

	    if (!ruleGroup) {
	      ruleGroup = { type: dataType, rules: [] };
	      RULES.push(ruleGroup);
	    }

	    var rule = {
	      keyword: keyword,
	      definition: definition,
	      custom: true,
	      code: customRuleCode,
	      implements: definition.implements
	    };
	    ruleGroup.rules.push(rule);
	    RULES.custom[keyword] = rule;
	  }

	  return this;
	}


	/**
	 * Get keyword
	 * @this  Ajv
	 * @param {String} keyword pre-defined or custom keyword.
	 * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
	 */
	function getKeyword(keyword) {
	  /* jshint validthis: true */
	  var rule = this.RULES.custom[keyword];
	  return rule ? rule.definition : this.RULES.keywords[keyword] || false;
	}


	/**
	 * Remove keyword
	 * @this  Ajv
	 * @param {String} keyword pre-defined or custom keyword.
	 * @return {Ajv} this for method chaining
	 */
	function removeKeyword(keyword) {
	  /* jshint validthis: true */
	  var RULES = this.RULES;
	  delete RULES.keywords[keyword];
	  delete RULES.all[keyword];
	  delete RULES.custom[keyword];
	  for (var i=0; i<RULES.length; i++) {
	    var rules = RULES[i].rules;
	    for (var j=0; j<rules.length; j++) {
	      if (rules[j].keyword == keyword) {
	        rules.splice(j, 1);
	        break;
	      }
	    }
	  }
	  return this;
	}


	/**
	 * Validate keyword definition
	 * @this  Ajv
	 * @param {Object} definition keyword definition object.
	 * @param {Boolean} throwError true to throw exception if definition is invalid
	 * @return {boolean} validation result
	 */
	function validateKeyword(definition, throwError) {
	  validateKeyword.errors = null;
	  var v = this._validateKeyword = this._validateKeyword
	                                  || this.compile(definitionSchema, true);

	  if (v(definition)) return true;
	  validateKeyword.errors = v.errors;
	  if (throwError)
	    throw new Error('custom keyword definition is invalid: '  + this.errorsText(v.errors));
	  else
	    return false;
	}
	return keyword;
}

var $schema$j = "http://json-schema.org/draft-07/schema#";
var $id$j = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
var description$2 = "Meta-schema for $data reference (JSON Schema extension proposal)";
var type$h = "object";
var required$g = [
	"$data"
];
var properties$j = {
	$data: {
		type: "string",
		anyOf: [
			{
				format: "relative-json-pointer"
			},
			{
				format: "json-pointer"
			}
		]
	}
};
var additionalProperties = false;
var require$$12$1 = {
	$schema: $schema$j,
	$id: $id$j,
	description: description$2,
	type: type$h,
	required: required$g,
	properties: properties$j,
	additionalProperties: additionalProperties
};

var ajv;
var hasRequiredAjv;

function requireAjv () {
	if (hasRequiredAjv) return ajv;
	hasRequiredAjv = 1;

	var compileSchema = requireCompile()
	  , resolve = requireResolve()
	  , Cache = requireCache()
	  , SchemaObject = requireSchema_obj()
	  , stableStringify = requireFastJsonStableStringify()
	  , formats = requireFormats()
	  , rules = requireRules()
	  , $dataMetaSchema = requireData()
	  , util = requireUtil$1();

	ajv = Ajv;

	Ajv.prototype.validate = validate;
	Ajv.prototype.compile = compile;
	Ajv.prototype.addSchema = addSchema;
	Ajv.prototype.addMetaSchema = addMetaSchema;
	Ajv.prototype.validateSchema = validateSchema;
	Ajv.prototype.getSchema = getSchema;
	Ajv.prototype.removeSchema = removeSchema;
	Ajv.prototype.addFormat = addFormat;
	Ajv.prototype.errorsText = errorsText;

	Ajv.prototype._addSchema = _addSchema;
	Ajv.prototype._compile = _compile;

	Ajv.prototype.compileAsync = requireAsync();
	var customKeyword = requireKeyword();
	Ajv.prototype.addKeyword = customKeyword.add;
	Ajv.prototype.getKeyword = customKeyword.get;
	Ajv.prototype.removeKeyword = customKeyword.remove;
	Ajv.prototype.validateKeyword = customKeyword.validate;

	var errorClasses = requireError_classes();
	Ajv.ValidationError = errorClasses.Validation;
	Ajv.MissingRefError = errorClasses.MissingRef;
	Ajv.$dataMetaSchema = $dataMetaSchema;

	var META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';

	var META_IGNORE_OPTIONS = [ 'removeAdditional', 'useDefaults', 'coerceTypes', 'strictDefaults' ];
	var META_SUPPORT_DATA = ['/properties'];

	/**
	 * Creates validator instance.
	 * Usage: `Ajv(opts)`
	 * @param {Object} opts optional options
	 * @return {Object} ajv instance
	 */
	function Ajv(opts) {
	  if (!(this instanceof Ajv)) return new Ajv(opts);
	  opts = this._opts = util.copy(opts) || {};
	  setLogger(this);
	  this._schemas = {};
	  this._refs = {};
	  this._fragments = {};
	  this._formats = formats(opts.format);

	  this._cache = opts.cache || new Cache;
	  this._loadingSchemas = {};
	  this._compilations = [];
	  this.RULES = rules();
	  this._getId = chooseGetId(opts);

	  opts.loopRequired = opts.loopRequired || Infinity;
	  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
	  if (opts.serialize === undefined) opts.serialize = stableStringify;
	  this._metaOpts = getMetaSchemaOptions(this);

	  if (opts.formats) addInitialFormats(this);
	  if (opts.keywords) addInitialKeywords(this);
	  addDefaultMetaSchema(this);
	  if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);
	  if (opts.nullable) this.addKeyword('nullable', {metaSchema: {type: 'boolean'}});
	  addInitialSchemas(this);
	}



	/**
	 * Validate data using schema
	 * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
	 * @this   Ajv
	 * @param  {String|Object} schemaKeyRef key, ref or schema object
	 * @param  {Any} data to be validated
	 * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
	 */
	function validate(schemaKeyRef, data) {
	  var v;
	  if (typeof schemaKeyRef == 'string') {
	    v = this.getSchema(schemaKeyRef);
	    if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
	  } else {
	    var schemaObj = this._addSchema(schemaKeyRef);
	    v = schemaObj.validate || this._compile(schemaObj);
	  }

	  var valid = v(data);
	  if (v.$async !== true) this.errors = v.errors;
	  return valid;
	}


	/**
	 * Create validating function for passed schema.
	 * @this   Ajv
	 * @param  {Object} schema schema object
	 * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
	 * @return {Function} validating function
	 */
	function compile(schema, _meta) {
	  var schemaObj = this._addSchema(schema, undefined, _meta);
	  return schemaObj.validate || this._compile(schemaObj);
	}


	/**
	 * Adds schema to the instance.
	 * @this   Ajv
	 * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
	 * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
	 * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
	 * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
	 * @return {Ajv} this for method chaining
	 */
	function addSchema(schema, key, _skipValidation, _meta) {
	  if (Array.isArray(schema)){
	    for (var i=0; i<schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);
	    return this;
	  }
	  var id = this._getId(schema);
	  if (id !== undefined && typeof id != 'string')
	    throw new Error('schema id must be string');
	  key = resolve.normalizeId(key || id);
	  checkUnique(this, key);
	  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
	  return this;
	}


	/**
	 * Add schema that will be used to validate other schemas
	 * options in META_IGNORE_OPTIONS are alway set to false
	 * @this   Ajv
	 * @param {Object} schema schema object
	 * @param {String} key optional schema key
	 * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
	 * @return {Ajv} this for method chaining
	 */
	function addMetaSchema(schema, key, skipValidation) {
	  this.addSchema(schema, key, skipValidation, true);
	  return this;
	}


	/**
	 * Validate schema
	 * @this   Ajv
	 * @param {Object} schema schema to validate
	 * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
	 * @return {Boolean} true if schema is valid
	 */
	function validateSchema(schema, throwOrLogError) {
	  var $schema = schema.$schema;
	  if ($schema !== undefined && typeof $schema != 'string')
	    throw new Error('$schema must be a string');
	  $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
	  if (!$schema) {
	    this.logger.warn('meta-schema not available');
	    this.errors = null;
	    return true;
	  }
	  var valid = this.validate($schema, schema);
	  if (!valid && throwOrLogError) {
	    var message = 'schema is invalid: ' + this.errorsText();
	    if (this._opts.validateSchema == 'log') this.logger.error(message);
	    else throw new Error(message);
	  }
	  return valid;
	}


	function defaultMeta(self) {
	  var meta = self._opts.meta;
	  self._opts.defaultMeta = typeof meta == 'object'
	                            ? self._getId(meta) || meta
	                            : self.getSchema(META_SCHEMA_ID)
	                              ? META_SCHEMA_ID
	                              : undefined;
	  return self._opts.defaultMeta;
	}


	/**
	 * Get compiled schema from the instance by `key` or `ref`.
	 * @this   Ajv
	 * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
	 * @return {Function} schema validating function (with property `schema`).
	 */
	function getSchema(keyRef) {
	  var schemaObj = _getSchemaObj(this, keyRef);
	  switch (typeof schemaObj) {
	    case 'object': return schemaObj.validate || this._compile(schemaObj);
	    case 'string': return this.getSchema(schemaObj);
	    case 'undefined': return _getSchemaFragment(this, keyRef);
	  }
	}


	function _getSchemaFragment(self, ref) {
	  var res = resolve.schema.call(self, { schema: {} }, ref);
	  if (res) {
	    var schema = res.schema
	      , root = res.root
	      , baseId = res.baseId;
	    var v = compileSchema.call(self, schema, root, undefined, baseId);
	    self._fragments[ref] = new SchemaObject({
	      ref: ref,
	      fragment: true,
	      schema: schema,
	      root: root,
	      baseId: baseId,
	      validate: v
	    });
	    return v;
	  }
	}


	function _getSchemaObj(self, keyRef) {
	  keyRef = resolve.normalizeId(keyRef);
	  return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
	}


	/**
	 * Remove cached schema(s).
	 * If no parameter is passed all schemas but meta-schemas are removed.
	 * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
	 * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
	 * @this   Ajv
	 * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
	 * @return {Ajv} this for method chaining
	 */
	function removeSchema(schemaKeyRef) {
	  if (schemaKeyRef instanceof RegExp) {
	    _removeAllSchemas(this, this._schemas, schemaKeyRef);
	    _removeAllSchemas(this, this._refs, schemaKeyRef);
	    return this;
	  }
	  switch (typeof schemaKeyRef) {
	    case 'undefined':
	      _removeAllSchemas(this, this._schemas);
	      _removeAllSchemas(this, this._refs);
	      this._cache.clear();
	      return this;
	    case 'string':
	      var schemaObj = _getSchemaObj(this, schemaKeyRef);
	      if (schemaObj) this._cache.del(schemaObj.cacheKey);
	      delete this._schemas[schemaKeyRef];
	      delete this._refs[schemaKeyRef];
	      return this;
	    case 'object':
	      var serialize = this._opts.serialize;
	      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
	      this._cache.del(cacheKey);
	      var id = this._getId(schemaKeyRef);
	      if (id) {
	        id = resolve.normalizeId(id);
	        delete this._schemas[id];
	        delete this._refs[id];
	      }
	  }
	  return this;
	}


	function _removeAllSchemas(self, schemas, regex) {
	  for (var keyRef in schemas) {
	    var schemaObj = schemas[keyRef];
	    if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
	      self._cache.del(schemaObj.cacheKey);
	      delete schemas[keyRef];
	    }
	  }
	}


	/* @this   Ajv */
	function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
	  if (typeof schema != 'object' && typeof schema != 'boolean')
	    throw new Error('schema should be object or boolean');
	  var serialize = this._opts.serialize;
	  var cacheKey = serialize ? serialize(schema) : schema;
	  var cached = this._cache.get(cacheKey);
	  if (cached) return cached;

	  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;

	  var id = resolve.normalizeId(this._getId(schema));
	  if (id && shouldAddSchema) checkUnique(this, id);

	  var willValidate = this._opts.validateSchema !== false && !skipValidation;
	  var recursiveMeta;
	  if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
	    this.validateSchema(schema, true);

	  var localRefs = resolve.ids.call(this, schema);

	  var schemaObj = new SchemaObject({
	    id: id,
	    schema: schema,
	    localRefs: localRefs,
	    cacheKey: cacheKey,
	    meta: meta
	  });

	  if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;
	  this._cache.put(cacheKey, schemaObj);

	  if (willValidate && recursiveMeta) this.validateSchema(schema, true);

	  return schemaObj;
	}


	/* @this   Ajv */
	function _compile(schemaObj, root) {
	  if (schemaObj.compiling) {
	    schemaObj.validate = callValidate;
	    callValidate.schema = schemaObj.schema;
	    callValidate.errors = null;
	    callValidate.root = root ? root : callValidate;
	    if (schemaObj.schema.$async === true)
	      callValidate.$async = true;
	    return callValidate;
	  }
	  schemaObj.compiling = true;

	  var currentOpts;
	  if (schemaObj.meta) {
	    currentOpts = this._opts;
	    this._opts = this._metaOpts;
	  }

	  var v;
	  try { v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs); }
	  catch(e) {
	    delete schemaObj.validate;
	    throw e;
	  }
	  finally {
	    schemaObj.compiling = false;
	    if (schemaObj.meta) this._opts = currentOpts;
	  }

	  schemaObj.validate = v;
	  schemaObj.refs = v.refs;
	  schemaObj.refVal = v.refVal;
	  schemaObj.root = v.root;
	  return v;


	  /* @this   {*} - custom context, see passContext option */
	  function callValidate() {
	    /* jshint validthis: true */
	    var _validate = schemaObj.validate;
	    var result = _validate.apply(this, arguments);
	    callValidate.errors = _validate.errors;
	    return result;
	  }
	}


	function chooseGetId(opts) {
	  switch (opts.schemaId) {
	    case 'auto': return _get$IdOrId;
	    case 'id': return _getId;
	    default: return _get$Id;
	  }
	}

	/* @this   Ajv */
	function _getId(schema) {
	  if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);
	  return schema.id;
	}

	/* @this   Ajv */
	function _get$Id(schema) {
	  if (schema.id) this.logger.warn('schema id ignored', schema.id);
	  return schema.$id;
	}


	function _get$IdOrId(schema) {
	  if (schema.$id && schema.id && schema.$id != schema.id)
	    throw new Error('schema $id is different from id');
	  return schema.$id || schema.id;
	}


	/**
	 * Convert array of error message objects to string
	 * @this   Ajv
	 * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
	 * @param  {Object} options optional options with properties `separator` and `dataVar`.
	 * @return {String} human readable string with all errors descriptions
	 */
	function errorsText(errors, options) {
	  errors = errors || this.errors;
	  if (!errors) return 'No errors';
	  options = options || {};
	  var separator = options.separator === undefined ? ', ' : options.separator;
	  var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;

	  var text = '';
	  for (var i=0; i<errors.length; i++) {
	    var e = errors[i];
	    if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
	  }
	  return text.slice(0, -separator.length);
	}


	/**
	 * Add custom format
	 * @this   Ajv
	 * @param {String} name format name
	 * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
	 * @return {Ajv} this for method chaining
	 */
	function addFormat(name, format) {
	  if (typeof format == 'string') format = new RegExp(format);
	  this._formats[name] = format;
	  return this;
	}


	function addDefaultMetaSchema(self) {
	  var $dataSchema;
	  if (self._opts.$data) {
	    $dataSchema = require$$12$1;
	    self.addMetaSchema($dataSchema, $dataSchema.$id, true);
	  }
	  if (self._opts.meta === false) return;
	  var metaSchema = require$$13$1;
	  if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
	  self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
	  self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
	}


	function addInitialSchemas(self) {
	  var optsSchemas = self._opts.schemas;
	  if (!optsSchemas) return;
	  if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
	  else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
	}


	function addInitialFormats(self) {
	  for (var name in self._opts.formats) {
	    var format = self._opts.formats[name];
	    self.addFormat(name, format);
	  }
	}


	function addInitialKeywords(self) {
	  for (var name in self._opts.keywords) {
	    var keyword = self._opts.keywords[name];
	    self.addKeyword(name, keyword);
	  }
	}


	function checkUnique(self, id) {
	  if (self._schemas[id] || self._refs[id])
	    throw new Error('schema with key or id "' + id + '" already exists');
	}


	function getMetaSchemaOptions(self) {
	  var metaOpts = util.copy(self._opts);
	  for (var i=0; i<META_IGNORE_OPTIONS.length; i++)
	    delete metaOpts[META_IGNORE_OPTIONS[i]];
	  return metaOpts;
	}


	function setLogger(self) {
	  var logger = self._opts.logger;
	  if (logger === false) {
	    self.logger = {log: noop, warn: noop, error: noop};
	  } else {
	    if (logger === undefined) logger = console;
	    if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error))
	      throw new Error('logger must implement log, warn and error methods');
	    self.logger = logger;
	  }
	}


	function noop() {}
	return ajv;
}

var error;
var hasRequiredError;

function requireError () {
	if (hasRequiredError) return error;
	hasRequiredError = 1;
	function HARError (errors) {
	  var message = 'validation failed';

	  this.name = 'HARError';
	  this.message = message;
	  this.errors = errors;

	  if (typeof Error.captureStackTrace === 'function') {
	    Error.captureStackTrace(this, this.constructor);
	  } else {
	    this.stack = (new Error(message)).stack;
	  }
	}

	HARError.prototype = Error.prototype;

	error = HARError;
	return error;
}

var $id$i = "afterRequest.json#";
var $schema$i = "http://json-schema.org/draft-06/schema#";
var type$g = "object";
var optional$4 = true;
var required$f = [
	"lastAccess",
	"eTag",
	"hitCount"
];
var properties$i = {
	expires: {
		type: "string",
		pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
	},
	lastAccess: {
		type: "string",
		pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
	},
	eTag: {
		type: "string"
	},
	hitCount: {
		type: "integer"
	},
	comment: {
		type: "string"
	}
};
var require$$0 = {
	$id: $id$i,
	$schema: $schema$i,
	type: type$g,
	optional: optional$4,
	required: required$f,
	properties: properties$i
};

var $id$h = "beforeRequest.json#";
var $schema$h = "http://json-schema.org/draft-06/schema#";
var type$f = "object";
var optional$3 = true;
var required$e = [
	"lastAccess",
	"eTag",
	"hitCount"
];
var properties$h = {
	expires: {
		type: "string",
		pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
	},
	lastAccess: {
		type: "string",
		pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
	},
	eTag: {
		type: "string"
	},
	hitCount: {
		type: "integer"
	},
	comment: {
		type: "string"
	}
};
var require$$1$1 = {
	$id: $id$h,
	$schema: $schema$h,
	type: type$f,
	optional: optional$3,
	required: required$e,
	properties: properties$h
};

var $id$g = "browser.json#";
var $schema$g = "http://json-schema.org/draft-06/schema#";
var type$e = "object";
var required$d = [
	"name",
	"version"
];
var properties$g = {
	name: {
		type: "string"
	},
	version: {
		type: "string"
	},
	comment: {
		type: "string"
	}
};
var require$$2 = {
	$id: $id$g,
	$schema: $schema$g,
	type: type$e,
	required: required$d,
	properties: properties$g
};

var $id$f = "cache.json#";
var $schema$f = "http://json-schema.org/draft-06/schema#";
var properties$f = {
	beforeRequest: {
		oneOf: [
			{
				type: "null"
			},
			{
				$ref: "beforeRequest.json#"
			}
		]
	},
	afterRequest: {
		oneOf: [
			{
				type: "null"
			},
			{
				$ref: "afterRequest.json#"
			}
		]
	},
	comment: {
		type: "string"
	}
};
var require$$3$3 = {
	$id: $id$f,
	$schema: $schema$f,
	properties: properties$f
};

var $id$e = "content.json#";
var $schema$e = "http://json-schema.org/draft-06/schema#";
var type$d = "object";
var required$c = [
	"size",
	"mimeType"
];
var properties$e = {
	size: {
		type: "integer"
	},
	compression: {
		type: "integer"
	},
	mimeType: {
		type: "string"
	},
	text: {
		type: "string"
	},
	encoding: {
		type: "string"
	},
	comment: {
		type: "string"
	}
};
var require$$4 = {
	$id: $id$e,
	$schema: $schema$e,
	type: type$d,
	required: required$c,
	properties: properties$e
};

var $id$d = "cookie.json#";
var $schema$d = "http://json-schema.org/draft-06/schema#";
var type$c = "object";
var required$b = [
	"name",
	"value"
];
var properties$d = {
	name: {
		type: "string"
	},
	value: {
		type: "string"
	},
	path: {
		type: "string"
	},
	domain: {
		type: "string"
	},
	expires: {
		type: [
			"string",
			"null"
		],
		format: "date-time"
	},
	httpOnly: {
		type: "boolean"
	},
	secure: {
		type: "boolean"
	},
	comment: {
		type: "string"
	}
};
var require$$5 = {
	$id: $id$d,
	$schema: $schema$d,
	type: type$c,
	required: required$b,
	properties: properties$d
};

var $id$c = "creator.json#";
var $schema$c = "http://json-schema.org/draft-06/schema#";
var type$b = "object";
var required$a = [
	"name",
	"version"
];
var properties$c = {
	name: {
		type: "string"
	},
	version: {
		type: "string"
	},
	comment: {
		type: "string"
	}
};
var require$$6 = {
	$id: $id$c,
	$schema: $schema$c,
	type: type$b,
	required: required$a,
	properties: properties$c
};

var $id$b = "entry.json#";
var $schema$b = "http://json-schema.org/draft-06/schema#";
var type$a = "object";
var optional$2 = true;
var required$9 = [
	"startedDateTime",
	"time",
	"request",
	"response",
	"cache",
	"timings"
];
var properties$b = {
	pageref: {
		type: "string"
	},
	startedDateTime: {
		type: "string",
		format: "date-time",
		pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))"
	},
	time: {
		type: "number",
		min: 0
	},
	request: {
		$ref: "request.json#"
	},
	response: {
		$ref: "response.json#"
	},
	cache: {
		$ref: "cache.json#"
	},
	timings: {
		$ref: "timings.json#"
	},
	serverIPAddress: {
		type: "string",
		oneOf: [
			{
				format: "ipv4"
			},
			{
				format: "ipv6"
			}
		]
	},
	connection: {
		type: "string"
	},
	comment: {
		type: "string"
	}
};
var require$$7 = {
	$id: $id$b,
	$schema: $schema$b,
	type: type$a,
	optional: optional$2,
	required: required$9,
	properties: properties$b
};

var $id$a = "har.json#";
var $schema$a = "http://json-schema.org/draft-06/schema#";
var type$9 = "object";
var required$8 = [
	"log"
];
var properties$a = {
	log: {
		$ref: "log.json#"
	}
};
var require$$8 = {
	$id: $id$a,
	$schema: $schema$a,
	type: type$9,
	required: required$8,
	properties: properties$a
};

var $id$9 = "header.json#";
var $schema$9 = "http://json-schema.org/draft-06/schema#";
var type$8 = "object";
var required$7 = [
	"name",
	"value"
];
var properties$9 = {
	name: {
		type: "string"
	},
	value: {
		type: "string"
	},
	comment: {
		type: "string"
	}
};
var require$$9 = {
	$id: $id$9,
	$schema: $schema$9,
	type: type$8,
	required: required$7,
	properties: properties$9
};

var $id$8 = "log.json#";
var $schema$8 = "http://json-schema.org/draft-06/schema#";
var type$7 = "object";
var required$6 = [
	"version",
	"creator",
	"entries"
];
var properties$8 = {
	version: {
		type: "string"
	},
	creator: {
		$ref: "creator.json#"
	},
	browser: {
		$ref: "browser.json#"
	},
	pages: {
		type: "array",
		items: {
			$ref: "page.json#"
		}
	},
	entries: {
		type: "array",
		items: {
			$ref: "entry.json#"
		}
	},
	comment: {
		type: "string"
	}
};
var require$$10 = {
	$id: $id$8,
	$schema: $schema$8,
	type: type$7,
	required: required$6,
	properties: properties$8
};

var $id$7 = "page.json#";
var $schema$7 = "http://json-schema.org/draft-06/schema#";
var type$6 = "object";
var optional$1 = true;
var required$5 = [
	"startedDateTime",
	"id",
	"title",
	"pageTimings"
];
var properties$7 = {
	startedDateTime: {
		type: "string",
		format: "date-time",
		pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))"
	},
	id: {
		type: "string",
		unique: true
	},
	title: {
		type: "string"
	},
	pageTimings: {
		$ref: "pageTimings.json#"
	},
	comment: {
		type: "string"
	}
};
var require$$11 = {
	$id: $id$7,
	$schema: $schema$7,
	type: type$6,
	optional: optional$1,
	required: required$5,
	properties: properties$7
};

var $id$6 = "pageTimings.json#";
var $schema$6 = "http://json-schema.org/draft-06/schema#";
var type$5 = "object";
var properties$6 = {
	onContentLoad: {
		type: "number",
		min: -1
	},
	onLoad: {
		type: "number",
		min: -1
	},
	comment: {
		type: "string"
	}
};
var require$$12 = {
	$id: $id$6,
	$schema: $schema$6,
	type: type$5,
	properties: properties$6
};

var $id$5 = "postData.json#";
var $schema$5 = "http://json-schema.org/draft-06/schema#";
var type$4 = "object";
var optional = true;
var required$4 = [
	"mimeType"
];
var properties$5 = {
	mimeType: {
		type: "string"
	},
	text: {
		type: "string"
	},
	params: {
		type: "array",
		required: [
			"name"
		],
		properties: {
			name: {
				type: "string"
			},
			value: {
				type: "string"
			},
			fileName: {
				type: "string"
			},
			contentType: {
				type: "string"
			},
			comment: {
				type: "string"
			}
		}
	},
	comment: {
		type: "string"
	}
};
var require$$13 = {
	$id: $id$5,
	$schema: $schema$5,
	type: type$4,
	optional: optional,
	required: required$4,
	properties: properties$5
};

var $id$4 = "query.json#";
var $schema$4 = "http://json-schema.org/draft-06/schema#";
var type$3 = "object";
var required$3 = [
	"name",
	"value"
];
var properties$4 = {
	name: {
		type: "string"
	},
	value: {
		type: "string"
	},
	comment: {
		type: "string"
	}
};
var require$$14 = {
	$id: $id$4,
	$schema: $schema$4,
	type: type$3,
	required: required$3,
	properties: properties$4
};

var $id$3 = "request.json#";
var $schema$3 = "http://json-schema.org/draft-06/schema#";
var type$2 = "object";
var required$2 = [
	"method",
	"url",
	"httpVersion",
	"cookies",
	"headers",
	"queryString",
	"headersSize",
	"bodySize"
];
var properties$3 = {
	method: {
		type: "string"
	},
	url: {
		type: "string",
		format: "uri"
	},
	httpVersion: {
		type: "string"
	},
	cookies: {
		type: "array",
		items: {
			$ref: "cookie.json#"
		}
	},
	headers: {
		type: "array",
		items: {
			$ref: "header.json#"
		}
	},
	queryString: {
		type: "array",
		items: {
			$ref: "query.json#"
		}
	},
	postData: {
		$ref: "postData.json#"
	},
	headersSize: {
		type: "integer"
	},
	bodySize: {
		type: "integer"
	},
	comment: {
		type: "string"
	}
};
var require$$15 = {
	$id: $id$3,
	$schema: $schema$3,
	type: type$2,
	required: required$2,
	properties: properties$3
};

var $id$2 = "response.json#";
var $schema$2 = "http://json-schema.org/draft-06/schema#";
var type$1 = "object";
var required$1 = [
	"status",
	"statusText",
	"httpVersion",
	"cookies",
	"headers",
	"content",
	"redirectURL",
	"headersSize",
	"bodySize"
];
var properties$2 = {
	status: {
		type: "integer"
	},
	statusText: {
		type: "string"
	},
	httpVersion: {
		type: "string"
	},
	cookies: {
		type: "array",
		items: {
			$ref: "cookie.json#"
		}
	},
	headers: {
		type: "array",
		items: {
			$ref: "header.json#"
		}
	},
	content: {
		$ref: "content.json#"
	},
	redirectURL: {
		type: "string"
	},
	headersSize: {
		type: "integer"
	},
	bodySize: {
		type: "integer"
	},
	comment: {
		type: "string"
	}
};
var require$$16 = {
	$id: $id$2,
	$schema: $schema$2,
	type: type$1,
	required: required$1,
	properties: properties$2
};

var $id$1 = "timings.json#";
var $schema$1 = "http://json-schema.org/draft-06/schema#";
var required = [
	"send",
	"wait",
	"receive"
];
var properties$1 = {
	dns: {
		type: "number",
		min: -1
	},
	connect: {
		type: "number",
		min: -1
	},
	blocked: {
		type: "number",
		min: -1
	},
	send: {
		type: "number",
		min: -1
	},
	wait: {
		type: "number",
		min: -1
	},
	receive: {
		type: "number",
		min: -1
	},
	ssl: {
		type: "number",
		min: -1
	},
	comment: {
		type: "string"
	}
};
var require$$17 = {
	$id: $id$1,
	$schema: $schema$1,
	required: required,
	properties: properties$1
};

var lib$5;
var hasRequiredLib$5;

function requireLib$5 () {
	if (hasRequiredLib$5) return lib$5;
	hasRequiredLib$5 = 1;

	lib$5 = {
	  afterRequest: require$$0,
	  beforeRequest: require$$1$1,
	  browser: require$$2,
	  cache: require$$3$3,
	  content: require$$4,
	  cookie: require$$5,
	  creator: require$$6,
	  entry: require$$7,
	  har: require$$8,
	  header: require$$9,
	  log: require$$10,
	  page: require$$11,
	  pageTimings: require$$12,
	  postData: require$$13,
	  query: require$$14,
	  request: require$$15,
	  response: require$$16,
	  timings: require$$17
	};
	return lib$5;
}

var $schema = "http://json-schema.org/draft-06/schema#";
var $id = "http://json-schema.org/draft-06/schema#";
var title = "Core schema meta-schema";
var definitions = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/nonNegativeInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	}
};
var type = [
	"object",
	"boolean"
];
var properties = {
	$id: {
		type: "string",
		format: "uri-reference"
	},
	$schema: {
		type: "string",
		format: "uri"
	},
	$ref: {
		type: "string",
		format: "uri-reference"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": {
	},
	examples: {
		type: "array",
		items: {
		}
	},
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		$ref: "#"
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": {
		}
	},
	maxItems: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	contains: {
		$ref: "#"
	},
	maxProperties: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minProperties: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		$ref: "#"
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	propertyNames: {
		$ref: "#"
	},
	"const": {
	},
	"enum": {
		type: "array",
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
var require$$3$2 = {
	$schema: $schema,
	$id: $id,
	title: title,
	definitions: definitions,
	type: type,
	properties: properties,
	"default": {
}
};

var hasRequiredPromise$1;

function requirePromise$1 () {
	if (hasRequiredPromise$1) return promise$1;
	hasRequiredPromise$1 = 1;
	var Ajv = requireAjv();
	var HARError = requireError();
	var schemas = requireLib$5();

	var ajv;

	function createAjvInstance () {
	  var ajv = new Ajv({
	    allErrors: true
	  });
	  ajv.addMetaSchema(require$$3$2);
	  ajv.addSchema(schemas);

	  return ajv
	}

	function validate (name, data) {
	  data = data || {};

	  // validator config
	  ajv = ajv || createAjvInstance();

	  var validate = ajv.getSchema(name + '.json');

	  return new Promise(function (resolve, reject) {
	    var valid = validate(data);

	    !valid ? reject(new HARError(validate.errors)) : resolve(data);
	  })
	}

	promise$1.afterRequest = function (data) {
	  return validate('afterRequest', data)
	};

	promise$1.beforeRequest = function (data) {
	  return validate('beforeRequest', data)
	};

	promise$1.browser = function (data) {
	  return validate('browser', data)
	};

	promise$1.cache = function (data) {
	  return validate('cache', data)
	};

	promise$1.content = function (data) {
	  return validate('content', data)
	};

	promise$1.cookie = function (data) {
	  return validate('cookie', data)
	};

	promise$1.creator = function (data) {
	  return validate('creator', data)
	};

	promise$1.entry = function (data) {
	  return validate('entry', data)
	};

	promise$1.har = function (data) {
	  return validate('har', data)
	};

	promise$1.header = function (data) {
	  return validate('header', data)
	};

	promise$1.log = function (data) {
	  return validate('log', data)
	};

	promise$1.page = function (data) {
	  return validate('page', data)
	};

	promise$1.pageTimings = function (data) {
	  return validate('pageTimings', data)
	};

	promise$1.postData = function (data) {
	  return validate('postData', data)
	};

	promise$1.query = function (data) {
	  return validate('query', data)
	};

	promise$1.request = function (data) {
	  return validate('request', data)
	};

	promise$1.response = function (data) {
	  return validate('response', data)
	};

	promise$1.timings = function (data) {
	  return validate('timings', data)
	};
	return promise$1;
}

var hasRequiredHar;

function requireHar () {
	if (hasRequiredHar) return har;
	hasRequiredHar = 1;

	var fs = require$$0$8;
	var qs = require$$1$3;
	var validate = requirePromise$1();
	var extend = requireExtend();

	function Har (request) {
	  this.request = request;
	}

	Har.prototype.reducer = function (obj, pair) {
	  // new property ?
	  if (obj[pair.name] === undefined) {
	    obj[pair.name] = pair.value;
	    return obj
	  }

	  // existing? convert to array
	  var arr = [
	    obj[pair.name],
	    pair.value
	  ];

	  obj[pair.name] = arr;

	  return obj
	};

	Har.prototype.prep = function (data) {
	  // construct utility properties
	  data.queryObj = {};
	  data.headersObj = {};
	  data.postData.jsonObj = false;
	  data.postData.paramsObj = false;

	  // construct query objects
	  if (data.queryString && data.queryString.length) {
	    data.queryObj = data.queryString.reduce(this.reducer, {});
	  }

	  // construct headers objects
	  if (data.headers && data.headers.length) {
	    // loweCase header keys
	    data.headersObj = data.headers.reduceRight(function (headers, header) {
	      headers[header.name] = header.value;
	      return headers
	    }, {});
	  }

	  // construct Cookie header
	  if (data.cookies && data.cookies.length) {
	    var cookies = data.cookies.map(function (cookie) {
	      return cookie.name + '=' + cookie.value
	    });

	    if (cookies.length) {
	      data.headersObj.cookie = cookies.join('; ');
	    }
	  }

	  // prep body
	  function some (arr) {
	    return arr.some(function (type) {
	      return data.postData.mimeType.indexOf(type) === 0
	    })
	  }

	  if (some([
	    'multipart/mixed',
	    'multipart/related',
	    'multipart/form-data',
	    'multipart/alternative'])) {
	    // reset values
	    data.postData.mimeType = 'multipart/form-data';
	  } else if (some([
	    'application/x-www-form-urlencoded'])) {
	    if (!data.postData.params) {
	      data.postData.text = '';
	    } else {
	      data.postData.paramsObj = data.postData.params.reduce(this.reducer, {});

	      // always overwrite
	      data.postData.text = qs.stringify(data.postData.paramsObj);
	    }
	  } else if (some([
	    'text/json',
	    'text/x-json',
	    'application/json',
	    'application/x-json'])) {
	    data.postData.mimeType = 'application/json';

	    if (data.postData.text) {
	      try {
	        data.postData.jsonObj = JSON.parse(data.postData.text);
	      } catch (e) {
	        this.request.debug(e);

	        // force back to text/plain
	        data.postData.mimeType = 'text/plain';
	      }
	    }
	  }

	  return data
	};

	Har.prototype.options = function (options) {
	  // skip if no har property defined
	  if (!options.har) {
	    return options
	  }

	  var har = {};
	  extend(har, options.har);

	  // only process the first entry
	  if (har.log && har.log.entries) {
	    har = har.log.entries[0];
	  }

	  // add optional properties to make validation successful
	  har.url = har.url || options.url || options.uri || options.baseUrl || '/';
	  har.httpVersion = har.httpVersion || 'HTTP/1.1';
	  har.queryString = har.queryString || [];
	  har.headers = har.headers || [];
	  har.cookies = har.cookies || [];
	  har.postData = har.postData || {};
	  har.postData.mimeType = har.postData.mimeType || 'application/octet-stream';

	  har.bodySize = 0;
	  har.headersSize = 0;
	  har.postData.size = 0;

	  if (!validate.request(har)) {
	    return options
	  }

	  // clean up and get some utility properties
	  var req = this.prep(har);

	  // construct new options
	  if (req.url) {
	    options.url = req.url;
	  }

	  if (req.method) {
	    options.method = req.method;
	  }

	  if (Object.keys(req.queryObj).length) {
	    options.qs = req.queryObj;
	  }

	  if (Object.keys(req.headersObj).length) {
	    options.headers = req.headersObj;
	  }

	  function test (type) {
	    return req.postData.mimeType.indexOf(type) === 0
	  }
	  if (test('application/x-www-form-urlencoded')) {
	    options.form = req.postData.paramsObj;
	  } else if (test('application/json')) {
	    if (req.postData.jsonObj) {
	      options.body = req.postData.jsonObj;
	      options.json = true;
	    }
	  } else if (test('multipart/form-data')) {
	    options.formData = {};

	    req.postData.params.forEach(function (param) {
	      var attachment = {};

	      if (!param.fileName && !param.contentType) {
	        options.formData[param.name] = param.value;
	        return
	      }

	      // attempt to read from disk!
	      if (param.fileName && !param.value) {
	        attachment.value = fs.createReadStream(param.fileName);
	      } else if (param.value) {
	        attachment.value = param.value;
	      }

	      if (param.fileName) {
	        attachment.options = {
	          filename: param.fileName,
	          contentType: param.contentType ? param.contentType : null
	        };
	      }

	      options.formData[param.name] = attachment;
	    });
	  } else {
	    if (req.postData.text) {
	      options.body = req.postData.text;
	    }
	  }

	  return options
	};

	har.Har = Har;
	return har;
}

var auth = {};

var rng;
var hasRequiredRng;

function requireRng () {
	if (hasRequiredRng) return rng;
	hasRequiredRng = 1;
	// Unique ID creation requires a high quality random # generator.  In node.js
	// this is pretty straight-forward - we use the crypto API.

	var crypto = require$$0$5;

	rng = function nodeRNG() {
	  return crypto.randomBytes(16);
	};
	return rng;
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var bytesToUuid_1;
var hasRequiredBytesToUuid;

function requireBytesToUuid () {
	if (hasRequiredBytesToUuid) return bytesToUuid_1;
	hasRequiredBytesToUuid = 1;
	var byteToHex = [];
	for (var i = 0; i < 256; ++i) {
	  byteToHex[i] = (i + 0x100).toString(16).substr(1);
	}

	function bytesToUuid(buf, offset) {
	  var i = offset || 0;
	  var bth = byteToHex;
	  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
	  return ([
	    bth[buf[i++]], bth[buf[i++]],
	    bth[buf[i++]], bth[buf[i++]], '-',
	    bth[buf[i++]], bth[buf[i++]], '-',
	    bth[buf[i++]], bth[buf[i++]], '-',
	    bth[buf[i++]], bth[buf[i++]], '-',
	    bth[buf[i++]], bth[buf[i++]],
	    bth[buf[i++]], bth[buf[i++]],
	    bth[buf[i++]], bth[buf[i++]]
	  ]).join('');
	}

	bytesToUuid_1 = bytesToUuid;
	return bytesToUuid_1;
}

var v4_1;
var hasRequiredV4;

function requireV4 () {
	if (hasRequiredV4) return v4_1;
	hasRequiredV4 = 1;
	var rng = requireRng();
	var bytesToUuid = requireBytesToUuid();

	function v4(options, buf, offset) {
	  var i = buf && offset || 0;

	  if (typeof(options) == 'string') {
	    buf = options === 'binary' ? new Array(16) : null;
	    options = null;
	  }
	  options = options || {};

	  var rnds = options.random || (options.rng || rng)();

	  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
	  rnds[6] = (rnds[6] & 0x0f) | 0x40;
	  rnds[8] = (rnds[8] & 0x3f) | 0x80;

	  // Copy bytes to buffer, if provided
	  if (buf) {
	    for (var ii = 0; ii < 16; ++ii) {
	      buf[i + ii] = rnds[ii];
	    }
	  }

	  return buf || bytesToUuid(rnds);
	}

	v4_1 = v4;
	return v4_1;
}

var hasRequiredAuth;

function requireAuth () {
	if (hasRequiredAuth) return auth;
	hasRequiredAuth = 1;

	var caseless = requireCaseless();
	var uuid = requireV4();
	var helpers = requireHelpers();

	var md5 = helpers.md5;
	var toBase64 = helpers.toBase64;

	function Auth (request) {
	  // define all public properties here
	  this.request = request;
	  this.hasAuth = false;
	  this.sentAuth = false;
	  this.bearerToken = null;
	  this.user = null;
	  this.pass = null;
	}

	Auth.prototype.basic = function (user, pass, sendImmediately) {
	  var self = this;
	  if (typeof user !== 'string' || (pass !== undefined && typeof pass !== 'string')) {
	    self.request.emit('error', new Error('auth() received invalid user or password'));
	  }
	  self.user = user;
	  self.pass = pass;
	  self.hasAuth = true;
	  var header = user + ':' + (pass || '');
	  if (sendImmediately || typeof sendImmediately === 'undefined') {
	    var authHeader = 'Basic ' + toBase64(header);
	    self.sentAuth = true;
	    return authHeader
	  }
	};

	Auth.prototype.bearer = function (bearer, sendImmediately) {
	  var self = this;
	  self.bearerToken = bearer;
	  self.hasAuth = true;
	  if (sendImmediately || typeof sendImmediately === 'undefined') {
	    if (typeof bearer === 'function') {
	      bearer = bearer();
	    }
	    var authHeader = 'Bearer ' + (bearer || '');
	    self.sentAuth = true;
	    return authHeader
	  }
	};

	Auth.prototype.digest = function (method, path, authHeader) {
	  // TODO: More complete implementation of RFC 2617.
	  //   - handle challenge.domain
	  //   - support qop="auth-int" only
	  //   - handle Authentication-Info (not necessarily?)
	  //   - check challenge.stale (not necessarily?)
	  //   - increase nc (not necessarily?)
	  // For reference:
	  // http://tools.ietf.org/html/rfc2617#section-3
	  // https://github.com/bagder/curl/blob/master/lib/http_digest.c

	  var self = this;

	  var challenge = {};
	  var re = /([a-z0-9_-]+)=(?:"([^"]+)"|([a-z0-9_-]+))/gi;
	  while (true) {
	    var match = re.exec(authHeader);
	    if (!match) {
	      break
	    }
	    challenge[match[1]] = match[2] || match[3];
	  }

	  /**
	   * RFC 2617: handle both MD5 and MD5-sess algorithms.
	   *
	   * If the algorithm directive's value is "MD5" or unspecified, then HA1 is
	   *   HA1=MD5(username:realm:password)
	   * If the algorithm directive's value is "MD5-sess", then HA1 is
	   *   HA1=MD5(MD5(username:realm:password):nonce:cnonce)
	   */
	  var ha1Compute = function (algorithm, user, realm, pass, nonce, cnonce) {
	    var ha1 = md5(user + ':' + realm + ':' + pass);
	    if (algorithm && algorithm.toLowerCase() === 'md5-sess') {
	      return md5(ha1 + ':' + nonce + ':' + cnonce)
	    } else {
	      return ha1
	    }
	  };

	  var qop = /(^|,)\s*auth\s*($|,)/.test(challenge.qop) && 'auth';
	  var nc = qop && '00000001';
	  var cnonce = qop && uuid().replace(/-/g, '');
	  var ha1 = ha1Compute(challenge.algorithm, self.user, challenge.realm, self.pass, challenge.nonce, cnonce);
	  var ha2 = md5(method + ':' + path);
	  var digestResponse = qop
	    ? md5(ha1 + ':' + challenge.nonce + ':' + nc + ':' + cnonce + ':' + qop + ':' + ha2)
	    : md5(ha1 + ':' + challenge.nonce + ':' + ha2);
	  var authValues = {
	    username: self.user,
	    realm: challenge.realm,
	    nonce: challenge.nonce,
	    uri: path,
	    qop: qop,
	    response: digestResponse,
	    nc: nc,
	    cnonce: cnonce,
	    algorithm: challenge.algorithm,
	    opaque: challenge.opaque
	  };

	  authHeader = [];
	  for (var k in authValues) {
	    if (authValues[k]) {
	      if (k === 'qop' || k === 'nc' || k === 'algorithm') {
	        authHeader.push(k + '=' + authValues[k]);
	      } else {
	        authHeader.push(k + '="' + authValues[k] + '"');
	      }
	    }
	  }
	  authHeader = 'Digest ' + authHeader.join(', ');
	  self.sentAuth = true;
	  return authHeader
	};

	Auth.prototype.onRequest = function (user, pass, sendImmediately, bearer) {
	  var self = this;
	  var request = self.request;

	  var authHeader;
	  if (bearer === undefined && user === undefined) {
	    self.request.emit('error', new Error('no auth mechanism defined'));
	  } else if (bearer !== undefined) {
	    authHeader = self.bearer(bearer, sendImmediately);
	  } else {
	    authHeader = self.basic(user, pass, sendImmediately);
	  }
	  if (authHeader) {
	    request.setHeader('authorization', authHeader);
	  }
	};

	Auth.prototype.onResponse = function (response) {
	  var self = this;
	  var request = self.request;

	  if (!self.hasAuth || self.sentAuth) { return null }

	  var c = caseless(response.headers);

	  var authHeader = c.get('www-authenticate');
	  var authVerb = authHeader && authHeader.split(' ')[0].toLowerCase();
	  request.debug('reauth', authVerb);

	  switch (authVerb) {
	    case 'basic':
	      return self.basic(self.user, self.pass, true)

	    case 'bearer':
	      return self.bearer(self.bearerToken, true)

	    case 'digest':
	      return self.digest(request.method, request.path, authHeader)
	  }
	};

	auth.Auth = Auth;
	return auth;
}

var oauth = {};

var oauthSign = {};

var hasRequiredOauthSign;

function requireOauthSign () {
	if (hasRequiredOauthSign) return oauthSign;
	hasRequiredOauthSign = 1;
	var crypto = require$$0$5;

	function sha (key, body, algorithm) {
	  return crypto.createHmac(algorithm, key).update(body).digest('base64')
	}

	function rsa (key, body) {
	  return crypto.createSign('RSA-SHA1').update(body).sign(key, 'base64')
	}

	function rfc3986 (str) {
	  return encodeURIComponent(str)
	    .replace(/!/g,'%21')
	    .replace(/\*/g,'%2A')
	    .replace(/\(/g,'%28')
	    .replace(/\)/g,'%29')
	    .replace(/'/g,'%27')
	}

	// Maps object to bi-dimensional array
	// Converts { foo: 'A', bar: [ 'b', 'B' ]} to
	// [ ['foo', 'A'], ['bar', 'b'], ['bar', 'B'] ]
	function map (obj) {
	  var key, val, arr = [];
	  for (key in obj) {
	    val = obj[key];
	    if (Array.isArray(val))
	      for (var i = 0; i < val.length; i++)
	        arr.push([key, val[i]]);
	    else if (typeof val === 'object')
	      for (var prop in val)
	        arr.push([key + '[' + prop + ']', val[prop]]);
	    else
	      arr.push([key, val]);
	  }
	  return arr
	}

	// Compare function for sort
	function compare (a, b) {
	  return a > b ? 1 : a < b ? -1 : 0
	}

	function generateBase (httpMethod, base_uri, params) {
	  // adapted from https://dev.twitter.com/docs/auth/oauth and 
	  // https://dev.twitter.com/docs/auth/creating-signature

	  // Parameter normalization
	  // http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2
	  var normalized = map(params)
	  // 1.  First, the name and value of each parameter are encoded
	  .map(function (p) {
	    return [ rfc3986(p[0]), rfc3986(p[1] || '') ]
	  })
	  // 2.  The parameters are sorted by name, using ascending byte value
	  //     ordering.  If two or more parameters share the same name, they
	  //     are sorted by their value.
	  .sort(function (a, b) {
	    return compare(a[0], b[0]) || compare(a[1], b[1])
	  })
	  // 3.  The name of each parameter is concatenated to its corresponding
	  //     value using an "=" character (ASCII code 61) as a separator, even
	  //     if the value is empty.
	  .map(function (p) { return p.join('=') })
	   // 4.  The sorted name/value pairs are concatenated together into a
	   //     single string by using an "&" character (ASCII code 38) as
	   //     separator.
	  .join('&');

	  var base = [
	    rfc3986(httpMethod ? httpMethod.toUpperCase() : 'GET'),
	    rfc3986(base_uri),
	    rfc3986(normalized)
	  ].join('&');

	  return base
	}

	function hmacsign (httpMethod, base_uri, params, consumer_secret, token_secret) {
	  var base = generateBase(httpMethod, base_uri, params);
	  var key = [
	    consumer_secret || '',
	    token_secret || ''
	  ].map(rfc3986).join('&');

	  return sha(key, base, 'sha1')
	}

	function hmacsign256 (httpMethod, base_uri, params, consumer_secret, token_secret) {
	  var base = generateBase(httpMethod, base_uri, params);
	  var key = [
	    consumer_secret || '',
	    token_secret || ''
	  ].map(rfc3986).join('&');

	  return sha(key, base, 'sha256')
	}

	function rsasign (httpMethod, base_uri, params, private_key, token_secret) {
	  var base = generateBase(httpMethod, base_uri, params);
	  var key = private_key || '';

	  return rsa(key, base)
	}

	function plaintext (consumer_secret, token_secret) {
	  var key = [
	    consumer_secret || '',
	    token_secret || ''
	  ].map(rfc3986).join('&');

	  return key
	}

	function sign (signMethod, httpMethod, base_uri, params, consumer_secret, token_secret) {
	  var method;
	  var skipArgs = 1;

	  switch (signMethod) {
	    case 'RSA-SHA1':
	      method = rsasign;
	      break
	    case 'HMAC-SHA1':
	      method = hmacsign;
	      break
	    case 'HMAC-SHA256':
	      method = hmacsign256;
	      break
	    case 'PLAINTEXT':
	      method = plaintext;
	      skipArgs = 4;
	      break
	    default:
	     throw new Error('Signature method not supported: ' + signMethod)
	  }

	  return method.apply(null, [].slice.call(arguments, skipArgs))
	}

	oauthSign.hmacsign = hmacsign;
	oauthSign.hmacsign256 = hmacsign256;
	oauthSign.rsasign = rsasign;
	oauthSign.plaintext = plaintext;
	oauthSign.sign = sign;
	oauthSign.rfc3986 = rfc3986;
	oauthSign.generateBase = generateBase;
	return oauthSign;
}

var hasRequiredOauth;

function requireOauth () {
	if (hasRequiredOauth) return oauth;
	hasRequiredOauth = 1;

	var url = require$$0$2;
	var qs = requireLib$6();
	var caseless = requireCaseless();
	var uuid = requireV4();
	var oauth$1 = requireOauthSign();
	var crypto = require$$0$5;
	var Buffer = requireSafeBuffer$1().Buffer;

	function OAuth (request) {
	  this.request = request;
	  this.params = null;
	}

	OAuth.prototype.buildParams = function (_oauth, uri, method, query, form, qsLib) {
	  var oa = {};
	  for (var i in _oauth) {
	    oa['oauth_' + i] = _oauth[i];
	  }
	  if (!oa.oauth_version) {
	    oa.oauth_version = '1.0';
	  }
	  if (!oa.oauth_timestamp) {
	    oa.oauth_timestamp = Math.floor(Date.now() / 1000).toString();
	  }
	  if (!oa.oauth_nonce) {
	    oa.oauth_nonce = uuid().replace(/-/g, '');
	  }
	  if (!oa.oauth_signature_method) {
	    oa.oauth_signature_method = 'HMAC-SHA1';
	  }

	  var consumer_secret_or_private_key = oa.oauth_consumer_secret || oa.oauth_private_key; // eslint-disable-line camelcase
	  delete oa.oauth_consumer_secret;
	  delete oa.oauth_private_key;

	  var token_secret = oa.oauth_token_secret; // eslint-disable-line camelcase
	  delete oa.oauth_token_secret;

	  var realm = oa.oauth_realm;
	  delete oa.oauth_realm;
	  delete oa.oauth_transport_method;

	  var baseurl = uri.protocol + '//' + uri.host + uri.pathname;
	  var params = qsLib.parse([].concat(query, form, qsLib.stringify(oa)).join('&'));

	  oa.oauth_signature = oauth$1.sign(
	    oa.oauth_signature_method,
	    method,
	    baseurl,
	    params,
	    consumer_secret_or_private_key, // eslint-disable-line camelcase
	    token_secret // eslint-disable-line camelcase
	  );

	  if (realm) {
	    oa.realm = realm;
	  }

	  return oa
	};

	OAuth.prototype.buildBodyHash = function (_oauth, body) {
	  if (['HMAC-SHA1', 'RSA-SHA1'].indexOf(_oauth.signature_method || 'HMAC-SHA1') < 0) {
	    this.request.emit('error', new Error('oauth: ' + _oauth.signature_method +
	      ' signature_method not supported with body_hash signing.'));
	  }

	  var shasum = crypto.createHash('sha1');
	  shasum.update(body || '');
	  var sha1 = shasum.digest('hex');

	  return Buffer.from(sha1, 'hex').toString('base64')
	};

	OAuth.prototype.concatParams = function (oa, sep, wrap) {
	  wrap = wrap || '';

	  var params = Object.keys(oa).filter(function (i) {
	    return i !== 'realm' && i !== 'oauth_signature'
	  }).sort();

	  if (oa.realm) {
	    params.splice(0, 0, 'realm');
	  }
	  params.push('oauth_signature');

	  return params.map(function (i) {
	    return i + '=' + wrap + oauth$1.rfc3986(oa[i]) + wrap
	  }).join(sep)
	};

	OAuth.prototype.onRequest = function (_oauth) {
	  var self = this;
	  self.params = _oauth;

	  var uri = self.request.uri || {};
	  var method = self.request.method || '';
	  var headers = caseless(self.request.headers);
	  var body = self.request.body || '';
	  var qsLib = self.request.qsLib || qs;

	  var form;
	  var query;
	  var contentType = headers.get('content-type') || '';
	  var formContentType = 'application/x-www-form-urlencoded';
	  var transport = _oauth.transport_method || 'header';

	  if (contentType.slice(0, formContentType.length) === formContentType) {
	    contentType = formContentType;
	    form = body;
	  }
	  if (uri.query) {
	    query = uri.query;
	  }
	  if (transport === 'body' && (method !== 'POST' || contentType !== formContentType)) {
	    self.request.emit('error', new Error('oauth: transport_method of body requires POST ' +
	      'and content-type ' + formContentType));
	  }

	  if (!form && typeof _oauth.body_hash === 'boolean') {
	    _oauth.body_hash = self.buildBodyHash(_oauth, self.request.body.toString());
	  }

	  var oa = self.buildParams(_oauth, uri, method, query, form, qsLib);

	  switch (transport) {
	    case 'header':
	      self.request.setHeader('Authorization', 'OAuth ' + self.concatParams(oa, ',', '"'));
	      break

	    case 'query':
	      var href = self.request.uri.href += (query ? '&' : '?') + self.concatParams(oa, '&');
	      self.request.uri = url.parse(href);
	      self.request.path = self.request.uri.path;
	      break

	    case 'body':
	      self.request.body = (form ? form + '&' : '') + self.concatParams(oa, '&');
	      break

	    default:
	      self.request.emit('error', new Error('oauth: transport_method invalid'));
	  }
	};

	oauth.OAuth = OAuth;
	return oauth;
}

var hawk = {};

var hasRequiredHawk;

function requireHawk () {
	if (hasRequiredHawk) return hawk;
	hasRequiredHawk = 1;
	(function (exports) {

		var crypto = require$$0$5;

		function randomString (size) {
		  var bits = (size + 1) * 6;
		  var buffer = crypto.randomBytes(Math.ceil(bits / 8));
		  var string = buffer.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
		  return string.slice(0, size)
		}

		function calculatePayloadHash (payload, algorithm, contentType) {
		  var hash = crypto.createHash(algorithm);
		  hash.update('hawk.1.payload\n');
		  hash.update((contentType ? contentType.split(';')[0].trim().toLowerCase() : '') + '\n');
		  hash.update(payload || '');
		  hash.update('\n');
		  return hash.digest('base64')
		}

		exports.calculateMac = function (credentials, opts) {
		  var normalized = 'hawk.1.header\n' +
		    opts.ts + '\n' +
		    opts.nonce + '\n' +
		    (opts.method || '').toUpperCase() + '\n' +
		    opts.resource + '\n' +
		    opts.host.toLowerCase() + '\n' +
		    opts.port + '\n' +
		    (opts.hash || '') + '\n';

		  if (opts.ext) {
		    normalized = normalized + opts.ext.replace('\\', '\\\\').replace('\n', '\\n');
		  }

		  normalized = normalized + '\n';

		  if (opts.app) {
		    normalized = normalized + opts.app + '\n' + (opts.dlg || '') + '\n';
		  }

		  var hmac = crypto.createHmac(credentials.algorithm, credentials.key).update(normalized);
		  var digest = hmac.digest('base64');
		  return digest
		};

		exports.header = function (uri, method, opts) {
		  var timestamp = opts.timestamp || Math.floor((Date.now() + (opts.localtimeOffsetMsec || 0)) / 1000);
		  var credentials = opts.credentials;
		  if (!credentials || !credentials.id || !credentials.key || !credentials.algorithm) {
		    return ''
		  }

		  if (['sha1', 'sha256'].indexOf(credentials.algorithm) === -1) {
		    return ''
		  }

		  var artifacts = {
		    ts: timestamp,
		    nonce: opts.nonce || randomString(6),
		    method: method,
		    resource: uri.pathname + (uri.search || ''),
		    host: uri.hostname,
		    port: uri.port || (uri.protocol === 'http:' ? 80 : 443),
		    hash: opts.hash,
		    ext: opts.ext,
		    app: opts.app,
		    dlg: opts.dlg
		  };

		  if (!artifacts.hash && (opts.payload || opts.payload === '')) {
		    artifacts.hash = calculatePayloadHash(opts.payload, credentials.algorithm, opts.contentType);
		  }

		  var mac = exports.calculateMac(credentials, artifacts);

		  var hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== '';
		  var header = 'Hawk id="' + credentials.id +
		    '", ts="' + artifacts.ts +
		    '", nonce="' + artifacts.nonce +
		    (artifacts.hash ? '", hash="' + artifacts.hash : '') +
		    (hasExt ? '", ext="' + artifacts.ext.replace(/\\/g, '\\\\').replace(/"/g, '\\"') : '') +
		    '", mac="' + mac + '"';

		  if (artifacts.app) {
		    header = header + ', app="' + artifacts.app + (artifacts.dlg ? '", dlg="' + artifacts.dlg : '') + '"';
		  }

		  return header
		}; 
	} (hawk));
	return hawk;
}

var multipart = {};

var hasRequiredMultipart;

function requireMultipart () {
	if (hasRequiredMultipart) return multipart;
	hasRequiredMultipart = 1;

	var uuid = requireV4();
	var CombinedStream = requireCombined_stream();
	var isstream = requireIsstream();
	var Buffer = requireSafeBuffer$1().Buffer;

	function Multipart (request) {
	  this.request = request;
	  this.boundary = uuid();
	  this.chunked = false;
	  this.body = null;
	}

	Multipart.prototype.isChunked = function (options) {
	  var self = this;
	  var chunked = false;
	  var parts = options.data || options;

	  if (!parts.forEach) {
	    self.request.emit('error', new Error('Argument error, options.multipart.'));
	  }

	  if (options.chunked !== undefined) {
	    chunked = options.chunked;
	  }

	  if (self.request.getHeader('transfer-encoding') === 'chunked') {
	    chunked = true;
	  }

	  if (!chunked) {
	    parts.forEach(function (part) {
	      if (typeof part.body === 'undefined') {
	        self.request.emit('error', new Error('Body attribute missing in multipart.'));
	      }
	      if (isstream(part.body)) {
	        chunked = true;
	      }
	    });
	  }

	  return chunked
	};

	Multipart.prototype.setHeaders = function (chunked) {
	  var self = this;

	  if (chunked && !self.request.hasHeader('transfer-encoding')) {
	    self.request.setHeader('transfer-encoding', 'chunked');
	  }

	  var header = self.request.getHeader('content-type');

	  if (!header || header.indexOf('multipart') === -1) {
	    self.request.setHeader('content-type', 'multipart/related; boundary=' + self.boundary);
	  } else {
	    if (header.indexOf('boundary') !== -1) {
	      self.boundary = header.replace(/.*boundary=([^\s;]+).*/, '$1');
	    } else {
	      self.request.setHeader('content-type', header + '; boundary=' + self.boundary);
	    }
	  }
	};

	Multipart.prototype.build = function (parts, chunked) {
	  var self = this;
	  var body = chunked ? new CombinedStream() : [];

	  function add (part) {
	    if (typeof part === 'number') {
	      part = part.toString();
	    }
	    return chunked ? body.append(part) : body.push(Buffer.from(part))
	  }

	  if (self.request.preambleCRLF) {
	    add('\r\n');
	  }

	  parts.forEach(function (part) {
	    var preamble = '--' + self.boundary + '\r\n';
	    Object.keys(part).forEach(function (key) {
	      if (key === 'body') { return }
	      preamble += key + ': ' + part[key] + '\r\n';
	    });
	    preamble += '\r\n';
	    add(preamble);
	    add(part.body);
	    add('\r\n');
	  });
	  add('--' + self.boundary + '--');

	  if (self.request.postambleCRLF) {
	    add('\r\n');
	  }

	  return body
	};

	Multipart.prototype.onRequest = function (options) {
	  var self = this;

	  var chunked = self.isChunked(options);
	  var parts = options.data || options;

	  self.setHeaders(chunked);
	  self.chunked = chunked;
	  self.body = self.build(parts, chunked);
	};

	multipart.Multipart = Multipart;
	return multipart;
}

var redirect = {};

var hasRequiredRedirect;

function requireRedirect () {
	if (hasRequiredRedirect) return redirect;
	hasRequiredRedirect = 1;

	var url = require$$0$2;
	var isUrl = /^https?:/;

	function Redirect (request) {
	  this.request = request;
	  this.followRedirect = true;
	  this.followRedirects = true;
	  this.followAllRedirects = false;
	  this.followOriginalHttpMethod = false;
	  this.allowRedirect = function () { return true };
	  this.maxRedirects = 10;
	  this.redirects = [];
	  this.redirectsFollowed = 0;
	  this.removeRefererHeader = false;
	}

	Redirect.prototype.onRequest = function (options) {
	  var self = this;

	  if (options.maxRedirects !== undefined) {
	    self.maxRedirects = options.maxRedirects;
	  }
	  if (typeof options.followRedirect === 'function') {
	    self.allowRedirect = options.followRedirect;
	  }
	  if (options.followRedirect !== undefined) {
	    self.followRedirects = !!options.followRedirect;
	  }
	  if (options.followAllRedirects !== undefined) {
	    self.followAllRedirects = options.followAllRedirects;
	  }
	  if (self.followRedirects || self.followAllRedirects) {
	    self.redirects = self.redirects || [];
	  }
	  if (options.removeRefererHeader !== undefined) {
	    self.removeRefererHeader = options.removeRefererHeader;
	  }
	  if (options.followOriginalHttpMethod !== undefined) {
	    self.followOriginalHttpMethod = options.followOriginalHttpMethod;
	  }
	};

	Redirect.prototype.redirectTo = function (response) {
	  var self = this;
	  var request = self.request;

	  var redirectTo = null;
	  if (response.statusCode >= 300 && response.statusCode < 400 && response.caseless.has('location')) {
	    var location = response.caseless.get('location');
	    request.debug('redirect', location);

	    if (self.followAllRedirects) {
	      redirectTo = location;
	    } else if (self.followRedirects) {
	      switch (request.method) {
	        case 'PATCH':
	        case 'PUT':
	        case 'POST':
	        case 'DELETE':
	          // Do not follow redirects
	          break
	        default:
	          redirectTo = location;
	          break
	      }
	    }
	  } else if (response.statusCode === 401) {
	    var authHeader = request._auth.onResponse(response);
	    if (authHeader) {
	      request.setHeader('authorization', authHeader);
	      redirectTo = request.uri;
	    }
	  }
	  return redirectTo
	};

	Redirect.prototype.onResponse = function (response) {
	  var self = this;
	  var request = self.request;

	  var redirectTo = self.redirectTo(response);
	  if (!redirectTo || !self.allowRedirect.call(request, response)) {
	    return false
	  }

	  request.debug('redirect to', redirectTo);

	  // ignore any potential response body.  it cannot possibly be useful
	  // to us at this point.
	  // response.resume should be defined, but check anyway before calling. Workaround for browserify.
	  if (response.resume) {
	    response.resume();
	  }

	  if (self.redirectsFollowed >= self.maxRedirects) {
	    request.emit('error', new Error('Exceeded maxRedirects. Probably stuck in a redirect loop ' + request.uri.href));
	    return false
	  }
	  self.redirectsFollowed += 1;

	  if (!isUrl.test(redirectTo)) {
	    redirectTo = url.resolve(request.uri.href, redirectTo);
	  }

	  var uriPrev = request.uri;
	  request.uri = url.parse(redirectTo);

	  // handle the case where we change protocol from https to http or vice versa
	  if (request.uri.protocol !== uriPrev.protocol) {
	    delete request.agent;
	  }

	  self.redirects.push({ statusCode: response.statusCode, redirectUri: redirectTo });

	  if (self.followAllRedirects && request.method !== 'HEAD' &&
	    response.statusCode !== 401 && response.statusCode !== 307) {
	    request.method = self.followOriginalHttpMethod ? request.method : 'GET';
	  }
	  // request.method = 'GET' // Force all redirects to use GET || commented out fixes #215
	  delete request.src;
	  delete request.req;
	  delete request._started;
	  if (response.statusCode !== 401 && response.statusCode !== 307) {
	    // Remove parameters from the previous response, unless this is the second request
	    // for a server that requires digest authentication.
	    delete request.body;
	    delete request._form;
	    if (request.headers) {
	      request.removeHeader('host');
	      request.removeHeader('content-type');
	      request.removeHeader('content-length');
	      if (request.uri.hostname !== request.originalHost.split(':')[0]) {
	        // Remove authorization if changing hostnames (but not if just
	        // changing ports or protocols).  This matches the behavior of curl:
	        // https://github.com/bagder/curl/blob/6beb0eee/lib/http.c#L710
	        request.removeHeader('authorization');
	      }
	    }
	  }

	  if (!self.removeRefererHeader) {
	    request.setHeader('referer', uriPrev.href);
	  }

	  request.emit('redirect');

	  request.init();

	  return true
	};

	redirect.Redirect = Redirect;
	return redirect;
}

var tunnel = {};

var tunnelAgent = {};

var hasRequiredTunnelAgent;

function requireTunnelAgent () {
	if (hasRequiredTunnelAgent) return tunnelAgent;
	hasRequiredTunnelAgent = 1;

	var tls = require$$3$4
	  , http = require$$2$1
	  , https = require$$4$1
	  , events = require$$4$2
	  , assert = require$$0$7
	  , util = require$$1$2
	  , Buffer = requireSafeBuffer$1().Buffer
	  ;

	tunnelAgent.httpOverHttp = httpOverHttp;
	tunnelAgent.httpsOverHttp = httpsOverHttp;
	tunnelAgent.httpOverHttps = httpOverHttps;
	tunnelAgent.httpsOverHttps = httpsOverHttps;


	function httpOverHttp(options) {
	  var agent = new TunnelingAgent(options);
	  agent.request = http.request;
	  return agent
	}

	function httpsOverHttp(options) {
	  var agent = new TunnelingAgent(options);
	  agent.request = http.request;
	  agent.createSocket = createSecureSocket;
	  agent.defaultPort = 443;
	  return agent
	}

	function httpOverHttps(options) {
	  var agent = new TunnelingAgent(options);
	  agent.request = https.request;
	  return agent
	}

	function httpsOverHttps(options) {
	  var agent = new TunnelingAgent(options);
	  agent.request = https.request;
	  agent.createSocket = createSecureSocket;
	  agent.defaultPort = 443;
	  return agent
	}


	function TunnelingAgent(options) {
	  var self = this;
	  self.options = options || {};
	  self.proxyOptions = self.options.proxy || {};
	  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
	  self.requests = [];
	  self.sockets = [];

	  self.on('free', function onFree(socket, host, port) {
	    for (var i = 0, len = self.requests.length; i < len; ++i) {
	      var pending = self.requests[i];
	      if (pending.host === host && pending.port === port) {
	        // Detect the request to connect same origin server,
	        // reuse the connection.
	        self.requests.splice(i, 1);
	        pending.request.onSocket(socket);
	        return
	      }
	    }
	    socket.destroy();
	    self.removeSocket(socket);
	  });
	}
	util.inherits(TunnelingAgent, events.EventEmitter);

	TunnelingAgent.prototype.addRequest = function addRequest(req, options) {
	  var self = this;

	   // Legacy API: addRequest(req, host, port, path)
	  if (typeof options === 'string') {
	    options = {
	      host: options,
	      port: arguments[2],
	      path: arguments[3]
	    };
	  }

	  if (self.sockets.length >= this.maxSockets) {
	    // We are over limit so we'll add it to the queue.
	    self.requests.push({host: options.host, port: options.port, request: req});
	    return
	  }

	  // If we are under maxSockets create a new one.
	  self.createConnection({host: options.host, port: options.port, request: req});
	};

	TunnelingAgent.prototype.createConnection = function createConnection(pending) {
	  var self = this;

	  self.createSocket(pending, function(socket) {
	    socket.on('free', onFree);
	    socket.on('close', onCloseOrRemove);
	    socket.on('agentRemove', onCloseOrRemove);
	    pending.request.onSocket(socket);

	    function onFree() {
	      self.emit('free', socket, pending.host, pending.port);
	    }

	    function onCloseOrRemove(err) {
	      self.removeSocket(socket);
	      socket.removeListener('free', onFree);
	      socket.removeListener('close', onCloseOrRemove);
	      socket.removeListener('agentRemove', onCloseOrRemove);
	    }
	  });
	};

	TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
	  var self = this;
	  var placeholder = {};
	  self.sockets.push(placeholder);

	  var connectOptions = mergeOptions({}, self.proxyOptions,
	    { method: 'CONNECT'
	    , path: options.host + ':' + options.port
	    , agent: false
	    }
	  );
	  if (connectOptions.proxyAuth) {
	    connectOptions.headers = connectOptions.headers || {};
	    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
	        Buffer.from(connectOptions.proxyAuth).toString('base64');
	  }

	  debug('making CONNECT request');
	  var connectReq = self.request(connectOptions);
	  connectReq.useChunkedEncodingByDefault = false; // for v0.6
	  connectReq.once('response', onResponse); // for v0.6
	  connectReq.once('upgrade', onUpgrade);   // for v0.6
	  connectReq.once('connect', onConnect);   // for v0.7 or later
	  connectReq.once('error', onError);
	  connectReq.end();

	  function onResponse(res) {
	    // Very hacky. This is necessary to avoid http-parser leaks.
	    res.upgrade = true;
	  }

	  function onUpgrade(res, socket, head) {
	    // Hacky.
	    process.nextTick(function() {
	      onConnect(res, socket, head);
	    });
	  }

	  function onConnect(res, socket, head) {
	    connectReq.removeAllListeners();
	    socket.removeAllListeners();

	    if (res.statusCode === 200) {
	      assert.equal(head.length, 0);
	      debug('tunneling connection has established');
	      self.sockets[self.sockets.indexOf(placeholder)] = socket;
	      cb(socket);
	    } else {
	      debug('tunneling socket could not be established, statusCode=%d', res.statusCode);
	      var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode);
	      error.code = 'ECONNRESET';
	      options.request.emit('error', error);
	      self.removeSocket(placeholder);
	    }
	  }

	  function onError(cause) {
	    connectReq.removeAllListeners();

	    debug('tunneling socket could not be established, cause=%s\n', cause.message, cause.stack);
	    var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message);
	    error.code = 'ECONNRESET';
	    options.request.emit('error', error);
	    self.removeSocket(placeholder);
	  }
	};

	TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
	  var pos = this.sockets.indexOf(socket);
	  if (pos === -1) return

	  this.sockets.splice(pos, 1);

	  var pending = this.requests.shift();
	  if (pending) {
	    // If we have pending requests and a socket gets closed a new one
	    // needs to be created to take over in the pool for the one that closed.
	    this.createConnection(pending);
	  }
	};

	function createSecureSocket(options, cb) {
	  var self = this;
	  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
	    // 0 is dummy port for v0.6
	    var secureSocket = tls.connect(0, mergeOptions({}, self.options,
	      { servername: options.host
	      , socket: socket
	      }
	    ));
	    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
	    cb(secureSocket);
	  });
	}


	function mergeOptions(target) {
	  for (var i = 1, len = arguments.length; i < len; ++i) {
	    var overrides = arguments[i];
	    if (typeof overrides === 'object') {
	      var keys = Object.keys(overrides);
	      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
	        var k = keys[j];
	        if (overrides[k] !== undefined) {
	          target[k] = overrides[k];
	        }
	      }
	    }
	  }
	  return target
	}


	var debug;
	if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
	  debug = function() {
	    var args = Array.prototype.slice.call(arguments);
	    if (typeof args[0] === 'string') {
	      args[0] = 'TUNNEL: ' + args[0];
	    } else {
	      args.unshift('TUNNEL:');
	    }
	    console.error.apply(console, args);
	  };
	} else {
	  debug = function() {};
	}
	tunnelAgent.debug = debug; // for test
	return tunnelAgent;
}

var hasRequiredTunnel;

function requireTunnel () {
	if (hasRequiredTunnel) return tunnel;
	hasRequiredTunnel = 1;

	var url = require$$0$2;
	var tunnel$1 = requireTunnelAgent();

	var defaultProxyHeaderWhiteList = [
	  'accept',
	  'accept-charset',
	  'accept-encoding',
	  'accept-language',
	  'accept-ranges',
	  'cache-control',
	  'content-encoding',
	  'content-language',
	  'content-location',
	  'content-md5',
	  'content-range',
	  'content-type',
	  'connection',
	  'date',
	  'expect',
	  'max-forwards',
	  'pragma',
	  'referer',
	  'te',
	  'user-agent',
	  'via'
	];

	var defaultProxyHeaderExclusiveList = [
	  'proxy-authorization'
	];

	function constructProxyHost (uriObject) {
	  var port = uriObject.port;
	  var protocol = uriObject.protocol;
	  var proxyHost = uriObject.hostname + ':';

	  if (port) {
	    proxyHost += port;
	  } else if (protocol === 'https:') {
	    proxyHost += '443';
	  } else {
	    proxyHost += '80';
	  }

	  return proxyHost
	}

	function constructProxyHeaderWhiteList (headers, proxyHeaderWhiteList) {
	  var whiteList = proxyHeaderWhiteList
	    .reduce(function (set, header) {
	      set[header.toLowerCase()] = true;
	      return set
	    }, {});

	  return Object.keys(headers)
	    .filter(function (header) {
	      return whiteList[header.toLowerCase()]
	    })
	    .reduce(function (set, header) {
	      set[header] = headers[header];
	      return set
	    }, {})
	}

	function constructTunnelOptions (request, proxyHeaders) {
	  var proxy = request.proxy;

	  var tunnelOptions = {
	    proxy: {
	      host: proxy.hostname,
	      port: +proxy.port,
	      proxyAuth: proxy.auth,
	      headers: proxyHeaders
	    },
	    headers: request.headers,
	    ca: request.ca,
	    cert: request.cert,
	    key: request.key,
	    passphrase: request.passphrase,
	    pfx: request.pfx,
	    ciphers: request.ciphers,
	    rejectUnauthorized: request.rejectUnauthorized,
	    secureOptions: request.secureOptions,
	    secureProtocol: request.secureProtocol
	  };

	  return tunnelOptions
	}

	function constructTunnelFnName (uri, proxy) {
	  var uriProtocol = (uri.protocol === 'https:' ? 'https' : 'http');
	  var proxyProtocol = (proxy.protocol === 'https:' ? 'Https' : 'Http');
	  return [uriProtocol, proxyProtocol].join('Over')
	}

	function getTunnelFn (request) {
	  var uri = request.uri;
	  var proxy = request.proxy;
	  var tunnelFnName = constructTunnelFnName(uri, proxy);
	  return tunnel$1[tunnelFnName]
	}

	function Tunnel (request) {
	  this.request = request;
	  this.proxyHeaderWhiteList = defaultProxyHeaderWhiteList;
	  this.proxyHeaderExclusiveList = [];
	  if (typeof request.tunnel !== 'undefined') {
	    this.tunnelOverride = request.tunnel;
	  }
	}

	Tunnel.prototype.isEnabled = function () {
	  var self = this;
	  var request = self.request;
	    // Tunnel HTTPS by default. Allow the user to override this setting.

	  // If self.tunnelOverride is set (the user specified a value), use it.
	  if (typeof self.tunnelOverride !== 'undefined') {
	    return self.tunnelOverride
	  }

	  // If the destination is HTTPS, tunnel.
	  if (request.uri.protocol === 'https:') {
	    return true
	  }

	  // Otherwise, do not use tunnel.
	  return false
	};

	Tunnel.prototype.setup = function (options) {
	  var self = this;
	  var request = self.request;

	  options = options || {};

	  if (typeof request.proxy === 'string') {
	    request.proxy = url.parse(request.proxy);
	  }

	  if (!request.proxy || !request.tunnel) {
	    return false
	  }

	  // Setup Proxy Header Exclusive List and White List
	  if (options.proxyHeaderWhiteList) {
	    self.proxyHeaderWhiteList = options.proxyHeaderWhiteList;
	  }
	  if (options.proxyHeaderExclusiveList) {
	    self.proxyHeaderExclusiveList = options.proxyHeaderExclusiveList;
	  }

	  var proxyHeaderExclusiveList = self.proxyHeaderExclusiveList.concat(defaultProxyHeaderExclusiveList);
	  var proxyHeaderWhiteList = self.proxyHeaderWhiteList.concat(proxyHeaderExclusiveList);

	  // Setup Proxy Headers and Proxy Headers Host
	  // Only send the Proxy White Listed Header names
	  var proxyHeaders = constructProxyHeaderWhiteList(request.headers, proxyHeaderWhiteList);
	  proxyHeaders.host = constructProxyHost(request.uri);

	  proxyHeaderExclusiveList.forEach(request.removeHeader, request);

	  // Set Agent from Tunnel Data
	  var tunnelFn = getTunnelFn(request);
	  var tunnelOptions = constructTunnelOptions(request, proxyHeaders);
	  request.agent = tunnelFn(tunnelOptions);

	  return true
	};

	Tunnel.defaultProxyHeaderWhiteList = defaultProxyHeaderWhiteList;
	Tunnel.defaultProxyHeaderExclusiveList = defaultProxyHeaderExclusiveList;
	tunnel.Tunnel = Tunnel;
	return tunnel;
}

var performanceNow$1 = {exports: {}};

var performanceNow = performanceNow$1.exports;

var hasRequiredPerformanceNow;

function requirePerformanceNow () {
	if (hasRequiredPerformanceNow) return performanceNow$1.exports;
	hasRequiredPerformanceNow = 1;
	// Generated by CoffeeScript 1.12.2
	(function() {
	  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

	  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
	    performanceNow$1.exports = function() {
	      return performance.now();
	    };
	  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
	    performanceNow$1.exports = function() {
	      return (getNanoSeconds() - nodeLoadTime) / 1e6;
	    };
	    hrtime = process.hrtime;
	    getNanoSeconds = function() {
	      var hr;
	      hr = hrtime();
	      return hr[0] * 1e9 + hr[1];
	    };
	    moduleLoadTime = getNanoSeconds();
	    upTime = process.uptime() * 1e9;
	    nodeLoadTime = moduleLoadTime - upTime;
	  } else if (Date.now) {
	    performanceNow$1.exports = function() {
	      return Date.now() - loadTime;
	    };
	    loadTime = Date.now();
	  } else {
	    performanceNow$1.exports = function() {
	      return new Date().getTime() - loadTime;
	    };
	    loadTime = new Date().getTime();
	  }

	}).call(performanceNow);

	
	return performanceNow$1.exports;
}

var request;
var hasRequiredRequest$1;

function requireRequest$1 () {
	if (hasRequiredRequest$1) return request;
	hasRequiredRequest$1 = 1;

	var http = require$$2$1;
	var https = require$$4$1;
	var url = require$$0$2;
	var util = require$$1$2;
	var stream = require$$0$6;
	var zlib = require$$5$1;
	var aws2 = requireAwsSign2();
	var aws4 = requireAws4();
	var httpSignature = requireLib$7();
	var mime = requireMimeTypes();
	var caseless = requireCaseless();
	var ForeverAgent = requireForeverAgent();
	var FormData = requireForm_data();
	var extend = requireExtend();
	var isstream = requireIsstream();
	var isTypedArray = requireIsTypedarray().strict;
	var helpers = requireHelpers();
	var cookies = requireCookies();
	var getProxyFromURI = requireGetProxyFromURI();
	var Querystring = requireQuerystring().Querystring;
	var Har = requireHar().Har;
	var Auth = requireAuth().Auth;
	var OAuth = requireOauth().OAuth;
	var hawk = requireHawk();
	var Multipart = requireMultipart().Multipart;
	var Redirect = requireRedirect().Redirect;
	var Tunnel = requireTunnel().Tunnel;
	var now = requirePerformanceNow();
	var Buffer = requireSafeBuffer$1().Buffer;

	var safeStringify = helpers.safeStringify;
	var isReadStream = helpers.isReadStream;
	var toBase64 = helpers.toBase64;
	var defer = helpers.defer;
	var copy = helpers.copy;
	var version = helpers.version;
	var globalCookieJar = cookies.jar();

	var globalPool = {};

	function filterForNonReserved (reserved, options) {
	  // Filter out properties that are not reserved.
	  // Reserved values are passed in at call site.

	  var object = {};
	  for (var i in options) {
	    var notReserved = (reserved.indexOf(i) === -1);
	    if (notReserved) {
	      object[i] = options[i];
	    }
	  }
	  return object
	}

	function filterOutReservedFunctions (reserved, options) {
	  // Filter out properties that are functions and are reserved.
	  // Reserved values are passed in at call site.

	  var object = {};
	  for (var i in options) {
	    var isReserved = !(reserved.indexOf(i) === -1);
	    var isFunction = (typeof options[i] === 'function');
	    if (!(isReserved && isFunction)) {
	      object[i] = options[i];
	    }
	  }
	  return object
	}

	// Return a simpler request object to allow serialization
	function requestToJSON () {
	  var self = this;
	  return {
	    uri: self.uri,
	    method: self.method,
	    headers: self.headers
	  }
	}

	// Return a simpler response object to allow serialization
	function responseToJSON () {
	  var self = this;
	  return {
	    statusCode: self.statusCode,
	    body: self.body,
	    headers: self.headers,
	    request: requestToJSON.call(self.request)
	  }
	}

	function Request (options) {
	  // if given the method property in options, set property explicitMethod to true

	  // extend the Request instance with any non-reserved properties
	  // remove any reserved functions from the options object
	  // set Request instance to be readable and writable
	  // call init

	  var self = this;

	  // start with HAR, then override with additional options
	  if (options.har) {
	    self._har = new Har(self);
	    options = self._har.options(options);
	  }

	  stream.Stream.call(self);
	  var reserved = Object.keys(Request.prototype);
	  var nonReserved = filterForNonReserved(reserved, options);

	  extend(self, nonReserved);
	  options = filterOutReservedFunctions(reserved, options);

	  self.readable = true;
	  self.writable = true;
	  if (options.method) {
	    self.explicitMethod = true;
	  }
	  self._qs = new Querystring(self);
	  self._auth = new Auth(self);
	  self._oauth = new OAuth(self);
	  self._multipart = new Multipart(self);
	  self._redirect = new Redirect(self);
	  self._tunnel = new Tunnel(self);
	  self.init(options);
	}

	util.inherits(Request, stream.Stream);

	// Debugging
	Request.debug = process.env.NODE_DEBUG && /\brequest\b/.test(process.env.NODE_DEBUG);
	function debug () {
	  if (Request.debug) {
	    console.error('REQUEST %s', util.format.apply(util, arguments));
	  }
	}
	Request.prototype.debug = debug;

	Request.prototype.init = function (options) {
	  // init() contains all the code to setup the request object.
	  // the actual outgoing request is not started until start() is called
	  // this function is called from both the constructor and on redirect.
	  var self = this;
	  if (!options) {
	    options = {};
	  }
	  self.headers = self.headers ? copy(self.headers) : {};

	  // Delete headers with value undefined since they break
	  // ClientRequest.OutgoingMessage.setHeader in node 0.12
	  for (var headerName in self.headers) {
	    if (typeof self.headers[headerName] === 'undefined') {
	      delete self.headers[headerName];
	    }
	  }

	  caseless.httpify(self, self.headers);

	  if (!self.method) {
	    self.method = options.method || 'GET';
	  }
	  if (!self.localAddress) {
	    self.localAddress = options.localAddress;
	  }

	  self._qs.init(options);

	  debug(options);
	  if (!self.pool && self.pool !== false) {
	    self.pool = globalPool;
	  }
	  self.dests = self.dests || [];
	  self.__isRequestRequest = true;

	  // Protect against double callback
	  if (!self._callback && self.callback) {
	    self._callback = self.callback;
	    self.callback = function () {
	      if (self._callbackCalled) {
	        return // Print a warning maybe?
	      }
	      self._callbackCalled = true;
	      self._callback.apply(self, arguments);
	    };
	    self.on('error', self.callback.bind());
	    self.on('complete', self.callback.bind(self, null));
	  }

	  // People use this property instead all the time, so support it
	  if (!self.uri && self.url) {
	    self.uri = self.url;
	    delete self.url;
	  }

	  // If there's a baseUrl, then use it as the base URL (i.e. uri must be
	  // specified as a relative path and is appended to baseUrl).
	  if (self.baseUrl) {
	    if (typeof self.baseUrl !== 'string') {
	      return self.emit('error', new Error('options.baseUrl must be a string'))
	    }

	    if (typeof self.uri !== 'string') {
	      return self.emit('error', new Error('options.uri must be a string when using options.baseUrl'))
	    }

	    if (self.uri.indexOf('//') === 0 || self.uri.indexOf('://') !== -1) {
	      return self.emit('error', new Error('options.uri must be a path when using options.baseUrl'))
	    }

	    // Handle all cases to make sure that there's only one slash between
	    // baseUrl and uri.
	    var baseUrlEndsWithSlash = self.baseUrl.lastIndexOf('/') === self.baseUrl.length - 1;
	    var uriStartsWithSlash = self.uri.indexOf('/') === 0;

	    if (baseUrlEndsWithSlash && uriStartsWithSlash) {
	      self.uri = self.baseUrl + self.uri.slice(1);
	    } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {
	      self.uri = self.baseUrl + self.uri;
	    } else if (self.uri === '') {
	      self.uri = self.baseUrl;
	    } else {
	      self.uri = self.baseUrl + '/' + self.uri;
	    }
	    delete self.baseUrl;
	  }

	  // A URI is needed by this point, emit error if we haven't been able to get one
	  if (!self.uri) {
	    return self.emit('error', new Error('options.uri is a required argument'))
	  }

	  // If a string URI/URL was given, parse it into a URL object
	  if (typeof self.uri === 'string') {
	    self.uri = url.parse(self.uri);
	  }

	  // Some URL objects are not from a URL parsed string and need href added
	  if (!self.uri.href) {
	    self.uri.href = url.format(self.uri);
	  }

	  // DEPRECATED: Warning for users of the old Unix Sockets URL Scheme
	  if (self.uri.protocol === 'unix:') {
	    return self.emit('error', new Error('`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`'))
	  }

	  // Support Unix Sockets
	  if (self.uri.host === 'unix') {
	    self.enableUnixSocket();
	  }

	  if (self.strictSSL === false) {
	    self.rejectUnauthorized = false;
	  }

	  if (!self.uri.pathname) { self.uri.pathname = '/'; }

	  if (!(self.uri.host || (self.uri.hostname && self.uri.port)) && !self.uri.isUnix) {
	    // Invalid URI: it may generate lot of bad errors, like 'TypeError: Cannot call method `indexOf` of undefined' in CookieJar
	    // Detect and reject it as soon as possible
	    var faultyUri = url.format(self.uri);
	    var message = 'Invalid URI "' + faultyUri + '"';
	    if (Object.keys(options).length === 0) {
	      // No option ? This can be the sign of a redirect
	      // As this is a case where the user cannot do anything (they didn't call request directly with this URL)
	      // they should be warned that it can be caused by a redirection (can save some hair)
	      message += '. This can be caused by a crappy redirection.';
	    }
	    // This error was fatal
	    self.abort();
	    return self.emit('error', new Error(message))
	  }

	  if (!self.hasOwnProperty('proxy')) {
	    self.proxy = getProxyFromURI(self.uri);
	  }

	  self.tunnel = self._tunnel.isEnabled();
	  if (self.proxy) {
	    self._tunnel.setup(options);
	  }

	  self._redirect.onRequest(options);

	  self.setHost = false;
	  if (!self.hasHeader('host')) {
	    var hostHeaderName = self.originalHostHeaderName || 'host';
	    self.setHeader(hostHeaderName, self.uri.host);
	    // Drop :port suffix from Host header if known protocol.
	    if (self.uri.port) {
	      if ((self.uri.port === '80' && self.uri.protocol === 'http:') ||
	          (self.uri.port === '443' && self.uri.protocol === 'https:')) {
	        self.setHeader(hostHeaderName, self.uri.hostname);
	      }
	    }
	    self.setHost = true;
	  }

	  self.jar(self._jar || options.jar);

	  if (!self.uri.port) {
	    if (self.uri.protocol === 'http:') { self.uri.port = 80; } else if (self.uri.protocol === 'https:') { self.uri.port = 443; }
	  }

	  if (self.proxy && !self.tunnel) {
	    self.port = self.proxy.port;
	    self.host = self.proxy.hostname;
	  } else {
	    self.port = self.uri.port;
	    self.host = self.uri.hostname;
	  }

	  if (options.form) {
	    self.form(options.form);
	  }

	  if (options.formData) {
	    var formData = options.formData;
	    var requestForm = self.form();
	    var appendFormValue = function (key, value) {
	      if (value && value.hasOwnProperty('value') && value.hasOwnProperty('options')) {
	        requestForm.append(key, value.value, value.options);
	      } else {
	        requestForm.append(key, value);
	      }
	    };
	    for (var formKey in formData) {
	      if (formData.hasOwnProperty(formKey)) {
	        var formValue = formData[formKey];
	        if (formValue instanceof Array) {
	          for (var j = 0; j < formValue.length; j++) {
	            appendFormValue(formKey, formValue[j]);
	          }
	        } else {
	          appendFormValue(formKey, formValue);
	        }
	      }
	    }
	  }

	  if (options.qs) {
	    self.qs(options.qs);
	  }

	  if (self.uri.path) {
	    self.path = self.uri.path;
	  } else {
	    self.path = self.uri.pathname + (self.uri.search || '');
	  }

	  if (self.path.length === 0) {
	    self.path = '/';
	  }

	  // Auth must happen last in case signing is dependent on other headers
	  if (options.aws) {
	    self.aws(options.aws);
	  }

	  if (options.hawk) {
	    self.hawk(options.hawk);
	  }

	  if (options.httpSignature) {
	    self.httpSignature(options.httpSignature);
	  }

	  if (options.auth) {
	    if (Object.prototype.hasOwnProperty.call(options.auth, 'username')) {
	      options.auth.user = options.auth.username;
	    }
	    if (Object.prototype.hasOwnProperty.call(options.auth, 'password')) {
	      options.auth.pass = options.auth.password;
	    }

	    self.auth(
	      options.auth.user,
	      options.auth.pass,
	      options.auth.sendImmediately,
	      options.auth.bearer
	    );
	  }

	  if (self.gzip && !self.hasHeader('accept-encoding')) {
	    self.setHeader('accept-encoding', 'gzip, deflate');
	  }

	  if (self.uri.auth && !self.hasHeader('authorization')) {
	    var uriAuthPieces = self.uri.auth.split(':').map(function (item) { return self._qs.unescape(item) });
	    self.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(':'), true);
	  }

	  if (!self.tunnel && self.proxy && self.proxy.auth && !self.hasHeader('proxy-authorization')) {
	    var proxyAuthPieces = self.proxy.auth.split(':').map(function (item) { return self._qs.unescape(item) });
	    var authHeader = 'Basic ' + toBase64(proxyAuthPieces.join(':'));
	    self.setHeader('proxy-authorization', authHeader);
	  }

	  if (self.proxy && !self.tunnel) {
	    self.path = (self.uri.protocol + '//' + self.uri.host + self.path);
	  }

	  if (options.json) {
	    self.json(options.json);
	  }
	  if (options.multipart) {
	    self.multipart(options.multipart);
	  }

	  if (options.time) {
	    self.timing = true;

	    // NOTE: elapsedTime is deprecated in favor of .timings
	    self.elapsedTime = self.elapsedTime || 0;
	  }

	  function setContentLength () {
	    if (isTypedArray(self.body)) {
	      self.body = Buffer.from(self.body);
	    }

	    if (!self.hasHeader('content-length')) {
	      var length;
	      if (typeof self.body === 'string') {
	        length = Buffer.byteLength(self.body);
	      } else if (Array.isArray(self.body)) {
	        length = self.body.reduce(function (a, b) { return a + b.length }, 0);
	      } else {
	        length = self.body.length;
	      }

	      if (length) {
	        self.setHeader('content-length', length);
	      } else {
	        self.emit('error', new Error('Argument error, options.body.'));
	      }
	    }
	  }
	  if (self.body && !isstream(self.body)) {
	    setContentLength();
	  }

	  if (options.oauth) {
	    self.oauth(options.oauth);
	  } else if (self._oauth.params && self.hasHeader('authorization')) {
	    self.oauth(self._oauth.params);
	  }

	  var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol;
	  var defaultModules = {'http:': http, 'https:': https};
	  var httpModules = self.httpModules || {};

	  self.httpModule = httpModules[protocol] || defaultModules[protocol];

	  if (!self.httpModule) {
	    return self.emit('error', new Error('Invalid protocol: ' + protocol))
	  }

	  if (options.ca) {
	    self.ca = options.ca;
	  }

	  if (!self.agent) {
	    if (options.agentOptions) {
	      self.agentOptions = options.agentOptions;
	    }

	    if (options.agentClass) {
	      self.agentClass = options.agentClass;
	    } else if (options.forever) {
	      var v = version();
	      // use ForeverAgent in node 0.10- only
	      if (v.major === 0 && v.minor <= 10) {
	        self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL;
	      } else {
	        self.agentClass = self.httpModule.Agent;
	        self.agentOptions = self.agentOptions || {};
	        self.agentOptions.keepAlive = true;
	      }
	    } else {
	      self.agentClass = self.httpModule.Agent;
	    }
	  }

	  if (self.pool === false) {
	    self.agent = false;
	  } else {
	    self.agent = self.agent || self.getNewAgent();
	  }

	  self.on('pipe', function (src) {
	    if (self.ntick && self._started) {
	      self.emit('error', new Error('You cannot pipe to this stream after the outbound request has started.'));
	    }
	    self.src = src;
	    if (isReadStream(src)) {
	      if (!self.hasHeader('content-type')) {
	        self.setHeader('content-type', mime.lookup(src.path));
	      }
	    } else {
	      if (src.headers) {
	        for (var i in src.headers) {
	          if (!self.hasHeader(i)) {
	            self.setHeader(i, src.headers[i]);
	          }
	        }
	      }
	      if (self._json && !self.hasHeader('content-type')) {
	        self.setHeader('content-type', 'application/json');
	      }
	      if (src.method && !self.explicitMethod) {
	        self.method = src.method;
	      }
	    }

	  // self.on('pipe', function () {
	  //   console.error('You have already piped to this stream. Pipeing twice is likely to break the request.')
	  // })
	  });

	  defer(function () {
	    if (self._aborted) {
	      return
	    }

	    var end = function () {
	      if (self._form) {
	        if (!self._auth.hasAuth) {
	          self._form.pipe(self);
	        } else if (self._auth.hasAuth && self._auth.sentAuth) {
	          self._form.pipe(self);
	        }
	      }
	      if (self._multipart && self._multipart.chunked) {
	        self._multipart.body.pipe(self);
	      }
	      if (self.body) {
	        if (isstream(self.body)) {
	          self.body.pipe(self);
	        } else {
	          setContentLength();
	          if (Array.isArray(self.body)) {
	            self.body.forEach(function (part) {
	              self.write(part);
	            });
	          } else {
	            self.write(self.body);
	          }
	          self.end();
	        }
	      } else if (self.requestBodyStream) {
	        console.warn('options.requestBodyStream is deprecated, please pass the request object to stream.pipe.');
	        self.requestBodyStream.pipe(self);
	      } else if (!self.src) {
	        if (self._auth.hasAuth && !self._auth.sentAuth) {
	          self.end();
	          return
	        }
	        if (self.method !== 'GET' && typeof self.method !== 'undefined') {
	          self.setHeader('content-length', 0);
	        }
	        self.end();
	      }
	    };

	    if (self._form && !self.hasHeader('content-length')) {
	      // Before ending the request, we had to compute the length of the whole form, asyncly
	      self.setHeader(self._form.getHeaders(), true);
	      self._form.getLength(function (err, length) {
	        if (!err && !isNaN(length)) {
	          self.setHeader('content-length', length);
	        }
	        end();
	      });
	    } else {
	      end();
	    }

	    self.ntick = true;
	  });
	};

	Request.prototype.getNewAgent = function () {
	  var self = this;
	  var Agent = self.agentClass;
	  var options = {};
	  if (self.agentOptions) {
	    for (var i in self.agentOptions) {
	      options[i] = self.agentOptions[i];
	    }
	  }
	  if (self.ca) {
	    options.ca = self.ca;
	  }
	  if (self.ciphers) {
	    options.ciphers = self.ciphers;
	  }
	  if (self.secureProtocol) {
	    options.secureProtocol = self.secureProtocol;
	  }
	  if (self.secureOptions) {
	    options.secureOptions = self.secureOptions;
	  }
	  if (typeof self.rejectUnauthorized !== 'undefined') {
	    options.rejectUnauthorized = self.rejectUnauthorized;
	  }

	  if (self.cert && self.key) {
	    options.key = self.key;
	    options.cert = self.cert;
	  }

	  if (self.pfx) {
	    options.pfx = self.pfx;
	  }

	  if (self.passphrase) {
	    options.passphrase = self.passphrase;
	  }

	  var poolKey = '';

	  // different types of agents are in different pools
	  if (Agent !== self.httpModule.Agent) {
	    poolKey += Agent.name;
	  }

	  // ca option is only relevant if proxy or destination are https
	  var proxy = self.proxy;
	  if (typeof proxy === 'string') {
	    proxy = url.parse(proxy);
	  }
	  var isHttps = (proxy && proxy.protocol === 'https:') || this.uri.protocol === 'https:';

	  if (isHttps) {
	    if (options.ca) {
	      if (poolKey) {
	        poolKey += ':';
	      }
	      poolKey += options.ca;
	    }

	    if (typeof options.rejectUnauthorized !== 'undefined') {
	      if (poolKey) {
	        poolKey += ':';
	      }
	      poolKey += options.rejectUnauthorized;
	    }

	    if (options.cert) {
	      if (poolKey) {
	        poolKey += ':';
	      }
	      poolKey += options.cert.toString('ascii') + options.key.toString('ascii');
	    }

	    if (options.pfx) {
	      if (poolKey) {
	        poolKey += ':';
	      }
	      poolKey += options.pfx.toString('ascii');
	    }

	    if (options.ciphers) {
	      if (poolKey) {
	        poolKey += ':';
	      }
	      poolKey += options.ciphers;
	    }

	    if (options.secureProtocol) {
	      if (poolKey) {
	        poolKey += ':';
	      }
	      poolKey += options.secureProtocol;
	    }

	    if (options.secureOptions) {
	      if (poolKey) {
	        poolKey += ':';
	      }
	      poolKey += options.secureOptions;
	    }
	  }

	  if (self.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self.httpModule.globalAgent) {
	    // not doing anything special.  Use the globalAgent
	    return self.httpModule.globalAgent
	  }

	  // we're using a stored agent.  Make sure it's protocol-specific
	  poolKey = self.uri.protocol + poolKey;

	  // generate a new agent for this setting if none yet exists
	  if (!self.pool[poolKey]) {
	    self.pool[poolKey] = new Agent(options);
	    // properly set maxSockets on new agents
	    if (self.pool.maxSockets) {
	      self.pool[poolKey].maxSockets = self.pool.maxSockets;
	    }
	  }

	  return self.pool[poolKey]
	};

	Request.prototype.start = function () {
	  // start() is called once we are ready to send the outgoing HTTP request.
	  // this is usually called on the first write(), end() or on nextTick()
	  var self = this;

	  if (self.timing) {
	    // All timings will be relative to this request's startTime.  In order to do this,
	    // we need to capture the wall-clock start time (via Date), immediately followed
	    // by the high-resolution timer (via now()).  While these two won't be set
	    // at the _exact_ same time, they should be close enough to be able to calculate
	    // high-resolution, monotonically non-decreasing timestamps relative to startTime.
	    var startTime = new Date().getTime();
	    var startTimeNow = now();
	  }

	  if (self._aborted) {
	    return
	  }

	  self._started = true;
	  self.method = self.method || 'GET';
	  self.href = self.uri.href;

	  if (self.src && self.src.stat && self.src.stat.size && !self.hasHeader('content-length')) {
	    self.setHeader('content-length', self.src.stat.size);
	  }
	  if (self._aws) {
	    self.aws(self._aws, true);
	  }

	  // We have a method named auth, which is completely different from the http.request
	  // auth option.  If we don't remove it, we're gonna have a bad time.
	  var reqOptions = copy(self);
	  delete reqOptions.auth;

	  debug('make request', self.uri.href);

	  // node v6.8.0 now supports a `timeout` value in `http.request()`, but we
	  // should delete it for now since we handle timeouts manually for better
	  // consistency with node versions before v6.8.0
	  delete reqOptions.timeout;

	  try {
	    self.req = self.httpModule.request(reqOptions);
	  } catch (err) {
	    self.emit('error', err);
	    return
	  }

	  if (self.timing) {
	    self.startTime = startTime;
	    self.startTimeNow = startTimeNow;

	    // Timing values will all be relative to startTime (by comparing to startTimeNow
	    // so we have an accurate clock)
	    self.timings = {};
	  }

	  var timeout;
	  if (self.timeout && !self.timeoutTimer) {
	    if (self.timeout < 0) {
	      timeout = 0;
	    } else if (typeof self.timeout === 'number' && isFinite(self.timeout)) {
	      timeout = self.timeout;
	    }
	  }

	  self.req.on('response', self.onRequestResponse.bind(self));
	  self.req.on('error', self.onRequestError.bind(self));
	  self.req.on('drain', function () {
	    self.emit('drain');
	  });

	  self.req.on('socket', function (socket) {
	    // `._connecting` was the old property which was made public in node v6.1.0
	    var isConnecting = socket._connecting || socket.connecting;
	    if (self.timing) {
	      self.timings.socket = now() - self.startTimeNow;

	      if (isConnecting) {
	        var onLookupTiming = function () {
	          self.timings.lookup = now() - self.startTimeNow;
	        };

	        var onConnectTiming = function () {
	          self.timings.connect = now() - self.startTimeNow;
	        };

	        socket.once('lookup', onLookupTiming);
	        socket.once('connect', onConnectTiming);

	        // clean up timing event listeners if needed on error
	        self.req.once('error', function () {
	          socket.removeListener('lookup', onLookupTiming);
	          socket.removeListener('connect', onConnectTiming);
	        });
	      }
	    }

	    var setReqTimeout = function () {
	      // This timeout sets the amount of time to wait *between* bytes sent
	      // from the server once connected.
	      //
	      // In particular, it's useful for erroring if the server fails to send
	      // data halfway through streaming a response.
	      self.req.setTimeout(timeout, function () {
	        if (self.req) {
	          self.abort();
	          var e = new Error('ESOCKETTIMEDOUT');
	          e.code = 'ESOCKETTIMEDOUT';
	          e.connect = false;
	          self.emit('error', e);
	        }
	      });
	    };
	    if (timeout !== undefined) {
	      // Only start the connection timer if we're actually connecting a new
	      // socket, otherwise if we're already connected (because this is a
	      // keep-alive connection) do not bother. This is important since we won't
	      // get a 'connect' event for an already connected socket.
	      if (isConnecting) {
	        var onReqSockConnect = function () {
	          socket.removeListener('connect', onReqSockConnect);
	          self.clearTimeout();
	          setReqTimeout();
	        };

	        socket.on('connect', onReqSockConnect);

	        self.req.on('error', function (err) { // eslint-disable-line handle-callback-err
	          socket.removeListener('connect', onReqSockConnect);
	        });

	        // Set a timeout in memory - this block will throw if the server takes more
	        // than `timeout` to write the HTTP status and headers (corresponding to
	        // the on('response') event on the client). NB: this measures wall-clock
	        // time, not the time between bytes sent by the server.
	        self.timeoutTimer = setTimeout(function () {
	          socket.removeListener('connect', onReqSockConnect);
	          self.abort();
	          var e = new Error('ETIMEDOUT');
	          e.code = 'ETIMEDOUT';
	          e.connect = true;
	          self.emit('error', e);
	        }, timeout);
	      } else {
	        // We're already connected
	        setReqTimeout();
	      }
	    }
	    self.emit('socket', socket);
	  });

	  self.emit('request', self.req);
	};

	Request.prototype.onRequestError = function (error) {
	  var self = this;
	  if (self._aborted) {
	    return
	  }
	  if (self.req && self.req._reusedSocket && error.code === 'ECONNRESET' &&
	    self.agent.addRequestNoreuse) {
	    self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) };
	    self.start();
	    self.req.end();
	    return
	  }
	  self.clearTimeout();
	  self.emit('error', error);
	};

	Request.prototype.onRequestResponse = function (response) {
	  var self = this;

	  if (self.timing) {
	    self.timings.response = now() - self.startTimeNow;
	  }

	  debug('onRequestResponse', self.uri.href, response.statusCode, response.headers);
	  response.on('end', function () {
	    if (self.timing) {
	      self.timings.end = now() - self.startTimeNow;
	      response.timingStart = self.startTime;

	      // fill in the blanks for any periods that didn't trigger, such as
	      // no lookup or connect due to keep alive
	      if (!self.timings.socket) {
	        self.timings.socket = 0;
	      }
	      if (!self.timings.lookup) {
	        self.timings.lookup = self.timings.socket;
	      }
	      if (!self.timings.connect) {
	        self.timings.connect = self.timings.lookup;
	      }
	      if (!self.timings.response) {
	        self.timings.response = self.timings.connect;
	      }

	      debug('elapsed time', self.timings.end);

	      // elapsedTime includes all redirects
	      self.elapsedTime += Math.round(self.timings.end);

	      // NOTE: elapsedTime is deprecated in favor of .timings
	      response.elapsedTime = self.elapsedTime;

	      // timings is just for the final fetch
	      response.timings = self.timings;

	      // pre-calculate phase timings as well
	      response.timingPhases = {
	        wait: self.timings.socket,
	        dns: self.timings.lookup - self.timings.socket,
	        tcp: self.timings.connect - self.timings.lookup,
	        firstByte: self.timings.response - self.timings.connect,
	        download: self.timings.end - self.timings.response,
	        total: self.timings.end
	      };
	    }
	    debug('response end', self.uri.href, response.statusCode, response.headers);
	  });

	  if (self._aborted) {
	    debug('aborted', self.uri.href);
	    response.resume();
	    return
	  }

	  self.response = response;
	  response.request = self;
	  response.toJSON = responseToJSON;

	  // XXX This is different on 0.10, because SSL is strict by default
	  if (self.httpModule === https &&
	    self.strictSSL && (!response.hasOwnProperty('socket') ||
	    !response.socket.authorized)) {
	    debug('strict ssl error', self.uri.href);
	    var sslErr = response.hasOwnProperty('socket') ? response.socket.authorizationError : self.uri.href + ' does not support SSL';
	    self.emit('error', new Error('SSL Error: ' + sslErr));
	    return
	  }

	  // Save the original host before any redirect (if it changes, we need to
	  // remove any authorization headers).  Also remember the case of the header
	  // name because lots of broken servers expect Host instead of host and we
	  // want the caller to be able to specify this.
	  self.originalHost = self.getHeader('host');
	  if (!self.originalHostHeaderName) {
	    self.originalHostHeaderName = self.hasHeader('host');
	  }
	  if (self.setHost) {
	    self.removeHeader('host');
	  }
	  self.clearTimeout();

	  var targetCookieJar = (self._jar && self._jar.setCookie) ? self._jar : globalCookieJar;
	  var addCookie = function (cookie) {
	    // set the cookie if it's domain in the href's domain.
	    try {
	      targetCookieJar.setCookie(cookie, self.uri.href, {ignoreError: true});
	    } catch (e) {
	      self.emit('error', e);
	    }
	  };

	  response.caseless = caseless(response.headers);

	  if (response.caseless.has('set-cookie') && (!self._disableCookies)) {
	    var headerName = response.caseless.has('set-cookie');
	    if (Array.isArray(response.headers[headerName])) {
	      response.headers[headerName].forEach(addCookie);
	    } else {
	      addCookie(response.headers[headerName]);
	    }
	  }

	  if (self._redirect.onResponse(response)) {
	    return // Ignore the rest of the response
	  } else {
	    // Be a good stream and emit end when the response is finished.
	    // Hack to emit end on close because of a core bug that never fires end
	    response.on('close', function () {
	      if (!self._ended) {
	        self.response.emit('end');
	      }
	    });

	    response.once('end', function () {
	      self._ended = true;
	    });

	    var noBody = function (code) {
	      return (
	        self.method === 'HEAD' ||
	        // Informational
	        (code >= 100 && code < 200) ||
	        // No Content
	        code === 204 ||
	        // Not Modified
	        code === 304
	      )
	    };

	    var responseContent;
	    if (self.gzip && !noBody(response.statusCode)) {
	      var contentEncoding = response.headers['content-encoding'] || 'identity';
	      contentEncoding = contentEncoding.trim().toLowerCase();

	      // Be more lenient with decoding compressed responses, since (very rarely)
	      // servers send slightly invalid gzip responses that are still accepted
	      // by common browsers.
	      // Always using Z_SYNC_FLUSH is what cURL does.
	      var zlibOptions = {
	        flush: zlib.Z_SYNC_FLUSH,
	        finishFlush: zlib.Z_SYNC_FLUSH
	      };

	      if (contentEncoding === 'gzip') {
	        responseContent = zlib.createGunzip(zlibOptions);
	        response.pipe(responseContent);
	      } else if (contentEncoding === 'deflate') {
	        responseContent = zlib.createInflate(zlibOptions);
	        response.pipe(responseContent);
	      } else {
	        // Since previous versions didn't check for Content-Encoding header,
	        // ignore any invalid values to preserve backwards-compatibility
	        if (contentEncoding !== 'identity') {
	          debug('ignoring unrecognized Content-Encoding ' + contentEncoding);
	        }
	        responseContent = response;
	      }
	    } else {
	      responseContent = response;
	    }

	    if (self.encoding) {
	      if (self.dests.length !== 0) {
	        console.error('Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.');
	      } else {
	        responseContent.setEncoding(self.encoding);
	      }
	    }

	    if (self._paused) {
	      responseContent.pause();
	    }

	    self.responseContent = responseContent;

	    self.emit('response', response);

	    self.dests.forEach(function (dest) {
	      self.pipeDest(dest);
	    });

	    responseContent.on('data', function (chunk) {
	      if (self.timing && !self.responseStarted) {
	        self.responseStartTime = (new Date()).getTime();

	        // NOTE: responseStartTime is deprecated in favor of .timings
	        response.responseStartTime = self.responseStartTime;
	      }
	      self._destdata = true;
	      self.emit('data', chunk);
	    });
	    responseContent.once('end', function (chunk) {
	      self.emit('end', chunk);
	    });
	    responseContent.on('error', function (error) {
	      self.emit('error', error);
	    });
	    responseContent.on('close', function () { self.emit('close'); });

	    if (self.callback) {
	      self.readResponseBody(response);
	    } else { // if no callback
	      self.on('end', function () {
	        if (self._aborted) {
	          debug('aborted', self.uri.href);
	          return
	        }
	        self.emit('complete', response);
	      });
	    }
	  }
	  debug('finish init function', self.uri.href);
	};

	Request.prototype.readResponseBody = function (response) {
	  var self = this;
	  debug("reading response's body");
	  var buffers = [];
	  var bufferLength = 0;
	  var strings = [];

	  self.on('data', function (chunk) {
	    if (!Buffer.isBuffer(chunk)) {
	      strings.push(chunk);
	    } else if (chunk.length) {
	      bufferLength += chunk.length;
	      buffers.push(chunk);
	    }
	  });
	  self.on('end', function () {
	    debug('end event', self.uri.href);
	    if (self._aborted) {
	      debug('aborted', self.uri.href);
	      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the request.
	      // This can lead to leaky behavior if the user retains a reference to the request object.
	      buffers = [];
	      bufferLength = 0;
	      return
	    }

	    if (bufferLength) {
	      debug('has body', self.uri.href, bufferLength);
	      response.body = Buffer.concat(buffers, bufferLength);
	      if (self.encoding !== null) {
	        response.body = response.body.toString(self.encoding);
	      }
	      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the Request.
	      // This can lead to leaky behavior if the user retains a reference to the request object.
	      buffers = [];
	      bufferLength = 0;
	    } else if (strings.length) {
	      // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.
	      // Strip this value out when the encoding is set to 'utf8', as upstream consumers won't expect it and it breaks JSON.parse().
	      if (self.encoding === 'utf8' && strings[0].length > 0 && strings[0][0] === '\uFEFF') {
	        strings[0] = strings[0].substring(1);
	      }
	      response.body = strings.join('');
	    }

	    if (self._json) {
	      try {
	        response.body = JSON.parse(response.body, self._jsonReviver);
	      } catch (e) {
	        debug('invalid JSON received', self.uri.href);
	      }
	    }
	    debug('emitting complete', self.uri.href);
	    if (typeof response.body === 'undefined' && !self._json) {
	      response.body = self.encoding === null ? Buffer.alloc(0) : '';
	    }
	    self.emit('complete', response, response.body);
	  });
	};

	Request.prototype.abort = function () {
	  var self = this;
	  self._aborted = true;

	  if (self.req) {
	    self.req.abort();
	  } else if (self.response) {
	    self.response.destroy();
	  }

	  self.clearTimeout();
	  self.emit('abort');
	};

	Request.prototype.pipeDest = function (dest) {
	  var self = this;
	  var response = self.response;
	  // Called after the response is received
	  if (dest.headers && !dest.headersSent) {
	    if (response.caseless.has('content-type')) {
	      var ctname = response.caseless.has('content-type');
	      if (dest.setHeader) {
	        dest.setHeader(ctname, response.headers[ctname]);
	      } else {
	        dest.headers[ctname] = response.headers[ctname];
	      }
	    }

	    if (response.caseless.has('content-length')) {
	      var clname = response.caseless.has('content-length');
	      if (dest.setHeader) {
	        dest.setHeader(clname, response.headers[clname]);
	      } else {
	        dest.headers[clname] = response.headers[clname];
	      }
	    }
	  }
	  if (dest.setHeader && !dest.headersSent) {
	    for (var i in response.headers) {
	      // If the response content is being decoded, the Content-Encoding header
	      // of the response doesn't represent the piped content, so don't pass it.
	      if (!self.gzip || i !== 'content-encoding') {
	        dest.setHeader(i, response.headers[i]);
	      }
	    }
	    dest.statusCode = response.statusCode;
	  }
	  if (self.pipefilter) {
	    self.pipefilter(response, dest);
	  }
	};

	Request.prototype.qs = function (q, clobber) {
	  var self = this;
	  var base;
	  if (!clobber && self.uri.query) {
	    base = self._qs.parse(self.uri.query);
	  } else {
	    base = {};
	  }

	  for (var i in q) {
	    base[i] = q[i];
	  }

	  var qs = self._qs.stringify(base);

	  if (qs === '') {
	    return self
	  }

	  self.uri = url.parse(self.uri.href.split('?')[0] + '?' + qs);
	  self.url = self.uri;
	  self.path = self.uri.path;

	  if (self.uri.host === 'unix') {
	    self.enableUnixSocket();
	  }

	  return self
	};
	Request.prototype.form = function (form) {
	  var self = this;
	  if (form) {
	    if (!/^application\/x-www-form-urlencoded\b/.test(self.getHeader('content-type'))) {
	      self.setHeader('content-type', 'application/x-www-form-urlencoded');
	    }
	    self.body = (typeof form === 'string')
	      ? self._qs.rfc3986(form.toString('utf8'))
	      : self._qs.stringify(form).toString('utf8');
	    return self
	  }
	  // create form-data object
	  self._form = new FormData();
	  self._form.on('error', function (err) {
	    err.message = 'form-data: ' + err.message;
	    self.emit('error', err);
	    self.abort();
	  });
	  return self._form
	};
	Request.prototype.multipart = function (multipart) {
	  var self = this;

	  self._multipart.onRequest(multipart);

	  if (!self._multipart.chunked) {
	    self.body = self._multipart.body;
	  }

	  return self
	};
	Request.prototype.json = function (val) {
	  var self = this;

	  if (!self.hasHeader('accept')) {
	    self.setHeader('accept', 'application/json');
	  }

	  if (typeof self.jsonReplacer === 'function') {
	    self._jsonReplacer = self.jsonReplacer;
	  }

	  self._json = true;
	  if (typeof val === 'boolean') {
	    if (self.body !== undefined) {
	      if (!/^application\/x-www-form-urlencoded\b/.test(self.getHeader('content-type'))) {
	        self.body = safeStringify(self.body, self._jsonReplacer);
	      } else {
	        self.body = self._qs.rfc3986(self.body);
	      }
	      if (!self.hasHeader('content-type')) {
	        self.setHeader('content-type', 'application/json');
	      }
	    }
	  } else {
	    self.body = safeStringify(val, self._jsonReplacer);
	    if (!self.hasHeader('content-type')) {
	      self.setHeader('content-type', 'application/json');
	    }
	  }

	  if (typeof self.jsonReviver === 'function') {
	    self._jsonReviver = self.jsonReviver;
	  }

	  return self
	};
	Request.prototype.getHeader = function (name, headers) {
	  var self = this;
	  var result, re, match;
	  if (!headers) {
	    headers = self.headers;
	  }
	  Object.keys(headers).forEach(function (key) {
	    if (key.length !== name.length) {
	      return
	    }
	    re = new RegExp(name, 'i');
	    match = key.match(re);
	    if (match) {
	      result = headers[key];
	    }
	  });
	  return result
	};
	Request.prototype.enableUnixSocket = function () {
	  // Get the socket & request paths from the URL
	  var unixParts = this.uri.path.split(':');
	  var host = unixParts[0];
	  var path = unixParts[1];
	  // Apply unix properties to request
	  this.socketPath = host;
	  this.uri.pathname = path;
	  this.uri.path = path;
	  this.uri.host = host;
	  this.uri.hostname = host;
	  this.uri.isUnix = true;
	};

	Request.prototype.auth = function (user, pass, sendImmediately, bearer) {
	  var self = this;

	  self._auth.onRequest(user, pass, sendImmediately, bearer);

	  return self
	};
	Request.prototype.aws = function (opts, now) {
	  var self = this;

	  if (!now) {
	    self._aws = opts;
	    return self
	  }

	  if (opts.sign_version === 4 || opts.sign_version === '4') {
	    // use aws4
	    var options = {
	      host: self.uri.host,
	      path: self.uri.path,
	      method: self.method,
	      headers: self.headers,
	      body: self.body
	    };
	    if (opts.service) {
	      options.service = opts.service;
	    }
	    var signRes = aws4.sign(options, {
	      accessKeyId: opts.key,
	      secretAccessKey: opts.secret,
	      sessionToken: opts.session
	    });
	    self.setHeader('authorization', signRes.headers.Authorization);
	    self.setHeader('x-amz-date', signRes.headers['X-Amz-Date']);
	    if (signRes.headers['X-Amz-Security-Token']) {
	      self.setHeader('x-amz-security-token', signRes.headers['X-Amz-Security-Token']);
	    }
	  } else {
	    // default: use aws-sign2
	    var date = new Date();
	    self.setHeader('date', date.toUTCString());
	    var auth = {
	      key: opts.key,
	      secret: opts.secret,
	      verb: self.method.toUpperCase(),
	      date: date,
	      contentType: self.getHeader('content-type') || '',
	      md5: self.getHeader('content-md5') || '',
	      amazonHeaders: aws2.canonicalizeHeaders(self.headers)
	    };
	    var path = self.uri.path;
	    if (opts.bucket && path) {
	      auth.resource = '/' + opts.bucket + path;
	    } else if (opts.bucket && !path) {
	      auth.resource = '/' + opts.bucket;
	    } else if (!opts.bucket && path) {
	      auth.resource = path;
	    } else if (!opts.bucket && !path) {
	      auth.resource = '/';
	    }
	    auth.resource = aws2.canonicalizeResource(auth.resource);
	    self.setHeader('authorization', aws2.authorization(auth));
	  }

	  return self
	};
	Request.prototype.httpSignature = function (opts) {
	  var self = this;
	  httpSignature.signRequest({
	    getHeader: function (header) {
	      return self.getHeader(header, self.headers)
	    },
	    setHeader: function (header, value) {
	      self.setHeader(header, value);
	    },
	    method: self.method,
	    path: self.path
	  }, opts);
	  debug('httpSignature authorization', self.getHeader('authorization'));

	  return self
	};
	Request.prototype.hawk = function (opts) {
	  var self = this;
	  self.setHeader('Authorization', hawk.header(self.uri, self.method, opts));
	};
	Request.prototype.oauth = function (_oauth) {
	  var self = this;

	  self._oauth.onRequest(_oauth);

	  return self
	};

	Request.prototype.jar = function (jar) {
	  var self = this;
	  var cookies;

	  if (self._redirect.redirectsFollowed === 0) {
	    self.originalCookieHeader = self.getHeader('cookie');
	  }

	  if (!jar) {
	    // disable cookies
	    cookies = false;
	    self._disableCookies = true;
	  } else {
	    var targetCookieJar = jar.getCookieString ? jar : globalCookieJar;
	    var urihref = self.uri.href;
	    // fetch cookie in the Specified host
	    if (targetCookieJar) {
	      cookies = targetCookieJar.getCookieString(urihref);
	    }
	  }

	  // if need cookie and cookie is not empty
	  if (cookies && cookies.length) {
	    if (self.originalCookieHeader) {
	      // Don't overwrite existing Cookie header
	      self.setHeader('cookie', self.originalCookieHeader + '; ' + cookies);
	    } else {
	      self.setHeader('cookie', cookies);
	    }
	  }
	  self._jar = jar;
	  return self
	};

	// Stream API
	Request.prototype.pipe = function (dest, opts) {
	  var self = this;

	  if (self.response) {
	    if (self._destdata) {
	      self.emit('error', new Error('You cannot pipe after data has been emitted from the response.'));
	    } else if (self._ended) {
	      self.emit('error', new Error('You cannot pipe after the response has been ended.'));
	    } else {
	      stream.Stream.prototype.pipe.call(self, dest, opts);
	      self.pipeDest(dest);
	      return dest
	    }
	  } else {
	    self.dests.push(dest);
	    stream.Stream.prototype.pipe.call(self, dest, opts);
	    return dest
	  }
	};
	Request.prototype.write = function () {
	  var self = this;
	  if (self._aborted) { return }

	  if (!self._started) {
	    self.start();
	  }
	  if (self.req) {
	    return self.req.write.apply(self.req, arguments)
	  }
	};
	Request.prototype.end = function (chunk) {
	  var self = this;
	  if (self._aborted) { return }

	  if (chunk) {
	    self.write(chunk);
	  }
	  if (!self._started) {
	    self.start();
	  }
	  if (self.req) {
	    self.req.end();
	  }
	};
	Request.prototype.pause = function () {
	  var self = this;
	  if (!self.responseContent) {
	    self._paused = true;
	  } else {
	    self.responseContent.pause.apply(self.responseContent, arguments);
	  }
	};
	Request.prototype.resume = function () {
	  var self = this;
	  if (!self.responseContent) {
	    self._paused = false;
	  } else {
	    self.responseContent.resume.apply(self.responseContent, arguments);
	  }
	};
	Request.prototype.destroy = function () {
	  var self = this;
	  this.clearTimeout();
	  if (!self._ended) {
	    self.end();
	  } else if (self.response) {
	    self.response.destroy();
	  }
	};

	Request.prototype.clearTimeout = function () {
	  if (this.timeoutTimer) {
	    clearTimeout(this.timeoutTimer);
	    this.timeoutTimer = null;
	  }
	};

	Request.defaultProxyHeaderWhiteList =
	  Tunnel.defaultProxyHeaderWhiteList.slice();

	Request.defaultProxyHeaderExclusiveList =
	  Tunnel.defaultProxyHeaderExclusiveList.slice();

	// Exports

	Request.prototype.toJSON = requestToJSON;
	request = Request;
	return request;
}

var request_1;
var hasRequiredRequest;

function requireRequest () {
	if (hasRequiredRequest) return request_1;
	hasRequiredRequest = 1;

	var extend = requireExtend();
	var cookies = requireCookies();
	var helpers = requireHelpers();

	var paramsHaveRequestBody = helpers.paramsHaveRequestBody;

	// organize params for patch, post, put, head, del
	function initParams (uri, options, callback) {
	  if (typeof options === 'function') {
	    callback = options;
	  }

	  var params = {};
	  if (options !== null && typeof options === 'object') {
	    extend(params, options, {uri: uri});
	  } else if (typeof uri === 'string') {
	    extend(params, {uri: uri});
	  } else {
	    extend(params, uri);
	  }

	  params.callback = callback || params.callback;
	  return params
	}

	function request (uri, options, callback) {
	  if (typeof uri === 'undefined') {
	    throw new Error('undefined is not a valid uri or options object.')
	  }

	  var params = initParams(uri, options, callback);

	  if (params.method === 'HEAD' && paramsHaveRequestBody(params)) {
	    throw new Error('HTTP HEAD requests MUST NOT include a request body.')
	  }

	  return new request.Request(params)
	}

	function verbFunc (verb) {
	  var method = verb.toUpperCase();
	  return function (uri, options, callback) {
	    var params = initParams(uri, options, callback);
	    params.method = method;
	    return request(params, params.callback)
	  }
	}

	// define like this to please codeintel/intellisense IDEs
	request.get = verbFunc('get');
	request.head = verbFunc('head');
	request.options = verbFunc('options');
	request.post = verbFunc('post');
	request.put = verbFunc('put');
	request.patch = verbFunc('patch');
	request.del = verbFunc('delete');
	request['delete'] = verbFunc('delete');

	request.jar = function (store) {
	  return cookies.jar(store)
	};

	request.cookie = function (str) {
	  return cookies.parse(str)
	};

	function wrapRequestMethod (method, options, requester, verb) {
	  return function (uri, opts, callback) {
	    var params = initParams(uri, opts, callback);

	    var target = {};
	    extend(true, target, options, params);

	    target.pool = params.pool || options.pool;

	    if (verb) {
	      target.method = verb.toUpperCase();
	    }

	    if (typeof requester === 'function') {
	      method = requester;
	    }

	    return method(target, target.callback)
	  }
	}

	request.defaults = function (options, requester) {
	  var self = this;

	  options = options || {};

	  if (typeof options === 'function') {
	    requester = options;
	    options = {};
	  }

	  var defaults = wrapRequestMethod(self, options, requester);

	  var verbs = ['get', 'head', 'post', 'put', 'patch', 'del', 'delete'];
	  verbs.forEach(function (verb) {
	    defaults[verb] = wrapRequestMethod(self[verb], options, requester, verb);
	  });

	  defaults.cookie = wrapRequestMethod(self.cookie, options, requester);
	  defaults.jar = self.jar;
	  defaults.defaults = self.defaults;
	  return defaults
	};

	request.forever = function (agentOptions, optionsArg) {
	  var options = {};
	  if (optionsArg) {
	    extend(options, optionsArg);
	  }
	  if (agentOptions) {
	    options.agentOptions = agentOptions;
	  }

	  options.forever = true;
	  return request.defaults(options)
	};

	// Exports

	request_1 = request;
	request.Request = requireRequest$1();
	request.initParams = initParams;

	// Backwards compatibility for request.debug
	Object.defineProperty(request, 'debug', {
	  enumerable: true,
	  get: function () {
	    return request.Request.debug
	  },
	  set: function (debug) {
	    request.Request.debug = debug;
	  }
	});
	return request_1;
}

var urlJoin$1 = {exports: {}};

var urlJoin = urlJoin$1.exports;

var hasRequiredUrlJoin;

function requireUrlJoin () {
	if (hasRequiredUrlJoin) return urlJoin$1.exports;
	hasRequiredUrlJoin = 1;
	(function (module) {
		(function (name, context, definition) {
		  if (module.exports) module.exports = definition();
		  else context[name] = definition();
		})('urljoin', urlJoin, function () {

		  function normalize (strArray) {
		    var resultArray = [];
		    if (strArray.length === 0) { return ''; }

		    if (typeof strArray[0] !== 'string') {
		      throw new TypeError('Url must be a string. Received ' + strArray[0]);
		    }

		    // If the first part is a plain protocol, we combine it with the next part.
		    if (strArray[0].match(/^[^/:]+:\/*$/) && strArray.length > 1) {
		      var first = strArray.shift();
		      strArray[0] = first + strArray[0];
		    }

		    // There must be two or three slashes in the file protocol, two slashes in anything else.
		    if (strArray[0].match(/^file:\/\/\//)) {
		      strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, '$1:///');
		    } else {
		      strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, '$1://');
		    }

		    for (var i = 0; i < strArray.length; i++) {
		      var component = strArray[i];

		      if (typeof component !== 'string') {
		        throw new TypeError('Url must be a string. Received ' + component);
		      }

		      if (component === '') { continue; }

		      if (i > 0) {
		        // Removing the starting slashes for each component but the first.
		        component = component.replace(/^[\/]+/, '');
		      }
		      if (i < strArray.length - 1) {
		        // Removing the ending slashes for each component but the last.
		        component = component.replace(/[\/]+$/, '');
		      } else {
		        // For the last component we will combine multiple slashes to a single one.
		        component = component.replace(/[\/]+$/, '/');
		      }

		      resultArray.push(component);

		    }

		    var str = resultArray.join('/');
		    // Each input component is now separated by a single slash except the possible first plain protocol part.

		    // remove trailing slash before parameters or hash
		    str = str.replace(/\/(\?|&|#[^!])/g, '$1');

		    // replace ? in parameters with &
		    var parts = str.split('?');
		    str = parts.shift() + (parts.length > 0 ? '?': '') + parts.join('&');

		    return str;
		  }

		  return function () {
		    var input;

		    if (typeof arguments[0] === 'object') {
		      input = arguments[0];
		    } else {
		      input = [].slice.call(arguments);
		    }

		    return normalize(input);
		  };

		}); 
	} (urlJoin$1));
	return urlJoin$1.exports;
}

var src$1 = {exports: {}};

var browser = {exports: {}};

/**
 * Helpers.
 */

var ms;
var hasRequiredMs;

function requireMs () {
	if (hasRequiredMs) return ms;
	hasRequiredMs = 1;
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	ms = function (val, options) {
	  options = options || {};
	  var type = typeof val;
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isFinite(val)) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error(
	    'val is not a non-empty string or a valid number. val=' +
	      JSON.stringify(val)
	  );
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
	    str
	  );
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'weeks':
	    case 'week':
	    case 'w':
	      return n * w;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (msAbs >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (msAbs >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (msAbs >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return plural(ms, msAbs, d, 'day');
	  }
	  if (msAbs >= h) {
	    return plural(ms, msAbs, h, 'hour');
	  }
	  if (msAbs >= m) {
	    return plural(ms, msAbs, m, 'minute');
	  }
	  if (msAbs >= s) {
	    return plural(ms, msAbs, s, 'second');
	  }
	  return ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, msAbs, n, name) {
	  var isPlural = msAbs >= n * 1.5;
	  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
	}
	return ms;
}

var common;
var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 */

	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = requireMs();
		createDebug.destroy = destroy;

		Object.keys(env).forEach(key => {
			createDebug[key] = env[key];
		});

		/**
		* The currently active debug mode names, and names to skip.
		*/

		createDebug.names = [];
		createDebug.skips = [];

		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};

		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash = 0;

			for (let i = 0; i < namespace.length; i++) {
				hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
				hash |= 0; // Convert to 32bit integer
			}

			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;

		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;

			function debug(...args) {
				// Disabled?
				if (!debug.enabled) {
					return;
				}

				const self = debug;

				// Set `diff` timestamp
				const curr = Number(new Date());
				const ms = curr - (prevTime || curr);
				self.diff = ms;
				self.prev = prevTime;
				self.curr = curr;
				prevTime = curr;

				args[0] = createDebug.coerce(args[0]);

				if (typeof args[0] !== 'string') {
					// Anything else let's inspect with %O
					args.unshift('%O');
				}

				// Apply any `formatters` transformations
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					// If we encounter an escaped % then don't increase the array index
					if (match === '%%') {
						return '%';
					}
					index++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === 'function') {
						const val = args[index];
						match = formatter.call(self, val);

						// Now we need to remove `args[index]` since it's inlined in the `format`
						args.splice(index, 1);
						index--;
					}
					return match;
				});

				// Apply env-specific formatting (colors, etc.)
				createDebug.formatArgs.call(self, args);

				const logFn = self.log || createDebug.log;
				logFn.apply(self, args);
			}

			debug.namespace = namespace;
			debug.useColors = createDebug.useColors();
			debug.color = createDebug.selectColor(namespace);
			debug.extend = extend;
			debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

			Object.defineProperty(debug, 'enabled', {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) {
						return enableOverride;
					}
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}

					return enabledCache;
				},
				set: v => {
					enableOverride = v;
				}
			});

			// Env-specific initialization logic for debug instances
			if (typeof createDebug.init === 'function') {
				createDebug.init(debug);
			}

			return debug;
		}

		function extend(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}

		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;

			createDebug.names = [];
			createDebug.skips = [];

			let i;
			const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
			const len = split.length;

			for (i = 0; i < len; i++) {
				if (!split[i]) {
					// ignore empty strings
					continue;
				}

				namespaces = split[i].replace(/\*/g, '.*?');

				if (namespaces[0] === '-') {
					createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
				} else {
					createDebug.names.push(new RegExp('^' + namespaces + '$'));
				}
			}
		}

		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [
				...createDebug.names.map(toNamespace),
				...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
			].join(',');
			createDebug.enable('');
			return namespaces;
		}

		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			if (name[name.length - 1] === '*') {
				return true;
			}

			let i;
			let len;

			for (i = 0, len = createDebug.skips.length; i < len; i++) {
				if (createDebug.skips[i].test(name)) {
					return false;
				}
			}

			for (i = 0, len = createDebug.names.length; i < len; i++) {
				if (createDebug.names[i].test(name)) {
					return true;
				}
			}

			return false;
		}

		/**
		* Convert regexp to namespace
		*
		* @param {RegExp} regxep
		* @return {String} namespace
		* @api private
		*/
		function toNamespace(regexp) {
			return regexp.toString()
				.substring(2, regexp.toString().length - 2)
				.replace(/\.\*\?$/, '*');
		}

		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) {
				return val.stack || val.message;
			}
			return val;
		}

		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy() {
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}

		createDebug.enable(createDebug.load());

		return createDebug;
	}

	common = setup;
	return common;
}

/* eslint-env browser */

var hasRequiredBrowser;

function requireBrowser () {
	if (hasRequiredBrowser) return browser.exports;
	hasRequiredBrowser = 1;
	(function (module, exports) {
		/**
		 * This is the web browser implementation of `debug()`.
		 */

		exports.formatArgs = formatArgs;
		exports.save = save;
		exports.load = load;
		exports.useColors = useColors;
		exports.storage = localstorage();
		exports.destroy = (() => {
			let warned = false;

			return () => {
				if (!warned) {
					warned = true;
					console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
				}
			};
		})();

		/**
		 * Colors.
		 */

		exports.colors = [
			'#0000CC',
			'#0000FF',
			'#0033CC',
			'#0033FF',
			'#0066CC',
			'#0066FF',
			'#0099CC',
			'#0099FF',
			'#00CC00',
			'#00CC33',
			'#00CC66',
			'#00CC99',
			'#00CCCC',
			'#00CCFF',
			'#3300CC',
			'#3300FF',
			'#3333CC',
			'#3333FF',
			'#3366CC',
			'#3366FF',
			'#3399CC',
			'#3399FF',
			'#33CC00',
			'#33CC33',
			'#33CC66',
			'#33CC99',
			'#33CCCC',
			'#33CCFF',
			'#6600CC',
			'#6600FF',
			'#6633CC',
			'#6633FF',
			'#66CC00',
			'#66CC33',
			'#9900CC',
			'#9900FF',
			'#9933CC',
			'#9933FF',
			'#99CC00',
			'#99CC33',
			'#CC0000',
			'#CC0033',
			'#CC0066',
			'#CC0099',
			'#CC00CC',
			'#CC00FF',
			'#CC3300',
			'#CC3333',
			'#CC3366',
			'#CC3399',
			'#CC33CC',
			'#CC33FF',
			'#CC6600',
			'#CC6633',
			'#CC9900',
			'#CC9933',
			'#CCCC00',
			'#CCCC33',
			'#FF0000',
			'#FF0033',
			'#FF0066',
			'#FF0099',
			'#FF00CC',
			'#FF00FF',
			'#FF3300',
			'#FF3333',
			'#FF3366',
			'#FF3399',
			'#FF33CC',
			'#FF33FF',
			'#FF6600',
			'#FF6633',
			'#FF9900',
			'#FF9933',
			'#FFCC00',
			'#FFCC33'
		];

		/**
		 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
		 * and the Firebug extension (any Firefox version) are known
		 * to support "%c" CSS customizations.
		 *
		 * TODO: add a `localStorage` variable to explicitly enable/disable colors
		 */

		// eslint-disable-next-line complexity
		function useColors() {
			// NB: In an Electron preload script, document will be defined but not fully
			// initialized. Since we know we're in Chrome, we'll just detect this case
			// explicitly
			if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
				return true;
			}

			// Internet Explorer and Edge do not support colors.
			if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
				return false;
			}

			let m;

			// Is webkit? http://stackoverflow.com/a/16459606/376773
			// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
			return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
				// Is firebug? http://stackoverflow.com/a/398120/376773
				(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
				// Is firefox >= v31?
				// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
				(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
				// Double check webkit in userAgent just in case we are in a worker
				(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
		}

		/**
		 * Colorize log arguments if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			args[0] = (this.useColors ? '%c' : '') +
				this.namespace +
				(this.useColors ? ' %c' : ' ') +
				args[0] +
				(this.useColors ? '%c ' : ' ') +
				'+' + module.exports.humanize(this.diff);

			if (!this.useColors) {
				return;
			}

			const c = 'color: ' + this.color;
			args.splice(1, 0, c, 'color: inherit');

			// The final "%c" is somewhat tricky, because there could be other
			// arguments passed either before or after the %c, so we need to
			// figure out the correct index to insert the CSS into
			let index = 0;
			let lastC = 0;
			args[0].replace(/%[a-zA-Z%]/g, match => {
				if (match === '%%') {
					return;
				}
				index++;
				if (match === '%c') {
					// We only are interested in the *last* %c
					// (the user may have provided their own)
					lastC = index;
				}
			});

			args.splice(lastC, 0, c);
		}

		/**
		 * Invokes `console.debug()` when available.
		 * No-op when `console.debug` is not a "function".
		 * If `console.debug` is not available, falls back
		 * to `console.log`.
		 *
		 * @api public
		 */
		exports.log = console.debug || console.log || (() => {});

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			try {
				if (namespaces) {
					exports.storage.setItem('debug', namespaces);
				} else {
					exports.storage.removeItem('debug');
				}
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */
		function load() {
			let r;
			try {
				r = exports.storage.getItem('debug');
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}

			// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
			if (!r && typeof process !== 'undefined' && 'env' in process) {
				r = process.env.DEBUG;
			}

			return r;
		}

		/**
		 * Localstorage attempts to return the localstorage.
		 *
		 * This is necessary because safari throws
		 * when a user disables cookies/localstorage
		 * and you attempt to access it.
		 *
		 * @return {LocalStorage}
		 * @api private
		 */

		function localstorage() {
			try {
				// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
				// The Browser also has localStorage in the global context.
				return localStorage;
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		module.exports = requireCommon()(exports);

		const {formatters} = module.exports;

		/**
		 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
		 */

		formatters.j = function (v) {
			try {
				return JSON.stringify(v);
			} catch (error) {
				return '[UnexpectedJSONParseError]: ' + error.message;
			}
		}; 
	} (browser, browser.exports));
	return browser.exports;
}

var node$1 = {exports: {}};

/**
 * Module dependencies.
 */

var hasRequiredNode$1;

function requireNode$1 () {
	if (hasRequiredNode$1) return node$1.exports;
	hasRequiredNode$1 = 1;
	(function (module, exports) {
		const tty = require$$0$9;
		const util = require$$1$2;

		/**
		 * This is the Node.js implementation of `debug()`.
		 */

		exports.init = init;
		exports.log = log;
		exports.formatArgs = formatArgs;
		exports.save = save;
		exports.load = load;
		exports.useColors = useColors;
		exports.destroy = util.deprecate(
			() => {},
			'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
		);

		/**
		 * Colors.
		 */

		exports.colors = [6, 2, 3, 4, 5, 1];

		try {
			// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
			// eslint-disable-next-line import/no-extraneous-dependencies
			const supportsColor = require('supports-color');

			if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
				exports.colors = [
					20,
					21,
					26,
					27,
					32,
					33,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					56,
					57,
					62,
					63,
					68,
					69,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					92,
					93,
					98,
					99,
					112,
					113,
					128,
					129,
					134,
					135,
					148,
					149,
					160,
					161,
					162,
					163,
					164,
					165,
					166,
					167,
					168,
					169,
					170,
					171,
					172,
					173,
					178,
					179,
					184,
					185,
					196,
					197,
					198,
					199,
					200,
					201,
					202,
					203,
					204,
					205,
					206,
					207,
					208,
					209,
					214,
					215,
					220,
					221
				];
			}
		} catch (error) {
			// Swallow - we only care if `supports-color` is available; it doesn't have to be.
		}

		/**
		 * Build up the default `inspectOpts` object from the environment variables.
		 *
		 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
		 */

		exports.inspectOpts = Object.keys(process.env).filter(key => {
			return /^debug_/i.test(key);
		}).reduce((obj, key) => {
			// Camel-case
			const prop = key
				.substring(6)
				.toLowerCase()
				.replace(/_([a-z])/g, (_, k) => {
					return k.toUpperCase();
				});

			// Coerce string value into JS value
			let val = process.env[key];
			if (/^(yes|on|true|enabled)$/i.test(val)) {
				val = true;
			} else if (/^(no|off|false|disabled)$/i.test(val)) {
				val = false;
			} else if (val === 'null') {
				val = null;
			} else {
				val = Number(val);
			}

			obj[prop] = val;
			return obj;
		}, {});

		/**
		 * Is stdout a TTY? Colored output is enabled when `true`.
		 */

		function useColors() {
			return 'colors' in exports.inspectOpts ?
				Boolean(exports.inspectOpts.colors) :
				tty.isatty(process.stderr.fd);
		}

		/**
		 * Adds ANSI color escape codes if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			const {namespace: name, useColors} = this;

			if (useColors) {
				const c = this.color;
				const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
				const prefix = `  ${colorCode};1m${name} \u001B[0m`;

				args[0] = prefix + args[0].split('\n').join('\n' + prefix);
				args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
			} else {
				args[0] = getDate() + name + ' ' + args[0];
			}
		}

		function getDate() {
			if (exports.inspectOpts.hideDate) {
				return '';
			}
			return new Date().toISOString() + ' ';
		}

		/**
		 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
		 */

		function log(...args) {
			return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
		}

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			if (namespaces) {
				process.env.DEBUG = namespaces;
			} else {
				// If you set a process.env field to null or undefined, it gets cast to the
				// string 'null' or 'undefined'. Just delete instead.
				delete process.env.DEBUG;
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */

		function load() {
			return process.env.DEBUG;
		}

		/**
		 * Init logic for `debug` instances.
		 *
		 * Create a new `inspectOpts` object in case `useColors` is set
		 * differently for a particular `debug` instance.
		 */

		function init(debug) {
			debug.inspectOpts = {};

			const keys = Object.keys(exports.inspectOpts);
			for (let i = 0; i < keys.length; i++) {
				debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
			}
		}

		module.exports = requireCommon()(exports);

		const {formatters} = module.exports;

		/**
		 * Map %o to `util.inspect()`, all on a single line.
		 */

		formatters.o = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts)
				.split('\n')
				.map(str => str.trim())
				.join(' ');
		};

		/**
		 * Map %O to `util.inspect()`, allowing multiple lines if needed.
		 */

		formatters.O = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts);
		}; 
	} (node$1, node$1.exports));
	return node$1.exports;
}

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

var hasRequiredSrc$1;

function requireSrc$1 () {
	if (hasRequiredSrc$1) return src$1.exports;
	hasRequiredSrc$1 = 1;
	if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
		src$1.exports = requireBrowser();
	} else {
		src$1.exports = requireNode$1();
	}
	return src$1.exports;
}

var rfdc_1;
var hasRequiredRfdc;

function requireRfdc () {
	if (hasRequiredRfdc) return rfdc_1;
	hasRequiredRfdc = 1;
	rfdc_1 = rfdc;

	function copyBuffer (cur) {
	  if (cur instanceof Buffer) {
	    return Buffer.from(cur)
	  }

	  return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length)
	}

	function rfdc (opts) {
	  opts = opts || {};
	  if (opts.circles) return rfdcCircles(opts)

	  const constructorHandlers = new Map();
	  constructorHandlers.set(Date, (o) => new Date(o));
	  constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
	  constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
	  if (opts.constructorHandlers) {
	    for (const handler of opts.constructorHandlers) {
	      constructorHandlers.set(handler[0], handler[1]);
	    }
	  }

	  let handler = null;

	  return opts.proto ? cloneProto : clone

	  function cloneArray (a, fn) {
	    const keys = Object.keys(a);
	    const a2 = new Array(keys.length);
	    for (let i = 0; i < keys.length; i++) {
	      const k = keys[i];
	      const cur = a[k];
	      if (typeof cur !== 'object' || cur === null) {
	        a2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        a2[k] = handler(cur, fn);
	      } else if (ArrayBuffer.isView(cur)) {
	        a2[k] = copyBuffer(cur);
	      } else {
	        a2[k] = fn(cur);
	      }
	    }
	    return a2
	  }

	  function clone (o) {
	    if (typeof o !== 'object' || o === null) return o
	    if (Array.isArray(o)) return cloneArray(o, clone)
	    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
	      return handler(o, clone)
	    }
	    const o2 = {};
	    for (const k in o) {
	      if (Object.hasOwnProperty.call(o, k) === false) continue
	      const cur = o[k];
	      if (typeof cur !== 'object' || cur === null) {
	        o2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        o2[k] = handler(cur, clone);
	      } else if (ArrayBuffer.isView(cur)) {
	        o2[k] = copyBuffer(cur);
	      } else {
	        o2[k] = clone(cur);
	      }
	    }
	    return o2
	  }

	  function cloneProto (o) {
	    if (typeof o !== 'object' || o === null) return o
	    if (Array.isArray(o)) return cloneArray(o, cloneProto)
	    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
	      return handler(o, cloneProto)
	    }
	    const o2 = {};
	    for (const k in o) {
	      const cur = o[k];
	      if (typeof cur !== 'object' || cur === null) {
	        o2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        o2[k] = handler(cur, cloneProto);
	      } else if (ArrayBuffer.isView(cur)) {
	        o2[k] = copyBuffer(cur);
	      } else {
	        o2[k] = cloneProto(cur);
	      }
	    }
	    return o2
	  }
	}

	function rfdcCircles (opts) {
	  const refs = [];
	  const refsNew = [];

	  const constructorHandlers = new Map();
	  constructorHandlers.set(Date, (o) => new Date(o));
	  constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
	  constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
	  if (opts.constructorHandlers) {
	    for (const handler of opts.constructorHandlers) {
	      constructorHandlers.set(handler[0], handler[1]);
	    }
	  }

	  let handler = null;
	  return opts.proto ? cloneProto : clone

	  function cloneArray (a, fn) {
	    const keys = Object.keys(a);
	    const a2 = new Array(keys.length);
	    for (let i = 0; i < keys.length; i++) {
	      const k = keys[i];
	      const cur = a[k];
	      if (typeof cur !== 'object' || cur === null) {
	        a2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        a2[k] = handler(cur, fn);
	      } else if (ArrayBuffer.isView(cur)) {
	        a2[k] = copyBuffer(cur);
	      } else {
	        const index = refs.indexOf(cur);
	        if (index !== -1) {
	          a2[k] = refsNew[index];
	        } else {
	          a2[k] = fn(cur);
	        }
	      }
	    }
	    return a2
	  }

	  function clone (o) {
	    if (typeof o !== 'object' || o === null) return o
	    if (Array.isArray(o)) return cloneArray(o, clone)
	    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
	      return handler(o, clone)
	    }
	    const o2 = {};
	    refs.push(o);
	    refsNew.push(o2);
	    for (const k in o) {
	      if (Object.hasOwnProperty.call(o, k) === false) continue
	      const cur = o[k];
	      if (typeof cur !== 'object' || cur === null) {
	        o2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        o2[k] = handler(cur, clone);
	      } else if (ArrayBuffer.isView(cur)) {
	        o2[k] = copyBuffer(cur);
	      } else {
	        const i = refs.indexOf(cur);
	        if (i !== -1) {
	          o2[k] = refsNew[i];
	        } else {
	          o2[k] = clone(cur);
	        }
	      }
	    }
	    refs.pop();
	    refsNew.pop();
	    return o2
	  }

	  function cloneProto (o) {
	    if (typeof o !== 'object' || o === null) return o
	    if (Array.isArray(o)) return cloneArray(o, cloneProto)
	    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
	      return handler(o, cloneProto)
	    }
	    const o2 = {};
	    refs.push(o);
	    refsNew.push(o2);
	    for (const k in o) {
	      const cur = o[k];
	      if (typeof cur !== 'object' || cur === null) {
	        o2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        o2[k] = handler(cur, cloneProto);
	      } else if (ArrayBuffer.isView(cur)) {
	        o2[k] = copyBuffer(cur);
	      } else {
	        const i = refs.indexOf(cur);
	        if (i !== -1) {
	          o2[k] = refsNew[i];
	        } else {
	          o2[k] = cloneProto(cur);
	        }
	      }
	    }
	    refs.pop();
	    refsNew.pop();
	    return o2
	  }
	}
	return rfdc_1;
}

var configuration;
var hasRequiredConfiguration;

function requireConfiguration () {
	if (hasRequiredConfiguration) return configuration;
	hasRequiredConfiguration = 1;
	const util = require$$1$2;
	const debug = requireSrc$1()('log4js:configuration');

	const preProcessingListeners = [];
	const listeners = [];

	const not = (thing) => !thing;

	const anObject = (thing) =>
	  thing && typeof thing === 'object' && !Array.isArray(thing);

	const validIdentifier = (thing) => /^[A-Za-z][A-Za-z0-9_]*$/g.test(thing);

	const anInteger = (thing) =>
	  thing && typeof thing === 'number' && Number.isInteger(thing);

	const addListener = (fn) => {
	  listeners.push(fn);
	  debug(`Added listener, now ${listeners.length} listeners`);
	};

	const addPreProcessingListener = (fn) => {
	  preProcessingListeners.push(fn);
	  debug(
	    `Added pre-processing listener, now ${preProcessingListeners.length} listeners`
	  );
	};

	const throwExceptionIf = (config, checks, message) => {
	  const tests = Array.isArray(checks) ? checks : [checks];
	  tests.forEach((test) => {
	    if (test) {
	      throw new Error(
	        `Problem with log4js configuration: (${util.inspect(config, {
	          depth: 5,
	        })}) - ${message}`
	      );
	    }
	  });
	};

	const configure = (candidate) => {
	  debug('New configuration to be validated: ', candidate);
	  throwExceptionIf(candidate, not(anObject(candidate)), 'must be an object.');

	  debug(`Calling pre-processing listeners (${preProcessingListeners.length})`);
	  preProcessingListeners.forEach((listener) => listener(candidate));
	  debug('Configuration pre-processing finished.');

	  debug(`Calling configuration listeners (${listeners.length})`);
	  listeners.forEach((listener) => listener(candidate));
	  debug('Configuration finished.');
	};

	configuration = {
	  configure,
	  addListener,
	  addPreProcessingListener,
	  throwExceptionIf,
	  anObject,
	  anInteger,
	  validIdentifier,
	  not,
	};
	return configuration;
}

var lib$4 = {exports: {}};

var hasRequiredLib$4;

function requireLib$4 () {
	if (hasRequiredLib$4) return lib$4.exports;
	hasRequiredLib$4 = 1;
	(function (module) {

		function padWithZeros(vNumber, width) {
		  var numAsString = vNumber.toString();
		  while (numAsString.length < width) {
		    numAsString = "0" + numAsString;
		  }
		  return numAsString;
		}

		function addZero(vNumber) {
		  return padWithZeros(vNumber, 2);
		}

		/**
		 * Formats the TimeOffset
		 * Thanks to http://www.svendtofte.com/code/date_format/
		 * @private
		 */
		function offset(timezoneOffset) {
		  var os = Math.abs(timezoneOffset);
		  var h = String(Math.floor(os / 60));
		  var m = String(os % 60);
		  h = ("0" + h).slice(-2);
		  m = ("0" + m).slice(-2);
		  return timezoneOffset === 0 ? "Z" : (timezoneOffset < 0 ? "+" : "-") + h + ":" + m;
		}

		function asString(format, date) {
		  if (typeof format !== "string") {
		    date = format;
		    format = module.exports.ISO8601_FORMAT;
		  }
		  if (!date) {
		    date = module.exports.now();
		  }

		  // Issue # 14 - Per ISO8601 standard, the time string should be local time
		  // with timezone info.
		  // See https://en.wikipedia.org/wiki/ISO_8601 section "Time offsets from UTC"

		  var vDay = addZero(date.getDate());
		  var vMonth = addZero(date.getMonth() + 1);
		  var vYearLong = addZero(date.getFullYear());
		  var vYearShort = addZero(vYearLong.substring(2, 4));
		  var vYear = format.indexOf("yyyy") > -1 ? vYearLong : vYearShort;
		  var vHour = addZero(date.getHours());
		  var vMinute = addZero(date.getMinutes());
		  var vSecond = addZero(date.getSeconds());
		  var vMillisecond = padWithZeros(date.getMilliseconds(), 3);
		  var vTimeZone = offset(date.getTimezoneOffset());
		  var formatted = format
		    .replace(/dd/g, vDay)
		    .replace(/MM/g, vMonth)
		    .replace(/y{1,4}/g, vYear)
		    .replace(/hh/g, vHour)
		    .replace(/mm/g, vMinute)
		    .replace(/ss/g, vSecond)
		    .replace(/SSS/g, vMillisecond)
		    .replace(/O/g, vTimeZone);
		  return formatted;
		}

		function setDatePart(date, part, value, local) {
		  date['set' + (local ? '' : 'UTC') + part](value);
		}

		function extractDateParts(pattern, str, missingValuesDate) {
		  // Javascript Date object doesn't support custom timezone.  Sets all felds as
		  // GMT based to begin with.  If the timezone offset is provided, then adjust
		  // it using provided timezone, otherwise, adjust it with the system timezone.
		  var local = pattern.indexOf('O') < 0;
		  var monthOverflow = false;
		  var matchers = [
		    {
		      pattern: /y{1,4}/,
		      regexp: "\\d{1,4}",
		      fn: function(date, value) {
		        setDatePart(date, 'FullYear', value, local);
		      }
		    },
		    {
		      pattern: /MM/,
		      regexp: "\\d{1,2}",
		      fn: function(date, value) {
		        setDatePart(date, 'Month', (value - 1), local);
		        if (date.getMonth() !== (value - 1)) {
		          // in the event of 31 May --> 31 Feb --> 3 Mar
		          // this is correct behavior if no Date is involved
		          monthOverflow = true;
		        }
		      }
		    },
		    {
		      pattern: /dd/,
		      regexp: "\\d{1,2}",
		      fn: function(date, value) {
		        // in the event of 31 May --> 31 Feb --> 3 Mar
		        // reset Mar back to Feb, before setting the Date
		        if (monthOverflow) {
		          setDatePart(date, 'Month', (date.getMonth() - 1), local);
		        }
		        setDatePart(date, 'Date', value, local);
		      }
		    },
		    {
		      pattern: /hh/,
		      regexp: "\\d{1,2}",
		      fn: function(date, value) {
		        setDatePart(date, 'Hours', value, local);
		      }
		    },
		    {
		      pattern: /mm/,
		      regexp: "\\d\\d",
		      fn: function(date, value) {
		        setDatePart(date, 'Minutes', value, local);
		      }
		    },
		    {
		      pattern: /ss/,
		      regexp: "\\d\\d",
		      fn: function(date, value) {
		        setDatePart(date, 'Seconds', value, local);
		      }
		    },
		    {
		      pattern: /SSS/,
		      regexp: "\\d\\d\\d",
		      fn: function(date, value) {
		        setDatePart(date, 'Milliseconds', value, local);
		      }
		    },
		    {
		      pattern: /O/,
		      regexp: "[+-]\\d{1,2}:?\\d{2}?|Z",
		      fn: function(date, value) {
		        if (value === "Z") {
		          value = 0;
		        }
		        else {
		          value = value.replace(":", "");
		        }
		        var offset = Math.abs(value);
		        var timezoneOffset = (value > 0 ? -1 :  1 ) * ((offset % 100) + Math.floor(offset / 100) * 60);
		        // Per ISO8601 standard: UTC = local time - offset
		        //
		        // For example, 2000-01-01T01:00:00-0700
		        //   local time: 2000-01-01T01:00:00
		        //   ==> UTC   : 2000-01-01T08:00:00 ( 01 - (-7) = 8 )
		        //
		        // To make it even more confusing, the date.getTimezoneOffset() is
		        // opposite sign of offset string in the ISO8601 standard.  So if offset
		        // is '-0700' the getTimezoneOffset() would be (+)420. The line above
		        // calculates timezoneOffset to matche Javascript's behavior.
		        //
		        // The date/time of the input is actually the local time, so the date
		        // object that was constructed is actually local time even thought the
		        // UTC setters are used.  This means the date object's internal UTC
		        // representation was wrong.  It needs to be fixed by substracting the
		        // offset (or adding the offset minutes as they are opposite sign).
		        //
		        // Note: the time zone has to be processed after all other fields are
		        // set.  The result would be incorrect if the offset was calculated
		        // first then overriden by the other filed setters.
		        date.setUTCMinutes(date.getUTCMinutes() + timezoneOffset);
		      }
		    }
		  ];

		  var parsedPattern = matchers.reduce(
		    function(p, m) {
		      if (m.pattern.test(p.regexp)) {
		        m.index = p.regexp.match(m.pattern).index;
		        p.regexp = p.regexp.replace(m.pattern, "(" + m.regexp + ")");
		      } else {
		        m.index = -1;
		      }
		      return p;
		    },
		    { regexp: pattern, index: [] }
		  );

		  var dateFns = matchers.filter(function(m) {
		    return m.index > -1;
		  });
		  dateFns.sort(function(a, b) {
		    return a.index - b.index;
		  });

		  var matcher = new RegExp(parsedPattern.regexp);
		  var matches = matcher.exec(str);
		  if (matches) {
		    var date = missingValuesDate || module.exports.now();
		    dateFns.forEach(function(f, i) {
		      f.fn(date, matches[i + 1]);
		    });

		    return date;
		  }

		  throw new Error(
		    "String '" + str + "' could not be parsed as '" + pattern + "'"
		  );
		}

		function parse(pattern, str, missingValuesDate) {
		  if (!pattern) {
		    throw new Error("pattern must be supplied");
		  }

		  return extractDateParts(pattern, str, missingValuesDate);
		}

		/**
		 * Used for testing - replace this function with a fixed date.
		 */
		function now() {
		  return new Date();
		}

		module.exports = asString;
		module.exports.asString = asString;
		module.exports.parse = parse;
		module.exports.now = now;
		module.exports.ISO8601_FORMAT = "yyyy-MM-ddThh:mm:ss.SSS";
		module.exports.ISO8601_WITH_TZ_OFFSET_FORMAT = "yyyy-MM-ddThh:mm:ss.SSSO";
		module.exports.DATETIME_FORMAT = "dd MM yyyy hh:mm:ss.SSS";
		module.exports.ABSOLUTETIME_FORMAT = "hh:mm:ss.SSS"; 
	} (lib$4));
	return lib$4.exports;
}

var layouts;
var hasRequiredLayouts;

function requireLayouts () {
	if (hasRequiredLayouts) return layouts;
	hasRequiredLayouts = 1;
	const dateFormat = requireLib$4();
	const os = require$$1$5;
	const util = require$$1$2;
	const path = require$$1$4;
	const url = require$$0$2;
	const debug = requireSrc$1()('log4js:layouts');

	const styles = {
	  // styles
	  bold: [1, 22],
	  italic: [3, 23],
	  underline: [4, 24],
	  inverse: [7, 27],
	  // grayscale
	  white: [37, 39],
	  grey: [90, 39],
	  black: [90, 39],
	  // colors
	  blue: [34, 39],
	  cyan: [36, 39],
	  green: [32, 39],
	  magenta: [35, 39],
	  red: [91, 39],
	  yellow: [33, 39],
	};

	function colorizeStart(style) {
	  return style ? `\x1B[${styles[style][0]}m` : '';
	}

	function colorizeEnd(style) {
	  return style ? `\x1B[${styles[style][1]}m` : '';
	}

	/**
	 * Taken from masylum's fork (https://github.com/masylum/log4js-node)
	 */
	function colorize(str, style) {
	  return colorizeStart(style) + str + colorizeEnd(style);
	}

	function timestampLevelAndCategory(loggingEvent, colour) {
	  return colorize(
	    util.format(
	      '[%s] [%s] %s - ',
	      dateFormat.asString(loggingEvent.startTime),
	      loggingEvent.level.toString(),
	      loggingEvent.categoryName
	    ),
	    colour
	  );
	}

	/**
	 * BasicLayout is a simple layout for storing the logs. The logs are stored
	 * in following format:
	 * <pre>
	 * [startTime] [logLevel] categoryName - message\n
	 * </pre>
	 *
	 * @author Stephan Strittmatter
	 */
	function basicLayout(loggingEvent) {
	  return (
	    timestampLevelAndCategory(loggingEvent) + util.format(...loggingEvent.data)
	  );
	}

	/**
	 * colouredLayout - taken from masylum's fork.
	 * same as basicLayout, but with colours.
	 */
	function colouredLayout(loggingEvent) {
	  return (
	    timestampLevelAndCategory(loggingEvent, loggingEvent.level.colour) +
	    util.format(...loggingEvent.data)
	  );
	}

	function messagePassThroughLayout(loggingEvent) {
	  return util.format(...loggingEvent.data);
	}

	function dummyLayout(loggingEvent) {
	  return loggingEvent.data[0];
	}

	/**
	 * PatternLayout
	 * Format for specifiers is %[padding].[truncation][field]{[format]}
	 * e.g. %5.10p - left pad the log level by 5 characters, up to a max of 10
	 * both padding and truncation can be negative.
	 * Negative truncation = trunc from end of string
	 * Positive truncation = trunc from start of string
	 * Negative padding = pad right
	 * Positive padding = pad left
	 *
	 * Fields can be any of:
	 *  - %r time in toLocaleTimeString format
	 *  - %p log level
	 *  - %c log category
	 *  - %h hostname
	 *  - %m log data
	 *  - %m{l} where l is an integer, log data.slice(l)
	 *  - %m{l,u} where l and u are integers, log data.slice(l, u)
	 *  - %d date in constious formats
	 *  - %% %
	 *  - %n newline
	 *  - %z pid
	 *  - %f filename
	 *  - %l line number
	 *  - %o column postion
	 *  - %s call stack
	 *  - %C class name [#1316](https://github.com/log4js-node/log4js-node/pull/1316)
	 *  - %M method or function name [#1316](https://github.com/log4js-node/log4js-node/pull/1316)
	 *  - %A method or function alias [#1316](https://github.com/log4js-node/log4js-node/pull/1316)
	 *  - %F fully qualified caller name [#1316](https://github.com/log4js-node/log4js-node/pull/1316)
	 *  - %x{<tokenname>} add dynamic tokens to your log. Tokens are specified in the tokens parameter
	 *  - %X{<tokenname>} add dynamic tokens to your log. Tokens are specified in logger context
	 * You can use %[ and %] to define a colored block.
	 *
	 * Tokens are specified as simple key:value objects.
	 * The key represents the token name whereas the value can be a string or function
	 * which is called to extract the value to put in the log message. If token is not
	 * found, it doesn't replace the field.
	 *
	 * A sample token would be: { 'pid' : function() { return process.pid; } }
	 *
	 * Takes a pattern string, array of tokens and returns a layout function.
	 * @return {Function}
	 * @param pattern
	 * @param tokens
	 * @param timezoneOffset
	 *
	 * @authors ['Stephan Strittmatter', 'Jan Schmidle']
	 */
	function patternLayout(pattern, tokens) {
	  const TTCC_CONVERSION_PATTERN = '%r %p %c - %m%n';
	  const regex =
	    /%(-?[0-9]+)?(\.?-?[0-9]+)?([[\]cdhmnprzxXyflosCMAF%])(\{([^}]+)\})?|([^%]+)/;

	  pattern = pattern || TTCC_CONVERSION_PATTERN;

	  function categoryName(loggingEvent, specifier) {
	    let loggerName = loggingEvent.categoryName;
	    if (specifier) {
	      const precision = parseInt(specifier, 10);
	      const loggerNameBits = loggerName.split('.');
	      if (precision < loggerNameBits.length) {
	        loggerName = loggerNameBits
	          .slice(loggerNameBits.length - precision)
	          .join('.');
	      }
	    }
	    return loggerName;
	  }

	  function formatAsDate(loggingEvent, specifier) {
	    let format = dateFormat.ISO8601_FORMAT;
	    if (specifier) {
	      format = specifier;
	      // Pick up special cases
	      switch (format) {
	        case 'ISO8601':
	        case 'ISO8601_FORMAT':
	          format = dateFormat.ISO8601_FORMAT;
	          break;
	        case 'ISO8601_WITH_TZ_OFFSET':
	        case 'ISO8601_WITH_TZ_OFFSET_FORMAT':
	          format = dateFormat.ISO8601_WITH_TZ_OFFSET_FORMAT;
	          break;
	        case 'ABSOLUTE':
	          process.emitWarning(
	            'Pattern %d{ABSOLUTE} is deprecated in favor of %d{ABSOLUTETIME}. ' +
	              'Please use %d{ABSOLUTETIME} instead.',
	            'DeprecationWarning',
	            'log4js-node-DEP0003'
	          );
	          debug(
	            '[log4js-node-DEP0003]',
	            'DEPRECATION: Pattern %d{ABSOLUTE} is deprecated and replaced by %d{ABSOLUTETIME}.'
	          );
	        // falls through
	        case 'ABSOLUTETIME':
	        case 'ABSOLUTETIME_FORMAT':
	          format = dateFormat.ABSOLUTETIME_FORMAT;
	          break;
	        case 'DATE':
	          process.emitWarning(
	            'Pattern %d{DATE} is deprecated due to the confusion it causes when used. ' +
	              'Please use %d{DATETIME} instead.',
	            'DeprecationWarning',
	            'log4js-node-DEP0004'
	          );
	          debug(
	            '[log4js-node-DEP0004]',
	            'DEPRECATION: Pattern %d{DATE} is deprecated and replaced by %d{DATETIME}.'
	          );
	        // falls through
	        case 'DATETIME':
	        case 'DATETIME_FORMAT':
	          format = dateFormat.DATETIME_FORMAT;
	          break;
	        // no default
	      }
	    }
	    // Format the date
	    return dateFormat.asString(format, loggingEvent.startTime);
	  }

	  function hostname() {
	    return os.hostname().toString();
	  }

	  function formatMessage(loggingEvent, specifier) {
	    let dataSlice = loggingEvent.data;
	    if (specifier) {
	      const [lowerBound, upperBound] = specifier.split(',');
	      dataSlice = dataSlice.slice(lowerBound, upperBound);
	    }
	    return util.format(...dataSlice);
	  }

	  function endOfLine() {
	    return os.EOL;
	  }

	  function logLevel(loggingEvent) {
	    return loggingEvent.level.toString();
	  }

	  function startTime(loggingEvent) {
	    return dateFormat.asString('hh:mm:ss', loggingEvent.startTime);
	  }

	  function startColour(loggingEvent) {
	    return colorizeStart(loggingEvent.level.colour);
	  }

	  function endColour(loggingEvent) {
	    return colorizeEnd(loggingEvent.level.colour);
	  }

	  function percent() {
	    return '%';
	  }

	  function pid(loggingEvent) {
	    return loggingEvent && loggingEvent.pid
	      ? loggingEvent.pid.toString()
	      : process.pid.toString();
	  }

	  function clusterInfo() {
	    // this used to try to return the master and worker pids,
	    // but it would never have worked because master pid is not available to workers
	    // leaving this here to maintain compatibility for patterns
	    return pid();
	  }

	  function userDefined(loggingEvent, specifier) {
	    if (typeof tokens[specifier] !== 'undefined') {
	      return typeof tokens[specifier] === 'function'
	        ? tokens[specifier](loggingEvent)
	        : tokens[specifier];
	    }

	    return null;
	  }

	  function contextDefined(loggingEvent, specifier) {
	    const resolver = loggingEvent.context[specifier];

	    if (typeof resolver !== 'undefined') {
	      return typeof resolver === 'function' ? resolver(loggingEvent) : resolver;
	    }

	    return null;
	  }

	  function fileName(loggingEvent, specifier) {
	    let filename = loggingEvent.fileName || '';

	    // support for ESM as it uses url instead of path for file
	    /* istanbul ignore next: unsure how to simulate ESM for test coverage */
	    const convertFileURLToPath = function (filepath) {
	      const urlPrefix = 'file://';
	      if (filepath.startsWith(urlPrefix)) {
	        // https://nodejs.org/api/url.html#urlfileurltopathurl
	        if (typeof url.fileURLToPath === 'function') {
	          filepath = url.fileURLToPath(filepath);
	        }
	        // backward-compatible for nodejs pre-10.12.0 (without url.fileURLToPath method)
	        else {
	          // posix: file:///hello/world/foo.txt -> /hello/world/foo.txt -> /hello/world/foo.txt
	          // win32: file:///C:/path/foo.txt     -> /C:/path/foo.txt     -> \C:\path\foo.txt     -> C:\path\foo.txt
	          // win32: file://nas/foo.txt          -> //nas/foo.txt        -> nas\foo.txt          -> \\nas\foo.txt
	          filepath = path.normalize(
	            filepath.replace(new RegExp(`^${urlPrefix}`), '')
	          );
	          if (process.platform === 'win32') {
	            if (filepath.startsWith('\\')) {
	              filepath = filepath.slice(1);
	            } else {
	              filepath = path.sep + path.sep + filepath;
	            }
	          }
	        }
	      }
	      return filepath;
	    };
	    filename = convertFileURLToPath(filename);

	    if (specifier) {
	      const fileDepth = parseInt(specifier, 10);
	      const fileList = filename.split(path.sep);
	      if (fileList.length > fileDepth) {
	        filename = fileList.slice(-fileDepth).join(path.sep);
	      }
	    }

	    return filename;
	  }

	  function lineNumber(loggingEvent) {
	    return loggingEvent.lineNumber ? `${loggingEvent.lineNumber}` : '';
	  }

	  function columnNumber(loggingEvent) {
	    return loggingEvent.columnNumber ? `${loggingEvent.columnNumber}` : '';
	  }

	  function callStack(loggingEvent) {
	    return loggingEvent.callStack || '';
	  }

	  function className(loggingEvent) {
	    return loggingEvent.className || '';
	  }

	  function functionName(loggingEvent) {
	    return loggingEvent.functionName || '';
	  }

	  function functionAlias(loggingEvent) {
	    return loggingEvent.functionAlias || '';
	  }

	  function callerName(loggingEvent) {
	    return loggingEvent.callerName || '';
	  }

	  const replacers = {
	    c: categoryName,
	    d: formatAsDate,
	    h: hostname,
	    m: formatMessage,
	    n: endOfLine,
	    p: logLevel,
	    r: startTime,
	    '[': startColour,
	    ']': endColour,
	    y: clusterInfo,
	    z: pid,
	    '%': percent,
	    x: userDefined,
	    X: contextDefined,
	    f: fileName,
	    l: lineNumber,
	    o: columnNumber,
	    s: callStack,
	    C: className,
	    M: functionName,
	    A: functionAlias,
	    F: callerName,
	  };

	  function replaceToken(conversionCharacter, loggingEvent, specifier) {
	    return replacers[conversionCharacter](loggingEvent, specifier);
	  }

	  function truncate(truncation, toTruncate) {
	    let len;
	    if (truncation) {
	      len = parseInt(truncation.slice(1), 10);
	      // negative truncate length means truncate from end of string
	      return len > 0 ? toTruncate.slice(0, len) : toTruncate.slice(len);
	    }

	    return toTruncate;
	  }

	  function pad(padding, toPad) {
	    let len;
	    if (padding) {
	      if (padding.charAt(0) === '-') {
	        len = parseInt(padding.slice(1), 10);
	        // Right pad with spaces
	        while (toPad.length < len) {
	          toPad += ' ';
	        }
	      } else {
	        len = parseInt(padding, 10);
	        // Left pad with spaces
	        while (toPad.length < len) {
	          toPad = ` ${toPad}`;
	        }
	      }
	    }
	    return toPad;
	  }

	  function truncateAndPad(toTruncAndPad, truncation, padding) {
	    let replacement = toTruncAndPad;
	    replacement = truncate(truncation, replacement);
	    replacement = pad(padding, replacement);
	    return replacement;
	  }

	  return function (loggingEvent) {
	    let formattedString = '';
	    let result;
	    let searchString = pattern;

	    while ((result = regex.exec(searchString)) !== null) {
	      // const matchedString = result[0];
	      const padding = result[1];
	      const truncation = result[2];
	      const conversionCharacter = result[3];
	      const specifier = result[5];
	      const text = result[6];

	      // Check if the pattern matched was just normal text
	      if (text) {
	        formattedString += text.toString();
	      } else {
	        // Create a raw replacement string based on the conversion
	        // character and specifier
	        const replacement = replaceToken(
	          conversionCharacter,
	          loggingEvent,
	          specifier
	        );
	        formattedString += truncateAndPad(replacement, truncation, padding);
	      }
	      searchString = searchString.slice(result.index + result[0].length);
	    }
	    return formattedString;
	  };
	}

	const layoutMakers = {
	  messagePassThrough() {
	    return messagePassThroughLayout;
	  },
	  basic() {
	    return basicLayout;
	  },
	  colored() {
	    return colouredLayout;
	  },
	  coloured() {
	    return colouredLayout;
	  },
	  pattern(config) {
	    return patternLayout(config && config.pattern, config && config.tokens);
	  },
	  dummy() {
	    return dummyLayout;
	  },
	};

	layouts = {
	  basicLayout,
	  messagePassThroughLayout,
	  patternLayout,
	  colouredLayout,
	  coloredLayout: colouredLayout,
	  dummyLayout,
	  addLayout(name, serializerGenerator) {
	    layoutMakers[name] = serializerGenerator;
	  },
	  layout(name, config) {
	    return layoutMakers[name] && layoutMakers[name](config);
	  },
	};
	return layouts;
}

var levels;
var hasRequiredLevels;

function requireLevels () {
	if (hasRequiredLevels) return levels;
	hasRequiredLevels = 1;
	const configuration = requireConfiguration();

	const validColours = [
	  'white',
	  'grey',
	  'black',
	  'blue',
	  'cyan',
	  'green',
	  'magenta',
	  'red',
	  'yellow',
	];

	class Level {
	  constructor(level, levelStr, colour) {
	    this.level = level;
	    this.levelStr = levelStr;
	    this.colour = colour;
	  }

	  toString() {
	    return this.levelStr;
	  }

	  /**
	   * converts given String to corresponding Level
	   * @param {(Level|string)} sArg -- String value of Level OR Log4js.Level
	   * @param {Level} [defaultLevel] -- default Level, if no String representation
	   * @return {Level}
	   */
	  static getLevel(sArg, defaultLevel) {
	    if (!sArg) {
	      return defaultLevel;
	    }

	    if (sArg instanceof Level) {
	      return sArg;
	    }

	    // a json-serialised level won't be an instance of Level (see issue #768)
	    if (sArg instanceof Object && sArg.levelStr) {
	      sArg = sArg.levelStr;
	    }

	    return Level[sArg.toString().toUpperCase()] || defaultLevel;
	  }

	  static addLevels(customLevels) {
	    if (customLevels) {
	      const levels = Object.keys(customLevels);
	      levels.forEach((l) => {
	        const levelStr = l.toUpperCase();
	        Level[levelStr] = new Level(
	          customLevels[l].value,
	          levelStr,
	          customLevels[l].colour
	        );
	        const existingLevelIndex = Level.levels.findIndex(
	          (lvl) => lvl.levelStr === levelStr
	        );
	        if (existingLevelIndex > -1) {
	          Level.levels[existingLevelIndex] = Level[levelStr];
	        } else {
	          Level.levels.push(Level[levelStr]);
	        }
	      });
	      Level.levels.sort((a, b) => a.level - b.level);
	    }
	  }

	  isLessThanOrEqualTo(otherLevel) {
	    if (typeof otherLevel === 'string') {
	      otherLevel = Level.getLevel(otherLevel);
	    }
	    return this.level <= otherLevel.level;
	  }

	  isGreaterThanOrEqualTo(otherLevel) {
	    if (typeof otherLevel === 'string') {
	      otherLevel = Level.getLevel(otherLevel);
	    }
	    return this.level >= otherLevel.level;
	  }

	  isEqualTo(otherLevel) {
	    if (typeof otherLevel === 'string') {
	      otherLevel = Level.getLevel(otherLevel);
	    }
	    return this.level === otherLevel.level;
	  }
	}

	Level.levels = [];
	Level.addLevels({
	  ALL: { value: Number.MIN_VALUE, colour: 'grey' },
	  TRACE: { value: 5000, colour: 'blue' },
	  DEBUG: { value: 10000, colour: 'cyan' },
	  INFO: { value: 20000, colour: 'green' },
	  WARN: { value: 30000, colour: 'yellow' },
	  ERROR: { value: 40000, colour: 'red' },
	  FATAL: { value: 50000, colour: 'magenta' },
	  MARK: { value: 9007199254740992, colour: 'grey' }, // 2^53
	  OFF: { value: Number.MAX_VALUE, colour: 'grey' },
	});

	configuration.addListener((config) => {
	  const levelConfig = config.levels;
	  if (levelConfig) {
	    configuration.throwExceptionIf(
	      config,
	      configuration.not(configuration.anObject(levelConfig)),
	      'levels must be an object'
	    );
	    const newLevels = Object.keys(levelConfig);
	    newLevels.forEach((l) => {
	      configuration.throwExceptionIf(
	        config,
	        configuration.not(configuration.validIdentifier(l)),
	        `level name "${l}" is not a valid identifier (must start with a letter, only contain A-Z,a-z,0-9,_)`
	      );
	      configuration.throwExceptionIf(
	        config,
	        configuration.not(configuration.anObject(levelConfig[l])),
	        `level "${l}" must be an object`
	      );
	      configuration.throwExceptionIf(
	        config,
	        configuration.not(levelConfig[l].value),
	        `level "${l}" must have a 'value' property`
	      );
	      configuration.throwExceptionIf(
	        config,
	        configuration.not(configuration.anInteger(levelConfig[l].value)),
	        `level "${l}".value must have an integer value`
	      );
	      configuration.throwExceptionIf(
	        config,
	        configuration.not(levelConfig[l].colour),
	        `level "${l}" must have a 'colour' property`
	      );
	      configuration.throwExceptionIf(
	        config,
	        configuration.not(validColours.indexOf(levelConfig[l].colour) > -1),
	        `level "${l}".colour must be one of ${validColours.join(', ')}`
	      );
	    });
	  }
	});

	configuration.addListener((config) => {
	  Level.addLevels(config.levels);
	});

	levels = Level;
	return levels;
}

var appenders = {exports: {}};

var cjs = {};

var hasRequiredCjs;

function requireCjs () {
	if (hasRequiredCjs) return cjs;
	hasRequiredCjs = 1;
	/// <reference types="../types/index.d.ts" />

	// (c) 2020-present Andrea Giammarchi

	const {parse: $parse, stringify: $stringify} = JSON;
	const {keys} = Object;

	const Primitive = String;   // it could be Number
	const primitive = 'string'; // it could be 'number'

	const ignore = {};
	const object = 'object';

	const noop = (_, value) => value;

	const primitives = value => (
	  value instanceof Primitive ? Primitive(value) : value
	);

	const Primitives = (_, value) => (
	  typeof value === primitive ? new Primitive(value) : value
	);

	const revive = (input, parsed, output, $) => {
	  const lazy = [];
	  for (let ke = keys(output), {length} = ke, y = 0; y < length; y++) {
	    const k = ke[y];
	    const value = output[k];
	    if (value instanceof Primitive) {
	      const tmp = input[value];
	      if (typeof tmp === object && !parsed.has(tmp)) {
	        parsed.add(tmp);
	        output[k] = ignore;
	        lazy.push({k, a: [input, parsed, tmp, $]});
	      }
	      else
	        output[k] = $.call(output, k, tmp);
	    }
	    else if (output[k] !== ignore)
	      output[k] = $.call(output, k, value);
	  }
	  for (let {length} = lazy, i = 0; i < length; i++) {
	    const {k, a} = lazy[i];
	    output[k] = $.call(output, k, revive.apply(null, a));
	  }
	  return output;
	};

	const set = (known, input, value) => {
	  const index = Primitive(input.push(value) - 1);
	  known.set(value, index);
	  return index;
	};

	/**
	 * Converts a specialized flatted string into a JS value.
	 * @param {string} text
	 * @param {(this: any, key: string, value: any) => any} [reviver]
	 * @returns {any}
	 */
	const parse = (text, reviver) => {
	  const input = $parse(text, Primitives).map(primitives);
	  const value = input[0];
	  const $ = reviver || noop;
	  const tmp = typeof value === object && value ?
	              revive(input, new Set, value, $) :
	              value;
	  return $.call({'': tmp}, '', tmp);
	};
	cjs.parse = parse;

	/**
	 * Converts a JS value into a specialized flatted string.
	 * @param {any} value
	 * @param {((this: any, key: string, value: any) => any) | (string | number)[] | null | undefined} [replacer]
	 * @param {string | number | undefined} [space]
	 * @returns {string}
	 */
	const stringify = (value, replacer, space) => {
	  const $ = replacer && typeof replacer === object ?
	            (k, v) => (k === '' || -1 < replacer.indexOf(k) ? v : void 0) :
	            (replacer || noop);
	  const known = new Map;
	  const input = [];
	  const output = [];
	  let i = +set(known, input, $.call({'': value}, '', value));
	  let firstRun = !i;
	  while (i < input.length) {
	    firstRun = true;
	    output[i] = $stringify(input[i++], replace, space);
	  }
	  return '[' + output.join(',') + ']';
	  function replace(key, value) {
	    if (firstRun) {
	      firstRun = !firstRun;
	      return value;
	    }
	    const after = $.call(this, key, value);
	    switch (typeof after) {
	      case object:
	        if (after === null) return after;
	      case primitive:
	        return known.get(after) || set(known, input, after);
	    }
	    return after;
	  }
	};
	cjs.stringify = stringify;

	/**
	 * Converts a generic value into a JSON serializable object without losing recursion.
	 * @param {any} value
	 * @returns {any}
	 */
	const toJSON = value => $parse(stringify(value));
	cjs.toJSON = toJSON;

	/**
	 * Converts a previously serialized object with recursion into a recursive one.
	 * @param {any} value
	 * @returns {any}
	 */
	const fromJSON = value => parse($stringify(value));
	cjs.fromJSON = fromJSON;
	return cjs;
}

/* eslint max-classes-per-file: ["error", 2] */

var LoggingEvent_1;
var hasRequiredLoggingEvent;

function requireLoggingEvent () {
	if (hasRequiredLoggingEvent) return LoggingEvent_1;
	hasRequiredLoggingEvent = 1;
	/* eslint no-underscore-dangle: ["error", { "allow": ["_getLocationKeys"] }] */

	const flatted = requireCjs();
	const levels = requireLevels();

	class SerDe {
	  constructor() {
	    const deserialise = {
	      __LOG4JS_undefined__: undefined,
	      __LOG4JS_NaN__: Number('abc'),
	      __LOG4JS_Infinity__: 1 / 0,
	      '__LOG4JS_-Infinity__': -1 / 0,
	    };
	    this.deMap = deserialise;
	    this.serMap = {};
	    Object.keys(this.deMap).forEach((key) => {
	      const value = this.deMap[key];
	      this.serMap[value] = key;
	    });
	  }

	  canSerialise(key) {
	    if (typeof key === 'string') return false;
	    return key in this.serMap;
	  }

	  serialise(key) {
	    if (this.canSerialise(key)) return this.serMap[key];
	    return key;
	  }

	  canDeserialise(key) {
	    return key in this.deMap;
	  }

	  deserialise(key) {
	    if (this.canDeserialise(key)) return this.deMap[key];
	    return key;
	  }
	}
	const serde = new SerDe();

	/**
	 * @name LoggingEvent
	 * @namespace Log4js
	 */
	class LoggingEvent {
	  /**
	   * Models a logging event.
	   * @constructor
	   * @param {string} categoryName name of category
	   * @param {Log4js.Level} level level of message
	   * @param {Array} data objects to log
	   * @param {Error} [error]
	   * @author Seth Chisamore
	   */
	  constructor(categoryName, level, data, context, location, error) {
	    this.startTime = new Date();
	    this.categoryName = categoryName;
	    this.data = data;
	    this.level = level;
	    this.context = Object.assign({}, context); // eslint-disable-line prefer-object-spread
	    this.pid = process.pid;
	    this.error = error;

	    if (typeof location !== 'undefined') {
	      if (!location || typeof location !== 'object' || Array.isArray(location))
	        throw new TypeError(
	          'Invalid location type passed to LoggingEvent constructor'
	        );

	      this.constructor._getLocationKeys().forEach((key) => {
	        if (typeof location[key] !== 'undefined') this[key] = location[key];
	      });
	    }
	  }

	  /** @private */
	  static _getLocationKeys() {
	    return [
	      'fileName',
	      'lineNumber',
	      'columnNumber',
	      'callStack',
	      'className',
	      'functionName',
	      'functionAlias',
	      'callerName',
	    ];
	  }

	  serialise() {
	    return flatted.stringify(this, (key, value) => {
	      // JSON.stringify(new Error('test')) returns {}, which is not really useful for us.
	      // The following allows us to serialize errors (semi) correctly.
	      if (value instanceof Error) {
	        // eslint-disable-next-line prefer-object-spread
	        value = Object.assign(
	          { message: value.message, stack: value.stack },
	          value
	        );
	      }
	      // JSON.stringify({a: Number('abc'), b: 1/0, c: -1/0}) returns {a: null, b: null, c: null}.
	      // The following allows us to serialize to NaN, Infinity and -Infinity correctly.
	      // JSON.stringify([undefined]) returns [null].
	      // The following allows us to serialize to undefined correctly.
	      return serde.serialise(value);
	    });
	  }

	  static deserialise(serialised) {
	    let event;
	    try {
	      const rehydratedEvent = flatted.parse(serialised, (key, value) => {
	        if (value && value.message && value.stack) {
	          const fakeError = new Error(value);
	          Object.keys(value).forEach((k) => {
	            fakeError[k] = value[k];
	          });
	          value = fakeError;
	        }
	        return serde.deserialise(value);
	      });
	      this._getLocationKeys().forEach((key) => {
	        if (typeof rehydratedEvent[key] !== 'undefined') {
	          if (!rehydratedEvent.location) rehydratedEvent.location = {};
	          rehydratedEvent.location[key] = rehydratedEvent[key];
	        }
	      });
	      event = new LoggingEvent(
	        rehydratedEvent.categoryName,
	        levels.getLevel(rehydratedEvent.level.levelStr),
	        rehydratedEvent.data,
	        rehydratedEvent.context,
	        rehydratedEvent.location,
	        rehydratedEvent.error
	      );
	      event.startTime = new Date(rehydratedEvent.startTime);
	      event.pid = rehydratedEvent.pid;
	      if (rehydratedEvent.cluster) {
	        event.cluster = rehydratedEvent.cluster;
	      }
	    } catch (e) {
	      event = new LoggingEvent('log4js', levels.ERROR, [
	        'Unable to parse log:',
	        serialised,
	        'because: ',
	        e,
	      ]);
	    }

	    return event;
	  }
	}

	LoggingEvent_1 = LoggingEvent;
	return LoggingEvent_1;
}

var clustering;
var hasRequiredClustering;

function requireClustering () {
	if (hasRequiredClustering) return clustering;
	hasRequiredClustering = 1;
	const debug = requireSrc$1()('log4js:clustering');
	const LoggingEvent = requireLoggingEvent();
	const configuration = requireConfiguration();

	let disabled = false;
	let cluster = null;
	try {
	  // eslint-disable-next-line global-require
	  cluster = require('cluster');
	} catch (e) {
	  debug('cluster module not present');
	  disabled = true;
	}

	const listeners = [];

	let pm2 = false;
	let pm2InstanceVar = 'NODE_APP_INSTANCE';

	const isPM2Master = () => pm2 && process.env[pm2InstanceVar] === '0';
	const isMaster = () =>
	  disabled || (cluster && cluster.isMaster) || isPM2Master();

	const sendToListeners = (logEvent) => {
	  listeners.forEach((l) => l(logEvent));
	};

	// in a multi-process node environment, worker loggers will use
	// process.send
	const receiver = (worker, message) => {
	  // prior to node v6, the worker parameter was not passed (args were message, handle)
	  debug('cluster message received from worker ', worker, ': ', message);
	  if (worker.topic && worker.data) {
	    message = worker;
	    worker = undefined;
	  }
	  if (message && message.topic && message.topic === 'log4js:message') {
	    debug('received message: ', message.data);
	    const logEvent = LoggingEvent.deserialise(message.data);
	    sendToListeners(logEvent);
	  }
	};

	if (!disabled) {
	  configuration.addListener((config) => {
	    // clear out the listeners, because configure has been called.
	    listeners.length = 0;

	    ({
	      pm2,
	      disableClustering: disabled,
	      pm2InstanceVar = 'NODE_APP_INSTANCE',
	    } = config);

	    debug(`clustering disabled ? ${disabled}`);
	    debug(`cluster.isMaster ? ${cluster && cluster.isMaster}`);
	    debug(`pm2 enabled ? ${pm2}`);
	    debug(`pm2InstanceVar = ${pm2InstanceVar}`);
	    debug(`process.env[${pm2InstanceVar}] = ${process.env[pm2InstanceVar]}`);

	    // just in case configure is called after shutdown
	    if (pm2) {
	      process.removeListener('message', receiver);
	    }
	    if (cluster && cluster.removeListener) {
	      cluster.removeListener('message', receiver);
	    }

	    if (disabled || config.disableClustering) {
	      debug('Not listening for cluster messages, because clustering disabled.');
	    } else if (isPM2Master()) {
	      // PM2 cluster support
	      // PM2 runs everything as workers - install pm2-intercom for this to work.
	      // we only want one of the app instances to write logs
	      debug('listening for PM2 broadcast messages');
	      process.on('message', receiver);
	    } else if (cluster && cluster.isMaster) {
	      debug('listening for cluster messages');
	      cluster.on('message', receiver);
	    } else {
	      debug('not listening for messages, because we are not a master process');
	    }
	  });
	}

	clustering = {
	  onlyOnMaster: (fn, notMaster) => (isMaster() ? fn() : notMaster),
	  isMaster,
	  send: (msg) => {
	    if (isMaster()) {
	      sendToListeners(msg);
	    } else {
	      if (!pm2) {
	        msg.cluster = {
	          workerId: cluster.worker.id,
	          worker: process.pid,
	        };
	      }
	      process.send({ topic: 'log4js:message', data: msg.serialise() });
	    }
	  },
	  onMessage: (listener) => {
	    listeners.push(listener);
	  },
	};
	return clustering;
}

var adapters = {};

var hasRequiredAdapters;

function requireAdapters () {
	if (hasRequiredAdapters) return adapters;
	hasRequiredAdapters = 1;
	function maxFileSizeUnitTransform(maxLogSize) {
	  if (typeof maxLogSize === 'number' && Number.isInteger(maxLogSize)) {
	    return maxLogSize;
	  }

	  const units = {
	    K: 1024,
	    M: 1024 * 1024,
	    G: 1024 * 1024 * 1024,
	  };
	  const validUnit = Object.keys(units);
	  const unit = maxLogSize.slice(-1).toLocaleUpperCase();
	  const value = maxLogSize.slice(0, -1).trim();

	  if (validUnit.indexOf(unit) < 0 || !Number.isInteger(Number(value))) {
	    throw Error(`maxLogSize: "${maxLogSize}" is invalid`);
	  } else {
	    return value * units[unit];
	  }
	}

	function adapter(configAdapter, config) {
	  const newConfig = Object.assign({}, config); // eslint-disable-line prefer-object-spread
	  Object.keys(configAdapter).forEach((key) => {
	    if (newConfig[key]) {
	      newConfig[key] = configAdapter[key](config[key]);
	    }
	  });
	  return newConfig;
	}

	function fileAppenderAdapter(config) {
	  const configAdapter = {
	    maxLogSize: maxFileSizeUnitTransform,
	  };
	  return adapter(configAdapter, config);
	}

	const adapters$1 = {
	  dateFile: fileAppenderAdapter,
	  file: fileAppenderAdapter,
	  fileSync: fileAppenderAdapter,
	};

	adapters.modifyConfig = (config) =>
	  adapters$1[config.type] ? adapters$1[config.type](config) : config;
	return adapters;
}

var console$1 = {};

var hasRequiredConsole;

function requireConsole () {
	if (hasRequiredConsole) return console$1;
	hasRequiredConsole = 1;
	// eslint-disable-next-line no-console
	const consoleLog = console.log.bind(console);

	function consoleAppender(layout, timezoneOffset) {
	  return (loggingEvent) => {
	    consoleLog(layout(loggingEvent, timezoneOffset));
	  };
	}

	function configure(config, layouts) {
	  let layout = layouts.colouredLayout;
	  if (config.layout) {
	    layout = layouts.layout(config.layout.type, config.layout);
	  }
	  return consoleAppender(layout, config.timezoneOffset);
	}

	console$1.configure = configure;
	return console$1;
}

var stdout = {};

var hasRequiredStdout;

function requireStdout () {
	if (hasRequiredStdout) return stdout;
	hasRequiredStdout = 1;
	function stdoutAppender(layout, timezoneOffset) {
	  return (loggingEvent) => {
	    process.stdout.write(`${layout(loggingEvent, timezoneOffset)}\n`);
	  };
	}

	function configure(config, layouts) {
	  let layout = layouts.colouredLayout;
	  if (config.layout) {
	    layout = layouts.layout(config.layout.type, config.layout);
	  }
	  return stdoutAppender(layout, config.timezoneOffset);
	}

	stdout.configure = configure;
	return stdout;
}

var stderr = {};

var hasRequiredStderr;

function requireStderr () {
	if (hasRequiredStderr) return stderr;
	hasRequiredStderr = 1;
	function stderrAppender(layout, timezoneOffset) {
	  return (loggingEvent) => {
	    process.stderr.write(`${layout(loggingEvent, timezoneOffset)}\n`);
	  };
	}

	function configure(config, layouts) {
	  let layout = layouts.colouredLayout;
	  if (config.layout) {
	    layout = layouts.layout(config.layout.type, config.layout);
	  }
	  return stderrAppender(layout, config.timezoneOffset);
	}

	stderr.configure = configure;
	return stderr;
}

var logLevelFilter = {};

var hasRequiredLogLevelFilter;

function requireLogLevelFilter () {
	if (hasRequiredLogLevelFilter) return logLevelFilter;
	hasRequiredLogLevelFilter = 1;
	function logLevelFilter$1(minLevelString, maxLevelString, appender, levels) {
	  const minLevel = levels.getLevel(minLevelString);
	  const maxLevel = levels.getLevel(maxLevelString, levels.FATAL);
	  return (logEvent) => {
	    const eventLevel = logEvent.level;
	    if (
	      minLevel.isLessThanOrEqualTo(eventLevel) &&
	      maxLevel.isGreaterThanOrEqualTo(eventLevel)
	    ) {
	      appender(logEvent);
	    }
	  };
	}

	function configure(config, layouts, findAppender, levels) {
	  const appender = findAppender(config.appender);
	  return logLevelFilter$1(config.level, config.maxLevel, appender, levels);
	}

	logLevelFilter.configure = configure;
	return logLevelFilter;
}

var categoryFilter = {};

var hasRequiredCategoryFilter;

function requireCategoryFilter () {
	if (hasRequiredCategoryFilter) return categoryFilter;
	hasRequiredCategoryFilter = 1;
	const debug = requireSrc$1()('log4js:categoryFilter');

	function categoryFilter$1(excludes, appender) {
	  if (typeof excludes === 'string') excludes = [excludes];
	  return (logEvent) => {
	    debug(`Checking ${logEvent.categoryName} against ${excludes}`);
	    if (excludes.indexOf(logEvent.categoryName) === -1) {
	      debug('Not excluded, sending to appender');
	      appender(logEvent);
	    }
	  };
	}

	function configure(config, layouts, findAppender) {
	  const appender = findAppender(config.appender);
	  return categoryFilter$1(config.exclude, appender);
	}

	categoryFilter.configure = configure;
	return categoryFilter;
}

var noLogFilter = {};

var hasRequiredNoLogFilter;

function requireNoLogFilter () {
	if (hasRequiredNoLogFilter) return noLogFilter;
	hasRequiredNoLogFilter = 1;
	const debug = requireSrc$1()('log4js:noLogFilter');

	/**
	 * The function removes empty or null regexp from the array
	 * @param {string[]} regexp
	 * @returns {string[]} a filtered string array with not empty or null regexp
	 */
	function removeNullOrEmptyRegexp(regexp) {
	  const filtered = regexp.filter((el) => el != null && el !== '');
	  return filtered;
	}

	/**
	 * Returns a function that will exclude the events in case they match
	 * with the regular expressions provided
	 * @param {(string|string[])} filters contains the regexp that will be used for the evaluation
	 * @param {*} appender
	 * @returns {function}
	 */
	function noLogFilter$1(filters, appender) {
	  return (logEvent) => {
	    debug(`Checking data: ${logEvent.data} against filters: ${filters}`);
	    if (typeof filters === 'string') {
	      filters = [filters];
	    }
	    filters = removeNullOrEmptyRegexp(filters);
	    const regex = new RegExp(filters.join('|'), 'i');
	    if (
	      filters.length === 0 ||
	      logEvent.data.findIndex((value) => regex.test(value)) < 0
	    ) {
	      debug('Not excluded, sending to appender');
	      appender(logEvent);
	    }
	  };
	}

	function configure(config, layouts, findAppender) {
	  const appender = findAppender(config.appender);
	  return noLogFilter$1(config.exclude, appender);
	}

	noLogFilter.configure = configure;
	return noLogFilter;
}

var file$3 = {};

var lib$3 = {exports: {}};

var fs$1 = {};

var universalify$1 = {};

var hasRequiredUniversalify$1;

function requireUniversalify$1 () {
	if (hasRequiredUniversalify$1) return universalify$1;
	hasRequiredUniversalify$1 = 1;

	universalify$1.fromCallback = function (fn) {
	  return Object.defineProperty(function () {
	    if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments);
	    else {
	      return new Promise((resolve, reject) => {
	        arguments[arguments.length] = (err, res) => {
	          if (err) return reject(err)
	          resolve(res);
	        };
	        arguments.length++;
	        fn.apply(this, arguments);
	      })
	    }
	  }, 'name', { value: fn.name })
	};

	universalify$1.fromPromise = function (fn) {
	  return Object.defineProperty(function () {
	    const cb = arguments[arguments.length - 1];
	    if (typeof cb !== 'function') return fn.apply(this, arguments)
	    else fn.apply(this, arguments).then(r => cb(null, r), cb);
	  }, 'name', { value: fn.name })
	};
	return universalify$1;
}

var polyfills;
var hasRequiredPolyfills;

function requirePolyfills () {
	if (hasRequiredPolyfills) return polyfills;
	hasRequiredPolyfills = 1;
	var constants = require$$0$a;

	var origCwd = process.cwd;
	var cwd = null;

	var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;

	process.cwd = function() {
	  if (!cwd)
	    cwd = origCwd.call(process);
	  return cwd
	};
	try {
	  process.cwd();
	} catch (er) {}

	// This check is needed until node.js 12 is required
	if (typeof process.chdir === 'function') {
	  var chdir = process.chdir;
	  process.chdir = function (d) {
	    cwd = null;
	    chdir.call(process, d);
	  };
	  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
	}

	polyfills = patch;

	function patch (fs) {
	  // (re-)implement some things that are known busted or missing.

	  // lchmod, broken prior to 0.6.2
	  // back-port the fix here.
	  if (constants.hasOwnProperty('O_SYMLINK') &&
	      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
	    patchLchmod(fs);
	  }

	  // lutimes implementation, or no-op
	  if (!fs.lutimes) {
	    patchLutimes(fs);
	  }

	  // https://github.com/isaacs/node-graceful-fs/issues/4
	  // Chown should not fail on einval or eperm if non-root.
	  // It should not fail on enosys ever, as this just indicates
	  // that a fs doesn't support the intended operation.

	  fs.chown = chownFix(fs.chown);
	  fs.fchown = chownFix(fs.fchown);
	  fs.lchown = chownFix(fs.lchown);

	  fs.chmod = chmodFix(fs.chmod);
	  fs.fchmod = chmodFix(fs.fchmod);
	  fs.lchmod = chmodFix(fs.lchmod);

	  fs.chownSync = chownFixSync(fs.chownSync);
	  fs.fchownSync = chownFixSync(fs.fchownSync);
	  fs.lchownSync = chownFixSync(fs.lchownSync);

	  fs.chmodSync = chmodFixSync(fs.chmodSync);
	  fs.fchmodSync = chmodFixSync(fs.fchmodSync);
	  fs.lchmodSync = chmodFixSync(fs.lchmodSync);

	  fs.stat = statFix(fs.stat);
	  fs.fstat = statFix(fs.fstat);
	  fs.lstat = statFix(fs.lstat);

	  fs.statSync = statFixSync(fs.statSync);
	  fs.fstatSync = statFixSync(fs.fstatSync);
	  fs.lstatSync = statFixSync(fs.lstatSync);

	  // if lchmod/lchown do not exist, then make them no-ops
	  if (fs.chmod && !fs.lchmod) {
	    fs.lchmod = function (path, mode, cb) {
	      if (cb) process.nextTick(cb);
	    };
	    fs.lchmodSync = function () {};
	  }
	  if (fs.chown && !fs.lchown) {
	    fs.lchown = function (path, uid, gid, cb) {
	      if (cb) process.nextTick(cb);
	    };
	    fs.lchownSync = function () {};
	  }

	  // on Windows, A/V software can lock the directory, causing this
	  // to fail with an EACCES or EPERM if the directory contains newly
	  // created files.  Try again on failure, for up to 60 seconds.

	  // Set the timeout this long because some Windows Anti-Virus, such as Parity
	  // bit9, may lock files for up to a minute, causing npm package install
	  // failures. Also, take care to yield the scheduler. Windows scheduling gives
	  // CPU to a busy looping process, which can cause the program causing the lock
	  // contention to be starved of CPU by node, so the contention doesn't resolve.
	  if (platform === "win32") {
	    fs.rename = typeof fs.rename !== 'function' ? fs.rename
	    : (function (fs$rename) {
	      function rename (from, to, cb) {
	        var start = Date.now();
	        var backoff = 0;
	        fs$rename(from, to, function CB (er) {
	          if (er
	              && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY")
	              && Date.now() - start < 60000) {
	            setTimeout(function() {
	              fs.stat(to, function (stater, st) {
	                if (stater && stater.code === "ENOENT")
	                  fs$rename(from, to, CB);
	                else
	                  cb(er);
	              });
	            }, backoff);
	            if (backoff < 100)
	              backoff += 10;
	            return;
	          }
	          if (cb) cb(er);
	        });
	      }
	      if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
	      return rename
	    })(fs.rename);
	  }

	  // if read() returns EAGAIN, then just try it again.
	  fs.read = typeof fs.read !== 'function' ? fs.read
	  : (function (fs$read) {
	    function read (fd, buffer, offset, length, position, callback_) {
	      var callback;
	      if (callback_ && typeof callback_ === 'function') {
	        var eagCounter = 0;
	        callback = function (er, _, __) {
	          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
	            eagCounter ++;
	            return fs$read.call(fs, fd, buffer, offset, length, position, callback)
	          }
	          callback_.apply(this, arguments);
	        };
	      }
	      return fs$read.call(fs, fd, buffer, offset, length, position, callback)
	    }

	    // This ensures `util.promisify` works as it does for native `fs.read`.
	    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
	    return read
	  })(fs.read);

	  fs.readSync = typeof fs.readSync !== 'function' ? fs.readSync
	  : (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
	    var eagCounter = 0;
	    while (true) {
	      try {
	        return fs$readSync.call(fs, fd, buffer, offset, length, position)
	      } catch (er) {
	        if (er.code === 'EAGAIN' && eagCounter < 10) {
	          eagCounter ++;
	          continue
	        }
	        throw er
	      }
	    }
	  }})(fs.readSync);

	  function patchLchmod (fs) {
	    fs.lchmod = function (path, mode, callback) {
	      fs.open( path
	             , constants.O_WRONLY | constants.O_SYMLINK
	             , mode
	             , function (err, fd) {
	        if (err) {
	          if (callback) callback(err);
	          return
	        }
	        // prefer to return the chmod error, if one occurs,
	        // but still try to close, and report closing errors if they occur.
	        fs.fchmod(fd, mode, function (err) {
	          fs.close(fd, function(err2) {
	            if (callback) callback(err || err2);
	          });
	        });
	      });
	    };

	    fs.lchmodSync = function (path, mode) {
	      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);

	      // prefer to return the chmod error, if one occurs,
	      // but still try to close, and report closing errors if they occur.
	      var threw = true;
	      var ret;
	      try {
	        ret = fs.fchmodSync(fd, mode);
	        threw = false;
	      } finally {
	        if (threw) {
	          try {
	            fs.closeSync(fd);
	          } catch (er) {}
	        } else {
	          fs.closeSync(fd);
	        }
	      }
	      return ret
	    };
	  }

	  function patchLutimes (fs) {
	    if (constants.hasOwnProperty("O_SYMLINK") && fs.futimes) {
	      fs.lutimes = function (path, at, mt, cb) {
	        fs.open(path, constants.O_SYMLINK, function (er, fd) {
	          if (er) {
	            if (cb) cb(er);
	            return
	          }
	          fs.futimes(fd, at, mt, function (er) {
	            fs.close(fd, function (er2) {
	              if (cb) cb(er || er2);
	            });
	          });
	        });
	      };

	      fs.lutimesSync = function (path, at, mt) {
	        var fd = fs.openSync(path, constants.O_SYMLINK);
	        var ret;
	        var threw = true;
	        try {
	          ret = fs.futimesSync(fd, at, mt);
	          threw = false;
	        } finally {
	          if (threw) {
	            try {
	              fs.closeSync(fd);
	            } catch (er) {}
	          } else {
	            fs.closeSync(fd);
	          }
	        }
	        return ret
	      };

	    } else if (fs.futimes) {
	      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb); };
	      fs.lutimesSync = function () {};
	    }
	  }

	  function chmodFix (orig) {
	    if (!orig) return orig
	    return function (target, mode, cb) {
	      return orig.call(fs, target, mode, function (er) {
	        if (chownErOk(er)) er = null;
	        if (cb) cb.apply(this, arguments);
	      })
	    }
	  }

	  function chmodFixSync (orig) {
	    if (!orig) return orig
	    return function (target, mode) {
	      try {
	        return orig.call(fs, target, mode)
	      } catch (er) {
	        if (!chownErOk(er)) throw er
	      }
	    }
	  }


	  function chownFix (orig) {
	    if (!orig) return orig
	    return function (target, uid, gid, cb) {
	      return orig.call(fs, target, uid, gid, function (er) {
	        if (chownErOk(er)) er = null;
	        if (cb) cb.apply(this, arguments);
	      })
	    }
	  }

	  function chownFixSync (orig) {
	    if (!orig) return orig
	    return function (target, uid, gid) {
	      try {
	        return orig.call(fs, target, uid, gid)
	      } catch (er) {
	        if (!chownErOk(er)) throw er
	      }
	    }
	  }

	  function statFix (orig) {
	    if (!orig) return orig
	    // Older versions of Node erroneously returned signed integers for
	    // uid + gid.
	    return function (target, options, cb) {
	      if (typeof options === 'function') {
	        cb = options;
	        options = null;
	      }
	      function callback (er, stats) {
	        if (stats) {
	          if (stats.uid < 0) stats.uid += 0x100000000;
	          if (stats.gid < 0) stats.gid += 0x100000000;
	        }
	        if (cb) cb.apply(this, arguments);
	      }
	      return options ? orig.call(fs, target, options, callback)
	        : orig.call(fs, target, callback)
	    }
	  }

	  function statFixSync (orig) {
	    if (!orig) return orig
	    // Older versions of Node erroneously returned signed integers for
	    // uid + gid.
	    return function (target, options) {
	      var stats = options ? orig.call(fs, target, options)
	        : orig.call(fs, target);
	      if (stats) {
	        if (stats.uid < 0) stats.uid += 0x100000000;
	        if (stats.gid < 0) stats.gid += 0x100000000;
	      }
	      return stats;
	    }
	  }

	  // ENOSYS means that the fs doesn't support the op. Just ignore
	  // that, because it doesn't matter.
	  //
	  // if there's no getuid, or if getuid() is something other
	  // than 0, and the error is EINVAL or EPERM, then just ignore
	  // it.
	  //
	  // This specific case is a silent failure in cp, install, tar,
	  // and most other unix tools that manage permissions.
	  //
	  // When running as root, or if other types of errors are
	  // encountered, then it's strict.
	  function chownErOk (er) {
	    if (!er)
	      return true

	    if (er.code === "ENOSYS")
	      return true

	    var nonroot = !process.getuid || process.getuid() !== 0;
	    if (nonroot) {
	      if (er.code === "EINVAL" || er.code === "EPERM")
	        return true
	    }

	    return false
	  }
	}
	return polyfills;
}

var legacyStreams;
var hasRequiredLegacyStreams;

function requireLegacyStreams () {
	if (hasRequiredLegacyStreams) return legacyStreams;
	hasRequiredLegacyStreams = 1;
	var Stream = require$$0$6.Stream;

	legacyStreams = legacy;

	function legacy (fs) {
	  return {
	    ReadStream: ReadStream,
	    WriteStream: WriteStream
	  }

	  function ReadStream (path, options) {
	    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

	    Stream.call(this);

	    var self = this;

	    this.path = path;
	    this.fd = null;
	    this.readable = true;
	    this.paused = false;

	    this.flags = 'r';
	    this.mode = 438; /*=0666*/
	    this.bufferSize = 64 * 1024;

	    options = options || {};

	    // Mixin options into this
	    var keys = Object.keys(options);
	    for (var index = 0, length = keys.length; index < length; index++) {
	      var key = keys[index];
	      this[key] = options[key];
	    }

	    if (this.encoding) this.setEncoding(this.encoding);

	    if (this.start !== undefined) {
	      if ('number' !== typeof this.start) {
	        throw TypeError('start must be a Number');
	      }
	      if (this.end === undefined) {
	        this.end = Infinity;
	      } else if ('number' !== typeof this.end) {
	        throw TypeError('end must be a Number');
	      }

	      if (this.start > this.end) {
	        throw new Error('start must be <= end');
	      }

	      this.pos = this.start;
	    }

	    if (this.fd !== null) {
	      process.nextTick(function() {
	        self._read();
	      });
	      return;
	    }

	    fs.open(this.path, this.flags, this.mode, function (err, fd) {
	      if (err) {
	        self.emit('error', err);
	        self.readable = false;
	        return;
	      }

	      self.fd = fd;
	      self.emit('open', fd);
	      self._read();
	    });
	  }

	  function WriteStream (path, options) {
	    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

	    Stream.call(this);

	    this.path = path;
	    this.fd = null;
	    this.writable = true;

	    this.flags = 'w';
	    this.encoding = 'binary';
	    this.mode = 438; /*=0666*/
	    this.bytesWritten = 0;

	    options = options || {};

	    // Mixin options into this
	    var keys = Object.keys(options);
	    for (var index = 0, length = keys.length; index < length; index++) {
	      var key = keys[index];
	      this[key] = options[key];
	    }

	    if (this.start !== undefined) {
	      if ('number' !== typeof this.start) {
	        throw TypeError('start must be a Number');
	      }
	      if (this.start < 0) {
	        throw new Error('start must be >= zero');
	      }

	      this.pos = this.start;
	    }

	    this.busy = false;
	    this._queue = [];

	    if (this.fd === null) {
	      this._open = fs.open;
	      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
	      this.flush();
	    }
	  }
	}
	return legacyStreams;
}

var clone_1;
var hasRequiredClone$1;

function requireClone$1 () {
	if (hasRequiredClone$1) return clone_1;
	hasRequiredClone$1 = 1;

	clone_1 = clone;

	var getPrototypeOf = Object.getPrototypeOf || function (obj) {
	  return obj.__proto__
	};

	function clone (obj) {
	  if (obj === null || typeof obj !== 'object')
	    return obj

	  if (obj instanceof Object)
	    var copy = { __proto__: getPrototypeOf(obj) };
	  else
	    var copy = Object.create(null);

	  Object.getOwnPropertyNames(obj).forEach(function (key) {
	    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
	  });

	  return copy
	}
	return clone_1;
}

var gracefulFs;
var hasRequiredGracefulFs;

function requireGracefulFs () {
	if (hasRequiredGracefulFs) return gracefulFs;
	hasRequiredGracefulFs = 1;
	var fs = require$$0$8;
	var polyfills = requirePolyfills();
	var legacy = requireLegacyStreams();
	var clone = requireClone$1();

	var util = require$$1$2;

	/* istanbul ignore next - node 0.x polyfill */
	var gracefulQueue;
	var previousSymbol;

	/* istanbul ignore else - node 0.x polyfill */
	if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
	  gracefulQueue = Symbol.for('graceful-fs.queue');
	  // This is used in testing by future versions
	  previousSymbol = Symbol.for('graceful-fs.previous');
	} else {
	  gracefulQueue = '___graceful-fs.queue';
	  previousSymbol = '___graceful-fs.previous';
	}

	function noop () {}

	function publishQueue(context, queue) {
	  Object.defineProperty(context, gracefulQueue, {
	    get: function() {
	      return queue
	    }
	  });
	}

	var debug = noop;
	if (util.debuglog)
	  debug = util.debuglog('gfs4');
	else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
	  debug = function() {
	    var m = util.format.apply(util, arguments);
	    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
	    console.error(m);
	  };

	// Once time initialization
	if (!fs[gracefulQueue]) {
	  // This queue can be shared by multiple loaded instances
	  var queue = commonjsGlobal[gracefulQueue] || [];
	  publishQueue(fs, queue);

	  // Patch fs.close/closeSync to shared queue version, because we need
	  // to retry() whenever a close happens *anywhere* in the program.
	  // This is essential when multiple graceful-fs instances are
	  // in play at the same time.
	  fs.close = (function (fs$close) {
	    function close (fd, cb) {
	      return fs$close.call(fs, fd, function (err) {
	        // This function uses the graceful-fs shared queue
	        if (!err) {
	          resetQueue();
	        }

	        if (typeof cb === 'function')
	          cb.apply(this, arguments);
	      })
	    }

	    Object.defineProperty(close, previousSymbol, {
	      value: fs$close
	    });
	    return close
	  })(fs.close);

	  fs.closeSync = (function (fs$closeSync) {
	    function closeSync (fd) {
	      // This function uses the graceful-fs shared queue
	      fs$closeSync.apply(fs, arguments);
	      resetQueue();
	    }

	    Object.defineProperty(closeSync, previousSymbol, {
	      value: fs$closeSync
	    });
	    return closeSync
	  })(fs.closeSync);

	  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
	    process.on('exit', function() {
	      debug(fs[gracefulQueue]);
	      require$$0$7.equal(fs[gracefulQueue].length, 0);
	    });
	  }
	}

	if (!commonjsGlobal[gracefulQueue]) {
	  publishQueue(commonjsGlobal, fs[gracefulQueue]);
	}

	gracefulFs = patch(clone(fs));
	if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
	    gracefulFs = patch(fs);
	    fs.__patched = true;
	}

	function patch (fs) {
	  // Everything that references the open() function needs to be in here
	  polyfills(fs);
	  fs.gracefulify = patch;

	  fs.createReadStream = createReadStream;
	  fs.createWriteStream = createWriteStream;
	  var fs$readFile = fs.readFile;
	  fs.readFile = readFile;
	  function readFile (path, options, cb) {
	    if (typeof options === 'function')
	      cb = options, options = null;

	    return go$readFile(path, options, cb)

	    function go$readFile (path, options, cb, startTime) {
	      return fs$readFile(path, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()]);
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments);
	        }
	      })
	    }
	  }

	  var fs$writeFile = fs.writeFile;
	  fs.writeFile = writeFile;
	  function writeFile (path, data, options, cb) {
	    if (typeof options === 'function')
	      cb = options, options = null;

	    return go$writeFile(path, data, options, cb)

	    function go$writeFile (path, data, options, cb, startTime) {
	      return fs$writeFile(path, data, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()]);
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments);
	        }
	      })
	    }
	  }

	  var fs$appendFile = fs.appendFile;
	  if (fs$appendFile)
	    fs.appendFile = appendFile;
	  function appendFile (path, data, options, cb) {
	    if (typeof options === 'function')
	      cb = options, options = null;

	    return go$appendFile(path, data, options, cb)

	    function go$appendFile (path, data, options, cb, startTime) {
	      return fs$appendFile(path, data, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()]);
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments);
	        }
	      })
	    }
	  }

	  var fs$copyFile = fs.copyFile;
	  if (fs$copyFile)
	    fs.copyFile = copyFile;
	  function copyFile (src, dest, flags, cb) {
	    if (typeof flags === 'function') {
	      cb = flags;
	      flags = 0;
	    }
	    return go$copyFile(src, dest, flags, cb)

	    function go$copyFile (src, dest, flags, cb, startTime) {
	      return fs$copyFile(src, dest, flags, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()]);
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments);
	        }
	      })
	    }
	  }

	  var fs$readdir = fs.readdir;
	  fs.readdir = readdir;
	  var noReaddirOptionVersions = /^v[0-5]\./;
	  function readdir (path, options, cb) {
	    if (typeof options === 'function')
	      cb = options, options = null;

	    var go$readdir = noReaddirOptionVersions.test(process.version)
	      ? function go$readdir (path, options, cb, startTime) {
	        return fs$readdir(path, fs$readdirCallback(
	          path, options, cb, startTime
	        ))
	      }
	      : function go$readdir (path, options, cb, startTime) {
	        return fs$readdir(path, options, fs$readdirCallback(
	          path, options, cb, startTime
	        ))
	      };

	    return go$readdir(path, options, cb)

	    function fs$readdirCallback (path, options, cb, startTime) {
	      return function (err, files) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([
	            go$readdir,
	            [path, options, cb],
	            err,
	            startTime || Date.now(),
	            Date.now()
	          ]);
	        else {
	          if (files && files.sort)
	            files.sort();

	          if (typeof cb === 'function')
	            cb.call(this, err, files);
	        }
	      }
	    }
	  }

	  if (process.version.substr(0, 4) === 'v0.8') {
	    var legStreams = legacy(fs);
	    ReadStream = legStreams.ReadStream;
	    WriteStream = legStreams.WriteStream;
	  }

	  var fs$ReadStream = fs.ReadStream;
	  if (fs$ReadStream) {
	    ReadStream.prototype = Object.create(fs$ReadStream.prototype);
	    ReadStream.prototype.open = ReadStream$open;
	  }

	  var fs$WriteStream = fs.WriteStream;
	  if (fs$WriteStream) {
	    WriteStream.prototype = Object.create(fs$WriteStream.prototype);
	    WriteStream.prototype.open = WriteStream$open;
	  }

	  Object.defineProperty(fs, 'ReadStream', {
	    get: function () {
	      return ReadStream
	    },
	    set: function (val) {
	      ReadStream = val;
	    },
	    enumerable: true,
	    configurable: true
	  });
	  Object.defineProperty(fs, 'WriteStream', {
	    get: function () {
	      return WriteStream
	    },
	    set: function (val) {
	      WriteStream = val;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  // legacy names
	  var FileReadStream = ReadStream;
	  Object.defineProperty(fs, 'FileReadStream', {
	    get: function () {
	      return FileReadStream
	    },
	    set: function (val) {
	      FileReadStream = val;
	    },
	    enumerable: true,
	    configurable: true
	  });
	  var FileWriteStream = WriteStream;
	  Object.defineProperty(fs, 'FileWriteStream', {
	    get: function () {
	      return FileWriteStream
	    },
	    set: function (val) {
	      FileWriteStream = val;
	    },
	    enumerable: true,
	    configurable: true
	  });

	  function ReadStream (path, options) {
	    if (this instanceof ReadStream)
	      return fs$ReadStream.apply(this, arguments), this
	    else
	      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
	  }

	  function ReadStream$open () {
	    var that = this;
	    open(that.path, that.flags, that.mode, function (err, fd) {
	      if (err) {
	        if (that.autoClose)
	          that.destroy();

	        that.emit('error', err);
	      } else {
	        that.fd = fd;
	        that.emit('open', fd);
	        that.read();
	      }
	    });
	  }

	  function WriteStream (path, options) {
	    if (this instanceof WriteStream)
	      return fs$WriteStream.apply(this, arguments), this
	    else
	      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
	  }

	  function WriteStream$open () {
	    var that = this;
	    open(that.path, that.flags, that.mode, function (err, fd) {
	      if (err) {
	        that.destroy();
	        that.emit('error', err);
	      } else {
	        that.fd = fd;
	        that.emit('open', fd);
	      }
	    });
	  }

	  function createReadStream (path, options) {
	    return new fs.ReadStream(path, options)
	  }

	  function createWriteStream (path, options) {
	    return new fs.WriteStream(path, options)
	  }

	  var fs$open = fs.open;
	  fs.open = open;
	  function open (path, flags, mode, cb) {
	    if (typeof mode === 'function')
	      cb = mode, mode = null;

	    return go$open(path, flags, mode, cb)

	    function go$open (path, flags, mode, cb, startTime) {
	      return fs$open(path, flags, mode, function (err, fd) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()]);
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments);
	        }
	      })
	    }
	  }

	  return fs
	}

	function enqueue (elem) {
	  debug('ENQUEUE', elem[0].name, elem[1]);
	  fs[gracefulQueue].push(elem);
	  retry();
	}

	// keep track of the timeout between retry() calls
	var retryTimer;

	// reset the startTime and lastTime to now
	// this resets the start of the 60 second overall timeout as well as the
	// delay between attempts so that we'll retry these jobs sooner
	function resetQueue () {
	  var now = Date.now();
	  for (var i = 0; i < fs[gracefulQueue].length; ++i) {
	    // entries that are only a length of 2 are from an older version, don't
	    // bother modifying those since they'll be retried anyway.
	    if (fs[gracefulQueue][i].length > 2) {
	      fs[gracefulQueue][i][3] = now; // startTime
	      fs[gracefulQueue][i][4] = now; // lastTime
	    }
	  }
	  // call retry to make sure we're actively processing the queue
	  retry();
	}

	function retry () {
	  // clear the timer and remove it to help prevent unintended concurrency
	  clearTimeout(retryTimer);
	  retryTimer = undefined;

	  if (fs[gracefulQueue].length === 0)
	    return

	  var elem = fs[gracefulQueue].shift();
	  var fn = elem[0];
	  var args = elem[1];
	  // these items may be unset if they were added by an older graceful-fs
	  var err = elem[2];
	  var startTime = elem[3];
	  var lastTime = elem[4];

	  // if we don't have a startTime we have no way of knowing if we've waited
	  // long enough, so go ahead and retry this item now
	  if (startTime === undefined) {
	    debug('RETRY', fn.name, args);
	    fn.apply(null, args);
	  } else if (Date.now() - startTime >= 60000) {
	    // it's been more than 60 seconds total, bail now
	    debug('TIMEOUT', fn.name, args);
	    var cb = args.pop();
	    if (typeof cb === 'function')
	      cb.call(null, err);
	  } else {
	    // the amount of time between the last attempt and right now
	    var sinceAttempt = Date.now() - lastTime;
	    // the amount of time between when we first tried, and when we last tried
	    // rounded up to at least 1
	    var sinceStart = Math.max(lastTime - startTime, 1);
	    // backoff. wait longer than the total time we've been retrying, but only
	    // up to a maximum of 100ms
	    var desiredDelay = Math.min(sinceStart * 1.2, 100);
	    // it's been long enough since the last retry, do it again
	    if (sinceAttempt >= desiredDelay) {
	      debug('RETRY', fn.name, args);
	      fn.apply(null, args.concat([startTime]));
	    } else {
	      // if we can't do this job yet, push it to the end of the queue
	      // and let the next iteration check again
	      fs[gracefulQueue].push(elem);
	    }
	  }

	  // schedule our next run if one isn't already scheduled
	  if (retryTimer === undefined) {
	    retryTimer = setTimeout(retry, 0);
	  }
	}
	return gracefulFs;
}

var hasRequiredFs$1;

function requireFs$1 () {
	if (hasRequiredFs$1) return fs$1;
	hasRequiredFs$1 = 1;
	(function (exports) {
		// This is adapted from https://github.com/normalize/mz
		// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
		const u = requireUniversalify$1().fromCallback;
		const fs = requireGracefulFs();

		const api = [
		  'access',
		  'appendFile',
		  'chmod',
		  'chown',
		  'close',
		  'copyFile',
		  'fchmod',
		  'fchown',
		  'fdatasync',
		  'fstat',
		  'fsync',
		  'ftruncate',
		  'futimes',
		  'lchown',
		  'lchmod',
		  'link',
		  'lstat',
		  'mkdir',
		  'mkdtemp',
		  'open',
		  'readFile',
		  'readdir',
		  'readlink',
		  'realpath',
		  'rename',
		  'rmdir',
		  'stat',
		  'symlink',
		  'truncate',
		  'unlink',
		  'utimes',
		  'writeFile'
		].filter(key => {
		  // Some commands are not available on some systems. Ex:
		  // fs.copyFile was added in Node.js v8.5.0
		  // fs.mkdtemp was added in Node.js v5.10.0
		  // fs.lchown is not available on at least some Linux
		  return typeof fs[key] === 'function'
		});

		// Export all keys:
		Object.keys(fs).forEach(key => {
		  if (key === 'promises') {
		    // fs.promises is a getter property that triggers ExperimentalWarning
		    // Don't re-export it here, the getter is defined in "lib/index.js"
		    return
		  }
		  exports[key] = fs[key];
		});

		// Universalify async methods:
		api.forEach(method => {
		  exports[method] = u(fs[method]);
		});

		// We differ from mz/fs in that we still ship the old, broken, fs.exists()
		// since we are a drop-in replacement for the native module
		exports.exists = function (filename, callback) {
		  if (typeof callback === 'function') {
		    return fs.exists(filename, callback)
		  }
		  return new Promise(resolve => {
		    return fs.exists(filename, resolve)
		  })
		};

		// fs.read() & fs.write need special treatment due to multiple callback args

		exports.read = function (fd, buffer, offset, length, position, callback) {
		  if (typeof callback === 'function') {
		    return fs.read(fd, buffer, offset, length, position, callback)
		  }
		  return new Promise((resolve, reject) => {
		    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
		      if (err) return reject(err)
		      resolve({ bytesRead, buffer });
		    });
		  })
		};

		// Function signature can be
		// fs.write(fd, buffer[, offset[, length[, position]]], callback)
		// OR
		// fs.write(fd, string[, position[, encoding]], callback)
		// We need to handle both cases, so we use ...args
		exports.write = function (fd, buffer, ...args) {
		  if (typeof args[args.length - 1] === 'function') {
		    return fs.write(fd, buffer, ...args)
		  }

		  return new Promise((resolve, reject) => {
		    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
		      if (err) return reject(err)
		      resolve({ bytesWritten, buffer });
		    });
		  })
		};

		// fs.realpath.native only available in Node v9.2+
		if (typeof fs.realpath.native === 'function') {
		  exports.realpath.native = u(fs.realpath.native);
		} 
	} (fs$1));
	return fs$1;
}

var win32;
var hasRequiredWin32;

function requireWin32 () {
	if (hasRequiredWin32) return win32;
	hasRequiredWin32 = 1;

	const path = require$$1$4;

	// get drive on windows
	function getRootPath (p) {
	  p = path.normalize(path.resolve(p)).split(path.sep);
	  if (p.length > 0) return p[0]
	  return null
	}

	// http://stackoverflow.com/a/62888/10333 contains more accurate
	// TODO: expand to include the rest
	const INVALID_PATH_CHARS = /[<>:"|?*]/;

	function invalidWin32Path (p) {
	  const rp = getRootPath(p);
	  p = p.replace(rp, '');
	  return INVALID_PATH_CHARS.test(p)
	}

	win32 = {
	  getRootPath,
	  invalidWin32Path
	};
	return win32;
}

var mkdirs_1$1;
var hasRequiredMkdirs$2;

function requireMkdirs$2 () {
	if (hasRequiredMkdirs$2) return mkdirs_1$1;
	hasRequiredMkdirs$2 = 1;

	const fs = requireGracefulFs();
	const path = require$$1$4;
	const invalidWin32Path = requireWin32().invalidWin32Path;

	const o777 = parseInt('0777', 8);

	function mkdirs (p, opts, callback, made) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  } else if (!opts || typeof opts !== 'object') {
	    opts = { mode: opts };
	  }

	  if (process.platform === 'win32' && invalidWin32Path(p)) {
	    const errInval = new Error(p + ' contains invalid WIN32 path characters.');
	    errInval.code = 'EINVAL';
	    return callback(errInval)
	  }

	  let mode = opts.mode;
	  const xfs = opts.fs || fs;

	  if (mode === undefined) {
	    mode = o777 & (~process.umask());
	  }
	  if (!made) made = null;

	  callback = callback || function () {};
	  p = path.resolve(p);

	  xfs.mkdir(p, mode, er => {
	    if (!er) {
	      made = made || p;
	      return callback(null, made)
	    }
	    switch (er.code) {
	      case 'ENOENT':
	        if (path.dirname(p) === p) return callback(er)
	        mkdirs(path.dirname(p), opts, (er, made) => {
	          if (er) callback(er, made);
	          else mkdirs(p, opts, callback, made);
	        });
	        break

	      // In the case of any other error, just see if there's a dir
	      // there already.  If so, then hooray!  If not, then something
	      // is borked.
	      default:
	        xfs.stat(p, (er2, stat) => {
	          // if the stat fails, then that's super weird.
	          // let the original error be the failure reason.
	          if (er2 || !stat.isDirectory()) callback(er, made);
	          else callback(null, made);
	        });
	        break
	    }
	  });
	}

	mkdirs_1$1 = mkdirs;
	return mkdirs_1$1;
}

var mkdirsSync_1;
var hasRequiredMkdirsSync;

function requireMkdirsSync () {
	if (hasRequiredMkdirsSync) return mkdirsSync_1;
	hasRequiredMkdirsSync = 1;

	const fs = requireGracefulFs();
	const path = require$$1$4;
	const invalidWin32Path = requireWin32().invalidWin32Path;

	const o777 = parseInt('0777', 8);

	function mkdirsSync (p, opts, made) {
	  if (!opts || typeof opts !== 'object') {
	    opts = { mode: opts };
	  }

	  let mode = opts.mode;
	  const xfs = opts.fs || fs;

	  if (process.platform === 'win32' && invalidWin32Path(p)) {
	    const errInval = new Error(p + ' contains invalid WIN32 path characters.');
	    errInval.code = 'EINVAL';
	    throw errInval
	  }

	  if (mode === undefined) {
	    mode = o777 & (~process.umask());
	  }
	  if (!made) made = null;

	  p = path.resolve(p);

	  try {
	    xfs.mkdirSync(p, mode);
	    made = made || p;
	  } catch (err0) {
	    if (err0.code === 'ENOENT') {
	      if (path.dirname(p) === p) throw err0
	      made = mkdirsSync(path.dirname(p), opts, made);
	      mkdirsSync(p, opts, made);
	    } else {
	      // In the case of any other error, just see if there's a dir there
	      // already. If so, then hooray!  If not, then something is borked.
	      let stat;
	      try {
	        stat = xfs.statSync(p);
	      } catch (err1) {
	        throw err0
	      }
	      if (!stat.isDirectory()) throw err0
	    }
	  }

	  return made
	}

	mkdirsSync_1 = mkdirsSync;
	return mkdirsSync_1;
}

var mkdirs_1;
var hasRequiredMkdirs$1;

function requireMkdirs$1 () {
	if (hasRequiredMkdirs$1) return mkdirs_1;
	hasRequiredMkdirs$1 = 1;
	const u = requireUniversalify$1().fromCallback;
	const mkdirs = u(requireMkdirs$2());
	const mkdirsSync = requireMkdirsSync();

	mkdirs_1 = {
	  mkdirs,
	  mkdirsSync,
	  // alias
	  mkdirp: mkdirs,
	  mkdirpSync: mkdirsSync,
	  ensureDir: mkdirs,
	  ensureDirSync: mkdirsSync
	};
	return mkdirs_1;
}

var utimes$1;
var hasRequiredUtimes$1;

function requireUtimes$1 () {
	if (hasRequiredUtimes$1) return utimes$1;
	hasRequiredUtimes$1 = 1;

	const fs = requireGracefulFs();
	const os = require$$1$5;
	const path = require$$1$4;

	// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not
	function hasMillisResSync () {
	  let tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2));
	  tmpfile = path.join(os.tmpdir(), tmpfile);

	  // 550 millis past UNIX epoch
	  const d = new Date(1435410243862);
	  fs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141');
	  const fd = fs.openSync(tmpfile, 'r+');
	  fs.futimesSync(fd, d, d);
	  fs.closeSync(fd);
	  return fs.statSync(tmpfile).mtime > 1435410243000
	}

	function hasMillisRes (callback) {
	  let tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2));
	  tmpfile = path.join(os.tmpdir(), tmpfile);

	  // 550 millis past UNIX epoch
	  const d = new Date(1435410243862);
	  fs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', err => {
	    if (err) return callback(err)
	    fs.open(tmpfile, 'r+', (err, fd) => {
	      if (err) return callback(err)
	      fs.futimes(fd, d, d, err => {
	        if (err) return callback(err)
	        fs.close(fd, err => {
	          if (err) return callback(err)
	          fs.stat(tmpfile, (err, stats) => {
	            if (err) return callback(err)
	            callback(null, stats.mtime > 1435410243000);
	          });
	        });
	      });
	    });
	  });
	}

	function timeRemoveMillis (timestamp) {
	  if (typeof timestamp === 'number') {
	    return Math.floor(timestamp / 1000) * 1000
	  } else if (timestamp instanceof Date) {
	    return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)
	  } else {
	    throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')
	  }
	}

	function utimesMillis (path, atime, mtime, callback) {
	  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
	  fs.open(path, 'r+', (err, fd) => {
	    if (err) return callback(err)
	    fs.futimes(fd, atime, mtime, futimesErr => {
	      fs.close(fd, closeErr => {
	        if (callback) callback(futimesErr || closeErr);
	      });
	    });
	  });
	}

	function utimesMillisSync (path, atime, mtime) {
	  const fd = fs.openSync(path, 'r+');
	  fs.futimesSync(fd, atime, mtime);
	  return fs.closeSync(fd)
	}

	utimes$1 = {
	  hasMillisRes,
	  hasMillisResSync,
	  timeRemoveMillis,
	  utimesMillis,
	  utimesMillisSync
	};
	return utimes$1;
}

var stat;
var hasRequiredStat$1;

function requireStat$1 () {
	if (hasRequiredStat$1) return stat;
	hasRequiredStat$1 = 1;

	const fs = requireGracefulFs();
	const path = require$$1$4;

	const NODE_VERSION_MAJOR_WITH_BIGINT = 10;
	const NODE_VERSION_MINOR_WITH_BIGINT = 5;
	const NODE_VERSION_PATCH_WITH_BIGINT = 0;
	const nodeVersion = process.versions.node.split('.');
	const nodeVersionMajor = Number.parseInt(nodeVersion[0], 10);
	const nodeVersionMinor = Number.parseInt(nodeVersion[1], 10);
	const nodeVersionPatch = Number.parseInt(nodeVersion[2], 10);

	function nodeSupportsBigInt () {
	  if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {
	    return true
	  } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {
	    if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {
	      return true
	    } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {
	      if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {
	        return true
	      }
	    }
	  }
	  return false
	}

	function getStats (src, dest, cb) {
	  if (nodeSupportsBigInt()) {
	    fs.stat(src, { bigint: true }, (err, srcStat) => {
	      if (err) return cb(err)
	      fs.stat(dest, { bigint: true }, (err, destStat) => {
	        if (err) {
	          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })
	          return cb(err)
	        }
	        return cb(null, { srcStat, destStat })
	      });
	    });
	  } else {
	    fs.stat(src, (err, srcStat) => {
	      if (err) return cb(err)
	      fs.stat(dest, (err, destStat) => {
	        if (err) {
	          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })
	          return cb(err)
	        }
	        return cb(null, { srcStat, destStat })
	      });
	    });
	  }
	}

	function getStatsSync (src, dest) {
	  let srcStat, destStat;
	  if (nodeSupportsBigInt()) {
	    srcStat = fs.statSync(src, { bigint: true });
	  } else {
	    srcStat = fs.statSync(src);
	  }
	  try {
	    if (nodeSupportsBigInt()) {
	      destStat = fs.statSync(dest, { bigint: true });
	    } else {
	      destStat = fs.statSync(dest);
	    }
	  } catch (err) {
	    if (err.code === 'ENOENT') return { srcStat, destStat: null }
	    throw err
	  }
	  return { srcStat, destStat }
	}

	function checkPaths (src, dest, funcName, cb) {
	  getStats(src, dest, (err, stats) => {
	    if (err) return cb(err)
	    const { srcStat, destStat } = stats;
	    if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
	      return cb(new Error('Source and destination must not be the same.'))
	    }
	    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
	      return cb(new Error(errMsg(src, dest, funcName)))
	    }
	    return cb(null, { srcStat, destStat })
	  });
	}

	function checkPathsSync (src, dest, funcName) {
	  const { srcStat, destStat } = getStatsSync(src, dest);
	  if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
	    throw new Error('Source and destination must not be the same.')
	  }
	  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
	    throw new Error(errMsg(src, dest, funcName))
	  }
	  return { srcStat, destStat }
	}

	// recursively check if dest parent is a subdirectory of src.
	// It works for all file types including symlinks since it
	// checks the src and dest inodes. It starts from the deepest
	// parent and stops once it reaches the src parent or the root path.
	function checkParentPaths (src, srcStat, dest, funcName, cb) {
	  const srcParent = path.resolve(path.dirname(src));
	  const destParent = path.resolve(path.dirname(dest));
	  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()
	  if (nodeSupportsBigInt()) {
	    fs.stat(destParent, { bigint: true }, (err, destStat) => {
	      if (err) {
	        if (err.code === 'ENOENT') return cb()
	        return cb(err)
	      }
	      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
	        return cb(new Error(errMsg(src, dest, funcName)))
	      }
	      return checkParentPaths(src, srcStat, destParent, funcName, cb)
	    });
	  } else {
	    fs.stat(destParent, (err, destStat) => {
	      if (err) {
	        if (err.code === 'ENOENT') return cb()
	        return cb(err)
	      }
	      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
	        return cb(new Error(errMsg(src, dest, funcName)))
	      }
	      return checkParentPaths(src, srcStat, destParent, funcName, cb)
	    });
	  }
	}

	function checkParentPathsSync (src, srcStat, dest, funcName) {
	  const srcParent = path.resolve(path.dirname(src));
	  const destParent = path.resolve(path.dirname(dest));
	  if (destParent === srcParent || destParent === path.parse(destParent).root) return
	  let destStat;
	  try {
	    if (nodeSupportsBigInt()) {
	      destStat = fs.statSync(destParent, { bigint: true });
	    } else {
	      destStat = fs.statSync(destParent);
	    }
	  } catch (err) {
	    if (err.code === 'ENOENT') return
	    throw err
	  }
	  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
	    throw new Error(errMsg(src, dest, funcName))
	  }
	  return checkParentPathsSync(src, srcStat, destParent, funcName)
	}

	// return true if dest is a subdir of src, otherwise false.
	// It only checks the path strings.
	function isSrcSubdir (src, dest) {
	  const srcArr = path.resolve(src).split(path.sep).filter(i => i);
	  const destArr = path.resolve(dest).split(path.sep).filter(i => i);
	  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)
	}

	function errMsg (src, dest, funcName) {
	  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`
	}

	stat = {
	  checkPaths,
	  checkPathsSync,
	  checkParentPaths,
	  checkParentPathsSync,
	  isSrcSubdir
	};
	return stat;
}

var buffer;
var hasRequiredBuffer;

function requireBuffer () {
	if (hasRequiredBuffer) return buffer;
	hasRequiredBuffer = 1;
	/* eslint-disable node/no-deprecated-api */
	buffer = function (size) {
	  if (typeof Buffer.allocUnsafe === 'function') {
	    try {
	      return Buffer.allocUnsafe(size)
	    } catch (e) {
	      return new Buffer(size)
	    }
	  }
	  return new Buffer(size)
	};
	return buffer;
}

var copySync_1$1;
var hasRequiredCopySync$3;

function requireCopySync$3 () {
	if (hasRequiredCopySync$3) return copySync_1$1;
	hasRequiredCopySync$3 = 1;

	const fs = requireGracefulFs();
	const path = require$$1$4;
	const mkdirpSync = requireMkdirs$1().mkdirsSync;
	const utimesSync = requireUtimes$1().utimesMillisSync;
	const stat = requireStat$1();

	function copySync (src, dest, opts) {
	  if (typeof opts === 'function') {
	    opts = { filter: opts };
	  }

	  opts = opts || {};
	  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
	  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

	  // Warn about using preserveTimestamps on 32-bit node
	  if (opts.preserveTimestamps && process.arch === 'ia32') {
	    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
	  }

	  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy');
	  stat.checkParentPathsSync(src, srcStat, dest, 'copy');
	  return handleFilterAndCopy(destStat, src, dest, opts)
	}

	function handleFilterAndCopy (destStat, src, dest, opts) {
	  if (opts.filter && !opts.filter(src, dest)) return
	  const destParent = path.dirname(dest);
	  if (!fs.existsSync(destParent)) mkdirpSync(destParent);
	  return startCopy(destStat, src, dest, opts)
	}

	function startCopy (destStat, src, dest, opts) {
	  if (opts.filter && !opts.filter(src, dest)) return
	  return getStats(destStat, src, dest, opts)
	}

	function getStats (destStat, src, dest, opts) {
	  const statSync = opts.dereference ? fs.statSync : fs.lstatSync;
	  const srcStat = statSync(src);

	  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)
	  else if (srcStat.isFile() ||
	           srcStat.isCharacterDevice() ||
	           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)
	  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)
	}

	function onFile (srcStat, destStat, src, dest, opts) {
	  if (!destStat) return copyFile(srcStat, src, dest, opts)
	  return mayCopyFile(srcStat, src, dest, opts)
	}

	function mayCopyFile (srcStat, src, dest, opts) {
	  if (opts.overwrite) {
	    fs.unlinkSync(dest);
	    return copyFile(srcStat, src, dest, opts)
	  } else if (opts.errorOnExist) {
	    throw new Error(`'${dest}' already exists`)
	  }
	}

	function copyFile (srcStat, src, dest, opts) {
	  if (typeof fs.copyFileSync === 'function') {
	    fs.copyFileSync(src, dest);
	    fs.chmodSync(dest, srcStat.mode);
	    if (opts.preserveTimestamps) {
	      return utimesSync(dest, srcStat.atime, srcStat.mtime)
	    }
	    return
	  }
	  return copyFileFallback(srcStat, src, dest, opts)
	}

	function copyFileFallback (srcStat, src, dest, opts) {
	  const BUF_LENGTH = 64 * 1024;
	  const _buff = requireBuffer()(BUF_LENGTH);

	  const fdr = fs.openSync(src, 'r');
	  const fdw = fs.openSync(dest, 'w', srcStat.mode);
	  let pos = 0;

	  while (pos < srcStat.size) {
	    const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
	    fs.writeSync(fdw, _buff, 0, bytesRead);
	    pos += bytesRead;
	  }

	  if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime);

	  fs.closeSync(fdr);
	  fs.closeSync(fdw);
	}

	function onDir (srcStat, destStat, src, dest, opts) {
	  if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts)
	  if (destStat && !destStat.isDirectory()) {
	    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)
	  }
	  return copyDir(src, dest, opts)
	}

	function mkDirAndCopy (srcStat, src, dest, opts) {
	  fs.mkdirSync(dest);
	  copyDir(src, dest, opts);
	  return fs.chmodSync(dest, srcStat.mode)
	}

	function copyDir (src, dest, opts) {
	  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts));
	}

	function copyDirItem (item, src, dest, opts) {
	  const srcItem = path.join(src, item);
	  const destItem = path.join(dest, item);
	  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy');
	  return startCopy(destStat, srcItem, destItem, opts)
	}

	function onLink (destStat, src, dest, opts) {
	  let resolvedSrc = fs.readlinkSync(src);
	  if (opts.dereference) {
	    resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
	  }

	  if (!destStat) {
	    return fs.symlinkSync(resolvedSrc, dest)
	  } else {
	    let resolvedDest;
	    try {
	      resolvedDest = fs.readlinkSync(dest);
	    } catch (err) {
	      // dest exists and is a regular file or directory,
	      // Windows may throw UNKNOWN error. If dest already exists,
	      // fs throws error anyway, so no need to guard against it here.
	      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)
	      throw err
	    }
	    if (opts.dereference) {
	      resolvedDest = path.resolve(process.cwd(), resolvedDest);
	    }
	    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
	      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)
	    }

	    // prevent copy if src is a subdir of dest since unlinking
	    // dest in this case would result in removing src contents
	    // and therefore a broken symlink would be created.
	    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
	      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)
	    }
	    return copyLink(resolvedSrc, dest)
	  }
	}

	function copyLink (resolvedSrc, dest) {
	  fs.unlinkSync(dest);
	  return fs.symlinkSync(resolvedSrc, dest)
	}

	copySync_1$1 = copySync;
	return copySync_1$1;
}

var copySync$1;
var hasRequiredCopySync$2;

function requireCopySync$2 () {
	if (hasRequiredCopySync$2) return copySync$1;
	hasRequiredCopySync$2 = 1;

	copySync$1 = {
	  copySync: requireCopySync$3()
	};
	return copySync$1;
}

var pathExists_1$1;
var hasRequiredPathExists$1;

function requirePathExists$1 () {
	if (hasRequiredPathExists$1) return pathExists_1$1;
	hasRequiredPathExists$1 = 1;
	const u = requireUniversalify$1().fromPromise;
	const fs = requireFs$1();

	function pathExists (path) {
	  return fs.access(path).then(() => true).catch(() => false)
	}

	pathExists_1$1 = {
	  pathExists: u(pathExists),
	  pathExistsSync: fs.existsSync
	};
	return pathExists_1$1;
}

var copy_1$1;
var hasRequiredCopy$3;

function requireCopy$3 () {
	if (hasRequiredCopy$3) return copy_1$1;
	hasRequiredCopy$3 = 1;

	const fs = requireGracefulFs();
	const path = require$$1$4;
	const mkdirp = requireMkdirs$1().mkdirs;
	const pathExists = requirePathExists$1().pathExists;
	const utimes = requireUtimes$1().utimesMillis;
	const stat = requireStat$1();

	function copy (src, dest, opts, cb) {
	  if (typeof opts === 'function' && !cb) {
	    cb = opts;
	    opts = {};
	  } else if (typeof opts === 'function') {
	    opts = { filter: opts };
	  }

	  cb = cb || function () {};
	  opts = opts || {};

	  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
	  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

	  // Warn about using preserveTimestamps on 32-bit node
	  if (opts.preserveTimestamps && process.arch === 'ia32') {
	    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
	  }

	  stat.checkPaths(src, dest, 'copy', (err, stats) => {
	    if (err) return cb(err)
	    const { srcStat, destStat } = stats;
	    stat.checkParentPaths(src, srcStat, dest, 'copy', err => {
	      if (err) return cb(err)
	      if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)
	      return checkParentDir(destStat, src, dest, opts, cb)
	    });
	  });
	}

	function checkParentDir (destStat, src, dest, opts, cb) {
	  const destParent = path.dirname(dest);
	  pathExists(destParent, (err, dirExists) => {
	    if (err) return cb(err)
	    if (dirExists) return startCopy(destStat, src, dest, opts, cb)
	    mkdirp(destParent, err => {
	      if (err) return cb(err)
	      return startCopy(destStat, src, dest, opts, cb)
	    });
	  });
	}

	function handleFilter (onInclude, destStat, src, dest, opts, cb) {
	  Promise.resolve(opts.filter(src, dest)).then(include => {
	    if (include) return onInclude(destStat, src, dest, opts, cb)
	    return cb()
	  }, error => cb(error));
	}

	function startCopy (destStat, src, dest, opts, cb) {
	  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)
	  return getStats(destStat, src, dest, opts, cb)
	}

	function getStats (destStat, src, dest, opts, cb) {
	  const stat = opts.dereference ? fs.stat : fs.lstat;
	  stat(src, (err, srcStat) => {
	    if (err) return cb(err)

	    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)
	    else if (srcStat.isFile() ||
	             srcStat.isCharacterDevice() ||
	             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)
	    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)
	  });
	}

	function onFile (srcStat, destStat, src, dest, opts, cb) {
	  if (!destStat) return copyFile(srcStat, src, dest, opts, cb)
	  return mayCopyFile(srcStat, src, dest, opts, cb)
	}

	function mayCopyFile (srcStat, src, dest, opts, cb) {
	  if (opts.overwrite) {
	    fs.unlink(dest, err => {
	      if (err) return cb(err)
	      return copyFile(srcStat, src, dest, opts, cb)
	    });
	  } else if (opts.errorOnExist) {
	    return cb(new Error(`'${dest}' already exists`))
	  } else return cb()
	}

	function copyFile (srcStat, src, dest, opts, cb) {
	  if (typeof fs.copyFile === 'function') {
	    return fs.copyFile(src, dest, err => {
	      if (err) return cb(err)
	      return setDestModeAndTimestamps(srcStat, dest, opts, cb)
	    })
	  }
	  return copyFileFallback(srcStat, src, dest, opts, cb)
	}

	function copyFileFallback (srcStat, src, dest, opts, cb) {
	  const rs = fs.createReadStream(src);
	  rs.on('error', err => cb(err)).once('open', () => {
	    const ws = fs.createWriteStream(dest, { mode: srcStat.mode });
	    ws.on('error', err => cb(err))
	      .on('open', () => rs.pipe(ws))
	      .once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb));
	  });
	}

	function setDestModeAndTimestamps (srcStat, dest, opts, cb) {
	  fs.chmod(dest, srcStat.mode, err => {
	    if (err) return cb(err)
	    if (opts.preserveTimestamps) {
	      return utimes(dest, srcStat.atime, srcStat.mtime, cb)
	    }
	    return cb()
	  });
	}

	function onDir (srcStat, destStat, src, dest, opts, cb) {
	  if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts, cb)
	  if (destStat && !destStat.isDirectory()) {
	    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))
	  }
	  return copyDir(src, dest, opts, cb)
	}

	function mkDirAndCopy (srcStat, src, dest, opts, cb) {
	  fs.mkdir(dest, err => {
	    if (err) return cb(err)
	    copyDir(src, dest, opts, err => {
	      if (err) return cb(err)
	      return fs.chmod(dest, srcStat.mode, cb)
	    });
	  });
	}

	function copyDir (src, dest, opts, cb) {
	  fs.readdir(src, (err, items) => {
	    if (err) return cb(err)
	    return copyDirItems(items, src, dest, opts, cb)
	  });
	}

	function copyDirItems (items, src, dest, opts, cb) {
	  const item = items.pop();
	  if (!item) return cb()
	  return copyDirItem(items, item, src, dest, opts, cb)
	}

	function copyDirItem (items, item, src, dest, opts, cb) {
	  const srcItem = path.join(src, item);
	  const destItem = path.join(dest, item);
	  stat.checkPaths(srcItem, destItem, 'copy', (err, stats) => {
	    if (err) return cb(err)
	    const { destStat } = stats;
	    startCopy(destStat, srcItem, destItem, opts, err => {
	      if (err) return cb(err)
	      return copyDirItems(items, src, dest, opts, cb)
	    });
	  });
	}

	function onLink (destStat, src, dest, opts, cb) {
	  fs.readlink(src, (err, resolvedSrc) => {
	    if (err) return cb(err)
	    if (opts.dereference) {
	      resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
	    }

	    if (!destStat) {
	      return fs.symlink(resolvedSrc, dest, cb)
	    } else {
	      fs.readlink(dest, (err, resolvedDest) => {
	        if (err) {
	          // dest exists and is a regular file or directory,
	          // Windows may throw UNKNOWN error. If dest already exists,
	          // fs throws error anyway, so no need to guard against it here.
	          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)
	          return cb(err)
	        }
	        if (opts.dereference) {
	          resolvedDest = path.resolve(process.cwd(), resolvedDest);
	        }
	        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
	          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))
	        }

	        // do not copy if src is a subdir of dest since unlinking
	        // dest in this case would result in removing src contents
	        // and therefore a broken symlink would be created.
	        if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
	          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))
	        }
	        return copyLink(resolvedSrc, dest, cb)
	      });
	    }
	  });
	}

	function copyLink (resolvedSrc, dest, cb) {
	  fs.unlink(dest, err => {
	    if (err) return cb(err)
	    return fs.symlink(resolvedSrc, dest, cb)
	  });
	}

	copy_1$1 = copy;
	return copy_1$1;
}

var copy$1;
var hasRequiredCopy$2;

function requireCopy$2 () {
	if (hasRequiredCopy$2) return copy$1;
	hasRequiredCopy$2 = 1;

	const u = requireUniversalify$1().fromCallback;
	copy$1 = {
	  copy: u(requireCopy$3())
	};
	return copy$1;
}

var rimraf_1$1;
var hasRequiredRimraf$1;

function requireRimraf$1 () {
	if (hasRequiredRimraf$1) return rimraf_1$1;
	hasRequiredRimraf$1 = 1;

	const fs = requireGracefulFs();
	const path = require$$1$4;
	const assert = require$$0$7;

	const isWindows = (process.platform === 'win32');

	function defaults (options) {
	  const methods = [
	    'unlink',
	    'chmod',
	    'stat',
	    'lstat',
	    'rmdir',
	    'readdir'
	  ];
	  methods.forEach(m => {
	    options[m] = options[m] || fs[m];
	    m = m + 'Sync';
	    options[m] = options[m] || fs[m];
	  });

	  options.maxBusyTries = options.maxBusyTries || 3;
	}

	function rimraf (p, options, cb) {
	  let busyTries = 0;

	  if (typeof options === 'function') {
	    cb = options;
	    options = {};
	  }

	  assert(p, 'rimraf: missing path');
	  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string');
	  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required');
	  assert(options, 'rimraf: invalid options argument provided');
	  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object');

	  defaults(options);

	  rimraf_(p, options, function CB (er) {
	    if (er) {
	      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&
	          busyTries < options.maxBusyTries) {
	        busyTries++;
	        const time = busyTries * 100;
	        // try again, with the same exact callback as this one.
	        return setTimeout(() => rimraf_(p, options, CB), time)
	      }

	      // already gone
	      if (er.code === 'ENOENT') er = null;
	    }

	    cb(er);
	  });
	}

	// Two possible strategies.
	// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
	// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
	//
	// Both result in an extra syscall when you guess wrong.  However, there
	// are likely far more normal files in the world than directories.  This
	// is based on the assumption that a the average number of files per
	// directory is >= 1.
	//
	// If anyone ever complains about this, then I guess the strategy could
	// be made configurable somehow.  But until then, YAGNI.
	function rimraf_ (p, options, cb) {
	  assert(p);
	  assert(options);
	  assert(typeof cb === 'function');

	  // sunos lets the root user unlink directories, which is... weird.
	  // so we have to lstat here and make sure it's not a dir.
	  options.lstat(p, (er, st) => {
	    if (er && er.code === 'ENOENT') {
	      return cb(null)
	    }

	    // Windows can EPERM on stat.  Life is suffering.
	    if (er && er.code === 'EPERM' && isWindows) {
	      return fixWinEPERM(p, options, er, cb)
	    }

	    if (st && st.isDirectory()) {
	      return rmdir(p, options, er, cb)
	    }

	    options.unlink(p, er => {
	      if (er) {
	        if (er.code === 'ENOENT') {
	          return cb(null)
	        }
	        if (er.code === 'EPERM') {
	          return (isWindows)
	            ? fixWinEPERM(p, options, er, cb)
	            : rmdir(p, options, er, cb)
	        }
	        if (er.code === 'EISDIR') {
	          return rmdir(p, options, er, cb)
	        }
	      }
	      return cb(er)
	    });
	  });
	}

	function fixWinEPERM (p, options, er, cb) {
	  assert(p);
	  assert(options);
	  assert(typeof cb === 'function');
	  if (er) {
	    assert(er instanceof Error);
	  }

	  options.chmod(p, 0o666, er2 => {
	    if (er2) {
	      cb(er2.code === 'ENOENT' ? null : er);
	    } else {
	      options.stat(p, (er3, stats) => {
	        if (er3) {
	          cb(er3.code === 'ENOENT' ? null : er);
	        } else if (stats.isDirectory()) {
	          rmdir(p, options, er, cb);
	        } else {
	          options.unlink(p, cb);
	        }
	      });
	    }
	  });
	}

	function fixWinEPERMSync (p, options, er) {
	  let stats;

	  assert(p);
	  assert(options);
	  if (er) {
	    assert(er instanceof Error);
	  }

	  try {
	    options.chmodSync(p, 0o666);
	  } catch (er2) {
	    if (er2.code === 'ENOENT') {
	      return
	    } else {
	      throw er
	    }
	  }

	  try {
	    stats = options.statSync(p);
	  } catch (er3) {
	    if (er3.code === 'ENOENT') {
	      return
	    } else {
	      throw er
	    }
	  }

	  if (stats.isDirectory()) {
	    rmdirSync(p, options, er);
	  } else {
	    options.unlinkSync(p);
	  }
	}

	function rmdir (p, options, originalEr, cb) {
	  assert(p);
	  assert(options);
	  if (originalEr) {
	    assert(originalEr instanceof Error);
	  }
	  assert(typeof cb === 'function');

	  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
	  // if we guessed wrong, and it's not a directory, then
	  // raise the original error.
	  options.rmdir(p, er => {
	    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {
	      rmkids(p, options, cb);
	    } else if (er && er.code === 'ENOTDIR') {
	      cb(originalEr);
	    } else {
	      cb(er);
	    }
	  });
	}

	function rmkids (p, options, cb) {
	  assert(p);
	  assert(options);
	  assert(typeof cb === 'function');

	  options.readdir(p, (er, files) => {
	    if (er) return cb(er)

	    let n = files.length;
	    let errState;

	    if (n === 0) return options.rmdir(p, cb)

	    files.forEach(f => {
	      rimraf(path.join(p, f), options, er => {
	        if (errState) {
	          return
	        }
	        if (er) return cb(errState = er)
	        if (--n === 0) {
	          options.rmdir(p, cb);
	        }
	      });
	    });
	  });
	}

	// this looks simpler, and is strictly *faster*, but will
	// tie up the JavaScript thread and fail on excessively
	// deep directory trees.
	function rimrafSync (p, options) {
	  let st;

	  options = options || {};
	  defaults(options);

	  assert(p, 'rimraf: missing path');
	  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string');
	  assert(options, 'rimraf: missing options');
	  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object');

	  try {
	    st = options.lstatSync(p);
	  } catch (er) {
	    if (er.code === 'ENOENT') {
	      return
	    }

	    // Windows can EPERM on stat.  Life is suffering.
	    if (er.code === 'EPERM' && isWindows) {
	      fixWinEPERMSync(p, options, er);
	    }
	  }

	  try {
	    // sunos lets the root user unlink directories, which is... weird.
	    if (st && st.isDirectory()) {
	      rmdirSync(p, options, null);
	    } else {
	      options.unlinkSync(p);
	    }
	  } catch (er) {
	    if (er.code === 'ENOENT') {
	      return
	    } else if (er.code === 'EPERM') {
	      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
	    } else if (er.code !== 'EISDIR') {
	      throw er
	    }
	    rmdirSync(p, options, er);
	  }
	}

	function rmdirSync (p, options, originalEr) {
	  assert(p);
	  assert(options);
	  if (originalEr) {
	    assert(originalEr instanceof Error);
	  }

	  try {
	    options.rmdirSync(p);
	  } catch (er) {
	    if (er.code === 'ENOTDIR') {
	      throw originalEr
	    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {
	      rmkidsSync(p, options);
	    } else if (er.code !== 'ENOENT') {
	      throw er
	    }
	  }
	}

	function rmkidsSync (p, options) {
	  assert(p);
	  assert(options);
	  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options));

	  if (isWindows) {
	    // We only end up here once we got ENOTEMPTY at least once, and
	    // at this point, we are guaranteed to have removed all the kids.
	    // So, we know that it won't be ENOENT or ENOTDIR or anything else.
	    // try really hard to delete stuff on windows, because it has a
	    // PROFOUNDLY annoying habit of not closing handles promptly when
	    // files are deleted, resulting in spurious ENOTEMPTY errors.
	    const startTime = Date.now();
	    do {
	      try {
	        const ret = options.rmdirSync(p, options);
	        return ret
	      } catch (er) { }
	    } while (Date.now() - startTime < 500) // give up after 500ms
	  } else {
	    const ret = options.rmdirSync(p, options);
	    return ret
	  }
	}

	rimraf_1$1 = rimraf;
	rimraf.sync = rimrafSync;
	return rimraf_1$1;
}

var remove$1;
var hasRequiredRemove$1;

function requireRemove$1 () {
	if (hasRequiredRemove$1) return remove$1;
	hasRequiredRemove$1 = 1;

	const u = requireUniversalify$1().fromCallback;
	const rimraf = requireRimraf$1();

	remove$1 = {
	  remove: u(rimraf),
	  removeSync: rimraf.sync
	};
	return remove$1;
}

var empty$1;
var hasRequiredEmpty$1;

function requireEmpty$1 () {
	if (hasRequiredEmpty$1) return empty$1;
	hasRequiredEmpty$1 = 1;

	const u = requireUniversalify$1().fromCallback;
	const fs = requireGracefulFs();
	const path = require$$1$4;
	const mkdir = requireMkdirs$1();
	const remove = requireRemove$1();

	const emptyDir = u(function emptyDir (dir, callback) {
	  callback = callback || function () {};
	  fs.readdir(dir, (err, items) => {
	    if (err) return mkdir.mkdirs(dir, callback)

	    items = items.map(item => path.join(dir, item));

	    deleteItem();

	    function deleteItem () {
	      const item = items.pop();
	      if (!item) return callback()
	      remove.remove(item, err => {
	        if (err) return callback(err)
	        deleteItem();
	      });
	    }
	  });
	});

	function emptyDirSync (dir) {
	  let items;
	  try {
	    items = fs.readdirSync(dir);
	  } catch (err) {
	    return mkdir.mkdirsSync(dir)
	  }

	  items.forEach(item => {
	    item = path.join(dir, item);
	    remove.removeSync(item);
	  });
	}

	empty$1 = {
	  emptyDirSync,
	  emptydirSync: emptyDirSync,
	  emptyDir,
	  emptydir: emptyDir
	};
	return empty$1;
}

var file$2;
var hasRequiredFile$3;

function requireFile$3 () {
	if (hasRequiredFile$3) return file$2;
	hasRequiredFile$3 = 1;

	const u = requireUniversalify$1().fromCallback;
	const path = require$$1$4;
	const fs = requireGracefulFs();
	const mkdir = requireMkdirs$1();
	const pathExists = requirePathExists$1().pathExists;

	function createFile (file, callback) {
	  function makeFile () {
	    fs.writeFile(file, '', err => {
	      if (err) return callback(err)
	      callback();
	    });
	  }

	  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err
	    if (!err && stats.isFile()) return callback()
	    const dir = path.dirname(file);
	    pathExists(dir, (err, dirExists) => {
	      if (err) return callback(err)
	      if (dirExists) return makeFile()
	      mkdir.mkdirs(dir, err => {
	        if (err) return callback(err)
	        makeFile();
	      });
	    });
	  });
	}

	function createFileSync (file) {
	  let stats;
	  try {
	    stats = fs.statSync(file);
	  } catch (e) {}
	  if (stats && stats.isFile()) return

	  const dir = path.dirname(file);
	  if (!fs.existsSync(dir)) {
	    mkdir.mkdirsSync(dir);
	  }

	  fs.writeFileSync(file, '');
	}

	file$2 = {
	  createFile: u(createFile),
	  createFileSync
	};
	return file$2;
}

var link$1;
var hasRequiredLink$1;

function requireLink$1 () {
	if (hasRequiredLink$1) return link$1;
	hasRequiredLink$1 = 1;

	const u = requireUniversalify$1().fromCallback;
	const path = require$$1$4;
	const fs = requireGracefulFs();
	const mkdir = requireMkdirs$1();
	const pathExists = requirePathExists$1().pathExists;

	function createLink (srcpath, dstpath, callback) {
	  function makeLink (srcpath, dstpath) {
	    fs.link(srcpath, dstpath, err => {
	      if (err) return callback(err)
	      callback(null);
	    });
	  }

	  pathExists(dstpath, (err, destinationExists) => {
	    if (err) return callback(err)
	    if (destinationExists) return callback(null)
	    fs.lstat(srcpath, (err) => {
	      if (err) {
	        err.message = err.message.replace('lstat', 'ensureLink');
	        return callback(err)
	      }

	      const dir = path.dirname(dstpath);
	      pathExists(dir, (err, dirExists) => {
	        if (err) return callback(err)
	        if (dirExists) return makeLink(srcpath, dstpath)
	        mkdir.mkdirs(dir, err => {
	          if (err) return callback(err)
	          makeLink(srcpath, dstpath);
	        });
	      });
	    });
	  });
	}

	function createLinkSync (srcpath, dstpath) {
	  const destinationExists = fs.existsSync(dstpath);
	  if (destinationExists) return undefined

	  try {
	    fs.lstatSync(srcpath);
	  } catch (err) {
	    err.message = err.message.replace('lstat', 'ensureLink');
	    throw err
	  }

	  const dir = path.dirname(dstpath);
	  const dirExists = fs.existsSync(dir);
	  if (dirExists) return fs.linkSync(srcpath, dstpath)
	  mkdir.mkdirsSync(dir);

	  return fs.linkSync(srcpath, dstpath)
	}

	link$1 = {
	  createLink: u(createLink),
	  createLinkSync
	};
	return link$1;
}

var symlinkPaths_1$1;
var hasRequiredSymlinkPaths$1;

function requireSymlinkPaths$1 () {
	if (hasRequiredSymlinkPaths$1) return symlinkPaths_1$1;
	hasRequiredSymlinkPaths$1 = 1;

	const path = require$$1$4;
	const fs = requireGracefulFs();
	const pathExists = requirePathExists$1().pathExists;

	/**
	 * Function that returns two types of paths, one relative to symlink, and one
	 * relative to the current working directory. Checks if path is absolute or
	 * relative. If the path is relative, this function checks if the path is
	 * relative to symlink or relative to current working directory. This is an
	 * initiative to find a smarter `srcpath` to supply when building symlinks.
	 * This allows you to determine which path to use out of one of three possible
	 * types of source paths. The first is an absolute path. This is detected by
	 * `path.isAbsolute()`. When an absolute path is provided, it is checked to
	 * see if it exists. If it does it's used, if not an error is returned
	 * (callback)/ thrown (sync). The other two options for `srcpath` are a
	 * relative url. By default Node's `fs.symlink` works by creating a symlink
	 * using `dstpath` and expects the `srcpath` to be relative to the newly
	 * created symlink. If you provide a `srcpath` that does not exist on the file
	 * system it results in a broken symlink. To minimize this, the function
	 * checks to see if the 'relative to symlink' source file exists, and if it
	 * does it will use it. If it does not, it checks if there's a file that
	 * exists that is relative to the current working directory, if does its used.
	 * This preserves the expectations of the original fs.symlink spec and adds
	 * the ability to pass in `relative to current working direcotry` paths.
	 */

	function symlinkPaths (srcpath, dstpath, callback) {
	  if (path.isAbsolute(srcpath)) {
	    return fs.lstat(srcpath, (err) => {
	      if (err) {
	        err.message = err.message.replace('lstat', 'ensureSymlink');
	        return callback(err)
	      }
	      return callback(null, {
	        'toCwd': srcpath,
	        'toDst': srcpath
	      })
	    })
	  } else {
	    const dstdir = path.dirname(dstpath);
	    const relativeToDst = path.join(dstdir, srcpath);
	    return pathExists(relativeToDst, (err, exists) => {
	      if (err) return callback(err)
	      if (exists) {
	        return callback(null, {
	          'toCwd': relativeToDst,
	          'toDst': srcpath
	        })
	      } else {
	        return fs.lstat(srcpath, (err) => {
	          if (err) {
	            err.message = err.message.replace('lstat', 'ensureSymlink');
	            return callback(err)
	          }
	          return callback(null, {
	            'toCwd': srcpath,
	            'toDst': path.relative(dstdir, srcpath)
	          })
	        })
	      }
	    })
	  }
	}

	function symlinkPathsSync (srcpath, dstpath) {
	  let exists;
	  if (path.isAbsolute(srcpath)) {
	    exists = fs.existsSync(srcpath);
	    if (!exists) throw new Error('absolute srcpath does not exist')
	    return {
	      'toCwd': srcpath,
	      'toDst': srcpath
	    }
	  } else {
	    const dstdir = path.dirname(dstpath);
	    const relativeToDst = path.join(dstdir, srcpath);
	    exists = fs.existsSync(relativeToDst);
	    if (exists) {
	      return {
	        'toCwd': relativeToDst,
	        'toDst': srcpath
	      }
	    } else {
	      exists = fs.existsSync(srcpath);
	      if (!exists) throw new Error('relative srcpath does not exist')
	      return {
	        'toCwd': srcpath,
	        'toDst': path.relative(dstdir, srcpath)
	      }
	    }
	  }
	}

	symlinkPaths_1$1 = {
	  symlinkPaths,
	  symlinkPathsSync
	};
	return symlinkPaths_1$1;
}

var symlinkType_1$1;
var hasRequiredSymlinkType$1;

function requireSymlinkType$1 () {
	if (hasRequiredSymlinkType$1) return symlinkType_1$1;
	hasRequiredSymlinkType$1 = 1;

	const fs = requireGracefulFs();

	function symlinkType (srcpath, type, callback) {
	  callback = (typeof type === 'function') ? type : callback;
	  type = (typeof type === 'function') ? false : type;
	  if (type) return callback(null, type)
	  fs.lstat(srcpath, (err, stats) => {
	    if (err) return callback(null, 'file')
	    type = (stats && stats.isDirectory()) ? 'dir' : 'file';
	    callback(null, type);
	  });
	}

	function symlinkTypeSync (srcpath, type) {
	  let stats;

	  if (type) return type
	  try {
	    stats = fs.lstatSync(srcpath);
	  } catch (e) {
	    return 'file'
	  }
	  return (stats && stats.isDirectory()) ? 'dir' : 'file'
	}

	symlinkType_1$1 = {
	  symlinkType,
	  symlinkTypeSync
	};
	return symlinkType_1$1;
}

var symlink$1;
var hasRequiredSymlink$1;

function requireSymlink$1 () {
	if (hasRequiredSymlink$1) return symlink$1;
	hasRequiredSymlink$1 = 1;

	const u = requireUniversalify$1().fromCallback;
	const path = require$$1$4;
	const fs = requireGracefulFs();
	const _mkdirs = requireMkdirs$1();
	const mkdirs = _mkdirs.mkdirs;
	const mkdirsSync = _mkdirs.mkdirsSync;

	const _symlinkPaths = requireSymlinkPaths$1();
	const symlinkPaths = _symlinkPaths.symlinkPaths;
	const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;

	const _symlinkType = requireSymlinkType$1();
	const symlinkType = _symlinkType.symlinkType;
	const symlinkTypeSync = _symlinkType.symlinkTypeSync;

	const pathExists = requirePathExists$1().pathExists;

	function createSymlink (srcpath, dstpath, type, callback) {
	  callback = (typeof type === 'function') ? type : callback;
	  type = (typeof type === 'function') ? false : type;

	  pathExists(dstpath, (err, destinationExists) => {
	    if (err) return callback(err)
	    if (destinationExists) return callback(null)
	    symlinkPaths(srcpath, dstpath, (err, relative) => {
	      if (err) return callback(err)
	      srcpath = relative.toDst;
	      symlinkType(relative.toCwd, type, (err, type) => {
	        if (err) return callback(err)
	        const dir = path.dirname(dstpath);
	        pathExists(dir, (err, dirExists) => {
	          if (err) return callback(err)
	          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)
	          mkdirs(dir, err => {
	            if (err) return callback(err)
	            fs.symlink(srcpath, dstpath, type, callback);
	          });
	        });
	      });
	    });
	  });
	}

	function createSymlinkSync (srcpath, dstpath, type) {
	  const destinationExists = fs.existsSync(dstpath);
	  if (destinationExists) return undefined

	  const relative = symlinkPathsSync(srcpath, dstpath);
	  srcpath = relative.toDst;
	  type = symlinkTypeSync(relative.toCwd, type);
	  const dir = path.dirname(dstpath);
	  const exists = fs.existsSync(dir);
	  if (exists) return fs.symlinkSync(srcpath, dstpath, type)
	  mkdirsSync(dir);
	  return fs.symlinkSync(srcpath, dstpath, type)
	}

	symlink$1 = {
	  createSymlink: u(createSymlink),
	  createSymlinkSync
	};
	return symlink$1;
}

var ensure$1;
var hasRequiredEnsure$1;

function requireEnsure$1 () {
	if (hasRequiredEnsure$1) return ensure$1;
	hasRequiredEnsure$1 = 1;

	const file = requireFile$3();
	const link = requireLink$1();
	const symlink = requireSymlink$1();

	ensure$1 = {
	  // file
	  createFile: file.createFile,
	  createFileSync: file.createFileSync,
	  ensureFile: file.createFile,
	  ensureFileSync: file.createFileSync,
	  // link
	  createLink: link.createLink,
	  createLinkSync: link.createLinkSync,
	  ensureLink: link.createLink,
	  ensureLinkSync: link.createLinkSync,
	  // symlink
	  createSymlink: symlink.createSymlink,
	  createSymlinkSync: symlink.createSymlinkSync,
	  ensureSymlink: symlink.createSymlink,
	  ensureSymlinkSync: symlink.createSymlinkSync
	};
	return ensure$1;
}

var jsonfile_1$1;
var hasRequiredJsonfile$3;

function requireJsonfile$3 () {
	if (hasRequiredJsonfile$3) return jsonfile_1$1;
	hasRequiredJsonfile$3 = 1;
	var _fs;
	try {
	  _fs = requireGracefulFs();
	} catch (_) {
	  _fs = require$$0$8;
	}

	function readFile (file, options, callback) {
	  if (callback == null) {
	    callback = options;
	    options = {};
	  }

	  if (typeof options === 'string') {
	    options = {encoding: options};
	  }

	  options = options || {};
	  var fs = options.fs || _fs;

	  var shouldThrow = true;
	  if ('throws' in options) {
	    shouldThrow = options.throws;
	  }

	  fs.readFile(file, options, function (err, data) {
	    if (err) return callback(err)

	    data = stripBom(data);

	    var obj;
	    try {
	      obj = JSON.parse(data, options ? options.reviver : null);
	    } catch (err2) {
	      if (shouldThrow) {
	        err2.message = file + ': ' + err2.message;
	        return callback(err2)
	      } else {
	        return callback(null, null)
	      }
	    }

	    callback(null, obj);
	  });
	}

	function readFileSync (file, options) {
	  options = options || {};
	  if (typeof options === 'string') {
	    options = {encoding: options};
	  }

	  var fs = options.fs || _fs;

	  var shouldThrow = true;
	  if ('throws' in options) {
	    shouldThrow = options.throws;
	  }

	  try {
	    var content = fs.readFileSync(file, options);
	    content = stripBom(content);
	    return JSON.parse(content, options.reviver)
	  } catch (err) {
	    if (shouldThrow) {
	      err.message = file + ': ' + err.message;
	      throw err
	    } else {
	      return null
	    }
	  }
	}

	function stringify (obj, options) {
	  var spaces;
	  var EOL = '\n';
	  if (typeof options === 'object' && options !== null) {
	    if (options.spaces) {
	      spaces = options.spaces;
	    }
	    if (options.EOL) {
	      EOL = options.EOL;
	    }
	  }

	  var str = JSON.stringify(obj, options ? options.replacer : null, spaces);

	  return str.replace(/\n/g, EOL) + EOL
	}

	function writeFile (file, obj, options, callback) {
	  if (callback == null) {
	    callback = options;
	    options = {};
	  }
	  options = options || {};
	  var fs = options.fs || _fs;

	  var str = '';
	  try {
	    str = stringify(obj, options);
	  } catch (err) {
	    // Need to return whether a callback was passed or not
	    if (callback) callback(err, null);
	    return
	  }

	  fs.writeFile(file, str, options, callback);
	}

	function writeFileSync (file, obj, options) {
	  options = options || {};
	  var fs = options.fs || _fs;

	  var str = stringify(obj, options);
	  // not sure if fs.writeFileSync returns anything, but just in case
	  return fs.writeFileSync(file, str, options)
	}

	function stripBom (content) {
	  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
	  if (Buffer.isBuffer(content)) content = content.toString('utf8');
	  content = content.replace(/^\uFEFF/, '');
	  return content
	}

	var jsonfile = {
	  readFile: readFile,
	  readFileSync: readFileSync,
	  writeFile: writeFile,
	  writeFileSync: writeFileSync
	};

	jsonfile_1$1 = jsonfile;
	return jsonfile_1$1;
}

var jsonfile$1;
var hasRequiredJsonfile$2;

function requireJsonfile$2 () {
	if (hasRequiredJsonfile$2) return jsonfile$1;
	hasRequiredJsonfile$2 = 1;

	const u = requireUniversalify$1().fromCallback;
	const jsonFile = requireJsonfile$3();

	jsonfile$1 = {
	  // jsonfile exports
	  readJson: u(jsonFile.readFile),
	  readJsonSync: jsonFile.readFileSync,
	  writeJson: u(jsonFile.writeFile),
	  writeJsonSync: jsonFile.writeFileSync
	};
	return jsonfile$1;
}

var outputJson_1$1;
var hasRequiredOutputJson$1;

function requireOutputJson$1 () {
	if (hasRequiredOutputJson$1) return outputJson_1$1;
	hasRequiredOutputJson$1 = 1;

	const path = require$$1$4;
	const mkdir = requireMkdirs$1();
	const pathExists = requirePathExists$1().pathExists;
	const jsonFile = requireJsonfile$2();

	function outputJson (file, data, options, callback) {
	  if (typeof options === 'function') {
	    callback = options;
	    options = {};
	  }

	  const dir = path.dirname(file);

	  pathExists(dir, (err, itDoes) => {
	    if (err) return callback(err)
	    if (itDoes) return jsonFile.writeJson(file, data, options, callback)

	    mkdir.mkdirs(dir, err => {
	      if (err) return callback(err)
	      jsonFile.writeJson(file, data, options, callback);
	    });
	  });
	}

	outputJson_1$1 = outputJson;
	return outputJson_1$1;
}

var outputJsonSync_1$1;
var hasRequiredOutputJsonSync$1;

function requireOutputJsonSync$1 () {
	if (hasRequiredOutputJsonSync$1) return outputJsonSync_1$1;
	hasRequiredOutputJsonSync$1 = 1;

	const fs = requireGracefulFs();
	const path = require$$1$4;
	const mkdir = requireMkdirs$1();
	const jsonFile = requireJsonfile$2();

	function outputJsonSync (file, data, options) {
	  const dir = path.dirname(file);

	  if (!fs.existsSync(dir)) {
	    mkdir.mkdirsSync(dir);
	  }

	  jsonFile.writeJsonSync(file, data, options);
	}

	outputJsonSync_1$1 = outputJsonSync;
	return outputJsonSync_1$1;
}

var json$1;
var hasRequiredJson$1;

function requireJson$1 () {
	if (hasRequiredJson$1) return json$1;
	hasRequiredJson$1 = 1;

	const u = requireUniversalify$1().fromCallback;
	const jsonFile = requireJsonfile$2();

	jsonFile.outputJson = u(requireOutputJson$1());
	jsonFile.outputJsonSync = requireOutputJsonSync$1();
	// aliases
	jsonFile.outputJSON = jsonFile.outputJson;
	jsonFile.outputJSONSync = jsonFile.outputJsonSync;
	jsonFile.writeJSON = jsonFile.writeJson;
	jsonFile.writeJSONSync = jsonFile.writeJsonSync;
	jsonFile.readJSON = jsonFile.readJson;
	jsonFile.readJSONSync = jsonFile.readJsonSync;

	json$1 = jsonFile;
	return json$1;
}

var moveSync_1$1;
var hasRequiredMoveSync$3;

function requireMoveSync$3 () {
	if (hasRequiredMoveSync$3) return moveSync_1$1;
	hasRequiredMoveSync$3 = 1;

	const fs = requireGracefulFs();
	const path = require$$1$4;
	const copySync = requireCopySync$2().copySync;
	const removeSync = requireRemove$1().removeSync;
	const mkdirpSync = requireMkdirs$1().mkdirpSync;
	const stat = requireStat$1();

	function moveSync (src, dest, opts) {
	  opts = opts || {};
	  const overwrite = opts.overwrite || opts.clobber || false;

	  const { srcStat } = stat.checkPathsSync(src, dest, 'move');
	  stat.checkParentPathsSync(src, srcStat, dest, 'move');
	  mkdirpSync(path.dirname(dest));
	  return doRename(src, dest, overwrite)
	}

	function doRename (src, dest, overwrite) {
	  if (overwrite) {
	    removeSync(dest);
	    return rename(src, dest, overwrite)
	  }
	  if (fs.existsSync(dest)) throw new Error('dest already exists.')
	  return rename(src, dest, overwrite)
	}

	function rename (src, dest, overwrite) {
	  try {
	    fs.renameSync(src, dest);
	  } catch (err) {
	    if (err.code !== 'EXDEV') throw err
	    return moveAcrossDevice(src, dest, overwrite)
	  }
	}

	function moveAcrossDevice (src, dest, overwrite) {
	  const opts = {
	    overwrite,
	    errorOnExist: true
	  };
	  copySync(src, dest, opts);
	  return removeSync(src)
	}

	moveSync_1$1 = moveSync;
	return moveSync_1$1;
}

var moveSync$1;
var hasRequiredMoveSync$2;

function requireMoveSync$2 () {
	if (hasRequiredMoveSync$2) return moveSync$1;
	hasRequiredMoveSync$2 = 1;

	moveSync$1 = {
	  moveSync: requireMoveSync$3()
	};
	return moveSync$1;
}

var move_1$1;
var hasRequiredMove$4;

function requireMove$4 () {
	if (hasRequiredMove$4) return move_1$1;
	hasRequiredMove$4 = 1;

	const fs = requireGracefulFs();
	const path = require$$1$4;
	const copy = requireCopy$2().copy;
	const remove = requireRemove$1().remove;
	const mkdirp = requireMkdirs$1().mkdirp;
	const pathExists = requirePathExists$1().pathExists;
	const stat = requireStat$1();

	function move (src, dest, opts, cb) {
	  if (typeof opts === 'function') {
	    cb = opts;
	    opts = {};
	  }

	  const overwrite = opts.overwrite || opts.clobber || false;

	  stat.checkPaths(src, dest, 'move', (err, stats) => {
	    if (err) return cb(err)
	    const { srcStat } = stats;
	    stat.checkParentPaths(src, srcStat, dest, 'move', err => {
	      if (err) return cb(err)
	      mkdirp(path.dirname(dest), err => {
	        if (err) return cb(err)
	        return doRename(src, dest, overwrite, cb)
	      });
	    });
	  });
	}

	function doRename (src, dest, overwrite, cb) {
	  if (overwrite) {
	    return remove(dest, err => {
	      if (err) return cb(err)
	      return rename(src, dest, overwrite, cb)
	    })
	  }
	  pathExists(dest, (err, destExists) => {
	    if (err) return cb(err)
	    if (destExists) return cb(new Error('dest already exists.'))
	    return rename(src, dest, overwrite, cb)
	  });
	}

	function rename (src, dest, overwrite, cb) {
	  fs.rename(src, dest, err => {
	    if (!err) return cb()
	    if (err.code !== 'EXDEV') return cb(err)
	    return moveAcrossDevice(src, dest, overwrite, cb)
	  });
	}

	function moveAcrossDevice (src, dest, overwrite, cb) {
	  const opts = {
	    overwrite,
	    errorOnExist: true
	  };
	  copy(src, dest, opts, err => {
	    if (err) return cb(err)
	    return remove(src, cb)
	  });
	}

	move_1$1 = move;
	return move_1$1;
}

var move$2;
var hasRequiredMove$3;

function requireMove$3 () {
	if (hasRequiredMove$3) return move$2;
	hasRequiredMove$3 = 1;

	const u = requireUniversalify$1().fromCallback;
	move$2 = {
	  move: u(requireMove$4())
	};
	return move$2;
}

var output$1;
var hasRequiredOutput$1;

function requireOutput$1 () {
	if (hasRequiredOutput$1) return output$1;
	hasRequiredOutput$1 = 1;

	const u = requireUniversalify$1().fromCallback;
	const fs = requireGracefulFs();
	const path = require$$1$4;
	const mkdir = requireMkdirs$1();
	const pathExists = requirePathExists$1().pathExists;

	function outputFile (file, data, encoding, callback) {
	  if (typeof encoding === 'function') {
	    callback = encoding;
	    encoding = 'utf8';
	  }

	  const dir = path.dirname(file);
	  pathExists(dir, (err, itDoes) => {
	    if (err) return callback(err)
	    if (itDoes) return fs.writeFile(file, data, encoding, callback)

	    mkdir.mkdirs(dir, err => {
	      if (err) return callback(err)

	      fs.writeFile(file, data, encoding, callback);
	    });
	  });
	}

	function outputFileSync (file, ...args) {
	  const dir = path.dirname(file);
	  if (fs.existsSync(dir)) {
	    return fs.writeFileSync(file, ...args)
	  }
	  mkdir.mkdirsSync(dir);
	  fs.writeFileSync(file, ...args);
	}

	output$1 = {
	  outputFile: u(outputFile),
	  outputFileSync
	};
	return output$1;
}

var hasRequiredLib$3;

function requireLib$3 () {
	if (hasRequiredLib$3) return lib$3.exports;
	hasRequiredLib$3 = 1;
	(function (module) {

		module.exports = Object.assign(
		  {},
		  // Export promiseified graceful-fs:
		  requireFs$1(),
		  // Export extra methods:
		  requireCopySync$2(),
		  requireCopy$2(),
		  requireEmpty$1(),
		  requireEnsure$1(),
		  requireJson$1(),
		  requireMkdirs$1(),
		  requireMoveSync$2(),
		  requireMove$3(),
		  requireOutput$1(),
		  requirePathExists$1(),
		  requireRemove$1()
		);

		// Export fs.promises as a getter property so that we don't trigger
		// ExperimentalWarning before fs.promises is actually accessed.
		const fs = require$$0$8;
		if (Object.getOwnPropertyDescriptor(fs, 'promises')) {
		  Object.defineProperty(module.exports, 'promises', {
		    get () { return fs.promises }
		  });
		} 
	} (lib$3));
	return lib$3.exports;
}

var now;
var hasRequiredNow;

function requireNow () {
	if (hasRequiredNow) return now;
	hasRequiredNow = 1;
	// allows us to inject a mock date in tests
	now = () => new Date();
	return now;
}

var fileNameFormatter;
var hasRequiredFileNameFormatter;

function requireFileNameFormatter () {
	if (hasRequiredFileNameFormatter) return fileNameFormatter;
	hasRequiredFileNameFormatter = 1;
	const debug = requireSrc$1()("streamroller:fileNameFormatter");
	const path = require$$1$4;
	const ZIP_EXT = ".gz";
	const DEFAULT_FILENAME_SEP = ".";

	fileNameFormatter = ({
	  file,
	  keepFileExt,
	  needsIndex,
	  alwaysIncludeDate,
	  compress,
	  fileNameSep
	}) => {
	  let FILENAME_SEP = fileNameSep || DEFAULT_FILENAME_SEP;
	  const dirAndName = path.join(file.dir, file.name);

	  const ext = f => f + file.ext;

	  const index = (f, i, d) =>
	    (needsIndex || !d) && i ? f + FILENAME_SEP + i : f;

	  const date = (f, i, d) => {
	    return (i > 0 || alwaysIncludeDate) && d ? f + FILENAME_SEP + d : f;
	  };

	  const gzip = (f, i) => (i && compress ? f + ZIP_EXT : f);

	  const parts = keepFileExt
	    ? [date, index, ext, gzip]
	    : [ext, date, index, gzip];

	  return ({ date, index }) => {
	    debug(`_formatFileName: date=${date}, index=${index}`);
	    return parts.reduce(
	      (filename, part) => part(filename, index, date),
	      dirAndName
	    );
	  };
	};
	return fileNameFormatter;
}

var fileNameParser;
var hasRequiredFileNameParser;

function requireFileNameParser () {
	if (hasRequiredFileNameParser) return fileNameParser;
	hasRequiredFileNameParser = 1;
	const debug = requireSrc$1()("streamroller:fileNameParser");
	const ZIP_EXT = ".gz";
	const format = requireLib$4();
	const DEFAULT_FILENAME_SEP = ".";

	fileNameParser = ({ file, keepFileExt, pattern, fileNameSep }) => {
	  let FILENAME_SEP = fileNameSep || DEFAULT_FILENAME_SEP;
	  // All these functions take two arguments: f, the filename, and p, the result placeholder
	  // They return the filename with any matching parts removed.
	  // The "zip" function, for instance, removes the ".gz" part of the filename (if present)
	  const zip = (f, p) => {
	    if (f.endsWith(ZIP_EXT)) {
	      debug("it is gzipped");
	      p.isCompressed = true;
	      return f.slice(0, -1 * ZIP_EXT.length);
	    }
	    return f;
	  };

	  const __NOT_MATCHING__ = "__NOT_MATCHING__";

	  const extAtEnd = f => {
	    if (f.startsWith(file.name) && f.endsWith(file.ext)) {
	      debug("it starts and ends with the right things");
	      return f.slice(file.name.length + 1, -1 * file.ext.length);
	    }
	    return __NOT_MATCHING__;
	  };

	  const extInMiddle = f => {
	    if (f.startsWith(file.base)) {
	      debug("it starts with the right things");
	      return f.slice(file.base.length + 1);
	    }
	    return __NOT_MATCHING__;
	  };

	  const dateAndIndex = (f, p) => {
	    const items = f.split(FILENAME_SEP);
	    let indexStr = items[items.length - 1];
	    debug("items: ", items, ", indexStr: ", indexStr);
	    let dateStr = f;
	    if (indexStr !== undefined && indexStr.match(/^\d+$/)) {
	      dateStr = f.slice(0, -1 * (indexStr.length + 1));
	      debug(`dateStr is ${dateStr}`);
	      if (pattern && !dateStr) {
	        dateStr = indexStr;
	        indexStr = "0";
	      }
	    } else {
	      indexStr = "0";
	    }

	    try {
	      // Two arguments for new Date() are intentional. This will set other date
	      // components to minimal values in the current timezone instead of UTC,
	      // as new Date(0) will do.
	      const date = format.parse(pattern, dateStr, new Date(0, 0));
	      if (format.asString(pattern, date) !== dateStr) return f;
	      p.index = parseInt(indexStr, 10);
	      p.date = dateStr;
	      p.timestamp = date.getTime();
	      return "";
	    } catch (e) {
	      //not a valid date, don't panic.
	      debug(`Problem parsing ${dateStr} as ${pattern}, error was: `, e);
	      return f;
	    }
	  };

	  const index = (f, p) => {
	    if (f.match(/^\d+$/)) {
	      debug("it has an index");
	      p.index = parseInt(f, 10);
	      return "";
	    }
	    return f;
	  };

	  let parts = [
	    zip,
	    keepFileExt ? extAtEnd : extInMiddle,
	    pattern ? dateAndIndex : index
	  ];

	  return filename => {
	    let result = { filename, index: 0, isCompressed: false };
	    // pass the filename through each of the file part parsers
	    let whatsLeftOver = parts.reduce(
	      (remains, part) => part(remains, result),
	      filename
	    );
	    // if there's anything left after parsing, then it wasn't a valid filename
	    return whatsLeftOver ? null : result;
	  };
	};
	return fileNameParser;
}

var moveAndMaybeCompressFile_1;
var hasRequiredMoveAndMaybeCompressFile;

function requireMoveAndMaybeCompressFile () {
	if (hasRequiredMoveAndMaybeCompressFile) return moveAndMaybeCompressFile_1;
	hasRequiredMoveAndMaybeCompressFile = 1;
	const debug = requireSrc$1()('streamroller:moveAndMaybeCompressFile');
	const fs = requireLib$3();
	const zlib = require$$5$1;

	const _parseOption = function(rawOptions){
	  const defaultOptions = {
	    mode: parseInt("0600", 8),
	    compress: false,
	  };
	  const options = Object.assign({}, defaultOptions, rawOptions);
	  debug(`_parseOption: moveAndMaybeCompressFile called with option=${JSON.stringify(options)}`);
	  return options;
	};

	const moveAndMaybeCompressFile = async (
	  sourceFilePath,
	  targetFilePath,
	  options
	) => {
	  options = _parseOption(options);

	  if (sourceFilePath === targetFilePath) {
	    debug(`moveAndMaybeCompressFile: source and target are the same, not doing anything`);
	    return;
	  }

	  if (await fs.pathExists(sourceFilePath)) {
	    debug(
	      `moveAndMaybeCompressFile: moving file from ${sourceFilePath} to ${targetFilePath} ${
	        options.compress ? "with" : "without"
	      } compress`
	    );
	    if (options.compress) {
	      await new Promise((resolve, reject) => {
	        let isCreated = false;
	        // to avoid concurrency, the forked process which can create the file will proceed (using flags wx)
	        const writeStream = fs.createWriteStream(targetFilePath, { mode: options.mode, flags: "wx" })
	          // wait until writable stream is valid before proceeding to read
	          .on("open", () => {
	            isCreated = true;
	            const readStream = fs.createReadStream(sourceFilePath)
	              // wait until readable stream is valid before piping
	              .on("open", () => {
	                readStream.pipe(zlib.createGzip()).pipe(writeStream);
	              })
	              .on("error", (e) => {
	                debug(`moveAndMaybeCompressFile: error reading ${sourceFilePath}`, e);
	                // manually close writable: https://nodejs.org/api/stream.html#readablepipedestination-options
	                writeStream.destroy(e);
	              });
	          })
	          .on("finish", () => {
	            debug(`moveAndMaybeCompressFile: finished compressing ${targetFilePath}, deleting ${sourceFilePath}`);
	            // delete sourceFilePath
	            fs.unlink(sourceFilePath)
	              .then(resolve)
	              .catch((e) => {
	                debug(`moveAndMaybeCompressFile: error deleting ${sourceFilePath}, truncating instead`, e);
	                // fallback to truncate
	                fs.truncate(sourceFilePath)
	                  .then(resolve)
	                  .catch((e) => {
	                    debug(`moveAndMaybeCompressFile: error truncating ${sourceFilePath}`, e);
	                    reject(e);
	                  });
	              });
	          })
	          .on("error", (e) => {
	            if (!isCreated) {
	              debug(`moveAndMaybeCompressFile: error creating ${targetFilePath}`, e);
	              // do not do anything if handled by another forked process
	              reject(e);
	            } else {
	              debug(`moveAndMaybeCompressFile: error writing ${targetFilePath}, deleting`, e);
	              // delete targetFilePath (taking as nothing happened)
	              fs.unlink(targetFilePath)
	                .then(() => { reject(e); })
	                .catch((e) => {
	                  debug(`moveAndMaybeCompressFile: error deleting ${targetFilePath}`, e);
	                  reject(e);
	                });
	            }
	          });
	      }).catch(() => {});
	    } else {
	      debug(`moveAndMaybeCompressFile: renaming ${sourceFilePath} to ${targetFilePath}`);
	      try {
	        await fs.move(sourceFilePath, targetFilePath, { overwrite: true });
	      } catch (e) {
	        debug(`moveAndMaybeCompressFile: error renaming ${sourceFilePath} to ${targetFilePath}`, e);
	        /* istanbul ignore else: no need to do anything if file does not exist */
	        if (e.code !== "ENOENT") {
	          debug(`moveAndMaybeCompressFile: trying copy+truncate instead`);
	          try {
	            await fs.copy(sourceFilePath, targetFilePath, { overwrite: true });
	            await fs.truncate(sourceFilePath);
	          } catch (e) {
	            debug(`moveAndMaybeCompressFile: error copy+truncate`, e);
	          }
	        }
	      }
	    }
	  }
	};

	moveAndMaybeCompressFile_1 = moveAndMaybeCompressFile;
	return moveAndMaybeCompressFile_1;
}

var RollingFileWriteStream_1;
var hasRequiredRollingFileWriteStream;

function requireRollingFileWriteStream () {
	if (hasRequiredRollingFileWriteStream) return RollingFileWriteStream_1;
	hasRequiredRollingFileWriteStream = 1;
	const debug = requireSrc$1()("streamroller:RollingFileWriteStream");
	const fs = requireLib$3();
	const path = require$$1$4;
	const os = require$$1$5;
	const newNow = requireNow();
	const format = requireLib$4();
	const { Writable } = require$$0$6;
	const fileNameFormatter = requireFileNameFormatter();
	const fileNameParser = requireFileNameParser();
	const moveAndMaybeCompressFile = requireMoveAndMaybeCompressFile();

	const deleteFiles = fileNames => {
	  debug(`deleteFiles: files to delete: ${fileNames}`);
	  return Promise.all(fileNames.map(f => fs.unlink(f).catch((e) => {
	    debug(`deleteFiles: error when unlinking ${f}, ignoring. Error was ${e}`);
	  })));
	};

	/**
	 * RollingFileWriteStream is mainly used when writing to a file rolling by date or size.
	 * RollingFileWriteStream inherits from stream.Writable
	 */
	class RollingFileWriteStream extends Writable {
	  /**
	   * Create a RollingFileWriteStream
	   * @constructor
	   * @param {string} filePath - The file path to write.
	   * @param {object} options - The extra options
	   * @param {number} options.numToKeep - The max numbers of files to keep.
	   * @param {number} options.maxSize - The maxSize one file can reach. Unit is Byte.
	   *                                   This should be more than 1024. The default is 0.
	   *                                   If not specified or 0, then no log rolling will happen.
	   * @param {string} options.mode - The mode of the files. The default is '0600'. Refer to stream.writable for more.
	   * @param {string} options.flags - The default is 'a'. Refer to stream.flags for more.
	   * @param {boolean} options.compress - Whether to compress backup files.
	   * @param {boolean} options.keepFileExt - Whether to keep the file extension.
	   * @param {string} options.pattern - The date string pattern in the file name.
	   * @param {boolean} options.alwaysIncludePattern - Whether to add date to the name of the first file.
	   */
	  constructor(filePath, options) {
	    debug(`constructor: creating RollingFileWriteStream. path=${filePath}`);
	    if (typeof filePath !== "string" || filePath.length === 0) {
	      throw new Error(`Invalid filename: ${filePath}`);
	    } else if (filePath.endsWith(path.sep)) {
	      throw new Error(`Filename is a directory: ${filePath}`);
	    } else if (filePath.indexOf(`~${path.sep}`) === 0) {
	      // handle ~ expansion: https://github.com/nodejs/node/issues/684
	      // exclude ~ and ~filename as these can be valid files
	      filePath = filePath.replace("~", os.homedir());
	    }
	    super(options);
	    this.options = this._parseOption(options);
	    this.fileObject = path.parse(filePath);
	    if (this.fileObject.dir === "") {
	      this.fileObject = path.parse(path.join(process.cwd(), filePath));
	    }
	    this.fileFormatter = fileNameFormatter({
	      file: this.fileObject,
	      alwaysIncludeDate: this.options.alwaysIncludePattern,
	      needsIndex: this.options.maxSize < Number.MAX_SAFE_INTEGER,
	      compress: this.options.compress,
	      keepFileExt: this.options.keepFileExt,
	      fileNameSep: this.options.fileNameSep
	    });

	    this.fileNameParser = fileNameParser({
	      file: this.fileObject,
	      keepFileExt: this.options.keepFileExt,
	      pattern: this.options.pattern,
	      fileNameSep: this.options.fileNameSep
	    });

	    this.state = {
	      currentSize: 0
	    };

	    if (this.options.pattern) {
	      this.state.currentDate = format(this.options.pattern, newNow());
	    }

	    this.filename = this.fileFormatter({
	      index: 0,
	      date: this.state.currentDate
	    });
	    if (["a", "a+", "as", "as+"].includes(this.options.flags)) {
	      this._setExistingSizeAndDate();
	    }

	    debug(
	      `constructor: create new file ${this.filename}, state=${JSON.stringify(
	        this.state
	      )}`
	    );
	    this._renewWriteStream();
	  }

	  _setExistingSizeAndDate() {
	    try {
	      const stats = fs.statSync(this.filename);
	      this.state.currentSize = stats.size;
	      if (this.options.pattern) {
	        this.state.currentDate = format(this.options.pattern, stats.mtime);
	      }
	    } catch (e) {
	      //file does not exist, that's fine - move along
	      return;
	    }
	  }

	  _parseOption(rawOptions) {
	    const defaultOptions = {
	      maxSize: 0,
	      numToKeep: Number.MAX_SAFE_INTEGER,
	      encoding: "utf8",
	      mode: parseInt("0600", 8),
	      flags: "a",
	      compress: false,
	      keepFileExt: false,
	      alwaysIncludePattern: false
	    };
	    const options = Object.assign({}, defaultOptions, rawOptions);
	    if (!options.maxSize) {
	      delete options.maxSize;
	    } else if (options.maxSize <= 0) {
	      throw new Error(`options.maxSize (${options.maxSize}) should be > 0`);
	    }
	    // options.numBackups will supercede options.numToKeep
	    if (options.numBackups || options.numBackups === 0) {
	      if (options.numBackups < 0) {
	        throw new Error(`options.numBackups (${options.numBackups}) should be >= 0`);
	      } else if (options.numBackups >= Number.MAX_SAFE_INTEGER) {
	        // to cater for numToKeep (include the hot file) at Number.MAX_SAFE_INTEGER
	        throw new Error(`options.numBackups (${options.numBackups}) should be < Number.MAX_SAFE_INTEGER`);
	      } else {
	        options.numToKeep = options.numBackups + 1;
	      }
	    } else if (options.numToKeep <= 0) {
	      throw new Error(`options.numToKeep (${options.numToKeep}) should be > 0`);
	    }
	    debug(
	      `_parseOption: creating stream with option=${JSON.stringify(options)}`
	    );
	    return options;
	  }

	  _final(callback) {
	    this.currentFileStream.end("", this.options.encoding, callback);
	  }

	  _write(chunk, encoding, callback) {
	    this._shouldRoll().then(() => {
	      debug(
	        `_write: writing chunk. ` +
	          `file=${this.currentFileStream.path} ` +
	          `state=${JSON.stringify(this.state)} ` +
	          `chunk=${chunk}`
	      );
	      this.currentFileStream.write(chunk, encoding, e => {
	        this.state.currentSize += chunk.length;
	        callback(e);
	      });
	    });
	  }

	  async _shouldRoll() {
	    if (this._dateChanged() || this._tooBig()) {
	      debug(
	        `_shouldRoll: rolling because dateChanged? ${this._dateChanged()} or tooBig? ${this._tooBig()}`
	      );
	      await this._roll();
	    }
	  }

	  _dateChanged() {
	    return (
	      this.state.currentDate &&
	      this.state.currentDate !== format(this.options.pattern, newNow())
	    );
	  }

	  _tooBig() {
	    return this.state.currentSize >= this.options.maxSize;
	  }

	  _roll() {
	    debug(`_roll: closing the current stream`);
	    return new Promise((resolve, reject) => {
	      this.currentFileStream.end("", this.options.encoding, () => {
	        this._moveOldFiles()
	          .then(resolve)
	          .catch(reject);
	      });
	    });
	  }

	  async _moveOldFiles() {
	    const files = await this._getExistingFiles();
	    const todaysFiles = this.state.currentDate
	      ? files.filter(f => f.date === this.state.currentDate)
	      : files;
	    for (let i = todaysFiles.length; i >= 0; i--) {
	      debug(`_moveOldFiles: i = ${i}`);
	      const sourceFilePath = this.fileFormatter({
	        date: this.state.currentDate,
	        index: i
	      });
	      const targetFilePath = this.fileFormatter({
	        date: this.state.currentDate,
	        index: i + 1
	      });

	      const moveAndCompressOptions = {
	        compress: this.options.compress && i === 0,
	        mode: this.options.mode
	      };
	      await moveAndMaybeCompressFile(
	        sourceFilePath,
	        targetFilePath,
	        moveAndCompressOptions
	      );
	    }

	    this.state.currentSize = 0;
	    this.state.currentDate = this.state.currentDate
	      ? format(this.options.pattern, newNow())
	      : null;
	    debug(
	      `_moveOldFiles: finished rolling files. state=${JSON.stringify(
	        this.state
	      )}`
	    );
	    this._renewWriteStream();
	    // wait for the file to be open before cleaning up old ones,
	    // otherwise the daysToKeep calculations can be off
	    await new Promise((resolve, reject) => {
	      this.currentFileStream.write("", "utf8", () => {
	        this._clean()
	          .then(resolve)
	          .catch(reject);
	      });
	    });
	  }

	  // Sorted from the oldest to the latest
	  async _getExistingFiles() {
	    const files = await fs.readdir(this.fileObject.dir)
	      .catch( /* istanbul ignore next: will not happen on windows */ () => []);

	    debug(`_getExistingFiles: files=${files}`);
	    const existingFileDetails = files
	      .map(n => this.fileNameParser(n))
	      .filter(n => n);

	    const getKey = n =>
	      (n.timestamp ? n.timestamp : newNow().getTime()) - n.index;
	    existingFileDetails.sort((a, b) => getKey(a) - getKey(b));

	    return existingFileDetails;
	  }

	  _renewWriteStream() {
	    const filePath = this.fileFormatter({
	      date: this.state.currentDate,
	      index: 0
	    });

	    // attempt to create the directory
	    const mkdir = (dir) => {
	      try {
	        return fs.mkdirSync(dir, { recursive: true });
	      }
	      // backward-compatible fs.mkdirSync for nodejs pre-10.12.0 (without recursive option)
	      catch (e) {
	        // recursive creation of parent first
	        if (e.code === "ENOENT") {
	          mkdir(path.dirname(dir));
	          return mkdir(dir);
	        }

	        // throw error for all except EEXIST and EROFS (read-only filesystem)
	        if (e.code !== "EEXIST" && e.code !== "EROFS") {
	          throw e;
	        }

	        // EEXIST: throw if file and not directory
	        // EROFS : throw if directory not found
	        else {
	          try {
	            if (fs.statSync(dir).isDirectory()) {
	              return dir;
	            }
	            throw e;
	          } catch (err) {
	            throw e;
	          }
	        }
	      }
	    };
	    mkdir(this.fileObject.dir);

	    const ops = {
	      flags: this.options.flags,
	      encoding: this.options.encoding,
	      mode: this.options.mode
	    };
	    const renameKey = function(obj, oldKey, newKey) {
	      obj[newKey] = obj[oldKey];
	      delete obj[oldKey];
	      return obj;
	    };
	    // try to throw EISDIR, EROFS, EACCES
	    fs.appendFileSync(filePath, "", renameKey({ ...ops }, "flags", "flag"));
	    this.currentFileStream = fs.createWriteStream(filePath, ops);
	    this.currentFileStream.on("error", e => {
	      this.emit("error", e);
	    });
	  }

	  async _clean() {
	    const existingFileDetails = await this._getExistingFiles();
	    debug(
	      `_clean: numToKeep = ${this.options.numToKeep}, existingFiles = ${existingFileDetails.length}`
	    );
	    debug("_clean: existing files are: ", existingFileDetails);
	    if (this._tooManyFiles(existingFileDetails.length)) {
	      const fileNamesToRemove = existingFileDetails
	        .slice(0, existingFileDetails.length - this.options.numToKeep)
	        .map(f => path.format({ dir: this.fileObject.dir, base: f.filename }));
	      await deleteFiles(fileNamesToRemove);
	    }
	  }

	  _tooManyFiles(numFiles) {
	    return this.options.numToKeep > 0 && numFiles > this.options.numToKeep;
	  }
	}

	RollingFileWriteStream_1 = RollingFileWriteStream;
	return RollingFileWriteStream_1;
}

var RollingFileStream_1;
var hasRequiredRollingFileStream;

function requireRollingFileStream () {
	if (hasRequiredRollingFileStream) return RollingFileStream_1;
	hasRequiredRollingFileStream = 1;
	const RollingFileWriteStream = requireRollingFileWriteStream();

	// just to adapt the previous version
	class RollingFileStream extends RollingFileWriteStream {
	  constructor(filename, size, backups, options) {
	    if (!options) {
	      options = {};
	    }
	    if (size) {
	      options.maxSize = size;
	    }
	    if (!options.numBackups && options.numBackups !== 0) {
	      if (!backups && backups !== 0) {
	        backups = 1;
	      }
	      options.numBackups = backups;
	    }
	    super(filename, options);
	    this.backups = options.numBackups;
	    this.size = this.options.maxSize;
	  }

	  get theStream() {
	    return this.currentFileStream;
	  }

	}

	RollingFileStream_1 = RollingFileStream;
	return RollingFileStream_1;
}

var DateRollingFileStream_1;
var hasRequiredDateRollingFileStream;

function requireDateRollingFileStream () {
	if (hasRequiredDateRollingFileStream) return DateRollingFileStream_1;
	hasRequiredDateRollingFileStream = 1;
	const RollingFileWriteStream = requireRollingFileWriteStream();

	// just to adapt the previous version
	class DateRollingFileStream extends RollingFileWriteStream {
	  constructor(filename, pattern, options) {
	    if (pattern && typeof(pattern) === 'object') {
	      options = pattern;
	      pattern = null;
	    }
	    if (!options) {
	      options = {};
	    }
	    if (!pattern) {
	      pattern = 'yyyy-MM-dd';
	    }
	    options.pattern = pattern;
	    if (!options.numBackups && options.numBackups !== 0) {
	      if (!options.daysToKeep && options.daysToKeep !== 0) {
	        options.daysToKeep = 1;
	      } else {
	        process.emitWarning(
	          "options.daysToKeep is deprecated due to the confusion it causes when used " + 
	          "together with file size rolling. Please use options.numBackups instead.",
	          "DeprecationWarning", "streamroller-DEP0001"
	        );
	      }
	      options.numBackups = options.daysToKeep;
	    } else {
	      options.daysToKeep = options.numBackups;
	    }
	    super(filename, options);
	    this.mode = this.options.mode;
	  }

	  get theStream() {
	    return this.currentFileStream;
	  }

	}

	DateRollingFileStream_1 = DateRollingFileStream;
	return DateRollingFileStream_1;
}

var lib$2;
var hasRequiredLib$2;

function requireLib$2 () {
	if (hasRequiredLib$2) return lib$2;
	hasRequiredLib$2 = 1;
	lib$2 = {
	  RollingFileWriteStream: requireRollingFileWriteStream(),
	  RollingFileStream: requireRollingFileStream(),
	  DateRollingFileStream: requireDateRollingFileStream()
	};
	return lib$2;
}

var hasRequiredFile$2;

function requireFile$2 () {
	if (hasRequiredFile$2) return file$3;
	hasRequiredFile$2 = 1;
	const debug = requireSrc$1()('log4js:file');
	const path = require$$1$4;
	const streams = requireLib$2();
	const os = require$$1$5;

	const eol = os.EOL;

	let mainSighupListenerStarted = false;
	const sighupListeners = new Set();
	function mainSighupHandler() {
	  sighupListeners.forEach((app) => {
	    app.sighupHandler();
	  });
	}

	/**
	 * File Appender writing the logs to a text file. Supports rolling of logs by size.
	 *
	 * @param file the file log messages will be written to
	 * @param layout a function that takes a logEvent and returns a string
	 *   (defaults to basicLayout).
	 * @param logSize - the maximum size (in bytes) for a log file,
	 *   if not provided then logs won't be rotated.
	 * @param numBackups - the number of log files to keep after logSize
	 *   has been reached (default 5)
	 * @param options - options to be passed to the underlying stream
	 * @param timezoneOffset - optional timezone offset in minutes (default system local)
	 */
	function fileAppender(
	  file,
	  layout,
	  logSize,
	  numBackups,
	  options,
	  timezoneOffset
	) {
	  if (typeof file !== 'string' || file.length === 0) {
	    throw new Error(`Invalid filename: ${file}`);
	  } else if (file.endsWith(path.sep)) {
	    throw new Error(`Filename is a directory: ${file}`);
	  } else if (file.indexOf(`~${path.sep}`) === 0) {
	    // handle ~ expansion: https://github.com/nodejs/node/issues/684
	    // exclude ~ and ~filename as these can be valid files
	    file = file.replace('~', os.homedir());
	  }
	  file = path.normalize(file);
	  numBackups = !numBackups && numBackups !== 0 ? 5 : numBackups;

	  debug(
	    'Creating file appender (',
	    file,
	    ', ',
	    logSize,
	    ', ',
	    numBackups,
	    ', ',
	    options,
	    ', ',
	    timezoneOffset,
	    ')'
	  );

	  function openTheStream(filePath, fileSize, numFiles, opt) {
	    const stream = new streams.RollingFileStream(
	      filePath,
	      fileSize,
	      numFiles,
	      opt
	    );
	    stream.on('error', (err) => {
	      // eslint-disable-next-line no-console
	      console.error(
	        'log4js.fileAppender - Writing to file %s, error happened ',
	        filePath,
	        err
	      );
	    });
	    stream.on('drain', () => {
	      process.emit('log4js:pause', false);
	    });
	    return stream;
	  }

	  let writer = openTheStream(file, logSize, numBackups, options);

	  const app = function (loggingEvent) {
	    if (!writer.writable) {
	      return;
	    }
	    if (options.removeColor === true) {
	      // eslint-disable-next-line no-control-regex
	      const regex = /\x1b[[0-9;]*m/g;
	      loggingEvent.data = loggingEvent.data.map((d) => {
	        if (typeof d === 'string') return d.replace(regex, '');
	        return d;
	      });
	    }
	    if (!writer.write(layout(loggingEvent, timezoneOffset) + eol, 'utf8')) {
	      process.emit('log4js:pause', true);
	    }
	  };

	  app.reopen = function () {
	    writer.end(() => {
	      writer = openTheStream(file, logSize, numBackups, options);
	    });
	  };

	  app.sighupHandler = function () {
	    debug('SIGHUP handler called.');
	    app.reopen();
	  };

	  app.shutdown = function (complete) {
	    sighupListeners.delete(app);
	    if (sighupListeners.size === 0 && mainSighupListenerStarted) {
	      process.removeListener('SIGHUP', mainSighupHandler);
	      mainSighupListenerStarted = false;
	    }
	    writer.end('', 'utf-8', complete);
	  };

	  // On SIGHUP, close and reopen all files. This allows this appender to work with
	  // logrotate. Note that if you are using logrotate, you should not set
	  // `logSize`.
	  sighupListeners.add(app);
	  if (!mainSighupListenerStarted) {
	    process.on('SIGHUP', mainSighupHandler);
	    mainSighupListenerStarted = true;
	  }

	  return app;
	}

	function configure(config, layouts) {
	  let layout = layouts.basicLayout;
	  if (config.layout) {
	    layout = layouts.layout(config.layout.type, config.layout);
	  }

	  // security default (instead of relying on streamroller default)
	  config.mode = config.mode || 0o600;

	  return fileAppender(
	    config.filename,
	    layout,
	    config.maxLogSize,
	    config.backups,
	    config,
	    config.timezoneOffset
	  );
	}

	file$3.configure = configure;
	return file$3;
}

var dateFile = {};

var hasRequiredDateFile;

function requireDateFile () {
	if (hasRequiredDateFile) return dateFile;
	hasRequiredDateFile = 1;
	const streams = requireLib$2();
	const os = require$$1$5;

	const eol = os.EOL;

	function openTheStream(filename, pattern, options) {
	  const stream = new streams.DateRollingFileStream(filename, pattern, options);
	  stream.on('error', (err) => {
	    // eslint-disable-next-line no-console
	    console.error(
	      'log4js.dateFileAppender - Writing to file %s, error happened ',
	      filename,
	      err
	    );
	  });
	  stream.on('drain', () => {
	    process.emit('log4js:pause', false);
	  });
	  return stream;
	}

	/**
	 * File appender that rolls files according to a date pattern.
	 * @param filename base filename.
	 * @param pattern the format that will be added to the end of filename when rolling,
	 *          also used to check when to roll files - defaults to '.yyyy-MM-dd'
	 * @param layout layout function for log messages - defaults to basicLayout
	 * @param options - options to be passed to the underlying stream
	 * @param timezoneOffset - optional timezone offset in minutes (default system local)
	 */
	function appender(filename, pattern, layout, options, timezoneOffset) {
	  // the options for file appender use maxLogSize, but the docs say any file appender
	  // options should work for dateFile as well.
	  options.maxSize = options.maxLogSize;

	  const writer = openTheStream(filename, pattern, options);

	  const app = function (logEvent) {
	    if (!writer.writable) {
	      return;
	    }
	    if (!writer.write(layout(logEvent, timezoneOffset) + eol, 'utf8')) {
	      process.emit('log4js:pause', true);
	    }
	  };

	  app.shutdown = function (complete) {
	    writer.end('', 'utf-8', complete);
	  };

	  return app;
	}

	function configure(config, layouts) {
	  let layout = layouts.basicLayout;
	  if (config.layout) {
	    layout = layouts.layout(config.layout.type, config.layout);
	  }

	  if (!config.alwaysIncludePattern) {
	    config.alwaysIncludePattern = false;
	  }

	  // security default (instead of relying on streamroller default)
	  config.mode = config.mode || 0o600;

	  return appender(
	    config.filename,
	    config.pattern,
	    layout,
	    config,
	    config.timezoneOffset
	  );
	}

	dateFile.configure = configure;
	return dateFile;
}

var fileSync = {};

var hasRequiredFileSync;

function requireFileSync () {
	if (hasRequiredFileSync) return fileSync;
	hasRequiredFileSync = 1;
	const debug = requireSrc$1()('log4js:fileSync');
	const path = require$$1$4;
	const fs = require$$0$8;
	const os = require$$1$5;

	const eol = os.EOL;

	function touchFile(file, options) {
	  // attempt to create the directory
	  const mkdir = (dir) => {
	    try {
	      return fs.mkdirSync(dir, { recursive: true });
	    } catch (e) {
	      // backward-compatible fs.mkdirSync for nodejs pre-10.12.0 (without recursive option)
	      // recursive creation of parent first
	      if (e.code === 'ENOENT') {
	        mkdir(path.dirname(dir));
	        return mkdir(dir);
	      }

	      // throw error for all except EEXIST and EROFS (read-only filesystem)
	      if (e.code !== 'EEXIST' && e.code !== 'EROFS') {
	        throw e;
	      }

	      // EEXIST: throw if file and not directory
	      // EROFS : throw if directory not found
	      else {
	        try {
	          if (fs.statSync(dir).isDirectory()) {
	            return dir;
	          }
	          throw e;
	        } catch (err) {
	          throw e;
	        }
	      }
	    }
	  };
	  mkdir(path.dirname(file));

	  // try to throw EISDIR, EROFS, EACCES
	  fs.appendFileSync(file, '', { mode: options.mode, flag: options.flags });
	}

	class RollingFileSync {
	  constructor(filename, maxLogSize, backups, options) {
	    debug('In RollingFileStream');

	    if (maxLogSize < 0) {
	      throw new Error(`maxLogSize (${maxLogSize}) should be > 0`);
	    }

	    this.filename = filename;
	    this.size = maxLogSize;
	    this.backups = backups;
	    this.options = options;
	    this.currentSize = 0;

	    function currentFileSize(file) {
	      let fileSize = 0;

	      try {
	        fileSize = fs.statSync(file).size;
	      } catch (e) {
	        // file does not exist
	        touchFile(file, options);
	      }
	      return fileSize;
	    }

	    this.currentSize = currentFileSize(this.filename);
	  }

	  shouldRoll() {
	    debug(
	      'should roll with current size %d, and max size %d',
	      this.currentSize,
	      this.size
	    );
	    return this.currentSize >= this.size;
	  }

	  roll(filename) {
	    const that = this;
	    const nameMatcher = new RegExp(`^${path.basename(filename)}`);

	    function justTheseFiles(item) {
	      return nameMatcher.test(item);
	    }

	    function index(filename_) {
	      return (
	        parseInt(filename_.slice(`${path.basename(filename)}.`.length), 10) || 0
	      );
	    }

	    function byIndex(a, b) {
	      return index(a) - index(b);
	    }

	    function increaseFileIndex(fileToRename) {
	      const idx = index(fileToRename);
	      debug(`Index of ${fileToRename} is ${idx}`);
	      if (that.backups === 0) {
	        fs.truncateSync(filename, 0);
	      } else if (idx < that.backups) {
	        // on windows, you can get a EEXIST error if you rename a file to an existing file
	        // so, we'll try to delete the file we're renaming to first
	        try {
	          fs.unlinkSync(`${filename}.${idx + 1}`);
	        } catch (e) {
	          // ignore err: if we could not delete, it's most likely that it doesn't exist
	        }

	        debug(`Renaming ${fileToRename} -> ${filename}.${idx + 1}`);
	        fs.renameSync(
	          path.join(path.dirname(filename), fileToRename),
	          `${filename}.${idx + 1}`
	        );
	      }
	    }

	    function renameTheFiles() {
	      // roll the backups (rename file.n to file.n+1, where n <= numBackups)
	      debug('Renaming the old files');

	      const files = fs.readdirSync(path.dirname(filename));
	      files
	        .filter(justTheseFiles)
	        .sort(byIndex)
	        .reverse()
	        .forEach(increaseFileIndex);
	    }

	    debug('Rolling, rolling, rolling');
	    renameTheFiles();
	  }

	  // eslint-disable-next-line no-unused-vars
	  write(chunk, encoding) {
	    const that = this;

	    function writeTheChunk() {
	      debug('writing the chunk to the file');
	      that.currentSize += chunk.length;
	      fs.appendFileSync(that.filename, chunk);
	    }

	    debug('in write');

	    if (this.shouldRoll()) {
	      this.currentSize = 0;
	      this.roll(this.filename);
	    }

	    writeTheChunk();
	  }
	}

	/**
	 * File Appender writing the logs to a text file. Supports rolling of logs by size.
	 *
	 * @param file the file log messages will be written to
	 * @param layout a function that takes a logevent and returns a string
	 *   (defaults to basicLayout).
	 * @param logSize - the maximum size (in bytes) for a log file,
	 *   if not provided then logs won't be rotated.
	 * @param numBackups - the number of log files to keep after logSize
	 *   has been reached (default 5)
	 * @param options - options to be passed to the underlying stream
	 * @param timezoneOffset - optional timezone offset in minutes (default system local)
	 */
	function fileAppender(
	  file,
	  layout,
	  logSize,
	  numBackups,
	  options,
	  timezoneOffset
	) {
	  if (typeof file !== 'string' || file.length === 0) {
	    throw new Error(`Invalid filename: ${file}`);
	  } else if (file.endsWith(path.sep)) {
	    throw new Error(`Filename is a directory: ${file}`);
	  } else if (file.indexOf(`~${path.sep}`) === 0) {
	    // handle ~ expansion: https://github.com/nodejs/node/issues/684
	    // exclude ~ and ~filename as these can be valid files
	    file = file.replace('~', os.homedir());
	  }
	  file = path.normalize(file);
	  numBackups = !numBackups && numBackups !== 0 ? 5 : numBackups;

	  debug(
	    'Creating fileSync appender (',
	    file,
	    ', ',
	    logSize,
	    ', ',
	    numBackups,
	    ', ',
	    options,
	    ', ',
	    timezoneOffset,
	    ')'
	  );

	  function openTheStream(filePath, fileSize, numFiles) {
	    let stream;

	    if (fileSize) {
	      stream = new RollingFileSync(filePath, fileSize, numFiles, options);
	    } else {
	      stream = ((f) => {
	        // touch the file to apply flags (like w to truncate the file)
	        touchFile(f, options);

	        return {
	          write(data) {
	            fs.appendFileSync(f, data);
	          },
	        };
	      })(filePath);
	    }

	    return stream;
	  }

	  const logFile = openTheStream(file, logSize, numBackups);

	  return (loggingEvent) => {
	    logFile.write(layout(loggingEvent, timezoneOffset) + eol);
	  };
	}

	function configure(config, layouts) {
	  let layout = layouts.basicLayout;
	  if (config.layout) {
	    layout = layouts.layout(config.layout.type, config.layout);
	  }

	  const options = {
	    flags: config.flags || 'a',
	    encoding: config.encoding || 'utf8',
	    mode: config.mode || 0o600,
	  };

	  return fileAppender(
	    config.filename,
	    layout,
	    config.maxLogSize,
	    config.backups,
	    options,
	    config.timezoneOffset
	  );
	}

	fileSync.configure = configure;
	return fileSync;
}

var tcp = {};

var hasRequiredTcp;

function requireTcp () {
	if (hasRequiredTcp) return tcp;
	hasRequiredTcp = 1;
	const debug = requireSrc$1()('log4js:tcp');
	const net = require$$0$3;

	function appender(config, layout) {
	  let canWrite = false;
	  const buffer = [];
	  let socket;
	  let shutdownAttempts = 3;
	  let endMsg = '__LOG4JS__';

	  function write(loggingEvent) {
	    debug('Writing log event to socket');
	    canWrite = socket.write(`${layout(loggingEvent)}${endMsg}`, 'utf8');
	  }

	  function emptyBuffer() {
	    let evt;
	    debug('emptying buffer');
	    while ((evt = buffer.shift())) {
	      write(evt);
	    }
	  }

	  function createSocket() {
	    debug(
	      `appender creating socket to ${config.host || 'localhost'}:${
	        config.port || 5000
	      }`
	    );
	    endMsg = `${config.endMsg || '__LOG4JS__'}`;
	    socket = net.createConnection(
	      config.port || 5000,
	      config.host || 'localhost'
	    );
	    socket.on('connect', () => {
	      debug('socket connected');
	      emptyBuffer();
	      canWrite = true;
	    });
	    socket.on('drain', () => {
	      debug('drain event received, emptying buffer');
	      canWrite = true;
	      emptyBuffer();
	    });
	    socket.on('timeout', socket.end.bind(socket));
	    socket.on('error', (e) => {
	      debug('connection error', e);
	      canWrite = false;
	      emptyBuffer();
	    });
	    socket.on('close', createSocket);
	  }

	  createSocket();

	  function log(loggingEvent) {
	    if (canWrite) {
	      write(loggingEvent);
	    } else {
	      debug('buffering log event because it cannot write at the moment');
	      buffer.push(loggingEvent);
	    }
	  }

	  log.shutdown = function (cb) {
	    debug('shutdown called');
	    if (buffer.length && shutdownAttempts) {
	      debug('buffer has items, waiting 100ms to empty');
	      shutdownAttempts -= 1;
	      setTimeout(() => {
	        log.shutdown(cb);
	      }, 100);
	    } else {
	      socket.removeAllListeners('close');
	      socket.end(cb);
	    }
	  };
	  return log;
	}

	function configure(config, layouts) {
	  debug(`configure with config = ${config}`);
	  let layout = function (loggingEvent) {
	    return loggingEvent.serialise();
	  };
	  if (config.layout) {
	    layout = layouts.layout(config.layout.type, config.layout);
	  }
	  return appender(config, layout);
	}

	tcp.configure = configure;
	return tcp;
}

var hasRequiredAppenders;

function requireAppenders () {
	if (hasRequiredAppenders) return appenders.exports;
	hasRequiredAppenders = 1;
	const path = require$$1$4;
	const debug = requireSrc$1()('log4js:appenders');
	const configuration = requireConfiguration();
	const clustering = requireClustering();
	const levels = requireLevels();
	const layouts = requireLayouts();
	const adapters = requireAdapters();

	// pre-load the core appenders so that webpack can find them
	const coreAppenders = new Map();
	coreAppenders.set('console', requireConsole());
	coreAppenders.set('stdout', requireStdout());
	coreAppenders.set('stderr', requireStderr());
	coreAppenders.set('logLevelFilter', requireLogLevelFilter());
	coreAppenders.set('categoryFilter', requireCategoryFilter());
	coreAppenders.set('noLogFilter', requireNoLogFilter());
	coreAppenders.set('file', requireFile$2());
	coreAppenders.set('dateFile', requireDateFile());
	coreAppenders.set('fileSync', requireFileSync());
	coreAppenders.set('tcp', requireTcp());

	const appenders$1 = new Map();

	const tryLoading = (modulePath, config) => {
	  let resolvedPath;
	  try {
	    const modulePathCJS = `${modulePath}.cjs`;
	    resolvedPath = require.resolve(modulePathCJS);
	    debug('Loading module from ', modulePathCJS);
	  } catch (e) {
	    resolvedPath = modulePath;
	    debug('Loading module from ', modulePath);
	  }
	  try {
	    // eslint-disable-next-line global-require, import/no-dynamic-require
	    return commonjsRequire(resolvedPath);
	  } catch (e) {
	    // if the module was found, and we still got an error, then raise it
	    configuration.throwExceptionIf(
	      config,
	      e.code !== 'MODULE_NOT_FOUND',
	      `appender "${modulePath}" could not be loaded (error was: ${e})`
	    );
	    return undefined;
	  }
	};

	const loadAppenderModule = (type, config) =>
	  coreAppenders.get(type) ||
	  tryLoading(`./${type}`, config) ||
	  tryLoading(type, config) ||
	  (require.main &&
	    require.main.filename &&
	    tryLoading(path.join(path.dirname(require.main.filename), type), config)) ||
	  tryLoading(path.join(process.cwd(), type), config);

	const appendersLoading = new Set();

	const getAppender = (name, config) => {
	  if (appenders$1.has(name)) return appenders$1.get(name);
	  if (!config.appenders[name]) return false;
	  if (appendersLoading.has(name))
	    throw new Error(`Dependency loop detected for appender ${name}.`);
	  appendersLoading.add(name);

	  debug(`Creating appender ${name}`);
	  // eslint-disable-next-line no-use-before-define
	  const appender = createAppender(name, config);
	  appendersLoading.delete(name);
	  appenders$1.set(name, appender);
	  return appender;
	};

	const createAppender = (name, config) => {
	  const appenderConfig = config.appenders[name];
	  const appenderModule = appenderConfig.type.configure
	    ? appenderConfig.type
	    : loadAppenderModule(appenderConfig.type, config);
	  configuration.throwExceptionIf(
	    config,
	    configuration.not(appenderModule),
	    `appender "${name}" is not valid (type "${appenderConfig.type}" could not be found)`
	  );
	  if (appenderModule.appender) {
	    process.emitWarning(
	      `Appender ${appenderConfig.type} exports an appender function.`,
	      'DeprecationWarning',
	      'log4js-node-DEP0001'
	    );
	    debug(
	      '[log4js-node-DEP0001]',
	      `DEPRECATION: Appender ${appenderConfig.type} exports an appender function.`
	    );
	  }
	  if (appenderModule.shutdown) {
	    process.emitWarning(
	      `Appender ${appenderConfig.type} exports a shutdown function.`,
	      'DeprecationWarning',
	      'log4js-node-DEP0002'
	    );
	    debug(
	      '[log4js-node-DEP0002]',
	      `DEPRECATION: Appender ${appenderConfig.type} exports a shutdown function.`
	    );
	  }

	  debug(`${name}: clustering.isMaster ? ${clustering.isMaster()}`);
	  debug(
	    // eslint-disable-next-line global-require
	    `${name}: appenderModule is ${require$$1$2.inspect(appenderModule)}`
	  );
	  return clustering.onlyOnMaster(
	    () => {
	      debug(
	        `calling appenderModule.configure for ${name} / ${appenderConfig.type}`
	      );
	      return appenderModule.configure(
	        adapters.modifyConfig(appenderConfig),
	        layouts,
	        (appender) => getAppender(appender, config),
	        levels
	      );
	    },
	    /* istanbul ignore next: fn never gets called by non-master yet needed to pass config validation */ () => {}
	  );
	};

	const setup = (config) => {
	  appenders$1.clear();
	  appendersLoading.clear();
	  if (!config) {
	    return;
	  }

	  const usedAppenders = [];
	  Object.values(config.categories).forEach((category) => {
	    usedAppenders.push(...category.appenders);
	  });
	  Object.keys(config.appenders).forEach((name) => {
	    // dodgy hard-coding of special case for tcp-server and multiprocess which may not have
	    // any categories associated with it, but needs to be started up anyway
	    if (
	      usedAppenders.includes(name) ||
	      config.appenders[name].type === 'tcp-server' ||
	      config.appenders[name].type === 'multiprocess'
	    ) {
	      getAppender(name, config);
	    }
	  });
	};

	const init = () => {
	  setup();
	};
	init();

	configuration.addListener((config) => {
	  configuration.throwExceptionIf(
	    config,
	    configuration.not(configuration.anObject(config.appenders)),
	    'must have a property "appenders" of type object.'
	  );
	  const appenderNames = Object.keys(config.appenders);
	  configuration.throwExceptionIf(
	    config,
	    configuration.not(appenderNames.length),
	    'must define at least one appender.'
	  );

	  appenderNames.forEach((name) => {
	    configuration.throwExceptionIf(
	      config,
	      configuration.not(config.appenders[name].type),
	      `appender "${name}" is not valid (must be an object with property "type")`
	    );
	  });
	});

	configuration.addListener(setup);

	appenders.exports = appenders$1;
	appenders.exports.init = init;
	return appenders.exports;
}

var categories = {exports: {}};

var hasRequiredCategories;

function requireCategories () {
	if (hasRequiredCategories) return categories.exports;
	hasRequiredCategories = 1;
	(function (module) {
		const debug = requireSrc$1()('log4js:categories');
		const configuration = requireConfiguration();
		const levels = requireLevels();
		const appenders = requireAppenders();

		const categories = new Map();

		/**
		 * Add inherited config to this category.  That includes extra appenders from parent,
		 * and level, if none is set on this category.
		 * This is recursive, so each parent also gets loaded with inherited appenders.
		 * Inheritance is blocked if a category has inherit=false
		 * @param  {*} config
		 * @param  {*} category the child category
		 * @param  {string} categoryName dotted path to category
		 * @return {void}
		 */
		function inheritFromParent(config, category, categoryName) {
		  if (category.inherit === false) return;
		  const lastDotIndex = categoryName.lastIndexOf('.');
		  if (lastDotIndex < 0) return; // category is not a child
		  const parentCategoryName = categoryName.slice(0, lastDotIndex);
		  let parentCategory = config.categories[parentCategoryName];

		  if (!parentCategory) {
		    // parent is missing, so implicitly create it, so that it can inherit from its parents
		    parentCategory = { inherit: true, appenders: [] };
		  }

		  // make sure parent has had its inheritance taken care of before pulling its properties to this child
		  inheritFromParent(config, parentCategory, parentCategoryName);

		  // if the parent is not in the config (because we just created it above),
		  // and it inherited a valid configuration, add it to config.categories
		  if (
		    !config.categories[parentCategoryName] &&
		    parentCategory.appenders &&
		    parentCategory.appenders.length &&
		    parentCategory.level
		  ) {
		    config.categories[parentCategoryName] = parentCategory;
		  }

		  category.appenders = category.appenders || [];
		  category.level = category.level || parentCategory.level;

		  // merge in appenders from parent (parent is already holding its inherited appenders)
		  parentCategory.appenders.forEach((ap) => {
		    if (!category.appenders.includes(ap)) {
		      category.appenders.push(ap);
		    }
		  });
		  category.parent = parentCategory;
		}

		/**
		 * Walk all categories in the config, and pull down any configuration from parent to child.
		 * This includes inherited appenders, and level, where level is not set.
		 * Inheritance is skipped where a category has inherit=false.
		 * @param  {*} config
		 */
		function addCategoryInheritance(config) {
		  if (!config.categories) return;
		  const categoryNames = Object.keys(config.categories);
		  categoryNames.forEach((name) => {
		    const category = config.categories[name];
		    // add inherited appenders and level to this category
		    inheritFromParent(config, category, name);
		  });
		}

		configuration.addPreProcessingListener((config) =>
		  addCategoryInheritance(config)
		);

		configuration.addListener((config) => {
		  configuration.throwExceptionIf(
		    config,
		    configuration.not(configuration.anObject(config.categories)),
		    'must have a property "categories" of type object.'
		  );

		  const categoryNames = Object.keys(config.categories);
		  configuration.throwExceptionIf(
		    config,
		    configuration.not(categoryNames.length),
		    'must define at least one category.'
		  );

		  categoryNames.forEach((name) => {
		    const category = config.categories[name];
		    configuration.throwExceptionIf(
		      config,
		      [
		        configuration.not(category.appenders),
		        configuration.not(category.level),
		      ],
		      `category "${name}" is not valid (must be an object with properties "appenders" and "level")`
		    );

		    configuration.throwExceptionIf(
		      config,
		      configuration.not(Array.isArray(category.appenders)),
		      `category "${name}" is not valid (appenders must be an array of appender names)`
		    );

		    configuration.throwExceptionIf(
		      config,
		      configuration.not(category.appenders.length),
		      `category "${name}" is not valid (appenders must contain at least one appender name)`
		    );

		    if (Object.prototype.hasOwnProperty.call(category, 'enableCallStack')) {
		      configuration.throwExceptionIf(
		        config,
		        typeof category.enableCallStack !== 'boolean',
		        `category "${name}" is not valid (enableCallStack must be boolean type)`
		      );
		    }

		    category.appenders.forEach((appender) => {
		      configuration.throwExceptionIf(
		        config,
		        configuration.not(appenders.get(appender)),
		        `category "${name}" is not valid (appender "${appender}" is not defined)`
		      );
		    });

		    configuration.throwExceptionIf(
		      config,
		      configuration.not(levels.getLevel(category.level)),
		      `category "${name}" is not valid (level "${category.level}" not recognised;` +
		        ` valid levels are ${levels.levels.join(', ')})`
		    );
		  });

		  configuration.throwExceptionIf(
		    config,
		    configuration.not(config.categories.default),
		    'must define a "default" category.'
		  );
		});

		const setup = (config) => {
		  categories.clear();
		  if (!config) {
		    return;
		  }

		  const categoryNames = Object.keys(config.categories);
		  categoryNames.forEach((name) => {
		    const category = config.categories[name];
		    const categoryAppenders = [];
		    category.appenders.forEach((appender) => {
		      categoryAppenders.push(appenders.get(appender));
		      debug(`Creating category ${name}`);
		      categories.set(name, {
		        appenders: categoryAppenders,
		        level: levels.getLevel(category.level),
		        enableCallStack: category.enableCallStack || false,
		      });
		    });
		  });
		};

		const init = () => {
		  setup();
		};
		init();

		configuration.addListener(setup);

		const configForCategory = (category) => {
		  debug(`configForCategory: searching for config for ${category}`);
		  if (categories.has(category)) {
		    debug(`configForCategory: ${category} exists in config, returning it`);
		    return categories.get(category);
		  }

		  let sourceCategoryConfig;
		  if (category.indexOf('.') > 0) {
		    debug(`configForCategory: ${category} has hierarchy, cloning from parents`);
		    sourceCategoryConfig = {
		      ...configForCategory(category.slice(0, category.lastIndexOf('.'))),
		    };
		  } else {
		    if (!categories.has('default')) {
		      setup({ categories: { default: { appenders: ['out'], level: 'OFF' } } });
		    }
		    debug('configForCategory: cloning default category');
		    sourceCategoryConfig = { ...categories.get('default') };
		  }
		  categories.set(category, sourceCategoryConfig);
		  return sourceCategoryConfig;
		};

		const appendersForCategory = (category) =>
		  configForCategory(category).appenders;

		const getLevelForCategory = (category) => configForCategory(category).level;
		const setLevelForCategory = (category, level) => {
		  configForCategory(category).level = level;
		};

		const getEnableCallStackForCategory = (category) =>
		  configForCategory(category).enableCallStack === true;
		const setEnableCallStackForCategory = (category, useCallStack) => {
		  configForCategory(category).enableCallStack = useCallStack;
		};

		module.exports = categories;
		module.exports = Object.assign(module.exports, {
		  appendersForCategory,
		  getLevelForCategory,
		  setLevelForCategory,
		  getEnableCallStackForCategory,
		  setEnableCallStackForCategory,
		  init,
		}); 
	} (categories));
	return categories.exports;
}

/* eslint no-underscore-dangle: ["error", { "allow": ["_log"] }] */

var logger;
var hasRequiredLogger$1;

function requireLogger$1 () {
	if (hasRequiredLogger$1) return logger;
	hasRequiredLogger$1 = 1;
	const debug = requireSrc$1()('log4js:logger');
	const LoggingEvent = requireLoggingEvent();
	const levels = requireLevels();
	const clustering = requireClustering();
	const categories = requireCategories();
	const configuration = requireConfiguration();

	const stackReg = /^(?:\s*)at (?:(.+) \()?(?:([^(]+?):(\d+):(\d+))\)?$/;
	/**
	 * The top entry is the Error
	 */
	const baseCallStackSkip = 1;
	/**
	 * The _log function is 3 levels deep, we need to skip those to make it to the callSite
	 */
	const defaultErrorCallStackSkip = 3;

	/**
	 *
	 * @param {Error} data
	 * @param {number} skipIdx
	 * @returns {import('../types/log4js').CallStack | null}
	 */
	function defaultParseCallStack(
	  data,
	  skipIdx = defaultErrorCallStackSkip + baseCallStackSkip
	) {
	  try {
	    const stacklines = data.stack.split('\n').slice(skipIdx);
	    if (!stacklines.length) {
	      // There's no stack in this stack
	      // Should we try a previous index if skipIdx was set?
	      return null;
	    }
	    const lineMatch = stackReg.exec(stacklines[0]);
	    /* istanbul ignore else: failsafe */
	    if (lineMatch && lineMatch.length === 5) {
	      // extract class, function and alias names
	      let className = '';
	      let functionName = '';
	      let functionAlias = '';
	      if (lineMatch[1] && lineMatch[1] !== '') {
	        // WARN: this will unset alias if alias is not present.
	        [functionName, functionAlias] = lineMatch[1]
	          .replace(/[[\]]/g, '')
	          .split(' as ');
	        functionAlias = functionAlias || '';

	        if (functionName.includes('.'))
	          [className, functionName] = functionName.split('.');
	      }

	      return {
	        fileName: lineMatch[2],
	        lineNumber: parseInt(lineMatch[3], 10),
	        columnNumber: parseInt(lineMatch[4], 10),
	        callStack: stacklines.join('\n'),
	        className,
	        functionName,
	        functionAlias,
	        callerName: lineMatch[1] || '',
	      };
	      // eslint-disable-next-line no-else-return
	    } else {
	      // will never get here unless nodejs has changes to Error
	      console.error('log4js.logger - defaultParseCallStack error'); // eslint-disable-line no-console
	    }
	  } catch (err) {
	    // will never get error unless nodejs has breaking changes to Error
	    console.error('log4js.logger - defaultParseCallStack error', err); // eslint-disable-line no-console
	  }
	  return null;
	}

	/**
	 * Logger to log messages.
	 * use {@see log4js#getLogger(String)} to get an instance.
	 *
	 * @name Logger
	 * @namespace Log4js
	 * @param name name of category to log to
	 * @param level - the loglevel for the category
	 * @param dispatch - the function which will receive the logevents
	 *
	 * @author Stephan Strittmatter
	 */
	class Logger {
	  constructor(name) {
	    if (!name) {
	      throw new Error('No category provided.');
	    }
	    this.category = name;
	    this.context = {};
	    /** @private */
	    this.callStackSkipIndex = 0;
	    /** @private */
	    this.parseCallStack = defaultParseCallStack;
	    debug(`Logger created (${this.category}, ${this.level})`);
	  }

	  get level() {
	    return levels.getLevel(
	      categories.getLevelForCategory(this.category),
	      levels.OFF
	    );
	  }

	  set level(level) {
	    categories.setLevelForCategory(
	      this.category,
	      levels.getLevel(level, this.level)
	    );
	  }

	  get useCallStack() {
	    return categories.getEnableCallStackForCategory(this.category);
	  }

	  set useCallStack(bool) {
	    categories.setEnableCallStackForCategory(this.category, bool === true);
	  }

	  get callStackLinesToSkip() {
	    return this.callStackSkipIndex;
	  }

	  set callStackLinesToSkip(number) {
	    if (typeof number !== 'number') {
	      throw new TypeError('Must be a number');
	    }
	    if (number < 0) {
	      throw new RangeError('Must be >= 0');
	    }
	    this.callStackSkipIndex = number;
	  }

	  log(level, ...args) {
	    const logLevel = levels.getLevel(level);
	    if (!logLevel) {
	      if (configuration.validIdentifier(level) && args.length > 0) {
	        // logLevel not found but of valid signature, WARN before fallback to INFO
	        this.log(
	          levels.WARN,
	          'log4js:logger.log: valid log-level not found as first parameter given:',
	          level
	        );
	        this.log(levels.INFO, `[${level}]`, ...args);
	      } else {
	        // apart from fallback, allow .log(...args) to be synonym with .log("INFO", ...args)
	        this.log(levels.INFO, level, ...args);
	      }
	    } else if (this.isLevelEnabled(logLevel)) {
	      this._log(logLevel, args);
	    }
	  }

	  isLevelEnabled(otherLevel) {
	    return this.level.isLessThanOrEqualTo(otherLevel);
	  }

	  _log(level, data) {
	    debug(`sending log data (${level}) to appenders`);
	    const error = data.find((item) => item instanceof Error);
	    let callStack;
	    if (this.useCallStack) {
	      try {
	        if (error) {
	          callStack = this.parseCallStack(
	            error,
	            this.callStackSkipIndex + baseCallStackSkip
	          );
	        }
	      } catch (_err) {
	        // Ignore Error and use the original method of creating a new Error.
	      }
	      callStack =
	        callStack ||
	        this.parseCallStack(
	          new Error(),
	          this.callStackSkipIndex +
	            defaultErrorCallStackSkip +
	            baseCallStackSkip
	        );
	    }
	    const loggingEvent = new LoggingEvent(
	      this.category,
	      level,
	      data,
	      this.context,
	      callStack,
	      error
	    );
	    clustering.send(loggingEvent);
	  }

	  addContext(key, value) {
	    this.context[key] = value;
	  }

	  removeContext(key) {
	    delete this.context[key];
	  }

	  clearContext() {
	    this.context = {};
	  }

	  setParseCallStackFunction(parseFunction) {
	    if (typeof parseFunction === 'function') {
	      this.parseCallStack = parseFunction;
	    } else if (typeof parseFunction === 'undefined') {
	      this.parseCallStack = defaultParseCallStack;
	    } else {
	      throw new TypeError('Invalid type passed to setParseCallStackFunction');
	    }
	  }
	}

	function addLevelMethods(target) {
	  const level = levels.getLevel(target);

	  const levelStrLower = level.toString().toLowerCase();
	  const levelMethod = levelStrLower.replace(/_([a-z])/g, (g) =>
	    g[1].toUpperCase()
	  );
	  const isLevelMethod = levelMethod[0].toUpperCase() + levelMethod.slice(1);

	  Logger.prototype[`is${isLevelMethod}Enabled`] = function () {
	    return this.isLevelEnabled(level);
	  };

	  Logger.prototype[levelMethod] = function (...args) {
	    this.log(level, ...args);
	  };
	}

	levels.levels.forEach(addLevelMethods);

	configuration.addListener(() => {
	  levels.levels.forEach(addLevelMethods);
	});

	logger = Logger;
	return logger;
}

/* eslint no-underscore-dangle: ["error", { "allow": ["__statusCode", "_remoteAddress", "__headers", "_logging"] }] */

var connectLogger;
var hasRequiredConnectLogger;

function requireConnectLogger () {
	if (hasRequiredConnectLogger) return connectLogger;
	hasRequiredConnectLogger = 1;
	const levels = requireLevels();

	const DEFAULT_FORMAT =
	  ':remote-addr - -' +
	  ' ":method :url HTTP/:http-version"' +
	  ' :status :content-length ":referrer"' +
	  ' ":user-agent"';

	/**
	 * Return request url path,
	 * adding this function prevents the Cyclomatic Complexity,
	 * for the assemble_tokens function at low, to pass the tests.
	 *
	 * @param  {IncomingMessage} req
	 * @return {string}
	 * @api private
	 */
	function getUrl(req) {
	  return req.originalUrl || req.url;
	}

	/**
	 * Adds custom {token, replacement} objects to defaults,
	 * overwriting the defaults if any tokens clash
	 *
	 * @param  {IncomingMessage} req
	 * @param  {ServerResponse} res
	 * @param  {Array} customTokens
	 *    [{ token: string-or-regexp, replacement: string-or-replace-function }]
	 * @return {Array}
	 */
	function assembleTokens(req, res, customTokens) {
	  const arrayUniqueTokens = (array) => {
	    const a = array.concat();
	    for (let i = 0; i < a.length; ++i) {
	      for (let j = i + 1; j < a.length; ++j) {
	        // not === because token can be regexp object
	        // eslint-disable-next-line eqeqeq
	        if (a[i].token == a[j].token) {
	          a.splice(j--, 1); // eslint-disable-line no-plusplus
	        }
	      }
	    }
	    return a;
	  };

	  const defaultTokens = [];
	  defaultTokens.push({ token: ':url', replacement: getUrl(req) });
	  defaultTokens.push({ token: ':protocol', replacement: req.protocol });
	  defaultTokens.push({ token: ':hostname', replacement: req.hostname });
	  defaultTokens.push({ token: ':method', replacement: req.method });
	  defaultTokens.push({
	    token: ':status',
	    replacement: res.__statusCode || res.statusCode,
	  });
	  defaultTokens.push({
	    token: ':response-time',
	    replacement: res.responseTime,
	  });
	  defaultTokens.push({ token: ':date', replacement: new Date().toUTCString() });
	  defaultTokens.push({
	    token: ':referrer',
	    replacement: req.headers.referer || req.headers.referrer || '',
	  });
	  defaultTokens.push({
	    token: ':http-version',
	    replacement: `${req.httpVersionMajor}.${req.httpVersionMinor}`,
	  });
	  defaultTokens.push({
	    token: ':remote-addr',
	    replacement:
	      req.headers['x-forwarded-for'] ||
	      req.ip ||
	      req._remoteAddress ||
	      (req.socket &&
	        (req.socket.remoteAddress ||
	          (req.socket.socket && req.socket.socket.remoteAddress))),
	  });
	  defaultTokens.push({
	    token: ':user-agent',
	    replacement: req.headers['user-agent'],
	  });
	  defaultTokens.push({
	    token: ':content-length',
	    replacement:
	      res.getHeader('content-length') ||
	      (res.__headers && res.__headers['Content-Length']) ||
	      '-',
	  });
	  defaultTokens.push({
	    token: /:req\[([^\]]+)]/g,
	    replacement(_, field) {
	      return req.headers[field.toLowerCase()];
	    },
	  });
	  defaultTokens.push({
	    token: /:res\[([^\]]+)]/g,
	    replacement(_, field) {
	      return (
	        res.getHeader(field.toLowerCase()) ||
	        (res.__headers && res.__headers[field])
	      );
	    },
	  });

	  return arrayUniqueTokens(customTokens.concat(defaultTokens));
	}

	/**
	 * Return formatted log line.
	 *
	 * @param  {string} str
	 * @param {Array} tokens
	 * @return {string}
	 * @api private
	 */
	function format(str, tokens) {
	  for (let i = 0; i < tokens.length; i++) {
	    str = str.replace(tokens[i].token, tokens[i].replacement);
	  }
	  return str;
	}

	/**
	 * Return RegExp Object about nolog
	 *
	 * @param  {(string|Array)} nolog
	 * @return {RegExp}
	 * @api private
	 *
	 * syntax
	 *  1. String
	 *   1.1 "\\.gif"
	 *         NOT LOGGING http://example.com/hoge.gif and http://example.com/hoge.gif?fuga
	 *         LOGGING http://example.com/hoge.agif
	 *   1.2 in "\\.gif|\\.jpg$"
	 *         NOT LOGGING http://example.com/hoge.gif and
	 *           http://example.com/hoge.gif?fuga and http://example.com/hoge.jpg?fuga
	 *         LOGGING http://example.com/hoge.agif,
	 *           http://example.com/hoge.ajpg and http://example.com/hoge.jpg?hoge
	 *   1.3 in "\\.(gif|jpe?g|png)$"
	 *         NOT LOGGING http://example.com/hoge.gif and http://example.com/hoge.jpeg
	 *         LOGGING http://example.com/hoge.gif?uid=2 and http://example.com/hoge.jpg?pid=3
	 *  2. RegExp
	 *   2.1 in /\.(gif|jpe?g|png)$/
	 *         SAME AS 1.3
	 *  3. Array
	 *   3.1 ["\\.jpg$", "\\.png", "\\.gif"]
	 *         SAME AS "\\.jpg|\\.png|\\.gif"
	 */
	function createNoLogCondition(nolog) {
	  let regexp = null;

	  if (nolog instanceof RegExp) {
	    regexp = nolog;
	  }

	  if (typeof nolog === 'string') {
	    regexp = new RegExp(nolog);
	  }

	  if (Array.isArray(nolog)) {
	    // convert to strings
	    const regexpsAsStrings = nolog.map((reg) =>
	      reg.source ? reg.source : reg
	    );
	    regexp = new RegExp(regexpsAsStrings.join('|'));
	  }

	  return regexp;
	}

	/**
	 * Allows users to define rules around status codes to assign them to a specific
	 * logging level.
	 * There are two types of rules:
	 *   - RANGE: matches a code within a certain range
	 *     E.g. { 'from': 200, 'to': 299, 'level': 'info' }
	 *   - CONTAINS: matches a code to a set of expected codes
	 *     E.g. { 'codes': [200, 203], 'level': 'debug' }
	 * Note*: Rules are respected only in order of prescendence.
	 *
	 * @param {Number} statusCode
	 * @param {Level} currentLevel
	 * @param {Object} ruleSet
	 * @return {Level}
	 * @api private
	 */
	function matchRules(statusCode, currentLevel, ruleSet) {
	  let level = currentLevel;

	  if (ruleSet) {
	    const matchedRule = ruleSet.find((rule) => {
	      let ruleMatched = false;
	      if (rule.from && rule.to) {
	        ruleMatched = statusCode >= rule.from && statusCode <= rule.to;
	      } else {
	        ruleMatched = rule.codes.indexOf(statusCode) !== -1;
	      }
	      return ruleMatched;
	    });
	    if (matchedRule) {
	      level = levels.getLevel(matchedRule.level, level);
	    }
	  }
	  return level;
	}

	/**
	 * Log requests with the given `options` or a `format` string.
	 *
	 * Options:
	 *
	 *   - `format`        Format string, see below for tokens
	 *   - `level`         A log4js levels instance. Supports also 'auto'
	 *   - `nolog`         A string or RegExp to exclude target logs or function(req, res): boolean
	 *   - `statusRules`   A array of rules for setting specific logging levels base on status codes
	 *   - `context`       Whether to add a response of express to the context
	 *
	 * Tokens:
	 *
	 *   - `:req[header]` ex: `:req[Accept]`
	 *   - `:res[header]` ex: `:res[Content-Length]`
	 *   - `:http-version`
	 *   - `:response-time`
	 *   - `:remote-addr`
	 *   - `:date`
	 *   - `:method`
	 *   - `:url`
	 *   - `:referrer`
	 *   - `:user-agent`
	 *   - `:status`
	 *
	 * @return {Function}
	 * @param logger4js
	 * @param options
	 * @api public
	 */
	connectLogger = function getLogger(logger4js, options) {
	  if (typeof options === 'string' || typeof options === 'function') {
	    options = { format: options };
	  } else {
	    options = options || {};
	  }

	  const thisLogger = logger4js;
	  let level = levels.getLevel(options.level, levels.INFO);
	  const fmt = options.format || DEFAULT_FORMAT;

	  return (req, res, next) => {
	    // mount safety
	    if (typeof req._logging !== 'undefined') return next();

	    // nologs
	    if (typeof options.nolog !== 'function') {
	      const nolog = createNoLogCondition(options.nolog);
	      if (nolog && nolog.test(req.originalUrl)) return next();
	    }

	    if (thisLogger.isLevelEnabled(level) || options.level === 'auto') {
	      const start = new Date();
	      const { writeHead } = res;

	      // flag as logging
	      req._logging = true;

	      // proxy for statusCode.
	      res.writeHead = (code, headers) => {
	        res.writeHead = writeHead;
	        res.writeHead(code, headers);

	        res.__statusCode = code;
	        res.__headers = headers || {};
	      };

	      // hook on end request to emit the log entry of the HTTP request.
	      let finished = false;
	      const handler = () => {
	        if (finished) {
	          return;
	        }
	        finished = true;

	        // nologs
	        if (typeof options.nolog === 'function') {
	          if (options.nolog(req, res) === true) {
	            req._logging = false;
	            return;
	          }
	        }

	        res.responseTime = new Date() - start;
	        // status code response level handling
	        if (res.statusCode && options.level === 'auto') {
	          level = levels.INFO;
	          if (res.statusCode >= 300) level = levels.WARN;
	          if (res.statusCode >= 400) level = levels.ERROR;
	        }
	        level = matchRules(res.statusCode, level, options.statusRules);

	        const combinedTokens = assembleTokens(req, res, options.tokens || []);

	        if (options.context) thisLogger.addContext('res', res);
	        if (typeof fmt === 'function') {
	          const line = fmt(req, res, (str) => format(str, combinedTokens));
	          if (line) thisLogger.log(level, line);
	        } else {
	          thisLogger.log(level, format(fmt, combinedTokens));
	        }
	        if (options.context) thisLogger.removeContext('res');
	      };
	      res.on('end', handler);
	      res.on('finish', handler);
	      res.on('error', handler);
	      res.on('close', handler);
	    }

	    // ensure next gets always called
	    return next();
	  };
	};
	return connectLogger;
}

var recording;
var hasRequiredRecording;

function requireRecording () {
	if (hasRequiredRecording) return recording;
	hasRequiredRecording = 1;
	const debug = requireSrc$1()('log4js:recording');

	const recordedEvents = [];

	function configure() {
	  return function (logEvent) {
	    debug(
	      `received logEvent, number of events now ${recordedEvents.length + 1}`
	    );
	    debug('log event was ', logEvent);
	    recordedEvents.push(logEvent);
	  };
	}

	function replay() {
	  return recordedEvents.slice();
	}

	function reset() {
	  recordedEvents.length = 0;
	}

	recording = {
	  configure,
	  replay,
	  playback: replay,
	  reset,
	  erase: reset,
	};
	return recording;
}

/**
 * @fileoverview log4js is a library to log in JavaScript in similar manner
 * than in log4j for Java (but not really).
 *
 * <h3>Example:</h3>
 * <pre>
 *  const logging = require('log4js');
 *  const log = logging.getLogger('some-category');
 *
 *  //call the log
 *  log.trace('trace me' );
 * </pre>
 *
 * NOTE: the authors below are the original browser-based log4js authors
 * don't try to contact them about bugs in this version :)
 * @author Stephan Strittmatter - http://jroller.com/page/stritti
 * @author Seth Chisamore - http://www.chisamore.com
 * @since 2005-05-20
 * Website: http://log4js.berlios.de
 */

var log4js_1;
var hasRequiredLog4js;

function requireLog4js () {
	if (hasRequiredLog4js) return log4js_1;
	hasRequiredLog4js = 1;
	const debug = requireSrc$1()('log4js:main');
	const fs = require$$0$8;
	const deepClone = requireRfdc()({ proto: true });
	const configuration = requireConfiguration();
	const layouts = requireLayouts();
	const levels = requireLevels();
	const appenders = requireAppenders();
	const categories = requireCategories();
	const Logger = requireLogger$1();
	const clustering = requireClustering();
	const connectLogger = requireConnectLogger();
	const recordingModule = requireRecording();

	let enabled = false;

	function sendLogEventToAppender(logEvent) {
	  if (!enabled) return;
	  debug('Received log event ', logEvent);
	  const categoryAppenders = categories.appendersForCategory(
	    logEvent.categoryName
	  );
	  categoryAppenders.forEach((appender) => {
	    appender(logEvent);
	  });
	}

	function loadConfigurationFile(filename) {
	  debug(`Loading configuration from ${filename}`);
	  try {
	    return JSON.parse(fs.readFileSync(filename, 'utf8'));
	  } catch (e) {
	    throw new Error(
	      `Problem reading config from file "${filename}". Error was ${e.message}`,
	      e
	    );
	  }
	}

	function configure(configurationFileOrObject) {
	  if (enabled) {
	    // eslint-disable-next-line no-use-before-define
	    shutdown();
	  }

	  let configObject = configurationFileOrObject;

	  if (typeof configObject === 'string') {
	    configObject = loadConfigurationFile(configurationFileOrObject);
	  }
	  debug(`Configuration is ${configObject}`);

	  configuration.configure(deepClone(configObject));

	  clustering.onMessage(sendLogEventToAppender);

	  enabled = true;

	  // eslint-disable-next-line no-use-before-define
	  return log4js;
	}

	function isConfigured() {
	  return enabled;
	}

	function recording() {
	  return recordingModule;
	}

	/**
	 * This callback type is called `shutdownCallback` and is displayed as a global symbol.
	 *
	 * @callback shutdownCallback
	 * @param {Error} [error]
	 */

	/**
	 * Shutdown all log appenders. This will first disable all writing to appenders
	 * and then call the shutdown function each appender.
	 *
	 * @param {shutdownCallback} [callback] - The callback to be invoked once all appenders have
	 *  shutdown. If an error occurs, the callback will be given the error object
	 *  as the first argument.
	 */
	function shutdown(callback = () => {}) {
	  if (typeof callback !== 'function') {
	    throw new TypeError('Invalid callback passed to shutdown');
	  }
	  debug('Shutdown called. Disabling all log writing.');
	  // First, disable all writing to appenders. This prevents appenders from
	  // not being able to be drained because of run-away log writes.
	  enabled = false;

	  // Clone out to maintain a reference
	  const appendersToCheck = Array.from(appenders.values());

	  // Reset immediately to prevent leaks
	  appenders.init();
	  categories.init();

	  // Count the number of shutdown functions
	  const shutdownFunctions = appendersToCheck.reduce(
	    (accum, next) => (next.shutdown ? accum + 1 : accum),
	    0
	  );
	  if (shutdownFunctions === 0) {
	    debug('No appenders with shutdown functions found.');
	    callback();
	  }

	  let completed = 0;
	  let error;
	  debug(`Found ${shutdownFunctions} appenders with shutdown functions.`);
	  function complete(err) {
	    error = error || err;
	    completed += 1;
	    debug(`Appender shutdowns complete: ${completed} / ${shutdownFunctions}`);
	    if (completed >= shutdownFunctions) {
	      debug('All shutdown functions completed.');
	      callback(error);
	    }
	  }

	  // Call each of the shutdown functions
	  appendersToCheck
	    .filter((a) => a.shutdown)
	    .forEach((a) => a.shutdown(complete));
	}

	/**
	 * Get a logger instance.
	 * @static
	 * @param {string} [category=default]
	 * @return {Logger} instance of logger for the category
	 */
	function getLogger(category) {
	  if (!enabled) {
	    configure(
	      process.env.LOG4JS_CONFIG || {
	        appenders: { out: { type: 'stdout' } },
	        categories: { default: { appenders: ['out'], level: 'OFF' } },
	      }
	    );
	  }
	  return new Logger(category || 'default');
	}

	/**
	 * @name log4js
	 * @namespace Log4js
	 * @property getLogger
	 * @property configure
	 * @property shutdown
	 */
	const log4js = {
	  getLogger,
	  configure,
	  isConfigured,
	  shutdown,
	  connectLogger,
	  levels,
	  addLayout: layouts.addLayout,
	  recording,
	};

	log4js_1 = log4js;
	return log4js_1;
}

var moment$1 = {exports: {}};

var moment = moment$1.exports;

var hasRequiredMoment;

function requireMoment () {
	if (hasRequiredMoment) return moment$1.exports;
	hasRequiredMoment = 1;
	(function (module, exports) {
(function (global, factory) {
		    module.exports = factory() ;
		}(moment, (function () {
		    var hookCallback;

		    function hooks() {
		        return hookCallback.apply(null, arguments);
		    }

		    // This is done to register the method called with moment()
		    // without creating circular dependencies.
		    function setHookCallback(callback) {
		        hookCallback = callback;
		    }

		    function isArray(input) {
		        return (
		            input instanceof Array ||
		            Object.prototype.toString.call(input) === '[object Array]'
		        );
		    }

		    function isObject(input) {
		        // IE8 will treat undefined and null as object if it wasn't for
		        // input != null
		        return (
		            input != null &&
		            Object.prototype.toString.call(input) === '[object Object]'
		        );
		    }

		    function hasOwnProp(a, b) {
		        return Object.prototype.hasOwnProperty.call(a, b);
		    }

		    function isObjectEmpty(obj) {
		        if (Object.getOwnPropertyNames) {
		            return Object.getOwnPropertyNames(obj).length === 0;
		        } else {
		            var k;
		            for (k in obj) {
		                if (hasOwnProp(obj, k)) {
		                    return false;
		                }
		            }
		            return true;
		        }
		    }

		    function isUndefined(input) {
		        return input === void 0;
		    }

		    function isNumber(input) {
		        return (
		            typeof input === 'number' ||
		            Object.prototype.toString.call(input) === '[object Number]'
		        );
		    }

		    function isDate(input) {
		        return (
		            input instanceof Date ||
		            Object.prototype.toString.call(input) === '[object Date]'
		        );
		    }

		    function map(arr, fn) {
		        var res = [],
		            i,
		            arrLen = arr.length;
		        for (i = 0; i < arrLen; ++i) {
		            res.push(fn(arr[i], i));
		        }
		        return res;
		    }

		    function extend(a, b) {
		        for (var i in b) {
		            if (hasOwnProp(b, i)) {
		                a[i] = b[i];
		            }
		        }

		        if (hasOwnProp(b, 'toString')) {
		            a.toString = b.toString;
		        }

		        if (hasOwnProp(b, 'valueOf')) {
		            a.valueOf = b.valueOf;
		        }

		        return a;
		    }

		    function createUTC(input, format, locale, strict) {
		        return createLocalOrUTC(input, format, locale, strict, true).utc();
		    }

		    function defaultParsingFlags() {
		        // We need to deep clone this object.
		        return {
		            empty: false,
		            unusedTokens: [],
		            unusedInput: [],
		            overflow: -2,
		            charsLeftOver: 0,
		            nullInput: false,
		            invalidEra: null,
		            invalidMonth: null,
		            invalidFormat: false,
		            userInvalidated: false,
		            iso: false,
		            parsedDateParts: [],
		            era: null,
		            meridiem: null,
		            rfc2822: false,
		            weekdayMismatch: false,
		        };
		    }

		    function getParsingFlags(m) {
		        if (m._pf == null) {
		            m._pf = defaultParsingFlags();
		        }
		        return m._pf;
		    }

		    var some;
		    if (Array.prototype.some) {
		        some = Array.prototype.some;
		    } else {
		        some = function (fun) {
		            var t = Object(this),
		                len = t.length >>> 0,
		                i;

		            for (i = 0; i < len; i++) {
		                if (i in t && fun.call(this, t[i], i, t)) {
		                    return true;
		                }
		            }

		            return false;
		        };
		    }

		    function isValid(m) {
		        var flags = null,
		            parsedParts = false,
		            isNowValid = m._d && !isNaN(m._d.getTime());
		        if (isNowValid) {
		            flags = getParsingFlags(m);
		            parsedParts = some.call(flags.parsedDateParts, function (i) {
		                return i != null;
		            });
		            isNowValid =
		                flags.overflow < 0 &&
		                !flags.empty &&
		                !flags.invalidEra &&
		                !flags.invalidMonth &&
		                !flags.invalidWeekday &&
		                !flags.weekdayMismatch &&
		                !flags.nullInput &&
		                !flags.invalidFormat &&
		                !flags.userInvalidated &&
		                (!flags.meridiem || (flags.meridiem && parsedParts));
		            if (m._strict) {
		                isNowValid =
		                    isNowValid &&
		                    flags.charsLeftOver === 0 &&
		                    flags.unusedTokens.length === 0 &&
		                    flags.bigHour === undefined;
		            }
		        }
		        if (Object.isFrozen == null || !Object.isFrozen(m)) {
		            m._isValid = isNowValid;
		        } else {
		            return isNowValid;
		        }
		        return m._isValid;
		    }

		    function createInvalid(flags) {
		        var m = createUTC(NaN);
		        if (flags != null) {
		            extend(getParsingFlags(m), flags);
		        } else {
		            getParsingFlags(m).userInvalidated = true;
		        }

		        return m;
		    }

		    // Plugins that add properties should also add the key here (null value),
		    // so we can properly clone ourselves.
		    var momentProperties = (hooks.momentProperties = []),
		        updateInProgress = false;

		    function copyConfig(to, from) {
		        var i,
		            prop,
		            val,
		            momentPropertiesLen = momentProperties.length;

		        if (!isUndefined(from._isAMomentObject)) {
		            to._isAMomentObject = from._isAMomentObject;
		        }
		        if (!isUndefined(from._i)) {
		            to._i = from._i;
		        }
		        if (!isUndefined(from._f)) {
		            to._f = from._f;
		        }
		        if (!isUndefined(from._l)) {
		            to._l = from._l;
		        }
		        if (!isUndefined(from._strict)) {
		            to._strict = from._strict;
		        }
		        if (!isUndefined(from._tzm)) {
		            to._tzm = from._tzm;
		        }
		        if (!isUndefined(from._isUTC)) {
		            to._isUTC = from._isUTC;
		        }
		        if (!isUndefined(from._offset)) {
		            to._offset = from._offset;
		        }
		        if (!isUndefined(from._pf)) {
		            to._pf = getParsingFlags(from);
		        }
		        if (!isUndefined(from._locale)) {
		            to._locale = from._locale;
		        }

		        if (momentPropertiesLen > 0) {
		            for (i = 0; i < momentPropertiesLen; i++) {
		                prop = momentProperties[i];
		                val = from[prop];
		                if (!isUndefined(val)) {
		                    to[prop] = val;
		                }
		            }
		        }

		        return to;
		    }

		    // Moment prototype object
		    function Moment(config) {
		        copyConfig(this, config);
		        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
		        if (!this.isValid()) {
		            this._d = new Date(NaN);
		        }
		        // Prevent infinite loop in case updateOffset creates new moment
		        // objects.
		        if (updateInProgress === false) {
		            updateInProgress = true;
		            hooks.updateOffset(this);
		            updateInProgress = false;
		        }
		    }

		    function isMoment(obj) {
		        return (
		            obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
		        );
		    }

		    function warn(msg) {
		        if (
		            hooks.suppressDeprecationWarnings === false &&
		            typeof console !== 'undefined' &&
		            console.warn
		        ) {
		            console.warn('Deprecation warning: ' + msg);
		        }
		    }

		    function deprecate(msg, fn) {
		        var firstTime = true;

		        return extend(function () {
		            if (hooks.deprecationHandler != null) {
		                hooks.deprecationHandler(null, msg);
		            }
		            if (firstTime) {
		                var args = [],
		                    arg,
		                    i,
		                    key,
		                    argLen = arguments.length;
		                for (i = 0; i < argLen; i++) {
		                    arg = '';
		                    if (typeof arguments[i] === 'object') {
		                        arg += '\n[' + i + '] ';
		                        for (key in arguments[0]) {
		                            if (hasOwnProp(arguments[0], key)) {
		                                arg += key + ': ' + arguments[0][key] + ', ';
		                            }
		                        }
		                        arg = arg.slice(0, -2); // Remove trailing comma and space
		                    } else {
		                        arg = arguments[i];
		                    }
		                    args.push(arg);
		                }
		                warn(
		                    msg +
		                        '\nArguments: ' +
		                        Array.prototype.slice.call(args).join('') +
		                        '\n' +
		                        new Error().stack
		                );
		                firstTime = false;
		            }
		            return fn.apply(this, arguments);
		        }, fn);
		    }

		    var deprecations = {};

		    function deprecateSimple(name, msg) {
		        if (hooks.deprecationHandler != null) {
		            hooks.deprecationHandler(name, msg);
		        }
		        if (!deprecations[name]) {
		            warn(msg);
		            deprecations[name] = true;
		        }
		    }

		    hooks.suppressDeprecationWarnings = false;
		    hooks.deprecationHandler = null;

		    function isFunction(input) {
		        return (
		            (typeof Function !== 'undefined' && input instanceof Function) ||
		            Object.prototype.toString.call(input) === '[object Function]'
		        );
		    }

		    function set(config) {
		        var prop, i;
		        for (i in config) {
		            if (hasOwnProp(config, i)) {
		                prop = config[i];
		                if (isFunction(prop)) {
		                    this[i] = prop;
		                } else {
		                    this['_' + i] = prop;
		                }
		            }
		        }
		        this._config = config;
		        // Lenient ordinal parsing accepts just a number in addition to
		        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
		        // TODO: Remove "ordinalParse" fallback in next major release.
		        this._dayOfMonthOrdinalParseLenient = new RegExp(
		            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
		                '|' +
		                /\d{1,2}/.source
		        );
		    }

		    function mergeConfigs(parentConfig, childConfig) {
		        var res = extend({}, parentConfig),
		            prop;
		        for (prop in childConfig) {
		            if (hasOwnProp(childConfig, prop)) {
		                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
		                    res[prop] = {};
		                    extend(res[prop], parentConfig[prop]);
		                    extend(res[prop], childConfig[prop]);
		                } else if (childConfig[prop] != null) {
		                    res[prop] = childConfig[prop];
		                } else {
		                    delete res[prop];
		                }
		            }
		        }
		        for (prop in parentConfig) {
		            if (
		                hasOwnProp(parentConfig, prop) &&
		                !hasOwnProp(childConfig, prop) &&
		                isObject(parentConfig[prop])
		            ) {
		                // make sure changes to properties don't modify parent config
		                res[prop] = extend({}, res[prop]);
		            }
		        }
		        return res;
		    }

		    function Locale(config) {
		        if (config != null) {
		            this.set(config);
		        }
		    }

		    var keys;

		    if (Object.keys) {
		        keys = Object.keys;
		    } else {
		        keys = function (obj) {
		            var i,
		                res = [];
		            for (i in obj) {
		                if (hasOwnProp(obj, i)) {
		                    res.push(i);
		                }
		            }
		            return res;
		        };
		    }

		    var defaultCalendar = {
		        sameDay: '[Today at] LT',
		        nextDay: '[Tomorrow at] LT',
		        nextWeek: 'dddd [at] LT',
		        lastDay: '[Yesterday at] LT',
		        lastWeek: '[Last] dddd [at] LT',
		        sameElse: 'L',
		    };

		    function calendar(key, mom, now) {
		        var output = this._calendar[key] || this._calendar['sameElse'];
		        return isFunction(output) ? output.call(mom, now) : output;
		    }

		    function zeroFill(number, targetLength, forceSign) {
		        var absNumber = '' + Math.abs(number),
		            zerosToFill = targetLength - absNumber.length,
		            sign = number >= 0;
		        return (
		            (sign ? (forceSign ? '+' : '') : '-') +
		            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
		            absNumber
		        );
		    }

		    var formattingTokens =
		            /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
		        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
		        formatFunctions = {},
		        formatTokenFunctions = {};

		    // token:    'M'
		    // padded:   ['MM', 2]
		    // ordinal:  'Mo'
		    // callback: function () { this.month() + 1 }
		    function addFormatToken(token, padded, ordinal, callback) {
		        var func = callback;
		        if (typeof callback === 'string') {
		            func = function () {
		                return this[callback]();
		            };
		        }
		        if (token) {
		            formatTokenFunctions[token] = func;
		        }
		        if (padded) {
		            formatTokenFunctions[padded[0]] = function () {
		                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
		            };
		        }
		        if (ordinal) {
		            formatTokenFunctions[ordinal] = function () {
		                return this.localeData().ordinal(
		                    func.apply(this, arguments),
		                    token
		                );
		            };
		        }
		    }

		    function removeFormattingTokens(input) {
		        if (input.match(/\[[\s\S]/)) {
		            return input.replace(/^\[|\]$/g, '');
		        }
		        return input.replace(/\\/g, '');
		    }

		    function makeFormatFunction(format) {
		        var array = format.match(formattingTokens),
		            i,
		            length;

		        for (i = 0, length = array.length; i < length; i++) {
		            if (formatTokenFunctions[array[i]]) {
		                array[i] = formatTokenFunctions[array[i]];
		            } else {
		                array[i] = removeFormattingTokens(array[i]);
		            }
		        }

		        return function (mom) {
		            var output = '',
		                i;
		            for (i = 0; i < length; i++) {
		                output += isFunction(array[i])
		                    ? array[i].call(mom, format)
		                    : array[i];
		            }
		            return output;
		        };
		    }

		    // format date using native date object
		    function formatMoment(m, format) {
		        if (!m.isValid()) {
		            return m.localeData().invalidDate();
		        }

		        format = expandFormat(format, m.localeData());
		        formatFunctions[format] =
		            formatFunctions[format] || makeFormatFunction(format);

		        return formatFunctions[format](m);
		    }

		    function expandFormat(format, locale) {
		        var i = 5;

		        function replaceLongDateFormatTokens(input) {
		            return locale.longDateFormat(input) || input;
		        }

		        localFormattingTokens.lastIndex = 0;
		        while (i >= 0 && localFormattingTokens.test(format)) {
		            format = format.replace(
		                localFormattingTokens,
		                replaceLongDateFormatTokens
		            );
		            localFormattingTokens.lastIndex = 0;
		            i -= 1;
		        }

		        return format;
		    }

		    var defaultLongDateFormat = {
		        LTS: 'h:mm:ss A',
		        LT: 'h:mm A',
		        L: 'MM/DD/YYYY',
		        LL: 'MMMM D, YYYY',
		        LLL: 'MMMM D, YYYY h:mm A',
		        LLLL: 'dddd, MMMM D, YYYY h:mm A',
		    };

		    function longDateFormat(key) {
		        var format = this._longDateFormat[key],
		            formatUpper = this._longDateFormat[key.toUpperCase()];

		        if (format || !formatUpper) {
		            return format;
		        }

		        this._longDateFormat[key] = formatUpper
		            .match(formattingTokens)
		            .map(function (tok) {
		                if (
		                    tok === 'MMMM' ||
		                    tok === 'MM' ||
		                    tok === 'DD' ||
		                    tok === 'dddd'
		                ) {
		                    return tok.slice(1);
		                }
		                return tok;
		            })
		            .join('');

		        return this._longDateFormat[key];
		    }

		    var defaultInvalidDate = 'Invalid date';

		    function invalidDate() {
		        return this._invalidDate;
		    }

		    var defaultOrdinal = '%d',
		        defaultDayOfMonthOrdinalParse = /\d{1,2}/;

		    function ordinal(number) {
		        return this._ordinal.replace('%d', number);
		    }

		    var defaultRelativeTime = {
		        future: 'in %s',
		        past: '%s ago',
		        s: 'a few seconds',
		        ss: '%d seconds',
		        m: 'a minute',
		        mm: '%d minutes',
		        h: 'an hour',
		        hh: '%d hours',
		        d: 'a day',
		        dd: '%d days',
		        w: 'a week',
		        ww: '%d weeks',
		        M: 'a month',
		        MM: '%d months',
		        y: 'a year',
		        yy: '%d years',
		    };

		    function relativeTime(number, withoutSuffix, string, isFuture) {
		        var output = this._relativeTime[string];
		        return isFunction(output)
		            ? output(number, withoutSuffix, string, isFuture)
		            : output.replace(/%d/i, number);
		    }

		    function pastFuture(diff, output) {
		        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
		        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
		    }

		    var aliases = {
		        D: 'date',
		        dates: 'date',
		        date: 'date',
		        d: 'day',
		        days: 'day',
		        day: 'day',
		        e: 'weekday',
		        weekdays: 'weekday',
		        weekday: 'weekday',
		        E: 'isoWeekday',
		        isoweekdays: 'isoWeekday',
		        isoweekday: 'isoWeekday',
		        DDD: 'dayOfYear',
		        dayofyears: 'dayOfYear',
		        dayofyear: 'dayOfYear',
		        h: 'hour',
		        hours: 'hour',
		        hour: 'hour',
		        ms: 'millisecond',
		        milliseconds: 'millisecond',
		        millisecond: 'millisecond',
		        m: 'minute',
		        minutes: 'minute',
		        minute: 'minute',
		        M: 'month',
		        months: 'month',
		        month: 'month',
		        Q: 'quarter',
		        quarters: 'quarter',
		        quarter: 'quarter',
		        s: 'second',
		        seconds: 'second',
		        second: 'second',
		        gg: 'weekYear',
		        weekyears: 'weekYear',
		        weekyear: 'weekYear',
		        GG: 'isoWeekYear',
		        isoweekyears: 'isoWeekYear',
		        isoweekyear: 'isoWeekYear',
		        w: 'week',
		        weeks: 'week',
		        week: 'week',
		        W: 'isoWeek',
		        isoweeks: 'isoWeek',
		        isoweek: 'isoWeek',
		        y: 'year',
		        years: 'year',
		        year: 'year',
		    };

		    function normalizeUnits(units) {
		        return typeof units === 'string'
		            ? aliases[units] || aliases[units.toLowerCase()]
		            : undefined;
		    }

		    function normalizeObjectUnits(inputObject) {
		        var normalizedInput = {},
		            normalizedProp,
		            prop;

		        for (prop in inputObject) {
		            if (hasOwnProp(inputObject, prop)) {
		                normalizedProp = normalizeUnits(prop);
		                if (normalizedProp) {
		                    normalizedInput[normalizedProp] = inputObject[prop];
		                }
		            }
		        }

		        return normalizedInput;
		    }

		    var priorities = {
		        date: 9,
		        day: 11,
		        weekday: 11,
		        isoWeekday: 11,
		        dayOfYear: 4,
		        hour: 13,
		        millisecond: 16,
		        minute: 14,
		        month: 8,
		        quarter: 7,
		        second: 15,
		        weekYear: 1,
		        isoWeekYear: 1,
		        week: 5,
		        isoWeek: 5,
		        year: 1,
		    };

		    function getPrioritizedUnits(unitsObj) {
		        var units = [],
		            u;
		        for (u in unitsObj) {
		            if (hasOwnProp(unitsObj, u)) {
		                units.push({ unit: u, priority: priorities[u] });
		            }
		        }
		        units.sort(function (a, b) {
		            return a.priority - b.priority;
		        });
		        return units;
		    }

		    var match1 = /\d/, //       0 - 9
		        match2 = /\d\d/, //      00 - 99
		        match3 = /\d{3}/, //     000 - 999
		        match4 = /\d{4}/, //    0000 - 9999
		        match6 = /[+-]?\d{6}/, // -999999 - 999999
		        match1to2 = /\d\d?/, //       0 - 99
		        match3to4 = /\d\d\d\d?/, //     999 - 9999
		        match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
		        match1to3 = /\d{1,3}/, //       0 - 999
		        match1to4 = /\d{1,4}/, //       0 - 9999
		        match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
		        matchUnsigned = /\d+/, //       0 - inf
		        matchSigned = /[+-]?\d+/, //    -inf - inf
		        matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
		        matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
		        matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
		        // any word (or two) characters or numbers including two/three word month in arabic.
		        // includes scottish gaelic two word and hyphenated months
		        matchWord =
		            /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
		        match1to2NoLeadingZero = /^[1-9]\d?/, //         1-99
		        match1to2HasZero = /^([1-9]\d|\d)/, //           0-99
		        regexes;

		    regexes = {};

		    function addRegexToken(token, regex, strictRegex) {
		        regexes[token] = isFunction(regex)
		            ? regex
		            : function (isStrict, localeData) {
		                  return isStrict && strictRegex ? strictRegex : regex;
		              };
		    }

		    function getParseRegexForToken(token, config) {
		        if (!hasOwnProp(regexes, token)) {
		            return new RegExp(unescapeFormat(token));
		        }

		        return regexes[token](config._strict, config._locale);
		    }

		    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
		    function unescapeFormat(s) {
		        return regexEscape(
		            s
		                .replace('\\', '')
		                .replace(
		                    /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
		                    function (matched, p1, p2, p3, p4) {
		                        return p1 || p2 || p3 || p4;
		                    }
		                )
		        );
		    }

		    function regexEscape(s) {
		        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
		    }

		    function absFloor(number) {
		        if (number < 0) {
		            // -0 -> 0
		            return Math.ceil(number) || 0;
		        } else {
		            return Math.floor(number);
		        }
		    }

		    function toInt(argumentForCoercion) {
		        var coercedNumber = +argumentForCoercion,
		            value = 0;

		        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
		            value = absFloor(coercedNumber);
		        }

		        return value;
		    }

		    var tokens = {};

		    function addParseToken(token, callback) {
		        var i,
		            func = callback,
		            tokenLen;
		        if (typeof token === 'string') {
		            token = [token];
		        }
		        if (isNumber(callback)) {
		            func = function (input, array) {
		                array[callback] = toInt(input);
		            };
		        }
		        tokenLen = token.length;
		        for (i = 0; i < tokenLen; i++) {
		            tokens[token[i]] = func;
		        }
		    }

		    function addWeekParseToken(token, callback) {
		        addParseToken(token, function (input, array, config, token) {
		            config._w = config._w || {};
		            callback(input, config._w, config, token);
		        });
		    }

		    function addTimeToArrayFromToken(token, input, config) {
		        if (input != null && hasOwnProp(tokens, token)) {
		            tokens[token](input, config._a, config, token);
		        }
		    }

		    function isLeapYear(year) {
		        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
		    }

		    var YEAR = 0,
		        MONTH = 1,
		        DATE = 2,
		        HOUR = 3,
		        MINUTE = 4,
		        SECOND = 5,
		        MILLISECOND = 6,
		        WEEK = 7,
		        WEEKDAY = 8;

		    // FORMATTING

		    addFormatToken('Y', 0, 0, function () {
		        var y = this.year();
		        return y <= 9999 ? zeroFill(y, 4) : '+' + y;
		    });

		    addFormatToken(0, ['YY', 2], 0, function () {
		        return this.year() % 100;
		    });

		    addFormatToken(0, ['YYYY', 4], 0, 'year');
		    addFormatToken(0, ['YYYYY', 5], 0, 'year');
		    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

		    // PARSING

		    addRegexToken('Y', matchSigned);
		    addRegexToken('YY', match1to2, match2);
		    addRegexToken('YYYY', match1to4, match4);
		    addRegexToken('YYYYY', match1to6, match6);
		    addRegexToken('YYYYYY', match1to6, match6);

		    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
		    addParseToken('YYYY', function (input, array) {
		        array[YEAR] =
		            input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
		    });
		    addParseToken('YY', function (input, array) {
		        array[YEAR] = hooks.parseTwoDigitYear(input);
		    });
		    addParseToken('Y', function (input, array) {
		        array[YEAR] = parseInt(input, 10);
		    });

		    // HELPERS

		    function daysInYear(year) {
		        return isLeapYear(year) ? 366 : 365;
		    }

		    // HOOKS

		    hooks.parseTwoDigitYear = function (input) {
		        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
		    };

		    // MOMENTS

		    var getSetYear = makeGetSet('FullYear', true);

		    function getIsLeapYear() {
		        return isLeapYear(this.year());
		    }

		    function makeGetSet(unit, keepTime) {
		        return function (value) {
		            if (value != null) {
		                set$1(this, unit, value);
		                hooks.updateOffset(this, keepTime);
		                return this;
		            } else {
		                return get(this, unit);
		            }
		        };
		    }

		    function get(mom, unit) {
		        if (!mom.isValid()) {
		            return NaN;
		        }

		        var d = mom._d,
		            isUTC = mom._isUTC;

		        switch (unit) {
		            case 'Milliseconds':
		                return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
		            case 'Seconds':
		                return isUTC ? d.getUTCSeconds() : d.getSeconds();
		            case 'Minutes':
		                return isUTC ? d.getUTCMinutes() : d.getMinutes();
		            case 'Hours':
		                return isUTC ? d.getUTCHours() : d.getHours();
		            case 'Date':
		                return isUTC ? d.getUTCDate() : d.getDate();
		            case 'Day':
		                return isUTC ? d.getUTCDay() : d.getDay();
		            case 'Month':
		                return isUTC ? d.getUTCMonth() : d.getMonth();
		            case 'FullYear':
		                return isUTC ? d.getUTCFullYear() : d.getFullYear();
		            default:
		                return NaN; // Just in case
		        }
		    }

		    function set$1(mom, unit, value) {
		        var d, isUTC, year, month, date;

		        if (!mom.isValid() || isNaN(value)) {
		            return;
		        }

		        d = mom._d;
		        isUTC = mom._isUTC;

		        switch (unit) {
		            case 'Milliseconds':
		                return void (isUTC
		                    ? d.setUTCMilliseconds(value)
		                    : d.setMilliseconds(value));
		            case 'Seconds':
		                return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
		            case 'Minutes':
		                return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
		            case 'Hours':
		                return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
		            case 'Date':
		                return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
		            // case 'Day': // Not real
		            //    return void (isUTC ? d.setUTCDay(value) : d.setDay(value));
		            // case 'Month': // Not used because we need to pass two variables
		            //     return void (isUTC ? d.setUTCMonth(value) : d.setMonth(value));
		            case 'FullYear':
		                break; // See below ...
		            default:
		                return; // Just in case
		        }

		        year = value;
		        month = mom.month();
		        date = mom.date();
		        date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
		        void (isUTC
		            ? d.setUTCFullYear(year, month, date)
		            : d.setFullYear(year, month, date));
		    }

		    // MOMENTS

		    function stringGet(units) {
		        units = normalizeUnits(units);
		        if (isFunction(this[units])) {
		            return this[units]();
		        }
		        return this;
		    }

		    function stringSet(units, value) {
		        if (typeof units === 'object') {
		            units = normalizeObjectUnits(units);
		            var prioritized = getPrioritizedUnits(units),
		                i,
		                prioritizedLen = prioritized.length;
		            for (i = 0; i < prioritizedLen; i++) {
		                this[prioritized[i].unit](units[prioritized[i].unit]);
		            }
		        } else {
		            units = normalizeUnits(units);
		            if (isFunction(this[units])) {
		                return this[units](value);
		            }
		        }
		        return this;
		    }

		    function mod(n, x) {
		        return ((n % x) + x) % x;
		    }

		    var indexOf;

		    if (Array.prototype.indexOf) {
		        indexOf = Array.prototype.indexOf;
		    } else {
		        indexOf = function (o) {
		            // I know
		            var i;
		            for (i = 0; i < this.length; ++i) {
		                if (this[i] === o) {
		                    return i;
		                }
		            }
		            return -1;
		        };
		    }

		    function daysInMonth(year, month) {
		        if (isNaN(year) || isNaN(month)) {
		            return NaN;
		        }
		        var modMonth = mod(month, 12);
		        year += (month - modMonth) / 12;
		        return modMonth === 1
		            ? isLeapYear(year)
		                ? 29
		                : 28
		            : 31 - ((modMonth % 7) % 2);
		    }

		    // FORMATTING

		    addFormatToken('M', ['MM', 2], 'Mo', function () {
		        return this.month() + 1;
		    });

		    addFormatToken('MMM', 0, 0, function (format) {
		        return this.localeData().monthsShort(this, format);
		    });

		    addFormatToken('MMMM', 0, 0, function (format) {
		        return this.localeData().months(this, format);
		    });

		    // PARSING

		    addRegexToken('M', match1to2, match1to2NoLeadingZero);
		    addRegexToken('MM', match1to2, match2);
		    addRegexToken('MMM', function (isStrict, locale) {
		        return locale.monthsShortRegex(isStrict);
		    });
		    addRegexToken('MMMM', function (isStrict, locale) {
		        return locale.monthsRegex(isStrict);
		    });

		    addParseToken(['M', 'MM'], function (input, array) {
		        array[MONTH] = toInt(input) - 1;
		    });

		    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
		        var month = config._locale.monthsParse(input, token, config._strict);
		        // if we didn't find a month name, mark the date as invalid.
		        if (month != null) {
		            array[MONTH] = month;
		        } else {
		            getParsingFlags(config).invalidMonth = input;
		        }
		    });

		    // LOCALES

		    var defaultLocaleMonths =
		            'January_February_March_April_May_June_July_August_September_October_November_December'.split(
		                '_'
		            ),
		        defaultLocaleMonthsShort =
		            'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
		        MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
		        defaultMonthsShortRegex = matchWord,
		        defaultMonthsRegex = matchWord;

		    function localeMonths(m, format) {
		        if (!m) {
		            return isArray(this._months)
		                ? this._months
		                : this._months['standalone'];
		        }
		        return isArray(this._months)
		            ? this._months[m.month()]
		            : this._months[
		                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
		                      ? 'format'
		                      : 'standalone'
		              ][m.month()];
		    }

		    function localeMonthsShort(m, format) {
		        if (!m) {
		            return isArray(this._monthsShort)
		                ? this._monthsShort
		                : this._monthsShort['standalone'];
		        }
		        return isArray(this._monthsShort)
		            ? this._monthsShort[m.month()]
		            : this._monthsShort[
		                  MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
		              ][m.month()];
		    }

		    function handleStrictParse(monthName, format, strict) {
		        var i,
		            ii,
		            mom,
		            llc = monthName.toLocaleLowerCase();
		        if (!this._monthsParse) {
		            // this is not used
		            this._monthsParse = [];
		            this._longMonthsParse = [];
		            this._shortMonthsParse = [];
		            for (i = 0; i < 12; ++i) {
		                mom = createUTC([2000, i]);
		                this._shortMonthsParse[i] = this.monthsShort(
		                    mom,
		                    ''
		                ).toLocaleLowerCase();
		                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
		            }
		        }

		        if (strict) {
		            if (format === 'MMM') {
		                ii = indexOf.call(this._shortMonthsParse, llc);
		                return ii !== -1 ? ii : null;
		            } else {
		                ii = indexOf.call(this._longMonthsParse, llc);
		                return ii !== -1 ? ii : null;
		            }
		        } else {
		            if (format === 'MMM') {
		                ii = indexOf.call(this._shortMonthsParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._longMonthsParse, llc);
		                return ii !== -1 ? ii : null;
		            } else {
		                ii = indexOf.call(this._longMonthsParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._shortMonthsParse, llc);
		                return ii !== -1 ? ii : null;
		            }
		        }
		    }

		    function localeMonthsParse(monthName, format, strict) {
		        var i, mom, regex;

		        if (this._monthsParseExact) {
		            return handleStrictParse.call(this, monthName, format, strict);
		        }

		        if (!this._monthsParse) {
		            this._monthsParse = [];
		            this._longMonthsParse = [];
		            this._shortMonthsParse = [];
		        }

		        // TODO: add sorting
		        // Sorting makes sure if one month (or abbr) is a prefix of another
		        // see sorting in computeMonthsParse
		        for (i = 0; i < 12; i++) {
		            // make the regex if we don't have it already
		            mom = createUTC([2000, i]);
		            if (strict && !this._longMonthsParse[i]) {
		                this._longMonthsParse[i] = new RegExp(
		                    '^' + this.months(mom, '').replace('.', '') + '$',
		                    'i'
		                );
		                this._shortMonthsParse[i] = new RegExp(
		                    '^' + this.monthsShort(mom, '').replace('.', '') + '$',
		                    'i'
		                );
		            }
		            if (!strict && !this._monthsParse[i]) {
		                regex =
		                    '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
		                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
		            }
		            // test the regex
		            if (
		                strict &&
		                format === 'MMMM' &&
		                this._longMonthsParse[i].test(monthName)
		            ) {
		                return i;
		            } else if (
		                strict &&
		                format === 'MMM' &&
		                this._shortMonthsParse[i].test(monthName)
		            ) {
		                return i;
		            } else if (!strict && this._monthsParse[i].test(monthName)) {
		                return i;
		            }
		        }
		    }

		    // MOMENTS

		    function setMonth(mom, value) {
		        if (!mom.isValid()) {
		            // No op
		            return mom;
		        }

		        if (typeof value === 'string') {
		            if (/^\d+$/.test(value)) {
		                value = toInt(value);
		            } else {
		                value = mom.localeData().monthsParse(value);
		                // TODO: Another silent failure?
		                if (!isNumber(value)) {
		                    return mom;
		                }
		            }
		        }

		        var month = value,
		            date = mom.date();

		        date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
		        void (mom._isUTC
		            ? mom._d.setUTCMonth(month, date)
		            : mom._d.setMonth(month, date));
		        return mom;
		    }

		    function getSetMonth(value) {
		        if (value != null) {
		            setMonth(this, value);
		            hooks.updateOffset(this, true);
		            return this;
		        } else {
		            return get(this, 'Month');
		        }
		    }

		    function getDaysInMonth() {
		        return daysInMonth(this.year(), this.month());
		    }

		    function monthsShortRegex(isStrict) {
		        if (this._monthsParseExact) {
		            if (!hasOwnProp(this, '_monthsRegex')) {
		                computeMonthsParse.call(this);
		            }
		            if (isStrict) {
		                return this._monthsShortStrictRegex;
		            } else {
		                return this._monthsShortRegex;
		            }
		        } else {
		            if (!hasOwnProp(this, '_monthsShortRegex')) {
		                this._monthsShortRegex = defaultMonthsShortRegex;
		            }
		            return this._monthsShortStrictRegex && isStrict
		                ? this._monthsShortStrictRegex
		                : this._monthsShortRegex;
		        }
		    }

		    function monthsRegex(isStrict) {
		        if (this._monthsParseExact) {
		            if (!hasOwnProp(this, '_monthsRegex')) {
		                computeMonthsParse.call(this);
		            }
		            if (isStrict) {
		                return this._monthsStrictRegex;
		            } else {
		                return this._monthsRegex;
		            }
		        } else {
		            if (!hasOwnProp(this, '_monthsRegex')) {
		                this._monthsRegex = defaultMonthsRegex;
		            }
		            return this._monthsStrictRegex && isStrict
		                ? this._monthsStrictRegex
		                : this._monthsRegex;
		        }
		    }

		    function computeMonthsParse() {
		        function cmpLenRev(a, b) {
		            return b.length - a.length;
		        }

		        var shortPieces = [],
		            longPieces = [],
		            mixedPieces = [],
		            i,
		            mom,
		            shortP,
		            longP;
		        for (i = 0; i < 12; i++) {
		            // make the regex if we don't have it already
		            mom = createUTC([2000, i]);
		            shortP = regexEscape(this.monthsShort(mom, ''));
		            longP = regexEscape(this.months(mom, ''));
		            shortPieces.push(shortP);
		            longPieces.push(longP);
		            mixedPieces.push(longP);
		            mixedPieces.push(shortP);
		        }
		        // Sorting makes sure if one month (or abbr) is a prefix of another it
		        // will match the longer piece.
		        shortPieces.sort(cmpLenRev);
		        longPieces.sort(cmpLenRev);
		        mixedPieces.sort(cmpLenRev);

		        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
		        this._monthsShortRegex = this._monthsRegex;
		        this._monthsStrictRegex = new RegExp(
		            '^(' + longPieces.join('|') + ')',
		            'i'
		        );
		        this._monthsShortStrictRegex = new RegExp(
		            '^(' + shortPieces.join('|') + ')',
		            'i'
		        );
		    }

		    function createDate(y, m, d, h, M, s, ms) {
		        // can't just apply() to create a date:
		        // https://stackoverflow.com/q/181348
		        var date;
		        // the date constructor remaps years 0-99 to 1900-1999
		        if (y < 100 && y >= 0) {
		            // preserve leap years using a full 400 year cycle, then reset
		            date = new Date(y + 400, m, d, h, M, s, ms);
		            if (isFinite(date.getFullYear())) {
		                date.setFullYear(y);
		            }
		        } else {
		            date = new Date(y, m, d, h, M, s, ms);
		        }

		        return date;
		    }

		    function createUTCDate(y) {
		        var date, args;
		        // the Date.UTC function remaps years 0-99 to 1900-1999
		        if (y < 100 && y >= 0) {
		            args = Array.prototype.slice.call(arguments);
		            // preserve leap years using a full 400 year cycle, then reset
		            args[0] = y + 400;
		            date = new Date(Date.UTC.apply(null, args));
		            if (isFinite(date.getUTCFullYear())) {
		                date.setUTCFullYear(y);
		            }
		        } else {
		            date = new Date(Date.UTC.apply(null, arguments));
		        }

		        return date;
		    }

		    // start-of-first-week - start-of-year
		    function firstWeekOffset(year, dow, doy) {
		        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
		            fwd = 7 + dow - doy,
		            // first-week day local weekday -- which local weekday is fwd
		            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

		        return -fwdlw + fwd - 1;
		    }

		    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
		    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
		        var localWeekday = (7 + weekday - dow) % 7,
		            weekOffset = firstWeekOffset(year, dow, doy),
		            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
		            resYear,
		            resDayOfYear;

		        if (dayOfYear <= 0) {
		            resYear = year - 1;
		            resDayOfYear = daysInYear(resYear) + dayOfYear;
		        } else if (dayOfYear > daysInYear(year)) {
		            resYear = year + 1;
		            resDayOfYear = dayOfYear - daysInYear(year);
		        } else {
		            resYear = year;
		            resDayOfYear = dayOfYear;
		        }

		        return {
		            year: resYear,
		            dayOfYear: resDayOfYear,
		        };
		    }

		    function weekOfYear(mom, dow, doy) {
		        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
		            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
		            resWeek,
		            resYear;

		        if (week < 1) {
		            resYear = mom.year() - 1;
		            resWeek = week + weeksInYear(resYear, dow, doy);
		        } else if (week > weeksInYear(mom.year(), dow, doy)) {
		            resWeek = week - weeksInYear(mom.year(), dow, doy);
		            resYear = mom.year() + 1;
		        } else {
		            resYear = mom.year();
		            resWeek = week;
		        }

		        return {
		            week: resWeek,
		            year: resYear,
		        };
		    }

		    function weeksInYear(year, dow, doy) {
		        var weekOffset = firstWeekOffset(year, dow, doy),
		            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
		        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
		    }

		    // FORMATTING

		    addFormatToken('w', ['ww', 2], 'wo', 'week');
		    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

		    // PARSING

		    addRegexToken('w', match1to2, match1to2NoLeadingZero);
		    addRegexToken('ww', match1to2, match2);
		    addRegexToken('W', match1to2, match1to2NoLeadingZero);
		    addRegexToken('WW', match1to2, match2);

		    addWeekParseToken(
		        ['w', 'ww', 'W', 'WW'],
		        function (input, week, config, token) {
		            week[token.substr(0, 1)] = toInt(input);
		        }
		    );

		    // HELPERS

		    // LOCALES

		    function localeWeek(mom) {
		        return weekOfYear(mom, this._week.dow, this._week.doy).week;
		    }

		    var defaultLocaleWeek = {
		        dow: 0, // Sunday is the first day of the week.
		        doy: 6, // The week that contains Jan 6th is the first week of the year.
		    };

		    function localeFirstDayOfWeek() {
		        return this._week.dow;
		    }

		    function localeFirstDayOfYear() {
		        return this._week.doy;
		    }

		    // MOMENTS

		    function getSetWeek(input) {
		        var week = this.localeData().week(this);
		        return input == null ? week : this.add((input - week) * 7, 'd');
		    }

		    function getSetISOWeek(input) {
		        var week = weekOfYear(this, 1, 4).week;
		        return input == null ? week : this.add((input - week) * 7, 'd');
		    }

		    // FORMATTING

		    addFormatToken('d', 0, 'do', 'day');

		    addFormatToken('dd', 0, 0, function (format) {
		        return this.localeData().weekdaysMin(this, format);
		    });

		    addFormatToken('ddd', 0, 0, function (format) {
		        return this.localeData().weekdaysShort(this, format);
		    });

		    addFormatToken('dddd', 0, 0, function (format) {
		        return this.localeData().weekdays(this, format);
		    });

		    addFormatToken('e', 0, 0, 'weekday');
		    addFormatToken('E', 0, 0, 'isoWeekday');

		    // PARSING

		    addRegexToken('d', match1to2);
		    addRegexToken('e', match1to2);
		    addRegexToken('E', match1to2);
		    addRegexToken('dd', function (isStrict, locale) {
		        return locale.weekdaysMinRegex(isStrict);
		    });
		    addRegexToken('ddd', function (isStrict, locale) {
		        return locale.weekdaysShortRegex(isStrict);
		    });
		    addRegexToken('dddd', function (isStrict, locale) {
		        return locale.weekdaysRegex(isStrict);
		    });

		    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
		        var weekday = config._locale.weekdaysParse(input, token, config._strict);
		        // if we didn't get a weekday name, mark the date as invalid
		        if (weekday != null) {
		            week.d = weekday;
		        } else {
		            getParsingFlags(config).invalidWeekday = input;
		        }
		    });

		    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
		        week[token] = toInt(input);
		    });

		    // HELPERS

		    function parseWeekday(input, locale) {
		        if (typeof input !== 'string') {
		            return input;
		        }

		        if (!isNaN(input)) {
		            return parseInt(input, 10);
		        }

		        input = locale.weekdaysParse(input);
		        if (typeof input === 'number') {
		            return input;
		        }

		        return null;
		    }

		    function parseIsoWeekday(input, locale) {
		        if (typeof input === 'string') {
		            return locale.weekdaysParse(input) % 7 || 7;
		        }
		        return isNaN(input) ? null : input;
		    }

		    // LOCALES
		    function shiftWeekdays(ws, n) {
		        return ws.slice(n, 7).concat(ws.slice(0, n));
		    }

		    var defaultLocaleWeekdays =
		            'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
		        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
		        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
		        defaultWeekdaysRegex = matchWord,
		        defaultWeekdaysShortRegex = matchWord,
		        defaultWeekdaysMinRegex = matchWord;

		    function localeWeekdays(m, format) {
		        var weekdays = isArray(this._weekdays)
		            ? this._weekdays
		            : this._weekdays[
		                  m && m !== true && this._weekdays.isFormat.test(format)
		                      ? 'format'
		                      : 'standalone'
		              ];
		        return m === true
		            ? shiftWeekdays(weekdays, this._week.dow)
		            : m
		              ? weekdays[m.day()]
		              : weekdays;
		    }

		    function localeWeekdaysShort(m) {
		        return m === true
		            ? shiftWeekdays(this._weekdaysShort, this._week.dow)
		            : m
		              ? this._weekdaysShort[m.day()]
		              : this._weekdaysShort;
		    }

		    function localeWeekdaysMin(m) {
		        return m === true
		            ? shiftWeekdays(this._weekdaysMin, this._week.dow)
		            : m
		              ? this._weekdaysMin[m.day()]
		              : this._weekdaysMin;
		    }

		    function handleStrictParse$1(weekdayName, format, strict) {
		        var i,
		            ii,
		            mom,
		            llc = weekdayName.toLocaleLowerCase();
		        if (!this._weekdaysParse) {
		            this._weekdaysParse = [];
		            this._shortWeekdaysParse = [];
		            this._minWeekdaysParse = [];

		            for (i = 0; i < 7; ++i) {
		                mom = createUTC([2000, 1]).day(i);
		                this._minWeekdaysParse[i] = this.weekdaysMin(
		                    mom,
		                    ''
		                ).toLocaleLowerCase();
		                this._shortWeekdaysParse[i] = this.weekdaysShort(
		                    mom,
		                    ''
		                ).toLocaleLowerCase();
		                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
		            }
		        }

		        if (strict) {
		            if (format === 'dddd') {
		                ii = indexOf.call(this._weekdaysParse, llc);
		                return ii !== -1 ? ii : null;
		            } else if (format === 'ddd') {
		                ii = indexOf.call(this._shortWeekdaysParse, llc);
		                return ii !== -1 ? ii : null;
		            } else {
		                ii = indexOf.call(this._minWeekdaysParse, llc);
		                return ii !== -1 ? ii : null;
		            }
		        } else {
		            if (format === 'dddd') {
		                ii = indexOf.call(this._weekdaysParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._shortWeekdaysParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._minWeekdaysParse, llc);
		                return ii !== -1 ? ii : null;
		            } else if (format === 'ddd') {
		                ii = indexOf.call(this._shortWeekdaysParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._weekdaysParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._minWeekdaysParse, llc);
		                return ii !== -1 ? ii : null;
		            } else {
		                ii = indexOf.call(this._minWeekdaysParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._weekdaysParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._shortWeekdaysParse, llc);
		                return ii !== -1 ? ii : null;
		            }
		        }
		    }

		    function localeWeekdaysParse(weekdayName, format, strict) {
		        var i, mom, regex;

		        if (this._weekdaysParseExact) {
		            return handleStrictParse$1.call(this, weekdayName, format, strict);
		        }

		        if (!this._weekdaysParse) {
		            this._weekdaysParse = [];
		            this._minWeekdaysParse = [];
		            this._shortWeekdaysParse = [];
		            this._fullWeekdaysParse = [];
		        }

		        for (i = 0; i < 7; i++) {
		            // make the regex if we don't have it already

		            mom = createUTC([2000, 1]).day(i);
		            if (strict && !this._fullWeekdaysParse[i]) {
		                this._fullWeekdaysParse[i] = new RegExp(
		                    '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
		                    'i'
		                );
		                this._shortWeekdaysParse[i] = new RegExp(
		                    '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
		                    'i'
		                );
		                this._minWeekdaysParse[i] = new RegExp(
		                    '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
		                    'i'
		                );
		            }
		            if (!this._weekdaysParse[i]) {
		                regex =
		                    '^' +
		                    this.weekdays(mom, '') +
		                    '|^' +
		                    this.weekdaysShort(mom, '') +
		                    '|^' +
		                    this.weekdaysMin(mom, '');
		                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
		            }
		            // test the regex
		            if (
		                strict &&
		                format === 'dddd' &&
		                this._fullWeekdaysParse[i].test(weekdayName)
		            ) {
		                return i;
		            } else if (
		                strict &&
		                format === 'ddd' &&
		                this._shortWeekdaysParse[i].test(weekdayName)
		            ) {
		                return i;
		            } else if (
		                strict &&
		                format === 'dd' &&
		                this._minWeekdaysParse[i].test(weekdayName)
		            ) {
		                return i;
		            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
		                return i;
		            }
		        }
		    }

		    // MOMENTS

		    function getSetDayOfWeek(input) {
		        if (!this.isValid()) {
		            return input != null ? this : NaN;
		        }

		        var day = get(this, 'Day');
		        if (input != null) {
		            input = parseWeekday(input, this.localeData());
		            return this.add(input - day, 'd');
		        } else {
		            return day;
		        }
		    }

		    function getSetLocaleDayOfWeek(input) {
		        if (!this.isValid()) {
		            return input != null ? this : NaN;
		        }
		        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
		        return input == null ? weekday : this.add(input - weekday, 'd');
		    }

		    function getSetISODayOfWeek(input) {
		        if (!this.isValid()) {
		            return input != null ? this : NaN;
		        }

		        // behaves the same as moment#day except
		        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
		        // as a setter, sunday should belong to the previous week.

		        if (input != null) {
		            var weekday = parseIsoWeekday(input, this.localeData());
		            return this.day(this.day() % 7 ? weekday : weekday - 7);
		        } else {
		            return this.day() || 7;
		        }
		    }

		    function weekdaysRegex(isStrict) {
		        if (this._weekdaysParseExact) {
		            if (!hasOwnProp(this, '_weekdaysRegex')) {
		                computeWeekdaysParse.call(this);
		            }
		            if (isStrict) {
		                return this._weekdaysStrictRegex;
		            } else {
		                return this._weekdaysRegex;
		            }
		        } else {
		            if (!hasOwnProp(this, '_weekdaysRegex')) {
		                this._weekdaysRegex = defaultWeekdaysRegex;
		            }
		            return this._weekdaysStrictRegex && isStrict
		                ? this._weekdaysStrictRegex
		                : this._weekdaysRegex;
		        }
		    }

		    function weekdaysShortRegex(isStrict) {
		        if (this._weekdaysParseExact) {
		            if (!hasOwnProp(this, '_weekdaysRegex')) {
		                computeWeekdaysParse.call(this);
		            }
		            if (isStrict) {
		                return this._weekdaysShortStrictRegex;
		            } else {
		                return this._weekdaysShortRegex;
		            }
		        } else {
		            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
		                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
		            }
		            return this._weekdaysShortStrictRegex && isStrict
		                ? this._weekdaysShortStrictRegex
		                : this._weekdaysShortRegex;
		        }
		    }

		    function weekdaysMinRegex(isStrict) {
		        if (this._weekdaysParseExact) {
		            if (!hasOwnProp(this, '_weekdaysRegex')) {
		                computeWeekdaysParse.call(this);
		            }
		            if (isStrict) {
		                return this._weekdaysMinStrictRegex;
		            } else {
		                return this._weekdaysMinRegex;
		            }
		        } else {
		            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
		                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
		            }
		            return this._weekdaysMinStrictRegex && isStrict
		                ? this._weekdaysMinStrictRegex
		                : this._weekdaysMinRegex;
		        }
		    }

		    function computeWeekdaysParse() {
		        function cmpLenRev(a, b) {
		            return b.length - a.length;
		        }

		        var minPieces = [],
		            shortPieces = [],
		            longPieces = [],
		            mixedPieces = [],
		            i,
		            mom,
		            minp,
		            shortp,
		            longp;
		        for (i = 0; i < 7; i++) {
		            // make the regex if we don't have it already
		            mom = createUTC([2000, 1]).day(i);
		            minp = regexEscape(this.weekdaysMin(mom, ''));
		            shortp = regexEscape(this.weekdaysShort(mom, ''));
		            longp = regexEscape(this.weekdays(mom, ''));
		            minPieces.push(minp);
		            shortPieces.push(shortp);
		            longPieces.push(longp);
		            mixedPieces.push(minp);
		            mixedPieces.push(shortp);
		            mixedPieces.push(longp);
		        }
		        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
		        // will match the longer piece.
		        minPieces.sort(cmpLenRev);
		        shortPieces.sort(cmpLenRev);
		        longPieces.sort(cmpLenRev);
		        mixedPieces.sort(cmpLenRev);

		        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
		        this._weekdaysShortRegex = this._weekdaysRegex;
		        this._weekdaysMinRegex = this._weekdaysRegex;

		        this._weekdaysStrictRegex = new RegExp(
		            '^(' + longPieces.join('|') + ')',
		            'i'
		        );
		        this._weekdaysShortStrictRegex = new RegExp(
		            '^(' + shortPieces.join('|') + ')',
		            'i'
		        );
		        this._weekdaysMinStrictRegex = new RegExp(
		            '^(' + minPieces.join('|') + ')',
		            'i'
		        );
		    }

		    // FORMATTING

		    function hFormat() {
		        return this.hours() % 12 || 12;
		    }

		    function kFormat() {
		        return this.hours() || 24;
		    }

		    addFormatToken('H', ['HH', 2], 0, 'hour');
		    addFormatToken('h', ['hh', 2], 0, hFormat);
		    addFormatToken('k', ['kk', 2], 0, kFormat);

		    addFormatToken('hmm', 0, 0, function () {
		        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
		    });

		    addFormatToken('hmmss', 0, 0, function () {
		        return (
		            '' +
		            hFormat.apply(this) +
		            zeroFill(this.minutes(), 2) +
		            zeroFill(this.seconds(), 2)
		        );
		    });

		    addFormatToken('Hmm', 0, 0, function () {
		        return '' + this.hours() + zeroFill(this.minutes(), 2);
		    });

		    addFormatToken('Hmmss', 0, 0, function () {
		        return (
		            '' +
		            this.hours() +
		            zeroFill(this.minutes(), 2) +
		            zeroFill(this.seconds(), 2)
		        );
		    });

		    function meridiem(token, lowercase) {
		        addFormatToken(token, 0, 0, function () {
		            return this.localeData().meridiem(
		                this.hours(),
		                this.minutes(),
		                lowercase
		            );
		        });
		    }

		    meridiem('a', true);
		    meridiem('A', false);

		    // PARSING

		    function matchMeridiem(isStrict, locale) {
		        return locale._meridiemParse;
		    }

		    addRegexToken('a', matchMeridiem);
		    addRegexToken('A', matchMeridiem);
		    addRegexToken('H', match1to2, match1to2HasZero);
		    addRegexToken('h', match1to2, match1to2NoLeadingZero);
		    addRegexToken('k', match1to2, match1to2NoLeadingZero);
		    addRegexToken('HH', match1to2, match2);
		    addRegexToken('hh', match1to2, match2);
		    addRegexToken('kk', match1to2, match2);

		    addRegexToken('hmm', match3to4);
		    addRegexToken('hmmss', match5to6);
		    addRegexToken('Hmm', match3to4);
		    addRegexToken('Hmmss', match5to6);

		    addParseToken(['H', 'HH'], HOUR);
		    addParseToken(['k', 'kk'], function (input, array, config) {
		        var kInput = toInt(input);
		        array[HOUR] = kInput === 24 ? 0 : kInput;
		    });
		    addParseToken(['a', 'A'], function (input, array, config) {
		        config._isPm = config._locale.isPM(input);
		        config._meridiem = input;
		    });
		    addParseToken(['h', 'hh'], function (input, array, config) {
		        array[HOUR] = toInt(input);
		        getParsingFlags(config).bigHour = true;
		    });
		    addParseToken('hmm', function (input, array, config) {
		        var pos = input.length - 2;
		        array[HOUR] = toInt(input.substr(0, pos));
		        array[MINUTE] = toInt(input.substr(pos));
		        getParsingFlags(config).bigHour = true;
		    });
		    addParseToken('hmmss', function (input, array, config) {
		        var pos1 = input.length - 4,
		            pos2 = input.length - 2;
		        array[HOUR] = toInt(input.substr(0, pos1));
		        array[MINUTE] = toInt(input.substr(pos1, 2));
		        array[SECOND] = toInt(input.substr(pos2));
		        getParsingFlags(config).bigHour = true;
		    });
		    addParseToken('Hmm', function (input, array, config) {
		        var pos = input.length - 2;
		        array[HOUR] = toInt(input.substr(0, pos));
		        array[MINUTE] = toInt(input.substr(pos));
		    });
		    addParseToken('Hmmss', function (input, array, config) {
		        var pos1 = input.length - 4,
		            pos2 = input.length - 2;
		        array[HOUR] = toInt(input.substr(0, pos1));
		        array[MINUTE] = toInt(input.substr(pos1, 2));
		        array[SECOND] = toInt(input.substr(pos2));
		    });

		    // LOCALES

		    function localeIsPM(input) {
		        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
		        // Using charAt should be more compatible.
		        return (input + '').toLowerCase().charAt(0) === 'p';
		    }

		    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
		        // Setting the hour should keep the time, because the user explicitly
		        // specified which hour they want. So trying to maintain the same hour (in
		        // a new timezone) makes sense. Adding/subtracting hours does not follow
		        // this rule.
		        getSetHour = makeGetSet('Hours', true);

		    function localeMeridiem(hours, minutes, isLower) {
		        if (hours > 11) {
		            return isLower ? 'pm' : 'PM';
		        } else {
		            return isLower ? 'am' : 'AM';
		        }
		    }

		    var baseConfig = {
		        calendar: defaultCalendar,
		        longDateFormat: defaultLongDateFormat,
		        invalidDate: defaultInvalidDate,
		        ordinal: defaultOrdinal,
		        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
		        relativeTime: defaultRelativeTime,

		        months: defaultLocaleMonths,
		        monthsShort: defaultLocaleMonthsShort,

		        week: defaultLocaleWeek,

		        weekdays: defaultLocaleWeekdays,
		        weekdaysMin: defaultLocaleWeekdaysMin,
		        weekdaysShort: defaultLocaleWeekdaysShort,

		        meridiemParse: defaultLocaleMeridiemParse,
		    };

		    // internal storage for locale config files
		    var locales = {},
		        localeFamilies = {},
		        globalLocale;

		    function commonPrefix(arr1, arr2) {
		        var i,
		            minl = Math.min(arr1.length, arr2.length);
		        for (i = 0; i < minl; i += 1) {
		            if (arr1[i] !== arr2[i]) {
		                return i;
		            }
		        }
		        return minl;
		    }

		    function normalizeLocale(key) {
		        return key ? key.toLowerCase().replace('_', '-') : key;
		    }

		    // pick the locale from the array
		    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
		    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
		    function chooseLocale(names) {
		        var i = 0,
		            j,
		            next,
		            locale,
		            split;

		        while (i < names.length) {
		            split = normalizeLocale(names[i]).split('-');
		            j = split.length;
		            next = normalizeLocale(names[i + 1]);
		            next = next ? next.split('-') : null;
		            while (j > 0) {
		                locale = loadLocale(split.slice(0, j).join('-'));
		                if (locale) {
		                    return locale;
		                }
		                if (
		                    next &&
		                    next.length >= j &&
		                    commonPrefix(split, next) >= j - 1
		                ) {
		                    //the next array item is better than a shallower substring of this one
		                    break;
		                }
		                j--;
		            }
		            i++;
		        }
		        return globalLocale;
		    }

		    function isLocaleNameSane(name) {
		        // Prevent names that look like filesystem paths, i.e contain '/' or '\'
		        // Ensure name is available and function returns boolean
		        return !!(name && name.match('^[^/\\\\]*$'));
		    }

		    function loadLocale(name) {
		        var oldLocale = null,
		            aliasedRequire;
		        // TODO: Find a better way to register and load all the locales in Node
		        if (
		            locales[name] === undefined &&
		            'object' !== 'undefined' &&
		            module &&
		            module.exports &&
		            isLocaleNameSane(name)
		        ) {
		            try {
		                oldLocale = globalLocale._abbr;
		                aliasedRequire = commonjsRequire;
		                aliasedRequire('./locale/' + name);
		                getSetGlobalLocale(oldLocale);
		            } catch (e) {
		                // mark as not found to avoid repeating expensive file require call causing high CPU
		                // when trying to find en-US, en_US, en-us for every format call
		                locales[name] = null; // null means not found
		            }
		        }
		        return locales[name];
		    }

		    // This function will load locale and then set the global locale.  If
		    // no arguments are passed in, it will simply return the current global
		    // locale key.
		    function getSetGlobalLocale(key, values) {
		        var data;
		        if (key) {
		            if (isUndefined(values)) {
		                data = getLocale(key);
		            } else {
		                data = defineLocale(key, values);
		            }

		            if (data) {
		                // moment.duration._locale = moment._locale = data;
		                globalLocale = data;
		            } else {
		                if (typeof console !== 'undefined' && console.warn) {
		                    //warn user if arguments are passed but the locale could not be set
		                    console.warn(
		                        'Locale ' + key + ' not found. Did you forget to load it?'
		                    );
		                }
		            }
		        }

		        return globalLocale._abbr;
		    }

		    function defineLocale(name, config) {
		        if (config !== null) {
		            var locale,
		                parentConfig = baseConfig;
		            config.abbr = name;
		            if (locales[name] != null) {
		                deprecateSimple(
		                    'defineLocaleOverride',
		                    'use moment.updateLocale(localeName, config) to change ' +
		                        'an existing locale. moment.defineLocale(localeName, ' +
		                        'config) should only be used for creating a new locale ' +
		                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
		                );
		                parentConfig = locales[name]._config;
		            } else if (config.parentLocale != null) {
		                if (locales[config.parentLocale] != null) {
		                    parentConfig = locales[config.parentLocale]._config;
		                } else {
		                    locale = loadLocale(config.parentLocale);
		                    if (locale != null) {
		                        parentConfig = locale._config;
		                    } else {
		                        if (!localeFamilies[config.parentLocale]) {
		                            localeFamilies[config.parentLocale] = [];
		                        }
		                        localeFamilies[config.parentLocale].push({
		                            name: name,
		                            config: config,
		                        });
		                        return null;
		                    }
		                }
		            }
		            locales[name] = new Locale(mergeConfigs(parentConfig, config));

		            if (localeFamilies[name]) {
		                localeFamilies[name].forEach(function (x) {
		                    defineLocale(x.name, x.config);
		                });
		            }

		            // backwards compat for now: also set the locale
		            // make sure we set the locale AFTER all child locales have been
		            // created, so we won't end up with the child locale set.
		            getSetGlobalLocale(name);

		            return locales[name];
		        } else {
		            // useful for testing
		            delete locales[name];
		            return null;
		        }
		    }

		    function updateLocale(name, config) {
		        if (config != null) {
		            var locale,
		                tmpLocale,
		                parentConfig = baseConfig;

		            if (locales[name] != null && locales[name].parentLocale != null) {
		                // Update existing child locale in-place to avoid memory-leaks
		                locales[name].set(mergeConfigs(locales[name]._config, config));
		            } else {
		                // MERGE
		                tmpLocale = loadLocale(name);
		                if (tmpLocale != null) {
		                    parentConfig = tmpLocale._config;
		                }
		                config = mergeConfigs(parentConfig, config);
		                if (tmpLocale == null) {
		                    // updateLocale is called for creating a new locale
		                    // Set abbr so it will have a name (getters return
		                    // undefined otherwise).
		                    config.abbr = name;
		                }
		                locale = new Locale(config);
		                locale.parentLocale = locales[name];
		                locales[name] = locale;
		            }

		            // backwards compat for now: also set the locale
		            getSetGlobalLocale(name);
		        } else {
		            // pass null for config to unupdate, useful for tests
		            if (locales[name] != null) {
		                if (locales[name].parentLocale != null) {
		                    locales[name] = locales[name].parentLocale;
		                    if (name === getSetGlobalLocale()) {
		                        getSetGlobalLocale(name);
		                    }
		                } else if (locales[name] != null) {
		                    delete locales[name];
		                }
		            }
		        }
		        return locales[name];
		    }

		    // returns locale data
		    function getLocale(key) {
		        var locale;

		        if (key && key._locale && key._locale._abbr) {
		            key = key._locale._abbr;
		        }

		        if (!key) {
		            return globalLocale;
		        }

		        if (!isArray(key)) {
		            //short-circuit everything else
		            locale = loadLocale(key);
		            if (locale) {
		                return locale;
		            }
		            key = [key];
		        }

		        return chooseLocale(key);
		    }

		    function listLocales() {
		        return keys(locales);
		    }

		    function checkOverflow(m) {
		        var overflow,
		            a = m._a;

		        if (a && getParsingFlags(m).overflow === -2) {
		            overflow =
		                a[MONTH] < 0 || a[MONTH] > 11
		                    ? MONTH
		                    : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
		                      ? DATE
		                      : a[HOUR] < 0 ||
		                          a[HOUR] > 24 ||
		                          (a[HOUR] === 24 &&
		                              (a[MINUTE] !== 0 ||
		                                  a[SECOND] !== 0 ||
		                                  a[MILLISECOND] !== 0))
		                        ? HOUR
		                        : a[MINUTE] < 0 || a[MINUTE] > 59
		                          ? MINUTE
		                          : a[SECOND] < 0 || a[SECOND] > 59
		                            ? SECOND
		                            : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
		                              ? MILLISECOND
		                              : -1;

		            if (
		                getParsingFlags(m)._overflowDayOfYear &&
		                (overflow < YEAR || overflow > DATE)
		            ) {
		                overflow = DATE;
		            }
		            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
		                overflow = WEEK;
		            }
		            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
		                overflow = WEEKDAY;
		            }

		            getParsingFlags(m).overflow = overflow;
		        }

		        return m;
		    }

		    // iso 8601 regex
		    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
		    var extendedIsoRegex =
		            /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
		        basicIsoRegex =
		            /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
		        tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
		        isoDates = [
		            ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
		            ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
		            ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
		            ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
		            ['YYYY-DDD', /\d{4}-\d{3}/],
		            ['YYYY-MM', /\d{4}-\d\d/, false],
		            ['YYYYYYMMDD', /[+-]\d{10}/],
		            ['YYYYMMDD', /\d{8}/],
		            ['GGGG[W]WWE', /\d{4}W\d{3}/],
		            ['GGGG[W]WW', /\d{4}W\d{2}/, false],
		            ['YYYYDDD', /\d{7}/],
		            ['YYYYMM', /\d{6}/, false],
		            ['YYYY', /\d{4}/, false],
		        ],
		        // iso time formats and regexes
		        isoTimes = [
		            ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
		            ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
		            ['HH:mm:ss', /\d\d:\d\d:\d\d/],
		            ['HH:mm', /\d\d:\d\d/],
		            ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
		            ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
		            ['HHmmss', /\d\d\d\d\d\d/],
		            ['HHmm', /\d\d\d\d/],
		            ['HH', /\d\d/],
		        ],
		        aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
		        // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
		        rfc2822 =
		            /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
		        obsOffsets = {
		            UT: 0,
		            GMT: 0,
		            EDT: -4 * 60,
		            EST: -5 * 60,
		            CDT: -5 * 60,
		            CST: -6 * 60,
		            MDT: -6 * 60,
		            MST: -7 * 60,
		            PDT: -7 * 60,
		            PST: -8 * 60,
		        };

		    // date from iso format
		    function configFromISO(config) {
		        var i,
		            l,
		            string = config._i,
		            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
		            allowTime,
		            dateFormat,
		            timeFormat,
		            tzFormat,
		            isoDatesLen = isoDates.length,
		            isoTimesLen = isoTimes.length;

		        if (match) {
		            getParsingFlags(config).iso = true;
		            for (i = 0, l = isoDatesLen; i < l; i++) {
		                if (isoDates[i][1].exec(match[1])) {
		                    dateFormat = isoDates[i][0];
		                    allowTime = isoDates[i][2] !== false;
		                    break;
		                }
		            }
		            if (dateFormat == null) {
		                config._isValid = false;
		                return;
		            }
		            if (match[3]) {
		                for (i = 0, l = isoTimesLen; i < l; i++) {
		                    if (isoTimes[i][1].exec(match[3])) {
		                        // match[2] should be 'T' or space
		                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
		                        break;
		                    }
		                }
		                if (timeFormat == null) {
		                    config._isValid = false;
		                    return;
		                }
		            }
		            if (!allowTime && timeFormat != null) {
		                config._isValid = false;
		                return;
		            }
		            if (match[4]) {
		                if (tzRegex.exec(match[4])) {
		                    tzFormat = 'Z';
		                } else {
		                    config._isValid = false;
		                    return;
		                }
		            }
		            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
		            configFromStringAndFormat(config);
		        } else {
		            config._isValid = false;
		        }
		    }

		    function extractFromRFC2822Strings(
		        yearStr,
		        monthStr,
		        dayStr,
		        hourStr,
		        minuteStr,
		        secondStr
		    ) {
		        var result = [
		            untruncateYear(yearStr),
		            defaultLocaleMonthsShort.indexOf(monthStr),
		            parseInt(dayStr, 10),
		            parseInt(hourStr, 10),
		            parseInt(minuteStr, 10),
		        ];

		        if (secondStr) {
		            result.push(parseInt(secondStr, 10));
		        }

		        return result;
		    }

		    function untruncateYear(yearStr) {
		        var year = parseInt(yearStr, 10);
		        if (year <= 49) {
		            return 2000 + year;
		        } else if (year <= 999) {
		            return 1900 + year;
		        }
		        return year;
		    }

		    function preprocessRFC2822(s) {
		        // Remove comments and folding whitespace and replace multiple-spaces with a single space
		        return s
		            .replace(/\([^()]*\)|[\n\t]/g, ' ')
		            .replace(/(\s\s+)/g, ' ')
		            .replace(/^\s\s*/, '')
		            .replace(/\s\s*$/, '');
		    }

		    function checkWeekday(weekdayStr, parsedInput, config) {
		        if (weekdayStr) {
		            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
		            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
		                weekdayActual = new Date(
		                    parsedInput[0],
		                    parsedInput[1],
		                    parsedInput[2]
		                ).getDay();
		            if (weekdayProvided !== weekdayActual) {
		                getParsingFlags(config).weekdayMismatch = true;
		                config._isValid = false;
		                return false;
		            }
		        }
		        return true;
		    }

		    function calculateOffset(obsOffset, militaryOffset, numOffset) {
		        if (obsOffset) {
		            return obsOffsets[obsOffset];
		        } else if (militaryOffset) {
		            // the only allowed military tz is Z
		            return 0;
		        } else {
		            var hm = parseInt(numOffset, 10),
		                m = hm % 100,
		                h = (hm - m) / 100;
		            return h * 60 + m;
		        }
		    }

		    // date and time from ref 2822 format
		    function configFromRFC2822(config) {
		        var match = rfc2822.exec(preprocessRFC2822(config._i)),
		            parsedArray;
		        if (match) {
		            parsedArray = extractFromRFC2822Strings(
		                match[4],
		                match[3],
		                match[2],
		                match[5],
		                match[6],
		                match[7]
		            );
		            if (!checkWeekday(match[1], parsedArray, config)) {
		                return;
		            }

		            config._a = parsedArray;
		            config._tzm = calculateOffset(match[8], match[9], match[10]);

		            config._d = createUTCDate.apply(null, config._a);
		            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

		            getParsingFlags(config).rfc2822 = true;
		        } else {
		            config._isValid = false;
		        }
		    }

		    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
		    function configFromString(config) {
		        var matched = aspNetJsonRegex.exec(config._i);
		        if (matched !== null) {
		            config._d = new Date(+matched[1]);
		            return;
		        }

		        configFromISO(config);
		        if (config._isValid === false) {
		            delete config._isValid;
		        } else {
		            return;
		        }

		        configFromRFC2822(config);
		        if (config._isValid === false) {
		            delete config._isValid;
		        } else {
		            return;
		        }

		        if (config._strict) {
		            config._isValid = false;
		        } else {
		            // Final attempt, use Input Fallback
		            hooks.createFromInputFallback(config);
		        }
		    }

		    hooks.createFromInputFallback = deprecate(
		        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
		            'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
		            'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
		        function (config) {
		            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
		        }
		    );

		    // Pick the first defined of two or three arguments.
		    function defaults(a, b, c) {
		        if (a != null) {
		            return a;
		        }
		        if (b != null) {
		            return b;
		        }
		        return c;
		    }

		    function currentDateArray(config) {
		        // hooks is actually the exported moment object
		        var nowValue = new Date(hooks.now());
		        if (config._useUTC) {
		            return [
		                nowValue.getUTCFullYear(),
		                nowValue.getUTCMonth(),
		                nowValue.getUTCDate(),
		            ];
		        }
		        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
		    }

		    // convert an array to a date.
		    // the array should mirror the parameters below
		    // note: all values past the year are optional and will default to the lowest possible value.
		    // [year, month, day , hour, minute, second, millisecond]
		    function configFromArray(config) {
		        var i,
		            date,
		            input = [],
		            currentDate,
		            expectedWeekday,
		            yearToUse;

		        if (config._d) {
		            return;
		        }

		        currentDate = currentDateArray(config);

		        //compute day of the year from weeks and weekdays
		        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
		            dayOfYearFromWeekInfo(config);
		        }

		        //if the day of the year is set, figure out what it is
		        if (config._dayOfYear != null) {
		            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

		            if (
		                config._dayOfYear > daysInYear(yearToUse) ||
		                config._dayOfYear === 0
		            ) {
		                getParsingFlags(config)._overflowDayOfYear = true;
		            }

		            date = createUTCDate(yearToUse, 0, config._dayOfYear);
		            config._a[MONTH] = date.getUTCMonth();
		            config._a[DATE] = date.getUTCDate();
		        }

		        // Default to current date.
		        // * if no year, month, day of month are given, default to today
		        // * if day of month is given, default month and year
		        // * if month is given, default only year
		        // * if year is given, don't default anything
		        for (i = 0; i < 3 && config._a[i] == null; ++i) {
		            config._a[i] = input[i] = currentDate[i];
		        }

		        // Zero out whatever was not defaulted, including time
		        for (; i < 7; i++) {
		            config._a[i] = input[i] =
		                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
		        }

		        // Check for 24:00:00.000
		        if (
		            config._a[HOUR] === 24 &&
		            config._a[MINUTE] === 0 &&
		            config._a[SECOND] === 0 &&
		            config._a[MILLISECOND] === 0
		        ) {
		            config._nextDay = true;
		            config._a[HOUR] = 0;
		        }

		        config._d = (config._useUTC ? createUTCDate : createDate).apply(
		            null,
		            input
		        );
		        expectedWeekday = config._useUTC
		            ? config._d.getUTCDay()
		            : config._d.getDay();

		        // Apply timezone offset from input. The actual utcOffset can be changed
		        // with parseZone.
		        if (config._tzm != null) {
		            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
		        }

		        if (config._nextDay) {
		            config._a[HOUR] = 24;
		        }

		        // check for mismatching day of week
		        if (
		            config._w &&
		            typeof config._w.d !== 'undefined' &&
		            config._w.d !== expectedWeekday
		        ) {
		            getParsingFlags(config).weekdayMismatch = true;
		        }
		    }

		    function dayOfYearFromWeekInfo(config) {
		        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

		        w = config._w;
		        if (w.GG != null || w.W != null || w.E != null) {
		            dow = 1;
		            doy = 4;

		            // TODO: We need to take the current isoWeekYear, but that depends on
		            // how we interpret now (local, utc, fixed offset). So create
		            // a now version of current config (take local/utc/offset flags, and
		            // create now).
		            weekYear = defaults(
		                w.GG,
		                config._a[YEAR],
		                weekOfYear(createLocal(), 1, 4).year
		            );
		            week = defaults(w.W, 1);
		            weekday = defaults(w.E, 1);
		            if (weekday < 1 || weekday > 7) {
		                weekdayOverflow = true;
		            }
		        } else {
		            dow = config._locale._week.dow;
		            doy = config._locale._week.doy;

		            curWeek = weekOfYear(createLocal(), dow, doy);

		            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

		            // Default to current week.
		            week = defaults(w.w, curWeek.week);

		            if (w.d != null) {
		                // weekday -- low day numbers are considered next week
		                weekday = w.d;
		                if (weekday < 0 || weekday > 6) {
		                    weekdayOverflow = true;
		                }
		            } else if (w.e != null) {
		                // local weekday -- counting starts from beginning of week
		                weekday = w.e + dow;
		                if (w.e < 0 || w.e > 6) {
		                    weekdayOverflow = true;
		                }
		            } else {
		                // default to beginning of week
		                weekday = dow;
		            }
		        }
		        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
		            getParsingFlags(config)._overflowWeeks = true;
		        } else if (weekdayOverflow != null) {
		            getParsingFlags(config)._overflowWeekday = true;
		        } else {
		            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
		            config._a[YEAR] = temp.year;
		            config._dayOfYear = temp.dayOfYear;
		        }
		    }

		    // constant that refers to the ISO standard
		    hooks.ISO_8601 = function () {};

		    // constant that refers to the RFC 2822 form
		    hooks.RFC_2822 = function () {};

		    // date from string and format string
		    function configFromStringAndFormat(config) {
		        // TODO: Move this to another part of the creation flow to prevent circular deps
		        if (config._f === hooks.ISO_8601) {
		            configFromISO(config);
		            return;
		        }
		        if (config._f === hooks.RFC_2822) {
		            configFromRFC2822(config);
		            return;
		        }
		        config._a = [];
		        getParsingFlags(config).empty = true;

		        // This array is used to make a Date, either with `new Date` or `Date.UTC`
		        var string = '' + config._i,
		            i,
		            parsedInput,
		            tokens,
		            token,
		            skipped,
		            stringLength = string.length,
		            totalParsedInputLength = 0,
		            era,
		            tokenLen;

		        tokens =
		            expandFormat(config._f, config._locale).match(formattingTokens) || [];
		        tokenLen = tokens.length;
		        for (i = 0; i < tokenLen; i++) {
		            token = tokens[i];
		            parsedInput = (string.match(getParseRegexForToken(token, config)) ||
		                [])[0];
		            if (parsedInput) {
		                skipped = string.substr(0, string.indexOf(parsedInput));
		                if (skipped.length > 0) {
		                    getParsingFlags(config).unusedInput.push(skipped);
		                }
		                string = string.slice(
		                    string.indexOf(parsedInput) + parsedInput.length
		                );
		                totalParsedInputLength += parsedInput.length;
		            }
		            // don't parse if it's not a known token
		            if (formatTokenFunctions[token]) {
		                if (parsedInput) {
		                    getParsingFlags(config).empty = false;
		                } else {
		                    getParsingFlags(config).unusedTokens.push(token);
		                }
		                addTimeToArrayFromToken(token, parsedInput, config);
		            } else if (config._strict && !parsedInput) {
		                getParsingFlags(config).unusedTokens.push(token);
		            }
		        }

		        // add remaining unparsed input length to the string
		        getParsingFlags(config).charsLeftOver =
		            stringLength - totalParsedInputLength;
		        if (string.length > 0) {
		            getParsingFlags(config).unusedInput.push(string);
		        }

		        // clear _12h flag if hour is <= 12
		        if (
		            config._a[HOUR] <= 12 &&
		            getParsingFlags(config).bigHour === true &&
		            config._a[HOUR] > 0
		        ) {
		            getParsingFlags(config).bigHour = undefined;
		        }

		        getParsingFlags(config).parsedDateParts = config._a.slice(0);
		        getParsingFlags(config).meridiem = config._meridiem;
		        // handle meridiem
		        config._a[HOUR] = meridiemFixWrap(
		            config._locale,
		            config._a[HOUR],
		            config._meridiem
		        );

		        // handle era
		        era = getParsingFlags(config).era;
		        if (era !== null) {
		            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
		        }

		        configFromArray(config);
		        checkOverflow(config);
		    }

		    function meridiemFixWrap(locale, hour, meridiem) {
		        var isPm;

		        if (meridiem == null) {
		            // nothing to do
		            return hour;
		        }
		        if (locale.meridiemHour != null) {
		            return locale.meridiemHour(hour, meridiem);
		        } else if (locale.isPM != null) {
		            // Fallback
		            isPm = locale.isPM(meridiem);
		            if (isPm && hour < 12) {
		                hour += 12;
		            }
		            if (!isPm && hour === 12) {
		                hour = 0;
		            }
		            return hour;
		        } else {
		            // this is not supposed to happen
		            return hour;
		        }
		    }

		    // date from string and array of format strings
		    function configFromStringAndArray(config) {
		        var tempConfig,
		            bestMoment,
		            scoreToBeat,
		            i,
		            currentScore,
		            validFormatFound,
		            bestFormatIsValid = false,
		            configfLen = config._f.length;

		        if (configfLen === 0) {
		            getParsingFlags(config).invalidFormat = true;
		            config._d = new Date(NaN);
		            return;
		        }

		        for (i = 0; i < configfLen; i++) {
		            currentScore = 0;
		            validFormatFound = false;
		            tempConfig = copyConfig({}, config);
		            if (config._useUTC != null) {
		                tempConfig._useUTC = config._useUTC;
		            }
		            tempConfig._f = config._f[i];
		            configFromStringAndFormat(tempConfig);

		            if (isValid(tempConfig)) {
		                validFormatFound = true;
		            }

		            // if there is any input that was not parsed add a penalty for that format
		            currentScore += getParsingFlags(tempConfig).charsLeftOver;

		            //or tokens
		            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

		            getParsingFlags(tempConfig).score = currentScore;

		            if (!bestFormatIsValid) {
		                if (
		                    scoreToBeat == null ||
		                    currentScore < scoreToBeat ||
		                    validFormatFound
		                ) {
		                    scoreToBeat = currentScore;
		                    bestMoment = tempConfig;
		                    if (validFormatFound) {
		                        bestFormatIsValid = true;
		                    }
		                }
		            } else {
		                if (currentScore < scoreToBeat) {
		                    scoreToBeat = currentScore;
		                    bestMoment = tempConfig;
		                }
		            }
		        }

		        extend(config, bestMoment || tempConfig);
		    }

		    function configFromObject(config) {
		        if (config._d) {
		            return;
		        }

		        var i = normalizeObjectUnits(config._i),
		            dayOrDate = i.day === undefined ? i.date : i.day;
		        config._a = map(
		            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
		            function (obj) {
		                return obj && parseInt(obj, 10);
		            }
		        );

		        configFromArray(config);
		    }

		    function createFromConfig(config) {
		        var res = new Moment(checkOverflow(prepareConfig(config)));
		        if (res._nextDay) {
		            // Adding is smart enough around DST
		            res.add(1, 'd');
		            res._nextDay = undefined;
		        }

		        return res;
		    }

		    function prepareConfig(config) {
		        var input = config._i,
		            format = config._f;

		        config._locale = config._locale || getLocale(config._l);

		        if (input === null || (format === undefined && input === '')) {
		            return createInvalid({ nullInput: true });
		        }

		        if (typeof input === 'string') {
		            config._i = input = config._locale.preparse(input);
		        }

		        if (isMoment(input)) {
		            return new Moment(checkOverflow(input));
		        } else if (isDate(input)) {
		            config._d = input;
		        } else if (isArray(format)) {
		            configFromStringAndArray(config);
		        } else if (format) {
		            configFromStringAndFormat(config);
		        } else {
		            configFromInput(config);
		        }

		        if (!isValid(config)) {
		            config._d = null;
		        }

		        return config;
		    }

		    function configFromInput(config) {
		        var input = config._i;
		        if (isUndefined(input)) {
		            config._d = new Date(hooks.now());
		        } else if (isDate(input)) {
		            config._d = new Date(input.valueOf());
		        } else if (typeof input === 'string') {
		            configFromString(config);
		        } else if (isArray(input)) {
		            config._a = map(input.slice(0), function (obj) {
		                return parseInt(obj, 10);
		            });
		            configFromArray(config);
		        } else if (isObject(input)) {
		            configFromObject(config);
		        } else if (isNumber(input)) {
		            // from milliseconds
		            config._d = new Date(input);
		        } else {
		            hooks.createFromInputFallback(config);
		        }
		    }

		    function createLocalOrUTC(input, format, locale, strict, isUTC) {
		        var c = {};

		        if (format === true || format === false) {
		            strict = format;
		            format = undefined;
		        }

		        if (locale === true || locale === false) {
		            strict = locale;
		            locale = undefined;
		        }

		        if (
		            (isObject(input) && isObjectEmpty(input)) ||
		            (isArray(input) && input.length === 0)
		        ) {
		            input = undefined;
		        }
		        // object construction must be done this way.
		        // https://github.com/moment/moment/issues/1423
		        c._isAMomentObject = true;
		        c._useUTC = c._isUTC = isUTC;
		        c._l = locale;
		        c._i = input;
		        c._f = format;
		        c._strict = strict;

		        return createFromConfig(c);
		    }

		    function createLocal(input, format, locale, strict) {
		        return createLocalOrUTC(input, format, locale, strict, false);
		    }

		    var prototypeMin = deprecate(
		            'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
		            function () {
		                var other = createLocal.apply(null, arguments);
		                if (this.isValid() && other.isValid()) {
		                    return other < this ? this : other;
		                } else {
		                    return createInvalid();
		                }
		            }
		        ),
		        prototypeMax = deprecate(
		            'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
		            function () {
		                var other = createLocal.apply(null, arguments);
		                if (this.isValid() && other.isValid()) {
		                    return other > this ? this : other;
		                } else {
		                    return createInvalid();
		                }
		            }
		        );

		    // Pick a moment m from moments so that m[fn](other) is true for all
		    // other. This relies on the function fn to be transitive.
		    //
		    // moments should either be an array of moment objects or an array, whose
		    // first element is an array of moment objects.
		    function pickBy(fn, moments) {
		        var res, i;
		        if (moments.length === 1 && isArray(moments[0])) {
		            moments = moments[0];
		        }
		        if (!moments.length) {
		            return createLocal();
		        }
		        res = moments[0];
		        for (i = 1; i < moments.length; ++i) {
		            if (!moments[i].isValid() || moments[i][fn](res)) {
		                res = moments[i];
		            }
		        }
		        return res;
		    }

		    // TODO: Use [].sort instead?
		    function min() {
		        var args = [].slice.call(arguments, 0);

		        return pickBy('isBefore', args);
		    }

		    function max() {
		        var args = [].slice.call(arguments, 0);

		        return pickBy('isAfter', args);
		    }

		    var now = function () {
		        return Date.now ? Date.now() : +new Date();
		    };

		    var ordering = [
		        'year',
		        'quarter',
		        'month',
		        'week',
		        'day',
		        'hour',
		        'minute',
		        'second',
		        'millisecond',
		    ];

		    function isDurationValid(m) {
		        var key,
		            unitHasDecimal = false,
		            i,
		            orderLen = ordering.length;
		        for (key in m) {
		            if (
		                hasOwnProp(m, key) &&
		                !(
		                    indexOf.call(ordering, key) !== -1 &&
		                    (m[key] == null || !isNaN(m[key]))
		                )
		            ) {
		                return false;
		            }
		        }

		        for (i = 0; i < orderLen; ++i) {
		            if (m[ordering[i]]) {
		                if (unitHasDecimal) {
		                    return false; // only allow non-integers for smallest unit
		                }
		                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
		                    unitHasDecimal = true;
		                }
		            }
		        }

		        return true;
		    }

		    function isValid$1() {
		        return this._isValid;
		    }

		    function createInvalid$1() {
		        return createDuration(NaN);
		    }

		    function Duration(duration) {
		        var normalizedInput = normalizeObjectUnits(duration),
		            years = normalizedInput.year || 0,
		            quarters = normalizedInput.quarter || 0,
		            months = normalizedInput.month || 0,
		            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
		            days = normalizedInput.day || 0,
		            hours = normalizedInput.hour || 0,
		            minutes = normalizedInput.minute || 0,
		            seconds = normalizedInput.second || 0,
		            milliseconds = normalizedInput.millisecond || 0;

		        this._isValid = isDurationValid(normalizedInput);

		        // representation for dateAddRemove
		        this._milliseconds =
		            +milliseconds +
		            seconds * 1e3 + // 1000
		            minutes * 6e4 + // 1000 * 60
		            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
		        // Because of dateAddRemove treats 24 hours as different from a
		        // day when working around DST, we need to store them separately
		        this._days = +days + weeks * 7;
		        // It is impossible to translate months into days without knowing
		        // which months you are are talking about, so we have to store
		        // it separately.
		        this._months = +months + quarters * 3 + years * 12;

		        this._data = {};

		        this._locale = getLocale();

		        this._bubble();
		    }

		    function isDuration(obj) {
		        return obj instanceof Duration;
		    }

		    function absRound(number) {
		        if (number < 0) {
		            return Math.round(-1 * number) * -1;
		        } else {
		            return Math.round(number);
		        }
		    }

		    // compare two arrays, return the number of differences
		    function compareArrays(array1, array2, dontConvert) {
		        var len = Math.min(array1.length, array2.length),
		            lengthDiff = Math.abs(array1.length - array2.length),
		            diffs = 0,
		            i;
		        for (i = 0; i < len; i++) {
		            if (
		                (toInt(array1[i]) !== toInt(array2[i]))
		            ) {
		                diffs++;
		            }
		        }
		        return diffs + lengthDiff;
		    }

		    // FORMATTING

		    function offset(token, separator) {
		        addFormatToken(token, 0, 0, function () {
		            var offset = this.utcOffset(),
		                sign = '+';
		            if (offset < 0) {
		                offset = -offset;
		                sign = '-';
		            }
		            return (
		                sign +
		                zeroFill(~~(offset / 60), 2) +
		                separator +
		                zeroFill(~~offset % 60, 2)
		            );
		        });
		    }

		    offset('Z', ':');
		    offset('ZZ', '');

		    // PARSING

		    addRegexToken('Z', matchShortOffset);
		    addRegexToken('ZZ', matchShortOffset);
		    addParseToken(['Z', 'ZZ'], function (input, array, config) {
		        config._useUTC = true;
		        config._tzm = offsetFromString(matchShortOffset, input);
		    });

		    // HELPERS

		    // timezone chunker
		    // '+10:00' > ['10',  '00']
		    // '-1530'  > ['-15', '30']
		    var chunkOffset = /([\+\-]|\d\d)/gi;

		    function offsetFromString(matcher, string) {
		        var matches = (string || '').match(matcher),
		            chunk,
		            parts,
		            minutes;

		        if (matches === null) {
		            return null;
		        }

		        chunk = matches[matches.length - 1] || [];
		        parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
		        minutes = +(parts[1] * 60) + toInt(parts[2]);

		        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
		    }

		    // Return a moment from input, that is local/utc/zone equivalent to model.
		    function cloneWithOffset(input, model) {
		        var res, diff;
		        if (model._isUTC) {
		            res = model.clone();
		            diff =
		                (isMoment(input) || isDate(input)
		                    ? input.valueOf()
		                    : createLocal(input).valueOf()) - res.valueOf();
		            // Use low-level api, because this fn is low-level api.
		            res._d.setTime(res._d.valueOf() + diff);
		            hooks.updateOffset(res, false);
		            return res;
		        } else {
		            return createLocal(input).local();
		        }
		    }

		    function getDateOffset(m) {
		        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
		        // https://github.com/moment/moment/pull/1871
		        return -Math.round(m._d.getTimezoneOffset());
		    }

		    // HOOKS

		    // This function will be called whenever a moment is mutated.
		    // It is intended to keep the offset in sync with the timezone.
		    hooks.updateOffset = function () {};

		    // MOMENTS

		    // keepLocalTime = true means only change the timezone, without
		    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
		    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
		    // +0200, so we adjust the time as needed, to be valid.
		    //
		    // Keeping the time actually adds/subtracts (one hour)
		    // from the actual represented time. That is why we call updateOffset
		    // a second time. In case it wants us to change the offset again
		    // _changeInProgress == true case, then we have to adjust, because
		    // there is no such time in the given timezone.
		    function getSetOffset(input, keepLocalTime, keepMinutes) {
		        var offset = this._offset || 0,
		            localAdjust;
		        if (!this.isValid()) {
		            return input != null ? this : NaN;
		        }
		        if (input != null) {
		            if (typeof input === 'string') {
		                input = offsetFromString(matchShortOffset, input);
		                if (input === null) {
		                    return this;
		                }
		            } else if (Math.abs(input) < 16 && !keepMinutes) {
		                input = input * 60;
		            }
		            if (!this._isUTC && keepLocalTime) {
		                localAdjust = getDateOffset(this);
		            }
		            this._offset = input;
		            this._isUTC = true;
		            if (localAdjust != null) {
		                this.add(localAdjust, 'm');
		            }
		            if (offset !== input) {
		                if (!keepLocalTime || this._changeInProgress) {
		                    addSubtract(
		                        this,
		                        createDuration(input - offset, 'm'),
		                        1,
		                        false
		                    );
		                } else if (!this._changeInProgress) {
		                    this._changeInProgress = true;
		                    hooks.updateOffset(this, true);
		                    this._changeInProgress = null;
		                }
		            }
		            return this;
		        } else {
		            return this._isUTC ? offset : getDateOffset(this);
		        }
		    }

		    function getSetZone(input, keepLocalTime) {
		        if (input != null) {
		            if (typeof input !== 'string') {
		                input = -input;
		            }

		            this.utcOffset(input, keepLocalTime);

		            return this;
		        } else {
		            return -this.utcOffset();
		        }
		    }

		    function setOffsetToUTC(keepLocalTime) {
		        return this.utcOffset(0, keepLocalTime);
		    }

		    function setOffsetToLocal(keepLocalTime) {
		        if (this._isUTC) {
		            this.utcOffset(0, keepLocalTime);
		            this._isUTC = false;

		            if (keepLocalTime) {
		                this.subtract(getDateOffset(this), 'm');
		            }
		        }
		        return this;
		    }

		    function setOffsetToParsedOffset() {
		        if (this._tzm != null) {
		            this.utcOffset(this._tzm, false, true);
		        } else if (typeof this._i === 'string') {
		            var tZone = offsetFromString(matchOffset, this._i);
		            if (tZone != null) {
		                this.utcOffset(tZone);
		            } else {
		                this.utcOffset(0, true);
		            }
		        }
		        return this;
		    }

		    function hasAlignedHourOffset(input) {
		        if (!this.isValid()) {
		            return false;
		        }
		        input = input ? createLocal(input).utcOffset() : 0;

		        return (this.utcOffset() - input) % 60 === 0;
		    }

		    function isDaylightSavingTime() {
		        return (
		            this.utcOffset() > this.clone().month(0).utcOffset() ||
		            this.utcOffset() > this.clone().month(5).utcOffset()
		        );
		    }

		    function isDaylightSavingTimeShifted() {
		        if (!isUndefined(this._isDSTShifted)) {
		            return this._isDSTShifted;
		        }

		        var c = {},
		            other;

		        copyConfig(c, this);
		        c = prepareConfig(c);

		        if (c._a) {
		            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
		            this._isDSTShifted =
		                this.isValid() && compareArrays(c._a, other.toArray()) > 0;
		        } else {
		            this._isDSTShifted = false;
		        }

		        return this._isDSTShifted;
		    }

		    function isLocal() {
		        return this.isValid() ? !this._isUTC : false;
		    }

		    function isUtcOffset() {
		        return this.isValid() ? this._isUTC : false;
		    }

		    function isUtc() {
		        return this.isValid() ? this._isUTC && this._offset === 0 : false;
		    }

		    // ASP.NET json date format regex
		    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
		        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
		        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
		        // and further modified to allow for strings containing both week and day
		        isoRegex =
		            /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

		    function createDuration(input, key) {
		        var duration = input,
		            // matching against regexp is expensive, do it on demand
		            match = null,
		            sign,
		            ret,
		            diffRes;

		        if (isDuration(input)) {
		            duration = {
		                ms: input._milliseconds,
		                d: input._days,
		                M: input._months,
		            };
		        } else if (isNumber(input) || !isNaN(+input)) {
		            duration = {};
		            if (key) {
		                duration[key] = +input;
		            } else {
		                duration.milliseconds = +input;
		            }
		        } else if ((match = aspNetRegex.exec(input))) {
		            sign = match[1] === '-' ? -1 : 1;
		            duration = {
		                y: 0,
		                d: toInt(match[DATE]) * sign,
		                h: toInt(match[HOUR]) * sign,
		                m: toInt(match[MINUTE]) * sign,
		                s: toInt(match[SECOND]) * sign,
		                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
		            };
		        } else if ((match = isoRegex.exec(input))) {
		            sign = match[1] === '-' ? -1 : 1;
		            duration = {
		                y: parseIso(match[2], sign),
		                M: parseIso(match[3], sign),
		                w: parseIso(match[4], sign),
		                d: parseIso(match[5], sign),
		                h: parseIso(match[6], sign),
		                m: parseIso(match[7], sign),
		                s: parseIso(match[8], sign),
		            };
		        } else if (duration == null) {
		            // checks for null or undefined
		            duration = {};
		        } else if (
		            typeof duration === 'object' &&
		            ('from' in duration || 'to' in duration)
		        ) {
		            diffRes = momentsDifference(
		                createLocal(duration.from),
		                createLocal(duration.to)
		            );

		            duration = {};
		            duration.ms = diffRes.milliseconds;
		            duration.M = diffRes.months;
		        }

		        ret = new Duration(duration);

		        if (isDuration(input) && hasOwnProp(input, '_locale')) {
		            ret._locale = input._locale;
		        }

		        if (isDuration(input) && hasOwnProp(input, '_isValid')) {
		            ret._isValid = input._isValid;
		        }

		        return ret;
		    }

		    createDuration.fn = Duration.prototype;
		    createDuration.invalid = createInvalid$1;

		    function parseIso(inp, sign) {
		        // We'd normally use ~~inp for this, but unfortunately it also
		        // converts floats to ints.
		        // inp may be undefined, so careful calling replace on it.
		        var res = inp && parseFloat(inp.replace(',', '.'));
		        // apply sign while we're at it
		        return (isNaN(res) ? 0 : res) * sign;
		    }

		    function positiveMomentsDifference(base, other) {
		        var res = {};

		        res.months =
		            other.month() - base.month() + (other.year() - base.year()) * 12;
		        if (base.clone().add(res.months, 'M').isAfter(other)) {
		            --res.months;
		        }

		        res.milliseconds = +other - +base.clone().add(res.months, 'M');

		        return res;
		    }

		    function momentsDifference(base, other) {
		        var res;
		        if (!(base.isValid() && other.isValid())) {
		            return { milliseconds: 0, months: 0 };
		        }

		        other = cloneWithOffset(other, base);
		        if (base.isBefore(other)) {
		            res = positiveMomentsDifference(base, other);
		        } else {
		            res = positiveMomentsDifference(other, base);
		            res.milliseconds = -res.milliseconds;
		            res.months = -res.months;
		        }

		        return res;
		    }

		    // TODO: remove 'name' arg after deprecation is removed
		    function createAdder(direction, name) {
		        return function (val, period) {
		            var dur, tmp;
		            //invert the arguments, but complain about it
		            if (period !== null && !isNaN(+period)) {
		                deprecateSimple(
		                    name,
		                    'moment().' +
		                        name +
		                        '(period, number) is deprecated. Please use moment().' +
		                        name +
		                        '(number, period). ' +
		                        'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
		                );
		                tmp = val;
		                val = period;
		                period = tmp;
		            }

		            dur = createDuration(val, period);
		            addSubtract(this, dur, direction);
		            return this;
		        };
		    }

		    function addSubtract(mom, duration, isAdding, updateOffset) {
		        var milliseconds = duration._milliseconds,
		            days = absRound(duration._days),
		            months = absRound(duration._months);

		        if (!mom.isValid()) {
		            // No op
		            return;
		        }

		        updateOffset = updateOffset == null ? true : updateOffset;

		        if (months) {
		            setMonth(mom, get(mom, 'Month') + months * isAdding);
		        }
		        if (days) {
		            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
		        }
		        if (milliseconds) {
		            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
		        }
		        if (updateOffset) {
		            hooks.updateOffset(mom, days || months);
		        }
		    }

		    var add = createAdder(1, 'add'),
		        subtract = createAdder(-1, 'subtract');

		    function isString(input) {
		        return typeof input === 'string' || input instanceof String;
		    }

		    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
		    function isMomentInput(input) {
		        return (
		            isMoment(input) ||
		            isDate(input) ||
		            isString(input) ||
		            isNumber(input) ||
		            isNumberOrStringArray(input) ||
		            isMomentInputObject(input) ||
		            input === null ||
		            input === undefined
		        );
		    }

		    function isMomentInputObject(input) {
		        var objectTest = isObject(input) && !isObjectEmpty(input),
		            propertyTest = false,
		            properties = [
		                'years',
		                'year',
		                'y',
		                'months',
		                'month',
		                'M',
		                'days',
		                'day',
		                'd',
		                'dates',
		                'date',
		                'D',
		                'hours',
		                'hour',
		                'h',
		                'minutes',
		                'minute',
		                'm',
		                'seconds',
		                'second',
		                's',
		                'milliseconds',
		                'millisecond',
		                'ms',
		            ],
		            i,
		            property,
		            propertyLen = properties.length;

		        for (i = 0; i < propertyLen; i += 1) {
		            property = properties[i];
		            propertyTest = propertyTest || hasOwnProp(input, property);
		        }

		        return objectTest && propertyTest;
		    }

		    function isNumberOrStringArray(input) {
		        var arrayTest = isArray(input),
		            dataTypeTest = false;
		        if (arrayTest) {
		            dataTypeTest =
		                input.filter(function (item) {
		                    return !isNumber(item) && isString(input);
		                }).length === 0;
		        }
		        return arrayTest && dataTypeTest;
		    }

		    function isCalendarSpec(input) {
		        var objectTest = isObject(input) && !isObjectEmpty(input),
		            propertyTest = false,
		            properties = [
		                'sameDay',
		                'nextDay',
		                'lastDay',
		                'nextWeek',
		                'lastWeek',
		                'sameElse',
		            ],
		            i,
		            property;

		        for (i = 0; i < properties.length; i += 1) {
		            property = properties[i];
		            propertyTest = propertyTest || hasOwnProp(input, property);
		        }

		        return objectTest && propertyTest;
		    }

		    function getCalendarFormat(myMoment, now) {
		        var diff = myMoment.diff(now, 'days', true);
		        return diff < -6
		            ? 'sameElse'
		            : diff < -1
		              ? 'lastWeek'
		              : diff < 0
		                ? 'lastDay'
		                : diff < 1
		                  ? 'sameDay'
		                  : diff < 2
		                    ? 'nextDay'
		                    : diff < 7
		                      ? 'nextWeek'
		                      : 'sameElse';
		    }

		    function calendar$1(time, formats) {
		        // Support for single parameter, formats only overload to the calendar function
		        if (arguments.length === 1) {
		            if (!arguments[0]) {
		                time = undefined;
		                formats = undefined;
		            } else if (isMomentInput(arguments[0])) {
		                time = arguments[0];
		                formats = undefined;
		            } else if (isCalendarSpec(arguments[0])) {
		                formats = arguments[0];
		                time = undefined;
		            }
		        }
		        // We want to compare the start of today, vs this.
		        // Getting start-of-today depends on whether we're local/utc/offset or not.
		        var now = time || createLocal(),
		            sod = cloneWithOffset(now, this).startOf('day'),
		            format = hooks.calendarFormat(this, sod) || 'sameElse',
		            output =
		                formats &&
		                (isFunction(formats[format])
		                    ? formats[format].call(this, now)
		                    : formats[format]);

		        return this.format(
		            output || this.localeData().calendar(format, this, createLocal(now))
		        );
		    }

		    function clone() {
		        return new Moment(this);
		    }

		    function isAfter(input, units) {
		        var localInput = isMoment(input) ? input : createLocal(input);
		        if (!(this.isValid() && localInput.isValid())) {
		            return false;
		        }
		        units = normalizeUnits(units) || 'millisecond';
		        if (units === 'millisecond') {
		            return this.valueOf() > localInput.valueOf();
		        } else {
		            return localInput.valueOf() < this.clone().startOf(units).valueOf();
		        }
		    }

		    function isBefore(input, units) {
		        var localInput = isMoment(input) ? input : createLocal(input);
		        if (!(this.isValid() && localInput.isValid())) {
		            return false;
		        }
		        units = normalizeUnits(units) || 'millisecond';
		        if (units === 'millisecond') {
		            return this.valueOf() < localInput.valueOf();
		        } else {
		            return this.clone().endOf(units).valueOf() < localInput.valueOf();
		        }
		    }

		    function isBetween(from, to, units, inclusivity) {
		        var localFrom = isMoment(from) ? from : createLocal(from),
		            localTo = isMoment(to) ? to : createLocal(to);
		        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
		            return false;
		        }
		        inclusivity = inclusivity || '()';
		        return (
		            (inclusivity[0] === '('
		                ? this.isAfter(localFrom, units)
		                : !this.isBefore(localFrom, units)) &&
		            (inclusivity[1] === ')'
		                ? this.isBefore(localTo, units)
		                : !this.isAfter(localTo, units))
		        );
		    }

		    function isSame(input, units) {
		        var localInput = isMoment(input) ? input : createLocal(input),
		            inputMs;
		        if (!(this.isValid() && localInput.isValid())) {
		            return false;
		        }
		        units = normalizeUnits(units) || 'millisecond';
		        if (units === 'millisecond') {
		            return this.valueOf() === localInput.valueOf();
		        } else {
		            inputMs = localInput.valueOf();
		            return (
		                this.clone().startOf(units).valueOf() <= inputMs &&
		                inputMs <= this.clone().endOf(units).valueOf()
		            );
		        }
		    }

		    function isSameOrAfter(input, units) {
		        return this.isSame(input, units) || this.isAfter(input, units);
		    }

		    function isSameOrBefore(input, units) {
		        return this.isSame(input, units) || this.isBefore(input, units);
		    }

		    function diff(input, units, asFloat) {
		        var that, zoneDelta, output;

		        if (!this.isValid()) {
		            return NaN;
		        }

		        that = cloneWithOffset(input, this);

		        if (!that.isValid()) {
		            return NaN;
		        }

		        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

		        units = normalizeUnits(units);

		        switch (units) {
		            case 'year':
		                output = monthDiff(this, that) / 12;
		                break;
		            case 'month':
		                output = monthDiff(this, that);
		                break;
		            case 'quarter':
		                output = monthDiff(this, that) / 3;
		                break;
		            case 'second':
		                output = (this - that) / 1e3;
		                break; // 1000
		            case 'minute':
		                output = (this - that) / 6e4;
		                break; // 1000 * 60
		            case 'hour':
		                output = (this - that) / 36e5;
		                break; // 1000 * 60 * 60
		            case 'day':
		                output = (this - that - zoneDelta) / 864e5;
		                break; // 1000 * 60 * 60 * 24, negate dst
		            case 'week':
		                output = (this - that - zoneDelta) / 6048e5;
		                break; // 1000 * 60 * 60 * 24 * 7, negate dst
		            default:
		                output = this - that;
		        }

		        return asFloat ? output : absFloor(output);
		    }

		    function monthDiff(a, b) {
		        if (a.date() < b.date()) {
		            // end-of-month calculations work correct when the start month has more
		            // days than the end month.
		            return -monthDiff(b, a);
		        }
		        // difference in months
		        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
		            // b is in (anchor - 1 month, anchor + 1 month)
		            anchor = a.clone().add(wholeMonthDiff, 'months'),
		            anchor2,
		            adjust;

		        if (b - anchor < 0) {
		            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
		            // linear across the month
		            adjust = (b - anchor) / (anchor - anchor2);
		        } else {
		            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
		            // linear across the month
		            adjust = (b - anchor) / (anchor2 - anchor);
		        }

		        //check for negative zero, return zero if negative zero
		        return -(wholeMonthDiff + adjust) || 0;
		    }

		    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
		    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

		    function toString() {
		        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
		    }

		    function toISOString(keepOffset) {
		        if (!this.isValid()) {
		            return null;
		        }
		        var utc = keepOffset !== true,
		            m = utc ? this.clone().utc() : this;
		        if (m.year() < 0 || m.year() > 9999) {
		            return formatMoment(
		                m,
		                utc
		                    ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
		                    : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
		            );
		        }
		        if (isFunction(Date.prototype.toISOString)) {
		            // native implementation is ~50x faster, use it when we can
		            if (utc) {
		                return this.toDate().toISOString();
		            } else {
		                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
		                    .toISOString()
		                    .replace('Z', formatMoment(m, 'Z'));
		            }
		        }
		        return formatMoment(
		            m,
		            utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
		        );
		    }

		    /**
		     * Return a human readable representation of a moment that can
		     * also be evaluated to get a new moment which is the same
		     *
		     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
		     */
		    function inspect() {
		        if (!this.isValid()) {
		            return 'moment.invalid(/* ' + this._i + ' */)';
		        }
		        var func = 'moment',
		            zone = '',
		            prefix,
		            year,
		            datetime,
		            suffix;
		        if (!this.isLocal()) {
		            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
		            zone = 'Z';
		        }
		        prefix = '[' + func + '("]';
		        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
		        datetime = '-MM-DD[T]HH:mm:ss.SSS';
		        suffix = zone + '[")]';

		        return this.format(prefix + year + datetime + suffix);
		    }

		    function format(inputString) {
		        if (!inputString) {
		            inputString = this.isUtc()
		                ? hooks.defaultFormatUtc
		                : hooks.defaultFormat;
		        }
		        var output = formatMoment(this, inputString);
		        return this.localeData().postformat(output);
		    }

		    function from(time, withoutSuffix) {
		        if (
		            this.isValid() &&
		            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
		        ) {
		            return createDuration({ to: this, from: time })
		                .locale(this.locale())
		                .humanize(!withoutSuffix);
		        } else {
		            return this.localeData().invalidDate();
		        }
		    }

		    function fromNow(withoutSuffix) {
		        return this.from(createLocal(), withoutSuffix);
		    }

		    function to(time, withoutSuffix) {
		        if (
		            this.isValid() &&
		            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
		        ) {
		            return createDuration({ from: this, to: time })
		                .locale(this.locale())
		                .humanize(!withoutSuffix);
		        } else {
		            return this.localeData().invalidDate();
		        }
		    }

		    function toNow(withoutSuffix) {
		        return this.to(createLocal(), withoutSuffix);
		    }

		    // If passed a locale key, it will set the locale for this
		    // instance.  Otherwise, it will return the locale configuration
		    // variables for this instance.
		    function locale(key) {
		        var newLocaleData;

		        if (key === undefined) {
		            return this._locale._abbr;
		        } else {
		            newLocaleData = getLocale(key);
		            if (newLocaleData != null) {
		                this._locale = newLocaleData;
		            }
		            return this;
		        }
		    }

		    var lang = deprecate(
		        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
		        function (key) {
		            if (key === undefined) {
		                return this.localeData();
		            } else {
		                return this.locale(key);
		            }
		        }
		    );

		    function localeData() {
		        return this._locale;
		    }

		    var MS_PER_SECOND = 1000,
		        MS_PER_MINUTE = 60 * MS_PER_SECOND,
		        MS_PER_HOUR = 60 * MS_PER_MINUTE,
		        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

		    // actual modulo - handles negative numbers (for dates before 1970):
		    function mod$1(dividend, divisor) {
		        return ((dividend % divisor) + divisor) % divisor;
		    }

		    function localStartOfDate(y, m, d) {
		        // the date constructor remaps years 0-99 to 1900-1999
		        if (y < 100 && y >= 0) {
		            // preserve leap years using a full 400 year cycle, then reset
		            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
		        } else {
		            return new Date(y, m, d).valueOf();
		        }
		    }

		    function utcStartOfDate(y, m, d) {
		        // Date.UTC remaps years 0-99 to 1900-1999
		        if (y < 100 && y >= 0) {
		            // preserve leap years using a full 400 year cycle, then reset
		            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
		        } else {
		            return Date.UTC(y, m, d);
		        }
		    }

		    function startOf(units) {
		        var time, startOfDate;
		        units = normalizeUnits(units);
		        if (units === undefined || units === 'millisecond' || !this.isValid()) {
		            return this;
		        }

		        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

		        switch (units) {
		            case 'year':
		                time = startOfDate(this.year(), 0, 1);
		                break;
		            case 'quarter':
		                time = startOfDate(
		                    this.year(),
		                    this.month() - (this.month() % 3),
		                    1
		                );
		                break;
		            case 'month':
		                time = startOfDate(this.year(), this.month(), 1);
		                break;
		            case 'week':
		                time = startOfDate(
		                    this.year(),
		                    this.month(),
		                    this.date() - this.weekday()
		                );
		                break;
		            case 'isoWeek':
		                time = startOfDate(
		                    this.year(),
		                    this.month(),
		                    this.date() - (this.isoWeekday() - 1)
		                );
		                break;
		            case 'day':
		            case 'date':
		                time = startOfDate(this.year(), this.month(), this.date());
		                break;
		            case 'hour':
		                time = this._d.valueOf();
		                time -= mod$1(
		                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
		                    MS_PER_HOUR
		                );
		                break;
		            case 'minute':
		                time = this._d.valueOf();
		                time -= mod$1(time, MS_PER_MINUTE);
		                break;
		            case 'second':
		                time = this._d.valueOf();
		                time -= mod$1(time, MS_PER_SECOND);
		                break;
		        }

		        this._d.setTime(time);
		        hooks.updateOffset(this, true);
		        return this;
		    }

		    function endOf(units) {
		        var time, startOfDate;
		        units = normalizeUnits(units);
		        if (units === undefined || units === 'millisecond' || !this.isValid()) {
		            return this;
		        }

		        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

		        switch (units) {
		            case 'year':
		                time = startOfDate(this.year() + 1, 0, 1) - 1;
		                break;
		            case 'quarter':
		                time =
		                    startOfDate(
		                        this.year(),
		                        this.month() - (this.month() % 3) + 3,
		                        1
		                    ) - 1;
		                break;
		            case 'month':
		                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
		                break;
		            case 'week':
		                time =
		                    startOfDate(
		                        this.year(),
		                        this.month(),
		                        this.date() - this.weekday() + 7
		                    ) - 1;
		                break;
		            case 'isoWeek':
		                time =
		                    startOfDate(
		                        this.year(),
		                        this.month(),
		                        this.date() - (this.isoWeekday() - 1) + 7
		                    ) - 1;
		                break;
		            case 'day':
		            case 'date':
		                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
		                break;
		            case 'hour':
		                time = this._d.valueOf();
		                time +=
		                    MS_PER_HOUR -
		                    mod$1(
		                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
		                        MS_PER_HOUR
		                    ) -
		                    1;
		                break;
		            case 'minute':
		                time = this._d.valueOf();
		                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
		                break;
		            case 'second':
		                time = this._d.valueOf();
		                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
		                break;
		        }

		        this._d.setTime(time);
		        hooks.updateOffset(this, true);
		        return this;
		    }

		    function valueOf() {
		        return this._d.valueOf() - (this._offset || 0) * 60000;
		    }

		    function unix() {
		        return Math.floor(this.valueOf() / 1000);
		    }

		    function toDate() {
		        return new Date(this.valueOf());
		    }

		    function toArray() {
		        var m = this;
		        return [
		            m.year(),
		            m.month(),
		            m.date(),
		            m.hour(),
		            m.minute(),
		            m.second(),
		            m.millisecond(),
		        ];
		    }

		    function toObject() {
		        var m = this;
		        return {
		            years: m.year(),
		            months: m.month(),
		            date: m.date(),
		            hours: m.hours(),
		            minutes: m.minutes(),
		            seconds: m.seconds(),
		            milliseconds: m.milliseconds(),
		        };
		    }

		    function toJSON() {
		        // new Date(NaN).toJSON() === null
		        return this.isValid() ? this.toISOString() : null;
		    }

		    function isValid$2() {
		        return isValid(this);
		    }

		    function parsingFlags() {
		        return extend({}, getParsingFlags(this));
		    }

		    function invalidAt() {
		        return getParsingFlags(this).overflow;
		    }

		    function creationData() {
		        return {
		            input: this._i,
		            format: this._f,
		            locale: this._locale,
		            isUTC: this._isUTC,
		            strict: this._strict,
		        };
		    }

		    addFormatToken('N', 0, 0, 'eraAbbr');
		    addFormatToken('NN', 0, 0, 'eraAbbr');
		    addFormatToken('NNN', 0, 0, 'eraAbbr');
		    addFormatToken('NNNN', 0, 0, 'eraName');
		    addFormatToken('NNNNN', 0, 0, 'eraNarrow');

		    addFormatToken('y', ['y', 1], 'yo', 'eraYear');
		    addFormatToken('y', ['yy', 2], 0, 'eraYear');
		    addFormatToken('y', ['yyy', 3], 0, 'eraYear');
		    addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

		    addRegexToken('N', matchEraAbbr);
		    addRegexToken('NN', matchEraAbbr);
		    addRegexToken('NNN', matchEraAbbr);
		    addRegexToken('NNNN', matchEraName);
		    addRegexToken('NNNNN', matchEraNarrow);

		    addParseToken(
		        ['N', 'NN', 'NNN', 'NNNN', 'NNNNN'],
		        function (input, array, config, token) {
		            var era = config._locale.erasParse(input, token, config._strict);
		            if (era) {
		                getParsingFlags(config).era = era;
		            } else {
		                getParsingFlags(config).invalidEra = input;
		            }
		        }
		    );

		    addRegexToken('y', matchUnsigned);
		    addRegexToken('yy', matchUnsigned);
		    addRegexToken('yyy', matchUnsigned);
		    addRegexToken('yyyy', matchUnsigned);
		    addRegexToken('yo', matchEraYearOrdinal);

		    addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
		    addParseToken(['yo'], function (input, array, config, token) {
		        var match;
		        if (config._locale._eraYearOrdinalRegex) {
		            match = input.match(config._locale._eraYearOrdinalRegex);
		        }

		        if (config._locale.eraYearOrdinalParse) {
		            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
		        } else {
		            array[YEAR] = parseInt(input, 10);
		        }
		    });

		    function localeEras(m, format) {
		        var i,
		            l,
		            date,
		            eras = this._eras || getLocale('en')._eras;
		        for (i = 0, l = eras.length; i < l; ++i) {
		            switch (typeof eras[i].since) {
		                case 'string':
		                    // truncate time
		                    date = hooks(eras[i].since).startOf('day');
		                    eras[i].since = date.valueOf();
		                    break;
		            }

		            switch (typeof eras[i].until) {
		                case 'undefined':
		                    eras[i].until = +Infinity;
		                    break;
		                case 'string':
		                    // truncate time
		                    date = hooks(eras[i].until).startOf('day').valueOf();
		                    eras[i].until = date.valueOf();
		                    break;
		            }
		        }
		        return eras;
		    }

		    function localeErasParse(eraName, format, strict) {
		        var i,
		            l,
		            eras = this.eras(),
		            name,
		            abbr,
		            narrow;
		        eraName = eraName.toUpperCase();

		        for (i = 0, l = eras.length; i < l; ++i) {
		            name = eras[i].name.toUpperCase();
		            abbr = eras[i].abbr.toUpperCase();
		            narrow = eras[i].narrow.toUpperCase();

		            if (strict) {
		                switch (format) {
		                    case 'N':
		                    case 'NN':
		                    case 'NNN':
		                        if (abbr === eraName) {
		                            return eras[i];
		                        }
		                        break;

		                    case 'NNNN':
		                        if (name === eraName) {
		                            return eras[i];
		                        }
		                        break;

		                    case 'NNNNN':
		                        if (narrow === eraName) {
		                            return eras[i];
		                        }
		                        break;
		                }
		            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
		                return eras[i];
		            }
		        }
		    }

		    function localeErasConvertYear(era, year) {
		        var dir = era.since <= era.until ? +1 : -1;
		        if (year === undefined) {
		            return hooks(era.since).year();
		        } else {
		            return hooks(era.since).year() + (year - era.offset) * dir;
		        }
		    }

		    function getEraName() {
		        var i,
		            l,
		            val,
		            eras = this.localeData().eras();
		        for (i = 0, l = eras.length; i < l; ++i) {
		            // truncate time
		            val = this.clone().startOf('day').valueOf();

		            if (eras[i].since <= val && val <= eras[i].until) {
		                return eras[i].name;
		            }
		            if (eras[i].until <= val && val <= eras[i].since) {
		                return eras[i].name;
		            }
		        }

		        return '';
		    }

		    function getEraNarrow() {
		        var i,
		            l,
		            val,
		            eras = this.localeData().eras();
		        for (i = 0, l = eras.length; i < l; ++i) {
		            // truncate time
		            val = this.clone().startOf('day').valueOf();

		            if (eras[i].since <= val && val <= eras[i].until) {
		                return eras[i].narrow;
		            }
		            if (eras[i].until <= val && val <= eras[i].since) {
		                return eras[i].narrow;
		            }
		        }

		        return '';
		    }

		    function getEraAbbr() {
		        var i,
		            l,
		            val,
		            eras = this.localeData().eras();
		        for (i = 0, l = eras.length; i < l; ++i) {
		            // truncate time
		            val = this.clone().startOf('day').valueOf();

		            if (eras[i].since <= val && val <= eras[i].until) {
		                return eras[i].abbr;
		            }
		            if (eras[i].until <= val && val <= eras[i].since) {
		                return eras[i].abbr;
		            }
		        }

		        return '';
		    }

		    function getEraYear() {
		        var i,
		            l,
		            dir,
		            val,
		            eras = this.localeData().eras();
		        for (i = 0, l = eras.length; i < l; ++i) {
		            dir = eras[i].since <= eras[i].until ? +1 : -1;

		            // truncate time
		            val = this.clone().startOf('day').valueOf();

		            if (
		                (eras[i].since <= val && val <= eras[i].until) ||
		                (eras[i].until <= val && val <= eras[i].since)
		            ) {
		                return (
		                    (this.year() - hooks(eras[i].since).year()) * dir +
		                    eras[i].offset
		                );
		            }
		        }

		        return this.year();
		    }

		    function erasNameRegex(isStrict) {
		        if (!hasOwnProp(this, '_erasNameRegex')) {
		            computeErasParse.call(this);
		        }
		        return isStrict ? this._erasNameRegex : this._erasRegex;
		    }

		    function erasAbbrRegex(isStrict) {
		        if (!hasOwnProp(this, '_erasAbbrRegex')) {
		            computeErasParse.call(this);
		        }
		        return isStrict ? this._erasAbbrRegex : this._erasRegex;
		    }

		    function erasNarrowRegex(isStrict) {
		        if (!hasOwnProp(this, '_erasNarrowRegex')) {
		            computeErasParse.call(this);
		        }
		        return isStrict ? this._erasNarrowRegex : this._erasRegex;
		    }

		    function matchEraAbbr(isStrict, locale) {
		        return locale.erasAbbrRegex(isStrict);
		    }

		    function matchEraName(isStrict, locale) {
		        return locale.erasNameRegex(isStrict);
		    }

		    function matchEraNarrow(isStrict, locale) {
		        return locale.erasNarrowRegex(isStrict);
		    }

		    function matchEraYearOrdinal(isStrict, locale) {
		        return locale._eraYearOrdinalRegex || matchUnsigned;
		    }

		    function computeErasParse() {
		        var abbrPieces = [],
		            namePieces = [],
		            narrowPieces = [],
		            mixedPieces = [],
		            i,
		            l,
		            erasName,
		            erasAbbr,
		            erasNarrow,
		            eras = this.eras();

		        for (i = 0, l = eras.length; i < l; ++i) {
		            erasName = regexEscape(eras[i].name);
		            erasAbbr = regexEscape(eras[i].abbr);
		            erasNarrow = regexEscape(eras[i].narrow);

		            namePieces.push(erasName);
		            abbrPieces.push(erasAbbr);
		            narrowPieces.push(erasNarrow);
		            mixedPieces.push(erasName);
		            mixedPieces.push(erasAbbr);
		            mixedPieces.push(erasNarrow);
		        }

		        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
		        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
		        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
		        this._erasNarrowRegex = new RegExp(
		            '^(' + narrowPieces.join('|') + ')',
		            'i'
		        );
		    }

		    // FORMATTING

		    addFormatToken(0, ['gg', 2], 0, function () {
		        return this.weekYear() % 100;
		    });

		    addFormatToken(0, ['GG', 2], 0, function () {
		        return this.isoWeekYear() % 100;
		    });

		    function addWeekYearFormatToken(token, getter) {
		        addFormatToken(0, [token, token.length], 0, getter);
		    }

		    addWeekYearFormatToken('gggg', 'weekYear');
		    addWeekYearFormatToken('ggggg', 'weekYear');
		    addWeekYearFormatToken('GGGG', 'isoWeekYear');
		    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

		    // ALIASES

		    // PARSING

		    addRegexToken('G', matchSigned);
		    addRegexToken('g', matchSigned);
		    addRegexToken('GG', match1to2, match2);
		    addRegexToken('gg', match1to2, match2);
		    addRegexToken('GGGG', match1to4, match4);
		    addRegexToken('gggg', match1to4, match4);
		    addRegexToken('GGGGG', match1to6, match6);
		    addRegexToken('ggggg', match1to6, match6);

		    addWeekParseToken(
		        ['gggg', 'ggggg', 'GGGG', 'GGGGG'],
		        function (input, week, config, token) {
		            week[token.substr(0, 2)] = toInt(input);
		        }
		    );

		    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
		        week[token] = hooks.parseTwoDigitYear(input);
		    });

		    // MOMENTS

		    function getSetWeekYear(input) {
		        return getSetWeekYearHelper.call(
		            this,
		            input,
		            this.week(),
		            this.weekday() + this.localeData()._week.dow,
		            this.localeData()._week.dow,
		            this.localeData()._week.doy
		        );
		    }

		    function getSetISOWeekYear(input) {
		        return getSetWeekYearHelper.call(
		            this,
		            input,
		            this.isoWeek(),
		            this.isoWeekday(),
		            1,
		            4
		        );
		    }

		    function getISOWeeksInYear() {
		        return weeksInYear(this.year(), 1, 4);
		    }

		    function getISOWeeksInISOWeekYear() {
		        return weeksInYear(this.isoWeekYear(), 1, 4);
		    }

		    function getWeeksInYear() {
		        var weekInfo = this.localeData()._week;
		        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
		    }

		    function getWeeksInWeekYear() {
		        var weekInfo = this.localeData()._week;
		        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
		    }

		    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
		        var weeksTarget;
		        if (input == null) {
		            return weekOfYear(this, dow, doy).year;
		        } else {
		            weeksTarget = weeksInYear(input, dow, doy);
		            if (week > weeksTarget) {
		                week = weeksTarget;
		            }
		            return setWeekAll.call(this, input, week, weekday, dow, doy);
		        }
		    }

		    function setWeekAll(weekYear, week, weekday, dow, doy) {
		        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
		            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

		        this.year(date.getUTCFullYear());
		        this.month(date.getUTCMonth());
		        this.date(date.getUTCDate());
		        return this;
		    }

		    // FORMATTING

		    addFormatToken('Q', 0, 'Qo', 'quarter');

		    // PARSING

		    addRegexToken('Q', match1);
		    addParseToken('Q', function (input, array) {
		        array[MONTH] = (toInt(input) - 1) * 3;
		    });

		    // MOMENTS

		    function getSetQuarter(input) {
		        return input == null
		            ? Math.ceil((this.month() + 1) / 3)
		            : this.month((input - 1) * 3 + (this.month() % 3));
		    }

		    // FORMATTING

		    addFormatToken('D', ['DD', 2], 'Do', 'date');

		    // PARSING

		    addRegexToken('D', match1to2, match1to2NoLeadingZero);
		    addRegexToken('DD', match1to2, match2);
		    addRegexToken('Do', function (isStrict, locale) {
		        // TODO: Remove "ordinalParse" fallback in next major release.
		        return isStrict
		            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
		            : locale._dayOfMonthOrdinalParseLenient;
		    });

		    addParseToken(['D', 'DD'], DATE);
		    addParseToken('Do', function (input, array) {
		        array[DATE] = toInt(input.match(match1to2)[0]);
		    });

		    // MOMENTS

		    var getSetDayOfMonth = makeGetSet('Date', true);

		    // FORMATTING

		    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

		    // PARSING

		    addRegexToken('DDD', match1to3);
		    addRegexToken('DDDD', match3);
		    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
		        config._dayOfYear = toInt(input);
		    });

		    // HELPERS

		    // MOMENTS

		    function getSetDayOfYear(input) {
		        var dayOfYear =
		            Math.round(
		                (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
		            ) + 1;
		        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
		    }

		    // FORMATTING

		    addFormatToken('m', ['mm', 2], 0, 'minute');

		    // PARSING

		    addRegexToken('m', match1to2, match1to2HasZero);
		    addRegexToken('mm', match1to2, match2);
		    addParseToken(['m', 'mm'], MINUTE);

		    // MOMENTS

		    var getSetMinute = makeGetSet('Minutes', false);

		    // FORMATTING

		    addFormatToken('s', ['ss', 2], 0, 'second');

		    // PARSING

		    addRegexToken('s', match1to2, match1to2HasZero);
		    addRegexToken('ss', match1to2, match2);
		    addParseToken(['s', 'ss'], SECOND);

		    // MOMENTS

		    var getSetSecond = makeGetSet('Seconds', false);

		    // FORMATTING

		    addFormatToken('S', 0, 0, function () {
		        return ~~(this.millisecond() / 100);
		    });

		    addFormatToken(0, ['SS', 2], 0, function () {
		        return ~~(this.millisecond() / 10);
		    });

		    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
		    addFormatToken(0, ['SSSS', 4], 0, function () {
		        return this.millisecond() * 10;
		    });
		    addFormatToken(0, ['SSSSS', 5], 0, function () {
		        return this.millisecond() * 100;
		    });
		    addFormatToken(0, ['SSSSSS', 6], 0, function () {
		        return this.millisecond() * 1000;
		    });
		    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
		        return this.millisecond() * 10000;
		    });
		    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
		        return this.millisecond() * 100000;
		    });
		    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
		        return this.millisecond() * 1000000;
		    });

		    // PARSING

		    addRegexToken('S', match1to3, match1);
		    addRegexToken('SS', match1to3, match2);
		    addRegexToken('SSS', match1to3, match3);

		    var token, getSetMillisecond;
		    for (token = 'SSSS'; token.length <= 9; token += 'S') {
		        addRegexToken(token, matchUnsigned);
		    }

		    function parseMs(input, array) {
		        array[MILLISECOND] = toInt(('0.' + input) * 1000);
		    }

		    for (token = 'S'; token.length <= 9; token += 'S') {
		        addParseToken(token, parseMs);
		    }

		    getSetMillisecond = makeGetSet('Milliseconds', false);

		    // FORMATTING

		    addFormatToken('z', 0, 0, 'zoneAbbr');
		    addFormatToken('zz', 0, 0, 'zoneName');

		    // MOMENTS

		    function getZoneAbbr() {
		        return this._isUTC ? 'UTC' : '';
		    }

		    function getZoneName() {
		        return this._isUTC ? 'Coordinated Universal Time' : '';
		    }

		    var proto = Moment.prototype;

		    proto.add = add;
		    proto.calendar = calendar$1;
		    proto.clone = clone;
		    proto.diff = diff;
		    proto.endOf = endOf;
		    proto.format = format;
		    proto.from = from;
		    proto.fromNow = fromNow;
		    proto.to = to;
		    proto.toNow = toNow;
		    proto.get = stringGet;
		    proto.invalidAt = invalidAt;
		    proto.isAfter = isAfter;
		    proto.isBefore = isBefore;
		    proto.isBetween = isBetween;
		    proto.isSame = isSame;
		    proto.isSameOrAfter = isSameOrAfter;
		    proto.isSameOrBefore = isSameOrBefore;
		    proto.isValid = isValid$2;
		    proto.lang = lang;
		    proto.locale = locale;
		    proto.localeData = localeData;
		    proto.max = prototypeMax;
		    proto.min = prototypeMin;
		    proto.parsingFlags = parsingFlags;
		    proto.set = stringSet;
		    proto.startOf = startOf;
		    proto.subtract = subtract;
		    proto.toArray = toArray;
		    proto.toObject = toObject;
		    proto.toDate = toDate;
		    proto.toISOString = toISOString;
		    proto.inspect = inspect;
		    if (typeof Symbol !== 'undefined' && Symbol.for != null) {
		        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
		            return 'Moment<' + this.format() + '>';
		        };
		    }
		    proto.toJSON = toJSON;
		    proto.toString = toString;
		    proto.unix = unix;
		    proto.valueOf = valueOf;
		    proto.creationData = creationData;
		    proto.eraName = getEraName;
		    proto.eraNarrow = getEraNarrow;
		    proto.eraAbbr = getEraAbbr;
		    proto.eraYear = getEraYear;
		    proto.year = getSetYear;
		    proto.isLeapYear = getIsLeapYear;
		    proto.weekYear = getSetWeekYear;
		    proto.isoWeekYear = getSetISOWeekYear;
		    proto.quarter = proto.quarters = getSetQuarter;
		    proto.month = getSetMonth;
		    proto.daysInMonth = getDaysInMonth;
		    proto.week = proto.weeks = getSetWeek;
		    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
		    proto.weeksInYear = getWeeksInYear;
		    proto.weeksInWeekYear = getWeeksInWeekYear;
		    proto.isoWeeksInYear = getISOWeeksInYear;
		    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
		    proto.date = getSetDayOfMonth;
		    proto.day = proto.days = getSetDayOfWeek;
		    proto.weekday = getSetLocaleDayOfWeek;
		    proto.isoWeekday = getSetISODayOfWeek;
		    proto.dayOfYear = getSetDayOfYear;
		    proto.hour = proto.hours = getSetHour;
		    proto.minute = proto.minutes = getSetMinute;
		    proto.second = proto.seconds = getSetSecond;
		    proto.millisecond = proto.milliseconds = getSetMillisecond;
		    proto.utcOffset = getSetOffset;
		    proto.utc = setOffsetToUTC;
		    proto.local = setOffsetToLocal;
		    proto.parseZone = setOffsetToParsedOffset;
		    proto.hasAlignedHourOffset = hasAlignedHourOffset;
		    proto.isDST = isDaylightSavingTime;
		    proto.isLocal = isLocal;
		    proto.isUtcOffset = isUtcOffset;
		    proto.isUtc = isUtc;
		    proto.isUTC = isUtc;
		    proto.zoneAbbr = getZoneAbbr;
		    proto.zoneName = getZoneName;
		    proto.dates = deprecate(
		        'dates accessor is deprecated. Use date instead.',
		        getSetDayOfMonth
		    );
		    proto.months = deprecate(
		        'months accessor is deprecated. Use month instead',
		        getSetMonth
		    );
		    proto.years = deprecate(
		        'years accessor is deprecated. Use year instead',
		        getSetYear
		    );
		    proto.zone = deprecate(
		        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
		        getSetZone
		    );
		    proto.isDSTShifted = deprecate(
		        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
		        isDaylightSavingTimeShifted
		    );

		    function createUnix(input) {
		        return createLocal(input * 1000);
		    }

		    function createInZone() {
		        return createLocal.apply(null, arguments).parseZone();
		    }

		    function preParsePostFormat(string) {
		        return string;
		    }

		    var proto$1 = Locale.prototype;

		    proto$1.calendar = calendar;
		    proto$1.longDateFormat = longDateFormat;
		    proto$1.invalidDate = invalidDate;
		    proto$1.ordinal = ordinal;
		    proto$1.preparse = preParsePostFormat;
		    proto$1.postformat = preParsePostFormat;
		    proto$1.relativeTime = relativeTime;
		    proto$1.pastFuture = pastFuture;
		    proto$1.set = set;
		    proto$1.eras = localeEras;
		    proto$1.erasParse = localeErasParse;
		    proto$1.erasConvertYear = localeErasConvertYear;
		    proto$1.erasAbbrRegex = erasAbbrRegex;
		    proto$1.erasNameRegex = erasNameRegex;
		    proto$1.erasNarrowRegex = erasNarrowRegex;

		    proto$1.months = localeMonths;
		    proto$1.monthsShort = localeMonthsShort;
		    proto$1.monthsParse = localeMonthsParse;
		    proto$1.monthsRegex = monthsRegex;
		    proto$1.monthsShortRegex = monthsShortRegex;
		    proto$1.week = localeWeek;
		    proto$1.firstDayOfYear = localeFirstDayOfYear;
		    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

		    proto$1.weekdays = localeWeekdays;
		    proto$1.weekdaysMin = localeWeekdaysMin;
		    proto$1.weekdaysShort = localeWeekdaysShort;
		    proto$1.weekdaysParse = localeWeekdaysParse;

		    proto$1.weekdaysRegex = weekdaysRegex;
		    proto$1.weekdaysShortRegex = weekdaysShortRegex;
		    proto$1.weekdaysMinRegex = weekdaysMinRegex;

		    proto$1.isPM = localeIsPM;
		    proto$1.meridiem = localeMeridiem;

		    function get$1(format, index, field, setter) {
		        var locale = getLocale(),
		            utc = createUTC().set(setter, index);
		        return locale[field](utc, format);
		    }

		    function listMonthsImpl(format, index, field) {
		        if (isNumber(format)) {
		            index = format;
		            format = undefined;
		        }

		        format = format || '';

		        if (index != null) {
		            return get$1(format, index, field, 'month');
		        }

		        var i,
		            out = [];
		        for (i = 0; i < 12; i++) {
		            out[i] = get$1(format, i, field, 'month');
		        }
		        return out;
		    }

		    // ()
		    // (5)
		    // (fmt, 5)
		    // (fmt)
		    // (true)
		    // (true, 5)
		    // (true, fmt, 5)
		    // (true, fmt)
		    function listWeekdaysImpl(localeSorted, format, index, field) {
		        if (typeof localeSorted === 'boolean') {
		            if (isNumber(format)) {
		                index = format;
		                format = undefined;
		            }

		            format = format || '';
		        } else {
		            format = localeSorted;
		            index = format;
		            localeSorted = false;

		            if (isNumber(format)) {
		                index = format;
		                format = undefined;
		            }

		            format = format || '';
		        }

		        var locale = getLocale(),
		            shift = localeSorted ? locale._week.dow : 0,
		            i,
		            out = [];

		        if (index != null) {
		            return get$1(format, (index + shift) % 7, field, 'day');
		        }

		        for (i = 0; i < 7; i++) {
		            out[i] = get$1(format, (i + shift) % 7, field, 'day');
		        }
		        return out;
		    }

		    function listMonths(format, index) {
		        return listMonthsImpl(format, index, 'months');
		    }

		    function listMonthsShort(format, index) {
		        return listMonthsImpl(format, index, 'monthsShort');
		    }

		    function listWeekdays(localeSorted, format, index) {
		        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
		    }

		    function listWeekdaysShort(localeSorted, format, index) {
		        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
		    }

		    function listWeekdaysMin(localeSorted, format, index) {
		        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
		    }

		    getSetGlobalLocale('en', {
		        eras: [
		            {
		                since: '0001-01-01',
		                until: +Infinity,
		                offset: 1,
		                name: 'Anno Domini',
		                narrow: 'AD',
		                abbr: 'AD',
		            },
		            {
		                since: '0000-12-31',
		                until: -Infinity,
		                offset: 1,
		                name: 'Before Christ',
		                narrow: 'BC',
		                abbr: 'BC',
		            },
		        ],
		        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
		        ordinal: function (number) {
		            var b = number % 10,
		                output =
		                    toInt((number % 100) / 10) === 1
		                        ? 'th'
		                        : b === 1
		                          ? 'st'
		                          : b === 2
		                            ? 'nd'
		                            : b === 3
		                              ? 'rd'
		                              : 'th';
		            return number + output;
		        },
		    });

		    // Side effect imports

		    hooks.lang = deprecate(
		        'moment.lang is deprecated. Use moment.locale instead.',
		        getSetGlobalLocale
		    );
		    hooks.langData = deprecate(
		        'moment.langData is deprecated. Use moment.localeData instead.',
		        getLocale
		    );

		    var mathAbs = Math.abs;

		    function abs() {
		        var data = this._data;

		        this._milliseconds = mathAbs(this._milliseconds);
		        this._days = mathAbs(this._days);
		        this._months = mathAbs(this._months);

		        data.milliseconds = mathAbs(data.milliseconds);
		        data.seconds = mathAbs(data.seconds);
		        data.minutes = mathAbs(data.minutes);
		        data.hours = mathAbs(data.hours);
		        data.months = mathAbs(data.months);
		        data.years = mathAbs(data.years);

		        return this;
		    }

		    function addSubtract$1(duration, input, value, direction) {
		        var other = createDuration(input, value);

		        duration._milliseconds += direction * other._milliseconds;
		        duration._days += direction * other._days;
		        duration._months += direction * other._months;

		        return duration._bubble();
		    }

		    // supports only 2.0-style add(1, 's') or add(duration)
		    function add$1(input, value) {
		        return addSubtract$1(this, input, value, 1);
		    }

		    // supports only 2.0-style subtract(1, 's') or subtract(duration)
		    function subtract$1(input, value) {
		        return addSubtract$1(this, input, value, -1);
		    }

		    function absCeil(number) {
		        if (number < 0) {
		            return Math.floor(number);
		        } else {
		            return Math.ceil(number);
		        }
		    }

		    function bubble() {
		        var milliseconds = this._milliseconds,
		            days = this._days,
		            months = this._months,
		            data = this._data,
		            seconds,
		            minutes,
		            hours,
		            years,
		            monthsFromDays;

		        // if we have a mix of positive and negative values, bubble down first
		        // check: https://github.com/moment/moment/issues/2166
		        if (
		            !(
		                (milliseconds >= 0 && days >= 0 && months >= 0) ||
		                (milliseconds <= 0 && days <= 0 && months <= 0)
		            )
		        ) {
		            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
		            days = 0;
		            months = 0;
		        }

		        // The following code bubbles up values, see the tests for
		        // examples of what that means.
		        data.milliseconds = milliseconds % 1000;

		        seconds = absFloor(milliseconds / 1000);
		        data.seconds = seconds % 60;

		        minutes = absFloor(seconds / 60);
		        data.minutes = minutes % 60;

		        hours = absFloor(minutes / 60);
		        data.hours = hours % 24;

		        days += absFloor(hours / 24);

		        // convert days to months
		        monthsFromDays = absFloor(daysToMonths(days));
		        months += monthsFromDays;
		        days -= absCeil(monthsToDays(monthsFromDays));

		        // 12 months -> 1 year
		        years = absFloor(months / 12);
		        months %= 12;

		        data.days = days;
		        data.months = months;
		        data.years = years;

		        return this;
		    }

		    function daysToMonths(days) {
		        // 400 years have 146097 days (taking into account leap year rules)
		        // 400 years have 12 months === 4800
		        return (days * 4800) / 146097;
		    }

		    function monthsToDays(months) {
		        // the reverse of daysToMonths
		        return (months * 146097) / 4800;
		    }

		    function as(units) {
		        if (!this.isValid()) {
		            return NaN;
		        }
		        var days,
		            months,
		            milliseconds = this._milliseconds;

		        units = normalizeUnits(units);

		        if (units === 'month' || units === 'quarter' || units === 'year') {
		            days = this._days + milliseconds / 864e5;
		            months = this._months + daysToMonths(days);
		            switch (units) {
		                case 'month':
		                    return months;
		                case 'quarter':
		                    return months / 3;
		                case 'year':
		                    return months / 12;
		            }
		        } else {
		            // handle milliseconds separately because of floating point math errors (issue #1867)
		            days = this._days + Math.round(monthsToDays(this._months));
		            switch (units) {
		                case 'week':
		                    return days / 7 + milliseconds / 6048e5;
		                case 'day':
		                    return days + milliseconds / 864e5;
		                case 'hour':
		                    return days * 24 + milliseconds / 36e5;
		                case 'minute':
		                    return days * 1440 + milliseconds / 6e4;
		                case 'second':
		                    return days * 86400 + milliseconds / 1000;
		                // Math.floor prevents floating point math errors here
		                case 'millisecond':
		                    return Math.floor(days * 864e5) + milliseconds;
		                default:
		                    throw new Error('Unknown unit ' + units);
		            }
		        }
		    }

		    function makeAs(alias) {
		        return function () {
		            return this.as(alias);
		        };
		    }

		    var asMilliseconds = makeAs('ms'),
		        asSeconds = makeAs('s'),
		        asMinutes = makeAs('m'),
		        asHours = makeAs('h'),
		        asDays = makeAs('d'),
		        asWeeks = makeAs('w'),
		        asMonths = makeAs('M'),
		        asQuarters = makeAs('Q'),
		        asYears = makeAs('y'),
		        valueOf$1 = asMilliseconds;

		    function clone$1() {
		        return createDuration(this);
		    }

		    function get$2(units) {
		        units = normalizeUnits(units);
		        return this.isValid() ? this[units + 's']() : NaN;
		    }

		    function makeGetter(name) {
		        return function () {
		            return this.isValid() ? this._data[name] : NaN;
		        };
		    }

		    var milliseconds = makeGetter('milliseconds'),
		        seconds = makeGetter('seconds'),
		        minutes = makeGetter('minutes'),
		        hours = makeGetter('hours'),
		        days = makeGetter('days'),
		        months = makeGetter('months'),
		        years = makeGetter('years');

		    function weeks() {
		        return absFloor(this.days() / 7);
		    }

		    var round = Math.round,
		        thresholds = {
		            ss: 44, // a few seconds to seconds
		            s: 45, // seconds to minute
		            m: 45, // minutes to hour
		            h: 22, // hours to day
		            d: 26, // days to month/week
		            w: null, // weeks to month
		            M: 11, // months to year
		        };

		    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
		    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
		        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
		    }

		    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
		        var duration = createDuration(posNegDuration).abs(),
		            seconds = round(duration.as('s')),
		            minutes = round(duration.as('m')),
		            hours = round(duration.as('h')),
		            days = round(duration.as('d')),
		            months = round(duration.as('M')),
		            weeks = round(duration.as('w')),
		            years = round(duration.as('y')),
		            a =
		                (seconds <= thresholds.ss && ['s', seconds]) ||
		                (seconds < thresholds.s && ['ss', seconds]) ||
		                (minutes <= 1 && ['m']) ||
		                (minutes < thresholds.m && ['mm', minutes]) ||
		                (hours <= 1 && ['h']) ||
		                (hours < thresholds.h && ['hh', hours]) ||
		                (days <= 1 && ['d']) ||
		                (days < thresholds.d && ['dd', days]);

		        if (thresholds.w != null) {
		            a =
		                a ||
		                (weeks <= 1 && ['w']) ||
		                (weeks < thresholds.w && ['ww', weeks]);
		        }
		        a = a ||
		            (months <= 1 && ['M']) ||
		            (months < thresholds.M && ['MM', months]) ||
		            (years <= 1 && ['y']) || ['yy', years];

		        a[2] = withoutSuffix;
		        a[3] = +posNegDuration > 0;
		        a[4] = locale;
		        return substituteTimeAgo.apply(null, a);
		    }

		    // This function allows you to set the rounding function for relative time strings
		    function getSetRelativeTimeRounding(roundingFunction) {
		        if (roundingFunction === undefined) {
		            return round;
		        }
		        if (typeof roundingFunction === 'function') {
		            round = roundingFunction;
		            return true;
		        }
		        return false;
		    }

		    // This function allows you to set a threshold for relative time strings
		    function getSetRelativeTimeThreshold(threshold, limit) {
		        if (thresholds[threshold] === undefined) {
		            return false;
		        }
		        if (limit === undefined) {
		            return thresholds[threshold];
		        }
		        thresholds[threshold] = limit;
		        if (threshold === 's') {
		            thresholds.ss = limit - 1;
		        }
		        return true;
		    }

		    function humanize(argWithSuffix, argThresholds) {
		        if (!this.isValid()) {
		            return this.localeData().invalidDate();
		        }

		        var withSuffix = false,
		            th = thresholds,
		            locale,
		            output;

		        if (typeof argWithSuffix === 'object') {
		            argThresholds = argWithSuffix;
		            argWithSuffix = false;
		        }
		        if (typeof argWithSuffix === 'boolean') {
		            withSuffix = argWithSuffix;
		        }
		        if (typeof argThresholds === 'object') {
		            th = Object.assign({}, thresholds, argThresholds);
		            if (argThresholds.s != null && argThresholds.ss == null) {
		                th.ss = argThresholds.s - 1;
		            }
		        }

		        locale = this.localeData();
		        output = relativeTime$1(this, !withSuffix, th, locale);

		        if (withSuffix) {
		            output = locale.pastFuture(+this, output);
		        }

		        return locale.postformat(output);
		    }

		    var abs$1 = Math.abs;

		    function sign(x) {
		        return (x > 0) - (x < 0) || +x;
		    }

		    function toISOString$1() {
		        // for ISO strings we do not use the normal bubbling rules:
		        //  * milliseconds bubble up until they become hours
		        //  * days do not bubble at all
		        //  * months bubble up until they become years
		        // This is because there is no context-free conversion between hours and days
		        // (think of clock changes)
		        // and also not between days and months (28-31 days per month)
		        if (!this.isValid()) {
		            return this.localeData().invalidDate();
		        }

		        var seconds = abs$1(this._milliseconds) / 1000,
		            days = abs$1(this._days),
		            months = abs$1(this._months),
		            minutes,
		            hours,
		            years,
		            s,
		            total = this.asSeconds(),
		            totalSign,
		            ymSign,
		            daysSign,
		            hmsSign;

		        if (!total) {
		            // this is the same as C#'s (Noda) and python (isodate)...
		            // but not other JS (goog.date)
		            return 'P0D';
		        }

		        // 3600 seconds -> 60 minutes -> 1 hour
		        minutes = absFloor(seconds / 60);
		        hours = absFloor(minutes / 60);
		        seconds %= 60;
		        minutes %= 60;

		        // 12 months -> 1 year
		        years = absFloor(months / 12);
		        months %= 12;

		        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
		        s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

		        totalSign = total < 0 ? '-' : '';
		        ymSign = sign(this._months) !== sign(total) ? '-' : '';
		        daysSign = sign(this._days) !== sign(total) ? '-' : '';
		        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

		        return (
		            totalSign +
		            'P' +
		            (years ? ymSign + years + 'Y' : '') +
		            (months ? ymSign + months + 'M' : '') +
		            (days ? daysSign + days + 'D' : '') +
		            (hours || minutes || seconds ? 'T' : '') +
		            (hours ? hmsSign + hours + 'H' : '') +
		            (minutes ? hmsSign + minutes + 'M' : '') +
		            (seconds ? hmsSign + s + 'S' : '')
		        );
		    }

		    var proto$2 = Duration.prototype;

		    proto$2.isValid = isValid$1;
		    proto$2.abs = abs;
		    proto$2.add = add$1;
		    proto$2.subtract = subtract$1;
		    proto$2.as = as;
		    proto$2.asMilliseconds = asMilliseconds;
		    proto$2.asSeconds = asSeconds;
		    proto$2.asMinutes = asMinutes;
		    proto$2.asHours = asHours;
		    proto$2.asDays = asDays;
		    proto$2.asWeeks = asWeeks;
		    proto$2.asMonths = asMonths;
		    proto$2.asQuarters = asQuarters;
		    proto$2.asYears = asYears;
		    proto$2.valueOf = valueOf$1;
		    proto$2._bubble = bubble;
		    proto$2.clone = clone$1;
		    proto$2.get = get$2;
		    proto$2.milliseconds = milliseconds;
		    proto$2.seconds = seconds;
		    proto$2.minutes = minutes;
		    proto$2.hours = hours;
		    proto$2.days = days;
		    proto$2.weeks = weeks;
		    proto$2.months = months;
		    proto$2.years = years;
		    proto$2.humanize = humanize;
		    proto$2.toISOString = toISOString$1;
		    proto$2.toString = toISOString$1;
		    proto$2.toJSON = toISOString$1;
		    proto$2.locale = locale;
		    proto$2.localeData = localeData;

		    proto$2.toIsoString = deprecate(
		        'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
		        toISOString$1
		    );
		    proto$2.lang = lang;

		    // FORMATTING

		    addFormatToken('X', 0, 0, 'unix');
		    addFormatToken('x', 0, 0, 'valueOf');

		    // PARSING

		    addRegexToken('x', matchSigned);
		    addRegexToken('X', matchTimestamp);
		    addParseToken('X', function (input, array, config) {
		        config._d = new Date(parseFloat(input) * 1000);
		    });
		    addParseToken('x', function (input, array, config) {
		        config._d = new Date(toInt(input));
		    });

		    //! moment.js

		    hooks.version = '2.30.1';

		    setHookCallback(createLocal);

		    hooks.fn = proto;
		    hooks.min = min;
		    hooks.max = max;
		    hooks.now = now;
		    hooks.utc = createUTC;
		    hooks.unix = createUnix;
		    hooks.months = listMonths;
		    hooks.isDate = isDate;
		    hooks.locale = getSetGlobalLocale;
		    hooks.invalid = createInvalid;
		    hooks.duration = createDuration;
		    hooks.isMoment = isMoment;
		    hooks.weekdays = listWeekdays;
		    hooks.parseZone = createInZone;
		    hooks.localeData = getLocale;
		    hooks.isDuration = isDuration;
		    hooks.monthsShort = listMonthsShort;
		    hooks.weekdaysMin = listWeekdaysMin;
		    hooks.defineLocale = defineLocale;
		    hooks.updateLocale = updateLocale;
		    hooks.locales = listLocales;
		    hooks.weekdaysShort = listWeekdaysShort;
		    hooks.normalizeUnits = normalizeUnits;
		    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
		    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
		    hooks.calendarFormat = getCalendarFormat;
		    hooks.prototype = proto;

		    // currently HTML5 input type only supports 24-hour formats
		    hooks.HTML5_FMT = {
		        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
		        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
		        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
		        DATE: 'YYYY-MM-DD', // <input type="date" />
		        TIME: 'HH:mm', // <input type="time" />
		        TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
		        TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
		        WEEK: 'GGGG-[W]WW', // <input type="week" />
		        MONTH: 'YYYY-MM', // <input type="month" />
		    };

		    return hooks;

		}))); 
	} (moment$1));
	return moment$1.exports;
}

var tmp = {exports: {}};

/*!
 * Tmp
 *
 * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
 *
 * MIT Licensed
 */

var hasRequiredTmp;

function requireTmp () {
	if (hasRequiredTmp) return tmp.exports;
	hasRequiredTmp = 1;
	(function (module) {
		/*
		 * Module dependencies.
		 */
		const fs = require$$0$8;
		const os = require$$1$5;
		const path = require$$1$4;
		const crypto = require$$0$5;
		const _c = { fs: fs.constants, os: os.constants };

		/*
		 * The working inner variables.
		 */
		const
		  // the random characters to choose from
		  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',

		  TEMPLATE_PATTERN = /XXXXXX/,

		  DEFAULT_TRIES = 3,

		  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),

		  // constants are off on the windows platform and will not match the actual errno codes
		  IS_WIN32 = os.platform() === 'win32',
		  EBADF = _c.EBADF || _c.os.errno.EBADF,
		  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,

		  DIR_MODE = 0o700 /* 448 */,
		  FILE_MODE = 0o600 /* 384 */,

		  EXIT = 'exit',

		  // this will hold the objects need to be removed on exit
		  _removeObjects = [],

		  // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback
		  FN_RMDIR_SYNC = fs.rmdirSync.bind(fs);

		let
		  _gracefulCleanup = false;

		/**
		 * Recursively remove a directory and its contents.
		 *
		 * @param {string} dirPath path of directory to remove
		 * @param {Function} callback
		 * @private
		 */
		function rimraf(dirPath, callback) {
		  return fs.rm(dirPath, { recursive: true }, callback);
		}

		/**
		 * Recursively remove a directory and its contents, synchronously.
		 *
		 * @param {string} dirPath path of directory to remove
		 * @private
		 */
		function FN_RIMRAF_SYNC(dirPath) {
		  return fs.rmSync(dirPath, { recursive: true });
		}

		/**
		 * Gets a temporary file name.
		 *
		 * @param {(Options|tmpNameCallback)} options options or callback
		 * @param {?tmpNameCallback} callback the callback function
		 */
		function tmpName(options, callback) {
		  const
		    args = _parseArguments(options, callback),
		    opts = args[0],
		    cb = args[1];

		  try {
		    _assertAndSanitizeOptions(opts);
		  } catch (err) {
		    return cb(err);
		  }

		  let tries = opts.tries;
		  (function _getUniqueName() {
		    try {
		      const name = _generateTmpName(opts);

		      // check whether the path exists then retry if needed
		      fs.stat(name, function (err) {
		        /* istanbul ignore else */
		        if (!err) {
		          /* istanbul ignore else */
		          if (tries-- > 0) return _getUniqueName();

		          return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));
		        }

		        cb(null, name);
		      });
		    } catch (err) {
		      cb(err);
		    }
		  }());
		}

		/**
		 * Synchronous version of tmpName.
		 *
		 * @param {Object} options
		 * @returns {string} the generated random name
		 * @throws {Error} if the options are invalid or could not generate a filename
		 */
		function tmpNameSync(options) {
		  const
		    args = _parseArguments(options),
		    opts = args[0];

		  _assertAndSanitizeOptions(opts);

		  let tries = opts.tries;
		  do {
		    const name = _generateTmpName(opts);
		    try {
		      fs.statSync(name);
		    } catch (e) {
		      return name;
		    }
		  } while (tries-- > 0);

		  throw new Error('Could not get a unique tmp filename, max tries reached');
		}

		/**
		 * Creates and opens a temporary file.
		 *
		 * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined
		 * @param {?fileCallback} callback
		 */
		function file(options, callback) {
		  const
		    args = _parseArguments(options, callback),
		    opts = args[0],
		    cb = args[1];

		  // gets a temporary filename
		  tmpName(opts, function _tmpNameCreated(err, name) {
		    /* istanbul ignore else */
		    if (err) return cb(err);

		    // create and open the file
		    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {
		      /* istanbu ignore else */
		      if (err) return cb(err);

		      if (opts.discardDescriptor) {
		        return fs.close(fd, function _discardCallback(possibleErr) {
		          // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only
		          return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));
		        });
		      } else {
		        // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care
		        // about the descriptor
		        const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
		        cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));
		      }
		    });
		  });
		}

		/**
		 * Synchronous version of file.
		 *
		 * @param {Options} options
		 * @returns {FileSyncObject} object consists of name, fd and removeCallback
		 * @throws {Error} if cannot create a file
		 */
		function fileSync(options) {
		  const
		    args = _parseArguments(options),
		    opts = args[0];

		  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
		  const name = tmpNameSync(opts);
		  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
		  /* istanbul ignore else */
		  if (opts.discardDescriptor) {
		    fs.closeSync(fd);
		    fd = undefined;
		  }

		  return {
		    name: name,
		    fd: fd,
		    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)
		  };
		}

		/**
		 * Creates a temporary directory.
		 *
		 * @param {(Options|dirCallback)} options the options or the callback function
		 * @param {?dirCallback} callback
		 */
		function dir(options, callback) {
		  const
		    args = _parseArguments(options, callback),
		    opts = args[0],
		    cb = args[1];

		  // gets a temporary filename
		  tmpName(opts, function _tmpNameCreated(err, name) {
		    /* istanbul ignore else */
		    if (err) return cb(err);

		    // create the directory
		    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {
		      /* istanbul ignore else */
		      if (err) return cb(err);

		      cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));
		    });
		  });
		}

		/**
		 * Synchronous version of dir.
		 *
		 * @param {Options} options
		 * @returns {DirSyncObject} object consists of name and removeCallback
		 * @throws {Error} if it cannot create a directory
		 */
		function dirSync(options) {
		  const
		    args = _parseArguments(options),
		    opts = args[0];

		  const name = tmpNameSync(opts);
		  fs.mkdirSync(name, opts.mode || DIR_MODE);

		  return {
		    name: name,
		    removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)
		  };
		}

		/**
		 * Removes files asynchronously.
		 *
		 * @param {Object} fdPath
		 * @param {Function} next
		 * @private
		 */
		function _removeFileAsync(fdPath, next) {
		  const _handler = function (err) {
		    if (err && !_isENOENT(err)) {
		      // reraise any unanticipated error
		      return next(err);
		    }
		    next();
		  };

		  if (0 <= fdPath[0])
		    fs.close(fdPath[0], function () {
		      fs.unlink(fdPath[1], _handler);
		    });
		  else fs.unlink(fdPath[1], _handler);
		}

		/**
		 * Removes files synchronously.
		 *
		 * @param {Object} fdPath
		 * @private
		 */
		function _removeFileSync(fdPath) {
		  let rethrownException = null;
		  try {
		    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);
		  } catch (e) {
		    // reraise any unanticipated error
		    if (!_isEBADF(e) && !_isENOENT(e)) throw e;
		  } finally {
		    try {
		      fs.unlinkSync(fdPath[1]);
		    }
		    catch (e) {
		      // reraise any unanticipated error
		      if (!_isENOENT(e)) rethrownException = e;
		    }
		  }
		  if (rethrownException !== null) {
		    throw rethrownException;
		  }
		}

		/**
		 * Prepares the callback for removal of the temporary file.
		 *
		 * Returns either a sync callback or a async callback depending on whether
		 * fileSync or file was called, which is expressed by the sync parameter.
		 *
		 * @param {string} name the path of the file
		 * @param {number} fd file descriptor
		 * @param {Object} opts
		 * @param {boolean} sync
		 * @returns {fileCallback | fileCallbackSync}
		 * @private
		 */
		function _prepareTmpFileRemoveCallback(name, fd, opts, sync) {
		  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);
		  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);

		  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);

		  return sync ? removeCallbackSync : removeCallback;
		}

		/**
		 * Prepares the callback for removal of the temporary directory.
		 *
		 * Returns either a sync callback or a async callback depending on whether
		 * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.
		 *
		 * @param {string} name
		 * @param {Object} opts
		 * @param {boolean} sync
		 * @returns {Function} the callback
		 * @private
		 */
		function _prepareTmpDirRemoveCallback(name, opts, sync) {
		  const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);
		  const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;
		  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);
		  const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);
		  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);

		  return sync ? removeCallbackSync : removeCallback;
		}

		/**
		 * Creates a guarded function wrapping the removeFunction call.
		 *
		 * The cleanup callback is save to be called multiple times.
		 * Subsequent invocations will be ignored.
		 *
		 * @param {Function} removeFunction
		 * @param {string} fileOrDirName
		 * @param {boolean} sync
		 * @param {cleanupCallbackSync?} cleanupCallbackSync
		 * @returns {cleanupCallback | cleanupCallbackSync}
		 * @private
		 */
		function _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {
		  let called = false;

		  // if sync is true, the next parameter will be ignored
		  return function _cleanupCallback(next) {

		    /* istanbul ignore else */
		    if (!called) {
		      // remove cleanupCallback from cache
		      const toRemove = cleanupCallbackSync || _cleanupCallback;
		      const index = _removeObjects.indexOf(toRemove);
		      /* istanbul ignore else */
		      if (index >= 0) _removeObjects.splice(index, 1);

		      called = true;
		      if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {
		        return removeFunction(fileOrDirName);
		      } else {
		        return removeFunction(fileOrDirName, next || function() {});
		      }
		    }
		  };
		}

		/**
		 * The garbage collector.
		 *
		 * @private
		 */
		function _garbageCollector() {
		  /* istanbul ignore else */
		  if (!_gracefulCleanup) return;

		  // the function being called removes itself from _removeObjects,
		  // loop until _removeObjects is empty
		  while (_removeObjects.length) {
		    try {
		      _removeObjects[0]();
		    } catch (e) {
		      // already removed?
		    }
		  }
		}

		/**
		 * Random name generator based on crypto.
		 * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript
		 *
		 * @param {number} howMany
		 * @returns {string} the generated random name
		 * @private
		 */
		function _randomChars(howMany) {
		  let
		    value = [],
		    rnd = null;

		  // make sure that we do not fail because we ran out of entropy
		  try {
		    rnd = crypto.randomBytes(howMany);
		  } catch (e) {
		    rnd = crypto.pseudoRandomBytes(howMany);
		  }

		  for (var i = 0; i < howMany; i++) {
		    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
		  }

		  return value.join('');
		}

		/**
		 * Helper which determines whether a string s is blank, that is undefined, or empty or null.
		 *
		 * @private
		 * @param {string} s
		 * @returns {Boolean} true whether the string s is blank, false otherwise
		 */
		function _isBlank(s) {
		  return s === null || _isUndefined(s) || !s.trim();
		}

		/**
		 * Checks whether the `obj` parameter is defined or not.
		 *
		 * @param {Object} obj
		 * @returns {boolean} true if the object is undefined
		 * @private
		 */
		function _isUndefined(obj) {
		  return typeof obj === 'undefined';
		}

		/**
		 * Parses the function arguments.
		 *
		 * This function helps to have optional arguments.
		 *
		 * @param {(Options|null|undefined|Function)} options
		 * @param {?Function} callback
		 * @returns {Array} parsed arguments
		 * @private
		 */
		function _parseArguments(options, callback) {
		  /* istanbul ignore else */
		  if (typeof options === 'function') {
		    return [{}, options];
		  }

		  /* istanbul ignore else */
		  if (_isUndefined(options)) {
		    return [{}, callback];
		  }

		  // copy options so we do not leak the changes we make internally
		  const actualOptions = {};
		  for (const key of Object.getOwnPropertyNames(options)) {
		    actualOptions[key] = options[key];
		  }

		  return [actualOptions, callback];
		}

		/**
		 * Generates a new temporary name.
		 *
		 * @param {Object} opts
		 * @returns {string} the new random name according to opts
		 * @private
		 */
		function _generateTmpName(opts) {

		  const tmpDir = opts.tmpdir;

		  /* istanbul ignore else */
		  if (!_isUndefined(opts.name))
		    return path.join(tmpDir, opts.dir, opts.name);

		  /* istanbul ignore else */
		  if (!_isUndefined(opts.template))
		    return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));

		  // prefix and postfix
		  const name = [
		    opts.prefix ? opts.prefix : 'tmp',
		    '-',
		    process.pid,
		    '-',
		    _randomChars(12),
		    opts.postfix ? '-' + opts.postfix : ''
		  ].join('');

		  return path.join(tmpDir, opts.dir, name);
		}

		/**
		 * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing
		 * options.
		 *
		 * @param {Options} options
		 * @private
		 */
		function _assertAndSanitizeOptions(options) {

		  options.tmpdir = _getTmpDir(options);

		  const tmpDir = options.tmpdir;

		  /* istanbul ignore else */
		  if (!_isUndefined(options.name))
		    _assertIsRelative(options.name, 'name', tmpDir);
		  /* istanbul ignore else */
		  if (!_isUndefined(options.dir))
		    _assertIsRelative(options.dir, 'dir', tmpDir);
		  /* istanbul ignore else */
		  if (!_isUndefined(options.template)) {
		    _assertIsRelative(options.template, 'template', tmpDir);
		    if (!options.template.match(TEMPLATE_PATTERN))
		      throw new Error(`Invalid template, found "${options.template}".`);
		  }
		  /* istanbul ignore else */
		  if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0)
		    throw new Error(`Invalid tries, found "${options.tries}".`);

		  // if a name was specified we will try once
		  options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;
		  options.keep = !!options.keep;
		  options.detachDescriptor = !!options.detachDescriptor;
		  options.discardDescriptor = !!options.discardDescriptor;
		  options.unsafeCleanup = !!options.unsafeCleanup;

		  // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to
		  options.dir = _isUndefined(options.dir) ? '' : path.relative(tmpDir, _resolvePath(options.dir, tmpDir));
		  options.template = _isUndefined(options.template) ? undefined : path.relative(tmpDir, _resolvePath(options.template, tmpDir));
		  // sanitize further if template is relative to options.dir
		  options.template = _isBlank(options.template) ? undefined : path.relative(options.dir, options.template);

		  // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to
		  options.name = _isUndefined(options.name) ? undefined : options.name;
		  options.prefix = _isUndefined(options.prefix) ? '' : options.prefix;
		  options.postfix = _isUndefined(options.postfix) ? '' : options.postfix;
		}

		/**
		 * Resolve the specified path name in respect to tmpDir.
		 *
		 * The specified name might include relative path components, e.g. ../
		 * so we need to resolve in order to be sure that is is located inside tmpDir
		 *
		 * @param name
		 * @param tmpDir
		 * @returns {string}
		 * @private
		 */
		function _resolvePath(name, tmpDir) {
		  if (name.startsWith(tmpDir)) {
		    return path.resolve(name);
		  } else {
		    return path.resolve(path.join(tmpDir, name));
		  }
		}

		/**
		 * Asserts whether specified name is relative to the specified tmpDir.
		 *
		 * @param {string} name
		 * @param {string} option
		 * @param {string} tmpDir
		 * @throws {Error}
		 * @private
		 */
		function _assertIsRelative(name, option, tmpDir) {
		  if (option === 'name') {
		    // assert that name is not absolute and does not contain a path
		    if (path.isAbsolute(name))
		      throw new Error(`${option} option must not contain an absolute path, found "${name}".`);
		    // must not fail on valid .<name> or ..<name> or similar such constructs
		    let basename = path.basename(name);
		    if (basename === '..' || basename === '.' || basename !== name)
		      throw new Error(`${option} option must not contain a path, found "${name}".`);
		  }
		  else { // if (option === 'dir' || option === 'template') {
		    // assert that dir or template are relative to tmpDir
		    if (path.isAbsolute(name) && !name.startsWith(tmpDir)) {
		      throw new Error(`${option} option must be relative to "${tmpDir}", found "${name}".`);
		    }
		    let resolvedPath = _resolvePath(name, tmpDir);
		    if (!resolvedPath.startsWith(tmpDir))
		      throw new Error(`${option} option must be relative to "${tmpDir}", found "${resolvedPath}".`);
		  }
		}

		/**
		 * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.
		 *
		 * @private
		 */
		function _isEBADF(error) {
		  return _isExpectedError(error, -EBADF, 'EBADF');
		}

		/**
		 * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.
		 *
		 * @private
		 */
		function _isENOENT(error) {
		  return _isExpectedError(error, -ENOENT, 'ENOENT');
		}

		/**
		 * Helper to determine whether the expected error code matches the actual code and errno,
		 * which will differ between the supported node versions.
		 *
		 * - Node >= 7.0:
		 *   error.code {string}
		 *   error.errno {number} any numerical value will be negated
		 *
		 * CAVEAT
		 *
		 * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT
		 * is no different here.
		 *
		 * @param {SystemError} error
		 * @param {number} errno
		 * @param {string} code
		 * @private
		 */
		function _isExpectedError(error, errno, code) {
		  return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;
		}

		/**
		 * Sets the graceful cleanup.
		 *
		 * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the
		 * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary
		 * object removals.
		 */
		function setGracefulCleanup() {
		  _gracefulCleanup = true;
		}

		/**
		 * Returns the currently configured tmp dir from os.tmpdir().
		 *
		 * @private
		 * @param {?Options} options
		 * @returns {string} the currently configured tmp dir
		 */
		function _getTmpDir(options) {
		  return path.resolve(options && options.tmpdir || os.tmpdir());
		}

		// Install process exit listener
		process.addListener(EXIT, _garbageCollector);

		/**
		 * Configuration options.
		 *
		 * @typedef {Object} Options
		 * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected
		 * @property {?number} tries the number of tries before give up the name generation
		 * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files
		 * @property {?string} template the "mkstemp" like filename template
		 * @property {?string} name fixed name relative to tmpdir or the specified dir option
		 * @property {?string} dir tmp directory relative to the root tmp directory in use
		 * @property {?string} prefix prefix for the generated name
		 * @property {?string} postfix postfix for the generated name
		 * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir
		 * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty
		 * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection
		 * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection
		 */

		/**
		 * @typedef {Object} FileSyncObject
		 * @property {string} name the name of the file
		 * @property {string} fd the file descriptor or -1 if the fd has been discarded
		 * @property {fileCallback} removeCallback the callback function to remove the file
		 */

		/**
		 * @typedef {Object} DirSyncObject
		 * @property {string} name the name of the directory
		 * @property {fileCallback} removeCallback the callback function to remove the directory
		 */

		/**
		 * @callback tmpNameCallback
		 * @param {?Error} err the error object if anything goes wrong
		 * @param {string} name the temporary file name
		 */

		/**
		 * @callback fileCallback
		 * @param {?Error} err the error object if anything goes wrong
		 * @param {string} name the temporary file name
		 * @param {number} fd the file descriptor or -1 if the fd had been discarded
		 * @param {cleanupCallback} fn the cleanup callback function
		 */

		/**
		 * @callback fileCallbackSync
		 * @param {?Error} err the error object if anything goes wrong
		 * @param {string} name the temporary file name
		 * @param {number} fd the file descriptor or -1 if the fd had been discarded
		 * @param {cleanupCallbackSync} fn the cleanup callback function
		 */

		/**
		 * @callback dirCallback
		 * @param {?Error} err the error object if anything goes wrong
		 * @param {string} name the temporary file name
		 * @param {cleanupCallback} fn the cleanup callback function
		 */

		/**
		 * @callback dirCallbackSync
		 * @param {?Error} err the error object if anything goes wrong
		 * @param {string} name the temporary file name
		 * @param {cleanupCallbackSync} fn the cleanup callback function
		 */

		/**
		 * Removes the temporary created file or directory.
		 *
		 * @callback cleanupCallback
		 * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed
		 */

		/**
		 * Removes the temporary created file or directory.
		 *
		 * @callback cleanupCallbackSync
		 */

		/**
		 * Callback function for function composition.
		 * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}
		 *
		 * @callback simpleCallback
		 */

		// exporting all the needed methods

		// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will
		// allow users to reconfigure the temporary directory
		Object.defineProperty(module.exports, 'tmpdir', {
		  enumerable: true,
		  configurable: false,
		  get: function () {
		    return _getTmpDir();
		  }
		});

		module.exports.dir = dir;
		module.exports.dirSync = dirSync;

		module.exports.file = file;
		module.exports.fileSync = fileSync;

		module.exports.tmpName = tmpName;
		module.exports.tmpNameSync = tmpNameSync;

		module.exports.setGracefulCleanup = setGracefulCleanup; 
	} (tmp));
	return tmp.exports;
}

var name$1 = "katalon-cli";
var version$1 = "v1.4.0";
var description$1 = "";
var main$1 = "cli.js";
var scripts$1 = {
	start: "node cli.js start-agent",
	beforebuild: "",
	build: "npm run build:pkg && npm run afterbuild",
	buildLinux: "npm run build:pkgLinux64 && npm run afterbuild",
	buildMacos: "npm run build:pkgMacos64 && npm run afterbuild",
	buildWin: "npm run build:pkgWin64 && npm run build:pkgWin86 && npm run afterbuild",
	"build:serv": "npm run beforebuild && npm run build:pkg && npm run afterbuild",
	"build:pkg": "pkg --targets node10-linux-x64,node10-macos-x64,node10-win-x64,node10-win-x86 --out-path bin cli.js",
	"build:pkgLinux64": "pkg --targets node10-linux-x64 --output bin/cli-linux-x64 cli.js",
	"build:pkgMacos64": "pkg --targets node10-macos-x64 --output bin/cli-macos-x64 cli.js",
	"build:pkgWin64": "pkg --targets node10-win-x64 --output bin/cli-win-x64 cli.js",
	"build:pkgWin86": "pkg --targets node10-win-x86 --output bin/cli-win-x86 cli.js",
	afterbuild: "npm run copyService && npm run copyStart",
	copyConfig: "cpy agentconfig_template bin --rename agentconfig",
	copyService: "cpy nssm.exe service.bat service.sh bin",
	copyStart: "cpy start.bat start.sh bin",
	release: "release-it --ci"
};
var dependencies$1 = {
	archiver: "^4.0.1",
	commander: "^5.1.0",
	"cpy-cli": "^3.1.1",
	decompress: "^4.2.1",
	find: "^0.3.0",
	"fs-extra": "^9.0.0",
	glob: "^7.1.6",
	ini: "^1.3.4",
	ip: "^1.1.5",
	lodash: "^4.17.15",
	log4js: "^6.3.0",
	moment: "^2.26.0",
	progress: "^2.0.3",
	properties: "^1.2.1",
	request: "^2.72.0",
	"simple-git": "^2.5.0",
	tmp: "^0.2.1",
	"triple-beam": "^1.3.0",
	"url-join": "^4.0.1",
	uuid: "^8.1.0",
	winston: "^3.2.1",
	"winston-transport": "^4.3.0"
};
var author = "katalon";
var license$1 = "ISC";
var devDependencies$1 = {
	eslint: "^7.1.0",
	"eslint-config-airbnb-base": "^14.1.0",
	"eslint-plugin-import": "^2.20.2",
	pkg: "4.4.8",
	"release-it": "^13.6.1"
};
var require$$3$1 = {
	name: name$1,
	version: version$1,
	description: description$1,
	main: main$1,
	scripts: scripts$1,
	dependencies: dependencies$1,
	author: author,
	license: license$1,
	devDependencies: devDependencies$1
};

var utils$2;
var hasRequiredUtils$2;

function requireUtils$2 () {
	if (hasRequiredUtils$2) return utils$2;
	hasRequiredUtils$2 = 1;
	const moment = requireMoment();
	const path = require$$1$4;
	const tmp = requireTmp();
	const packageJson = require$$3$1;

	utils$2 = {
	  getPath(relativePath) {
	    if (!commonjsGlobal.appRoot) {
	      commonjsGlobal.appRoot = path.resolve('.');
	    }
	    return path.join(commonjsGlobal.appRoot, relativePath);
	  },

	  createTempDir(tmpRoot, options) {
	    const tmpPrefix = moment(new Date()).format('YYYY.MM.DD-H.m-');
	    const tmpDir = tmp.dirSync({
	      unsafeCleanup: true,
	      keep: true,
	      tmpdir: tmpRoot,
	      prefix: tmpPrefix,
	      ...options,
	    });
	    return tmpDir;
	  },

	  stringify(object) {
	    return object && Object.keys(object).length > 0 ? JSON.stringify(object, null, 2) : '';
	  },

	  updateCommand(command, ...options) {
	    return options.reduce((cmd, option) => {
	      const { flag, value } = option;
	      if (cmd.includes(flag)) {
	        return cmd;
	      }
	      if (value) {
	        return `${cmd} ${flag}="${value}"`;
	      }
	      return `${cmd} ${flag}`;
	    }, command);
	  },

	  getVersion() {
	    return packageJson.version;
	  },
	};
	return utils$2;
}

var logger_1;
var hasRequiredLogger;

function requireLogger () {
	if (hasRequiredLogger) return logger_1;
	hasRequiredLogger = 1;
	const log4js = requireLog4js();
	const utils = requireUtils$2();

	const logConfigs = {
	  appenders: {
	    access: {
	      type: 'dateFile',
	      filename: utils.getPath('log/access.log'),
	      pattern: '-yyyy-MM-dd',
	      category: 'http',
	    },
	    out: { type: 'stdout' },
	    app: {
	      type: 'file',
	      filename: utils.getPath('log/app.log'),
	      maxLogSize: 10485760,
	      numBackups: 3,
	    },
	    errorFile: {
	      type: 'file',
	      filename: utils.getPath('log/errors.log'),
	    },
	    errors: {
	      type: 'logLevelFilter',
	      level: 'ERROR',
	      appender: 'errorFile',
	    },
	  },
	  categories: {
	    default: { appenders: ['app', 'errors', 'out'], level: 'INFO' },
	  },
	};

	log4js.configure(logConfigs);
	const logger = log4js.getLogger('katalon');

	logger_1 = logger;
	return logger_1;
}

var config$1 = {exports: {}};

var lib$1 = {exports: {}};

var fs = {};

var universalify = {};

var hasRequiredUniversalify;

function requireUniversalify () {
	if (hasRequiredUniversalify) return universalify;
	hasRequiredUniversalify = 1;

	universalify.fromCallback = function (fn) {
	  return Object.defineProperty(function (...args) {
	    if (typeof args[args.length - 1] === 'function') fn.apply(this, args);
	    else {
	      return new Promise((resolve, reject) => {
	        args.push((err, res) => (err != null) ? reject(err) : resolve(res));
	        fn.apply(this, args);
	      })
	    }
	  }, 'name', { value: fn.name })
	};

	universalify.fromPromise = function (fn) {
	  return Object.defineProperty(function (...args) {
	    const cb = args[args.length - 1];
	    if (typeof cb !== 'function') return fn.apply(this, args)
	    else {
	      args.pop();
	      fn.apply(this, args).then(r => cb(null, r), cb);
	    }
	  }, 'name', { value: fn.name })
	};
	return universalify;
}

var hasRequiredFs;

function requireFs () {
	if (hasRequiredFs) return fs;
	hasRequiredFs = 1;
	(function (exports) {
		// This is adapted from https://github.com/normalize/mz
		// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
		const u = requireUniversalify().fromCallback;
		const fs = requireGracefulFs();

		const api = [
		  'access',
		  'appendFile',
		  'chmod',
		  'chown',
		  'close',
		  'copyFile',
		  'fchmod',
		  'fchown',
		  'fdatasync',
		  'fstat',
		  'fsync',
		  'ftruncate',
		  'futimes',
		  'lchmod',
		  'lchown',
		  'link',
		  'lstat',
		  'mkdir',
		  'mkdtemp',
		  'open',
		  'opendir',
		  'readdir',
		  'readFile',
		  'readlink',
		  'realpath',
		  'rename',
		  'rm',
		  'rmdir',
		  'stat',
		  'symlink',
		  'truncate',
		  'unlink',
		  'utimes',
		  'writeFile'
		].filter(key => {
		  // Some commands are not available on some systems. Ex:
		  // fs.opendir was added in Node.js v12.12.0
		  // fs.rm was added in Node.js v14.14.0
		  // fs.lchown is not available on at least some Linux
		  return typeof fs[key] === 'function'
		});

		// Export all keys:
		Object.keys(fs).forEach(key => {
		  if (key === 'promises') {
		    // fs.promises is a getter property that triggers ExperimentalWarning
		    // Don't re-export it here, the getter is defined in "lib/index.js"
		    return
		  }
		  exports[key] = fs[key];
		});

		// Universalify async methods:
		api.forEach(method => {
		  exports[method] = u(fs[method]);
		});

		// We differ from mz/fs in that we still ship the old, broken, fs.exists()
		// since we are a drop-in replacement for the native module
		exports.exists = function (filename, callback) {
		  if (typeof callback === 'function') {
		    return fs.exists(filename, callback)
		  }
		  return new Promise(resolve => {
		    return fs.exists(filename, resolve)
		  })
		};

		// fs.read(), fs.write(), & fs.writev() need special treatment due to multiple callback args

		exports.read = function (fd, buffer, offset, length, position, callback) {
		  if (typeof callback === 'function') {
		    return fs.read(fd, buffer, offset, length, position, callback)
		  }
		  return new Promise((resolve, reject) => {
		    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
		      if (err) return reject(err)
		      resolve({ bytesRead, buffer });
		    });
		  })
		};

		// Function signature can be
		// fs.write(fd, buffer[, offset[, length[, position]]], callback)
		// OR
		// fs.write(fd, string[, position[, encoding]], callback)
		// We need to handle both cases, so we use ...args
		exports.write = function (fd, buffer, ...args) {
		  if (typeof args[args.length - 1] === 'function') {
		    return fs.write(fd, buffer, ...args)
		  }

		  return new Promise((resolve, reject) => {
		    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
		      if (err) return reject(err)
		      resolve({ bytesWritten, buffer });
		    });
		  })
		};

		// fs.writev only available in Node v12.9.0+
		if (typeof fs.writev === 'function') {
		  // Function signature is
		  // s.writev(fd, buffers[, position], callback)
		  // We need to handle the optional arg, so we use ...args
		  exports.writev = function (fd, buffers, ...args) {
		    if (typeof args[args.length - 1] === 'function') {
		      return fs.writev(fd, buffers, ...args)
		    }

		    return new Promise((resolve, reject) => {
		      fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {
		        if (err) return reject(err)
		        resolve({ bytesWritten, buffers });
		      });
		    })
		  };
		}

		// fs.realpath.native only available in Node v9.2+
		if (typeof fs.realpath.native === 'function') {
		  exports.realpath.native = u(fs.realpath.native);
		} 
	} (fs));
	return fs;
}

var makeDir$1 = {};

var atLeastNode;
var hasRequiredAtLeastNode;

function requireAtLeastNode () {
	if (hasRequiredAtLeastNode) return atLeastNode;
	hasRequiredAtLeastNode = 1;
	atLeastNode = r => {
	  const n = process.versions.node.split('.').map(x => parseInt(x, 10));
	  r = r.split('.').map(x => parseInt(x, 10));
	  return n[0] > r[0] || (n[0] === r[0] && (n[1] > r[1] || (n[1] === r[1] && n[2] >= r[2])))
	};
	return atLeastNode;
}

var hasRequiredMakeDir$1;

function requireMakeDir$1 () {
	if (hasRequiredMakeDir$1) return makeDir$1;
	hasRequiredMakeDir$1 = 1;
	const fs = requireFs();
	const path = require$$1$4;
	const atLeastNode = requireAtLeastNode();

	const useNativeRecursiveOption = atLeastNode('10.12.0');

	// https://github.com/nodejs/node/issues/8987
	// https://github.com/libuv/libuv/pull/1088
	const checkPath = pth => {
	  if (process.platform === 'win32') {
	    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ''));

	    if (pathHasInvalidWinCharacters) {
	      const error = new Error(`Path contains invalid characters: ${pth}`);
	      error.code = 'EINVAL';
	      throw error
	    }
	  }
	};

	const processOptions = options => {
	  const defaults = { mode: 0o777 };
	  if (typeof options === 'number') options = { mode: options };
	  return { ...defaults, ...options }
	};

	const permissionError = pth => {
	  // This replicates the exception of `fs.mkdir` with native the
	  // `recusive` option when run on an invalid drive under Windows.
	  const error = new Error(`operation not permitted, mkdir '${pth}'`);
	  error.code = 'EPERM';
	  error.errno = -4048;
	  error.path = pth;
	  error.syscall = 'mkdir';
	  return error
	};

	makeDir$1.makeDir = async (input, options) => {
	  checkPath(input);
	  options = processOptions(options);

	  if (useNativeRecursiveOption) {
	    const pth = path.resolve(input);

	    return fs.mkdir(pth, {
	      mode: options.mode,
	      recursive: true
	    })
	  }

	  const make = async pth => {
	    try {
	      await fs.mkdir(pth, options.mode);
	    } catch (error) {
	      if (error.code === 'EPERM') {
	        throw error
	      }

	      if (error.code === 'ENOENT') {
	        if (path.dirname(pth) === pth) {
	          throw permissionError(pth)
	        }

	        if (error.message.includes('null bytes')) {
	          throw error
	        }

	        await make(path.dirname(pth));
	        return make(pth)
	      }

	      try {
	        const stats = await fs.stat(pth);
	        if (!stats.isDirectory()) {
	          // This error is never exposed to the user
	          // it is caught below, and the original error is thrown
	          throw new Error('The path is not a directory')
	        }
	      } catch {
	        throw error
	      }
	    }
	  };

	  return make(path.resolve(input))
	};

	makeDir$1.makeDirSync = (input, options) => {
	  checkPath(input);
	  options = processOptions(options);

	  if (useNativeRecursiveOption) {
	    const pth = path.resolve(input);

	    return fs.mkdirSync(pth, {
	      mode: options.mode,
	      recursive: true
	    })
	  }

	  const make = pth => {
	    try {
	      fs.mkdirSync(pth, options.mode);
	    } catch (error) {
	      if (error.code === 'EPERM') {
	        throw error
	      }

	      if (error.code === 'ENOENT') {
	        if (path.dirname(pth) === pth) {
	          throw permissionError(pth)
	        }

	        if (error.message.includes('null bytes')) {
	          throw error
	        }

	        make(path.dirname(pth));
	        return make(pth)
	      }

	      try {
	        if (!fs.statSync(pth).isDirectory()) {
	          // This error is never exposed to the user
	          // it is caught below, and the original error is thrown
	          throw new Error('The path is not a directory')
	        }
	      } catch {
	        throw error
	      }
	    }
	  };

	  return make(path.resolve(input))
	};
	return makeDir$1;
}

var mkdirs;
var hasRequiredMkdirs;

function requireMkdirs () {
	if (hasRequiredMkdirs) return mkdirs;
	hasRequiredMkdirs = 1;
	const u = requireUniversalify().fromPromise;
	const { makeDir: _makeDir, makeDirSync } = requireMakeDir$1();
	const makeDir = u(_makeDir);

	mkdirs = {
	  mkdirs: makeDir,
	  mkdirsSync: makeDirSync,
	  // alias
	  mkdirp: makeDir,
	  mkdirpSync: makeDirSync,
	  ensureDir: makeDir,
	  ensureDirSync: makeDirSync
	};
	return mkdirs;
}

var utimes;
var hasRequiredUtimes;

function requireUtimes () {
	if (hasRequiredUtimes) return utimes;
	hasRequiredUtimes = 1;

	const fs = requireGracefulFs();

	function utimesMillis (path, atime, mtime, callback) {
	  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
	  fs.open(path, 'r+', (err, fd) => {
	    if (err) return callback(err)
	    fs.futimes(fd, atime, mtime, futimesErr => {
	      fs.close(fd, closeErr => {
	        if (callback) callback(futimesErr || closeErr);
	      });
	    });
	  });
	}

	function utimesMillisSync (path, atime, mtime) {
	  const fd = fs.openSync(path, 'r+');
	  fs.futimesSync(fd, atime, mtime);
	  return fs.closeSync(fd)
	}

	utimes = {
	  utimesMillis,
	  utimesMillisSync
	};
	return utimes;
}

var stat_1;
var hasRequiredStat;

function requireStat () {
	if (hasRequiredStat) return stat_1;
	hasRequiredStat = 1;

	const fs = requireFs();
	const path = require$$1$4;
	const util = require$$1$2;
	const atLeastNode = requireAtLeastNode();

	const nodeSupportsBigInt = atLeastNode('10.5.0');
	const stat = (file) => nodeSupportsBigInt ? fs.stat(file, { bigint: true }) : fs.stat(file);
	const statSync = (file) => nodeSupportsBigInt ? fs.statSync(file, { bigint: true }) : fs.statSync(file);

	function getStats (src, dest) {
	  return Promise.all([
	    stat(src),
	    stat(dest).catch(err => {
	      if (err.code === 'ENOENT') return null
	      throw err
	    })
	  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))
	}

	function getStatsSync (src, dest) {
	  let destStat;
	  const srcStat = statSync(src);
	  try {
	    destStat = statSync(dest);
	  } catch (err) {
	    if (err.code === 'ENOENT') return { srcStat, destStat: null }
	    throw err
	  }
	  return { srcStat, destStat }
	}

	function checkPaths (src, dest, funcName, cb) {
	  util.callbackify(getStats)(src, dest, (err, stats) => {
	    if (err) return cb(err)
	    const { srcStat, destStat } = stats;
	    if (destStat && areIdentical(srcStat, destStat)) {
	      return cb(new Error('Source and destination must not be the same.'))
	    }
	    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
	      return cb(new Error(errMsg(src, dest, funcName)))
	    }
	    return cb(null, { srcStat, destStat })
	  });
	}

	function checkPathsSync (src, dest, funcName) {
	  const { srcStat, destStat } = getStatsSync(src, dest);
	  if (destStat && areIdentical(srcStat, destStat)) {
	    throw new Error('Source and destination must not be the same.')
	  }
	  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
	    throw new Error(errMsg(src, dest, funcName))
	  }
	  return { srcStat, destStat }
	}

	// recursively check if dest parent is a subdirectory of src.
	// It works for all file types including symlinks since it
	// checks the src and dest inodes. It starts from the deepest
	// parent and stops once it reaches the src parent or the root path.
	function checkParentPaths (src, srcStat, dest, funcName, cb) {
	  const srcParent = path.resolve(path.dirname(src));
	  const destParent = path.resolve(path.dirname(dest));
	  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()
	  const callback = (err, destStat) => {
	    if (err) {
	      if (err.code === 'ENOENT') return cb()
	      return cb(err)
	    }
	    if (areIdentical(srcStat, destStat)) {
	      return cb(new Error(errMsg(src, dest, funcName)))
	    }
	    return checkParentPaths(src, srcStat, destParent, funcName, cb)
	  };
	  if (nodeSupportsBigInt) fs.stat(destParent, { bigint: true }, callback);
	  else fs.stat(destParent, callback);
	}

	function checkParentPathsSync (src, srcStat, dest, funcName) {
	  const srcParent = path.resolve(path.dirname(src));
	  const destParent = path.resolve(path.dirname(dest));
	  if (destParent === srcParent || destParent === path.parse(destParent).root) return
	  let destStat;
	  try {
	    destStat = statSync(destParent);
	  } catch (err) {
	    if (err.code === 'ENOENT') return
	    throw err
	  }
	  if (areIdentical(srcStat, destStat)) {
	    throw new Error(errMsg(src, dest, funcName))
	  }
	  return checkParentPathsSync(src, srcStat, destParent, funcName)
	}

	function areIdentical (srcStat, destStat) {
	  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
	    if (nodeSupportsBigInt || destStat.ino < Number.MAX_SAFE_INTEGER) {
	      // definitive answer
	      return true
	    }
	    // Use additional heuristics if we can't use 'bigint'.
	    // Different 'ino' could be represented the same if they are >= Number.MAX_SAFE_INTEGER
	    // See issue 657
	    if (destStat.size === srcStat.size &&
	        destStat.mode === srcStat.mode &&
	        destStat.nlink === srcStat.nlink &&
	        destStat.atimeMs === srcStat.atimeMs &&
	        destStat.mtimeMs === srcStat.mtimeMs &&
	        destStat.ctimeMs === srcStat.ctimeMs &&
	        destStat.birthtimeMs === srcStat.birthtimeMs) {
	      // heuristic answer
	      return true
	    }
	  }
	  return false
	}

	// return true if dest is a subdir of src, otherwise false.
	// It only checks the path strings.
	function isSrcSubdir (src, dest) {
	  const srcArr = path.resolve(src).split(path.sep).filter(i => i);
	  const destArr = path.resolve(dest).split(path.sep).filter(i => i);
	  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)
	}

	function errMsg (src, dest, funcName) {
	  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`
	}

	stat_1 = {
	  checkPaths,
	  checkPathsSync,
	  checkParentPaths,
	  checkParentPathsSync,
	  isSrcSubdir
	};
	return stat_1;
}

var copySync_1;
var hasRequiredCopySync$1;

function requireCopySync$1 () {
	if (hasRequiredCopySync$1) return copySync_1;
	hasRequiredCopySync$1 = 1;

	const fs = requireGracefulFs();
	const path = require$$1$4;
	const mkdirsSync = requireMkdirs().mkdirsSync;
	const utimesMillisSync = requireUtimes().utimesMillisSync;
	const stat = requireStat();

	function copySync (src, dest, opts) {
	  if (typeof opts === 'function') {
	    opts = { filter: opts };
	  }

	  opts = opts || {};
	  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
	  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

	  // Warn about using preserveTimestamps on 32-bit node
	  if (opts.preserveTimestamps && process.arch === 'ia32') {
	    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
	  }

	  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy');
	  stat.checkParentPathsSync(src, srcStat, dest, 'copy');
	  return handleFilterAndCopy(destStat, src, dest, opts)
	}

	function handleFilterAndCopy (destStat, src, dest, opts) {
	  if (opts.filter && !opts.filter(src, dest)) return
	  const destParent = path.dirname(dest);
	  if (!fs.existsSync(destParent)) mkdirsSync(destParent);
	  return startCopy(destStat, src, dest, opts)
	}

	function startCopy (destStat, src, dest, opts) {
	  if (opts.filter && !opts.filter(src, dest)) return
	  return getStats(destStat, src, dest, opts)
	}

	function getStats (destStat, src, dest, opts) {
	  const statSync = opts.dereference ? fs.statSync : fs.lstatSync;
	  const srcStat = statSync(src);

	  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)
	  else if (srcStat.isFile() ||
	           srcStat.isCharacterDevice() ||
	           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)
	  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)
	}

	function onFile (srcStat, destStat, src, dest, opts) {
	  if (!destStat) return copyFile(srcStat, src, dest, opts)
	  return mayCopyFile(srcStat, src, dest, opts)
	}

	function mayCopyFile (srcStat, src, dest, opts) {
	  if (opts.overwrite) {
	    fs.unlinkSync(dest);
	    return copyFile(srcStat, src, dest, opts)
	  } else if (opts.errorOnExist) {
	    throw new Error(`'${dest}' already exists`)
	  }
	}

	function copyFile (srcStat, src, dest, opts) {
	  fs.copyFileSync(src, dest);
	  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);
	  return setDestMode(dest, srcStat.mode)
	}

	function handleTimestamps (srcMode, src, dest) {
	  // Make sure the file is writable before setting the timestamp
	  // otherwise open fails with EPERM when invoked with 'r+'
	  // (through utimes call)
	  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);
	  return setDestTimestamps(src, dest)
	}

	function fileIsNotWritable (srcMode) {
	  return (srcMode & 0o200) === 0
	}

	function makeFileWritable (dest, srcMode) {
	  return setDestMode(dest, srcMode | 0o200)
	}

	function setDestMode (dest, srcMode) {
	  return fs.chmodSync(dest, srcMode)
	}

	function setDestTimestamps (src, dest) {
	  // The initial srcStat.atime cannot be trusted
	  // because it is modified by the read(2) system call
	  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
	  const updatedSrcStat = fs.statSync(src);
	  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime)
	}

	function onDir (srcStat, destStat, src, dest, opts) {
	  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts)
	  if (destStat && !destStat.isDirectory()) {
	    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)
	  }
	  return copyDir(src, dest, opts)
	}

	function mkDirAndCopy (srcMode, src, dest, opts) {
	  fs.mkdirSync(dest);
	  copyDir(src, dest, opts);
	  return setDestMode(dest, srcMode)
	}

	function copyDir (src, dest, opts) {
	  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts));
	}

	function copyDirItem (item, src, dest, opts) {
	  const srcItem = path.join(src, item);
	  const destItem = path.join(dest, item);
	  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy');
	  return startCopy(destStat, srcItem, destItem, opts)
	}

	function onLink (destStat, src, dest, opts) {
	  let resolvedSrc = fs.readlinkSync(src);
	  if (opts.dereference) {
	    resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
	  }

	  if (!destStat) {
	    return fs.symlinkSync(resolvedSrc, dest)
	  } else {
	    let resolvedDest;
	    try {
	      resolvedDest = fs.readlinkSync(dest);
	    } catch (err) {
	      // dest exists and is a regular file or directory,
	      // Windows may throw UNKNOWN error. If dest already exists,
	      // fs throws error anyway, so no need to guard against it here.
	      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)
	      throw err
	    }
	    if (opts.dereference) {
	      resolvedDest = path.resolve(process.cwd(), resolvedDest);
	    }
	    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
	      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)
	    }

	    // prevent copy if src is a subdir of dest since unlinking
	    // dest in this case would result in removing src contents
	    // and therefore a broken symlink would be created.
	    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
	      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)
	    }
	    return copyLink(resolvedSrc, dest)
	  }
	}

	function copyLink (resolvedSrc, dest) {
	  fs.unlinkSync(dest);
	  return fs.symlinkSync(resolvedSrc, dest)
	}

	copySync_1 = copySync;
	return copySync_1;
}

var copySync;
var hasRequiredCopySync;

function requireCopySync () {
	if (hasRequiredCopySync) return copySync;
	hasRequiredCopySync = 1;

	copySync = {
	  copySync: requireCopySync$1()
	};
	return copySync;
}

var pathExists_1;
var hasRequiredPathExists;

function requirePathExists () {
	if (hasRequiredPathExists) return pathExists_1;
	hasRequiredPathExists = 1;
	const u = requireUniversalify().fromPromise;
	const fs = requireFs();

	function pathExists (path) {
	  return fs.access(path).then(() => true).catch(() => false)
	}

	pathExists_1 = {
	  pathExists: u(pathExists),
	  pathExistsSync: fs.existsSync
	};
	return pathExists_1;
}

var copy_1;
var hasRequiredCopy$1;

function requireCopy$1 () {
	if (hasRequiredCopy$1) return copy_1;
	hasRequiredCopy$1 = 1;

	const fs = requireGracefulFs();
	const path = require$$1$4;
	const mkdirs = requireMkdirs().mkdirs;
	const pathExists = requirePathExists().pathExists;
	const utimesMillis = requireUtimes().utimesMillis;
	const stat = requireStat();

	function copy (src, dest, opts, cb) {
	  if (typeof opts === 'function' && !cb) {
	    cb = opts;
	    opts = {};
	  } else if (typeof opts === 'function') {
	    opts = { filter: opts };
	  }

	  cb = cb || function () {};
	  opts = opts || {};

	  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
	  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

	  // Warn about using preserveTimestamps on 32-bit node
	  if (opts.preserveTimestamps && process.arch === 'ia32') {
	    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
	  }

	  stat.checkPaths(src, dest, 'copy', (err, stats) => {
	    if (err) return cb(err)
	    const { srcStat, destStat } = stats;
	    stat.checkParentPaths(src, srcStat, dest, 'copy', err => {
	      if (err) return cb(err)
	      if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)
	      return checkParentDir(destStat, src, dest, opts, cb)
	    });
	  });
	}

	function checkParentDir (destStat, src, dest, opts, cb) {
	  const destParent = path.dirname(dest);
	  pathExists(destParent, (err, dirExists) => {
	    if (err) return cb(err)
	    if (dirExists) return startCopy(destStat, src, dest, opts, cb)
	    mkdirs(destParent, err => {
	      if (err) return cb(err)
	      return startCopy(destStat, src, dest, opts, cb)
	    });
	  });
	}

	function handleFilter (onInclude, destStat, src, dest, opts, cb) {
	  Promise.resolve(opts.filter(src, dest)).then(include => {
	    if (include) return onInclude(destStat, src, dest, opts, cb)
	    return cb()
	  }, error => cb(error));
	}

	function startCopy (destStat, src, dest, opts, cb) {
	  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)
	  return getStats(destStat, src, dest, opts, cb)
	}

	function getStats (destStat, src, dest, opts, cb) {
	  const stat = opts.dereference ? fs.stat : fs.lstat;
	  stat(src, (err, srcStat) => {
	    if (err) return cb(err)

	    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)
	    else if (srcStat.isFile() ||
	             srcStat.isCharacterDevice() ||
	             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)
	    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)
	  });
	}

	function onFile (srcStat, destStat, src, dest, opts, cb) {
	  if (!destStat) return copyFile(srcStat, src, dest, opts, cb)
	  return mayCopyFile(srcStat, src, dest, opts, cb)
	}

	function mayCopyFile (srcStat, src, dest, opts, cb) {
	  if (opts.overwrite) {
	    fs.unlink(dest, err => {
	      if (err) return cb(err)
	      return copyFile(srcStat, src, dest, opts, cb)
	    });
	  } else if (opts.errorOnExist) {
	    return cb(new Error(`'${dest}' already exists`))
	  } else return cb()
	}

	function copyFile (srcStat, src, dest, opts, cb) {
	  fs.copyFile(src, dest, err => {
	    if (err) return cb(err)
	    if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src, dest, cb)
	    return setDestMode(dest, srcStat.mode, cb)
	  });
	}

	function handleTimestampsAndMode (srcMode, src, dest, cb) {
	  // Make sure the file is writable before setting the timestamp
	  // otherwise open fails with EPERM when invoked with 'r+'
	  // (through utimes call)
	  if (fileIsNotWritable(srcMode)) {
	    return makeFileWritable(dest, srcMode, err => {
	      if (err) return cb(err)
	      return setDestTimestampsAndMode(srcMode, src, dest, cb)
	    })
	  }
	  return setDestTimestampsAndMode(srcMode, src, dest, cb)
	}

	function fileIsNotWritable (srcMode) {
	  return (srcMode & 0o200) === 0
	}

	function makeFileWritable (dest, srcMode, cb) {
	  return setDestMode(dest, srcMode | 0o200, cb)
	}

	function setDestTimestampsAndMode (srcMode, src, dest, cb) {
	  setDestTimestamps(src, dest, err => {
	    if (err) return cb(err)
	    return setDestMode(dest, srcMode, cb)
	  });
	}

	function setDestMode (dest, srcMode, cb) {
	  return fs.chmod(dest, srcMode, cb)
	}

	function setDestTimestamps (src, dest, cb) {
	  // The initial srcStat.atime cannot be trusted
	  // because it is modified by the read(2) system call
	  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
	  fs.stat(src, (err, updatedSrcStat) => {
	    if (err) return cb(err)
	    return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb)
	  });
	}

	function onDir (srcStat, destStat, src, dest, opts, cb) {
	  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts, cb)
	  if (destStat && !destStat.isDirectory()) {
	    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))
	  }
	  return copyDir(src, dest, opts, cb)
	}

	function mkDirAndCopy (srcMode, src, dest, opts, cb) {
	  fs.mkdir(dest, err => {
	    if (err) return cb(err)
	    copyDir(src, dest, opts, err => {
	      if (err) return cb(err)
	      return setDestMode(dest, srcMode, cb)
	    });
	  });
	}

	function copyDir (src, dest, opts, cb) {
	  fs.readdir(src, (err, items) => {
	    if (err) return cb(err)
	    return copyDirItems(items, src, dest, opts, cb)
	  });
	}

	function copyDirItems (items, src, dest, opts, cb) {
	  const item = items.pop();
	  if (!item) return cb()
	  return copyDirItem(items, item, src, dest, opts, cb)
	}

	function copyDirItem (items, item, src, dest, opts, cb) {
	  const srcItem = path.join(src, item);
	  const destItem = path.join(dest, item);
	  stat.checkPaths(srcItem, destItem, 'copy', (err, stats) => {
	    if (err) return cb(err)
	    const { destStat } = stats;
	    startCopy(destStat, srcItem, destItem, opts, err => {
	      if (err) return cb(err)
	      return copyDirItems(items, src, dest, opts, cb)
	    });
	  });
	}

	function onLink (destStat, src, dest, opts, cb) {
	  fs.readlink(src, (err, resolvedSrc) => {
	    if (err) return cb(err)
	    if (opts.dereference) {
	      resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
	    }

	    if (!destStat) {
	      return fs.symlink(resolvedSrc, dest, cb)
	    } else {
	      fs.readlink(dest, (err, resolvedDest) => {
	        if (err) {
	          // dest exists and is a regular file or directory,
	          // Windows may throw UNKNOWN error. If dest already exists,
	          // fs throws error anyway, so no need to guard against it here.
	          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)
	          return cb(err)
	        }
	        if (opts.dereference) {
	          resolvedDest = path.resolve(process.cwd(), resolvedDest);
	        }
	        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
	          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))
	        }

	        // do not copy if src is a subdir of dest since unlinking
	        // dest in this case would result in removing src contents
	        // and therefore a broken symlink would be created.
	        if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
	          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))
	        }
	        return copyLink(resolvedSrc, dest, cb)
	      });
	    }
	  });
	}

	function copyLink (resolvedSrc, dest, cb) {
	  fs.unlink(dest, err => {
	    if (err) return cb(err)
	    return fs.symlink(resolvedSrc, dest, cb)
	  });
	}

	copy_1 = copy;
	return copy_1;
}

var copy;
var hasRequiredCopy;

function requireCopy () {
	if (hasRequiredCopy) return copy;
	hasRequiredCopy = 1;

	const u = requireUniversalify().fromCallback;
	copy = {
	  copy: u(requireCopy$1())
	};
	return copy;
}

var rimraf_1;
var hasRequiredRimraf;

function requireRimraf () {
	if (hasRequiredRimraf) return rimraf_1;
	hasRequiredRimraf = 1;

	const fs = requireGracefulFs();
	const path = require$$1$4;
	const assert = require$$0$7;

	const isWindows = (process.platform === 'win32');

	function defaults (options) {
	  const methods = [
	    'unlink',
	    'chmod',
	    'stat',
	    'lstat',
	    'rmdir',
	    'readdir'
	  ];
	  methods.forEach(m => {
	    options[m] = options[m] || fs[m];
	    m = m + 'Sync';
	    options[m] = options[m] || fs[m];
	  });

	  options.maxBusyTries = options.maxBusyTries || 3;
	}

	function rimraf (p, options, cb) {
	  let busyTries = 0;

	  if (typeof options === 'function') {
	    cb = options;
	    options = {};
	  }

	  assert(p, 'rimraf: missing path');
	  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string');
	  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required');
	  assert(options, 'rimraf: invalid options argument provided');
	  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object');

	  defaults(options);

	  rimraf_(p, options, function CB (er) {
	    if (er) {
	      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&
	          busyTries < options.maxBusyTries) {
	        busyTries++;
	        const time = busyTries * 100;
	        // try again, with the same exact callback as this one.
	        return setTimeout(() => rimraf_(p, options, CB), time)
	      }

	      // already gone
	      if (er.code === 'ENOENT') er = null;
	    }

	    cb(er);
	  });
	}

	// Two possible strategies.
	// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
	// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
	//
	// Both result in an extra syscall when you guess wrong.  However, there
	// are likely far more normal files in the world than directories.  This
	// is based on the assumption that a the average number of files per
	// directory is >= 1.
	//
	// If anyone ever complains about this, then I guess the strategy could
	// be made configurable somehow.  But until then, YAGNI.
	function rimraf_ (p, options, cb) {
	  assert(p);
	  assert(options);
	  assert(typeof cb === 'function');

	  // sunos lets the root user unlink directories, which is... weird.
	  // so we have to lstat here and make sure it's not a dir.
	  options.lstat(p, (er, st) => {
	    if (er && er.code === 'ENOENT') {
	      return cb(null)
	    }

	    // Windows can EPERM on stat.  Life is suffering.
	    if (er && er.code === 'EPERM' && isWindows) {
	      return fixWinEPERM(p, options, er, cb)
	    }

	    if (st && st.isDirectory()) {
	      return rmdir(p, options, er, cb)
	    }

	    options.unlink(p, er => {
	      if (er) {
	        if (er.code === 'ENOENT') {
	          return cb(null)
	        }
	        if (er.code === 'EPERM') {
	          return (isWindows)
	            ? fixWinEPERM(p, options, er, cb)
	            : rmdir(p, options, er, cb)
	        }
	        if (er.code === 'EISDIR') {
	          return rmdir(p, options, er, cb)
	        }
	      }
	      return cb(er)
	    });
	  });
	}

	function fixWinEPERM (p, options, er, cb) {
	  assert(p);
	  assert(options);
	  assert(typeof cb === 'function');

	  options.chmod(p, 0o666, er2 => {
	    if (er2) {
	      cb(er2.code === 'ENOENT' ? null : er);
	    } else {
	      options.stat(p, (er3, stats) => {
	        if (er3) {
	          cb(er3.code === 'ENOENT' ? null : er);
	        } else if (stats.isDirectory()) {
	          rmdir(p, options, er, cb);
	        } else {
	          options.unlink(p, cb);
	        }
	      });
	    }
	  });
	}

	function fixWinEPERMSync (p, options, er) {
	  let stats;

	  assert(p);
	  assert(options);

	  try {
	    options.chmodSync(p, 0o666);
	  } catch (er2) {
	    if (er2.code === 'ENOENT') {
	      return
	    } else {
	      throw er
	    }
	  }

	  try {
	    stats = options.statSync(p);
	  } catch (er3) {
	    if (er3.code === 'ENOENT') {
	      return
	    } else {
	      throw er
	    }
	  }

	  if (stats.isDirectory()) {
	    rmdirSync(p, options, er);
	  } else {
	    options.unlinkSync(p);
	  }
	}

	function rmdir (p, options, originalEr, cb) {
	  assert(p);
	  assert(options);
	  assert(typeof cb === 'function');

	  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
	  // if we guessed wrong, and it's not a directory, then
	  // raise the original error.
	  options.rmdir(p, er => {
	    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {
	      rmkids(p, options, cb);
	    } else if (er && er.code === 'ENOTDIR') {
	      cb(originalEr);
	    } else {
	      cb(er);
	    }
	  });
	}

	function rmkids (p, options, cb) {
	  assert(p);
	  assert(options);
	  assert(typeof cb === 'function');

	  options.readdir(p, (er, files) => {
	    if (er) return cb(er)

	    let n = files.length;
	    let errState;

	    if (n === 0) return options.rmdir(p, cb)

	    files.forEach(f => {
	      rimraf(path.join(p, f), options, er => {
	        if (errState) {
	          return
	        }
	        if (er) return cb(errState = er)
	        if (--n === 0) {
	          options.rmdir(p, cb);
	        }
	      });
	    });
	  });
	}

	// this looks simpler, and is strictly *faster*, but will
	// tie up the JavaScript thread and fail on excessively
	// deep directory trees.
	function rimrafSync (p, options) {
	  let st;

	  options = options || {};
	  defaults(options);

	  assert(p, 'rimraf: missing path');
	  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string');
	  assert(options, 'rimraf: missing options');
	  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object');

	  try {
	    st = options.lstatSync(p);
	  } catch (er) {
	    if (er.code === 'ENOENT') {
	      return
	    }

	    // Windows can EPERM on stat.  Life is suffering.
	    if (er.code === 'EPERM' && isWindows) {
	      fixWinEPERMSync(p, options, er);
	    }
	  }

	  try {
	    // sunos lets the root user unlink directories, which is... weird.
	    if (st && st.isDirectory()) {
	      rmdirSync(p, options, null);
	    } else {
	      options.unlinkSync(p);
	    }
	  } catch (er) {
	    if (er.code === 'ENOENT') {
	      return
	    } else if (er.code === 'EPERM') {
	      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
	    } else if (er.code !== 'EISDIR') {
	      throw er
	    }
	    rmdirSync(p, options, er);
	  }
	}

	function rmdirSync (p, options, originalEr) {
	  assert(p);
	  assert(options);

	  try {
	    options.rmdirSync(p);
	  } catch (er) {
	    if (er.code === 'ENOTDIR') {
	      throw originalEr
	    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {
	      rmkidsSync(p, options);
	    } else if (er.code !== 'ENOENT') {
	      throw er
	    }
	  }
	}

	function rmkidsSync (p, options) {
	  assert(p);
	  assert(options);
	  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options));

	  if (isWindows) {
	    // We only end up here once we got ENOTEMPTY at least once, and
	    // at this point, we are guaranteed to have removed all the kids.
	    // So, we know that it won't be ENOENT or ENOTDIR or anything else.
	    // try really hard to delete stuff on windows, because it has a
	    // PROFOUNDLY annoying habit of not closing handles promptly when
	    // files are deleted, resulting in spurious ENOTEMPTY errors.
	    const startTime = Date.now();
	    do {
	      try {
	        const ret = options.rmdirSync(p, options);
	        return ret
	      } catch {}
	    } while (Date.now() - startTime < 500) // give up after 500ms
	  } else {
	    const ret = options.rmdirSync(p, options);
	    return ret
	  }
	}

	rimraf_1 = rimraf;
	rimraf.sync = rimrafSync;
	return rimraf_1;
}

var remove;
var hasRequiredRemove;

function requireRemove () {
	if (hasRequiredRemove) return remove;
	hasRequiredRemove = 1;

	const u = requireUniversalify().fromCallback;
	const rimraf = requireRimraf();

	remove = {
	  remove: u(rimraf),
	  removeSync: rimraf.sync
	};
	return remove;
}

var empty;
var hasRequiredEmpty;

function requireEmpty () {
	if (hasRequiredEmpty) return empty;
	hasRequiredEmpty = 1;

	const u = requireUniversalify().fromCallback;
	const fs = requireGracefulFs();
	const path = require$$1$4;
	const mkdir = requireMkdirs();
	const remove = requireRemove();

	const emptyDir = u(function emptyDir (dir, callback) {
	  callback = callback || function () {};
	  fs.readdir(dir, (err, items) => {
	    if (err) return mkdir.mkdirs(dir, callback)

	    items = items.map(item => path.join(dir, item));

	    deleteItem();

	    function deleteItem () {
	      const item = items.pop();
	      if (!item) return callback()
	      remove.remove(item, err => {
	        if (err) return callback(err)
	        deleteItem();
	      });
	    }
	  });
	});

	function emptyDirSync (dir) {
	  let items;
	  try {
	    items = fs.readdirSync(dir);
	  } catch {
	    return mkdir.mkdirsSync(dir)
	  }

	  items.forEach(item => {
	    item = path.join(dir, item);
	    remove.removeSync(item);
	  });
	}

	empty = {
	  emptyDirSync,
	  emptydirSync: emptyDirSync,
	  emptyDir,
	  emptydir: emptyDir
	};
	return empty;
}

var file$1;
var hasRequiredFile$1;

function requireFile$1 () {
	if (hasRequiredFile$1) return file$1;
	hasRequiredFile$1 = 1;

	const u = requireUniversalify().fromCallback;
	const path = require$$1$4;
	const fs = requireGracefulFs();
	const mkdir = requireMkdirs();

	function createFile (file, callback) {
	  function makeFile () {
	    fs.writeFile(file, '', err => {
	      if (err) return callback(err)
	      callback();
	    });
	  }

	  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err
	    if (!err && stats.isFile()) return callback()
	    const dir = path.dirname(file);
	    fs.stat(dir, (err, stats) => {
	      if (err) {
	        // if the directory doesn't exist, make it
	        if (err.code === 'ENOENT') {
	          return mkdir.mkdirs(dir, err => {
	            if (err) return callback(err)
	            makeFile();
	          })
	        }
	        return callback(err)
	      }

	      if (stats.isDirectory()) makeFile();
	      else {
	        // parent is not a directory
	        // This is just to cause an internal ENOTDIR error to be thrown
	        fs.readdir(dir, err => {
	          if (err) return callback(err)
	        });
	      }
	    });
	  });
	}

	function createFileSync (file) {
	  let stats;
	  try {
	    stats = fs.statSync(file);
	  } catch {}
	  if (stats && stats.isFile()) return

	  const dir = path.dirname(file);
	  try {
	    if (!fs.statSync(dir).isDirectory()) {
	      // parent is not a directory
	      // This is just to cause an internal ENOTDIR error to be thrown
	      fs.readdirSync(dir);
	    }
	  } catch (err) {
	    // If the stat call above failed because the directory doesn't exist, create it
	    if (err && err.code === 'ENOENT') mkdir.mkdirsSync(dir);
	    else throw err
	  }

	  fs.writeFileSync(file, '');
	}

	file$1 = {
	  createFile: u(createFile),
	  createFileSync
	};
	return file$1;
}

var link;
var hasRequiredLink;

function requireLink () {
	if (hasRequiredLink) return link;
	hasRequiredLink = 1;

	const u = requireUniversalify().fromCallback;
	const path = require$$1$4;
	const fs = requireGracefulFs();
	const mkdir = requireMkdirs();
	const pathExists = requirePathExists().pathExists;

	function createLink (srcpath, dstpath, callback) {
	  function makeLink (srcpath, dstpath) {
	    fs.link(srcpath, dstpath, err => {
	      if (err) return callback(err)
	      callback(null);
	    });
	  }

	  pathExists(dstpath, (err, destinationExists) => {
	    if (err) return callback(err)
	    if (destinationExists) return callback(null)
	    fs.lstat(srcpath, (err) => {
	      if (err) {
	        err.message = err.message.replace('lstat', 'ensureLink');
	        return callback(err)
	      }

	      const dir = path.dirname(dstpath);
	      pathExists(dir, (err, dirExists) => {
	        if (err) return callback(err)
	        if (dirExists) return makeLink(srcpath, dstpath)
	        mkdir.mkdirs(dir, err => {
	          if (err) return callback(err)
	          makeLink(srcpath, dstpath);
	        });
	      });
	    });
	  });
	}

	function createLinkSync (srcpath, dstpath) {
	  const destinationExists = fs.existsSync(dstpath);
	  if (destinationExists) return undefined

	  try {
	    fs.lstatSync(srcpath);
	  } catch (err) {
	    err.message = err.message.replace('lstat', 'ensureLink');
	    throw err
	  }

	  const dir = path.dirname(dstpath);
	  const dirExists = fs.existsSync(dir);
	  if (dirExists) return fs.linkSync(srcpath, dstpath)
	  mkdir.mkdirsSync(dir);

	  return fs.linkSync(srcpath, dstpath)
	}

	link = {
	  createLink: u(createLink),
	  createLinkSync
	};
	return link;
}

var symlinkPaths_1;
var hasRequiredSymlinkPaths;

function requireSymlinkPaths () {
	if (hasRequiredSymlinkPaths) return symlinkPaths_1;
	hasRequiredSymlinkPaths = 1;

	const path = require$$1$4;
	const fs = requireGracefulFs();
	const pathExists = requirePathExists().pathExists;

	/**
	 * Function that returns two types of paths, one relative to symlink, and one
	 * relative to the current working directory. Checks if path is absolute or
	 * relative. If the path is relative, this function checks if the path is
	 * relative to symlink or relative to current working directory. This is an
	 * initiative to find a smarter `srcpath` to supply when building symlinks.
	 * This allows you to determine which path to use out of one of three possible
	 * types of source paths. The first is an absolute path. This is detected by
	 * `path.isAbsolute()`. When an absolute path is provided, it is checked to
	 * see if it exists. If it does it's used, if not an error is returned
	 * (callback)/ thrown (sync). The other two options for `srcpath` are a
	 * relative url. By default Node's `fs.symlink` works by creating a symlink
	 * using `dstpath` and expects the `srcpath` to be relative to the newly
	 * created symlink. If you provide a `srcpath` that does not exist on the file
	 * system it results in a broken symlink. To minimize this, the function
	 * checks to see if the 'relative to symlink' source file exists, and if it
	 * does it will use it. If it does not, it checks if there's a file that
	 * exists that is relative to the current working directory, if does its used.
	 * This preserves the expectations of the original fs.symlink spec and adds
	 * the ability to pass in `relative to current working direcotry` paths.
	 */

	function symlinkPaths (srcpath, dstpath, callback) {
	  if (path.isAbsolute(srcpath)) {
	    return fs.lstat(srcpath, (err) => {
	      if (err) {
	        err.message = err.message.replace('lstat', 'ensureSymlink');
	        return callback(err)
	      }
	      return callback(null, {
	        toCwd: srcpath,
	        toDst: srcpath
	      })
	    })
	  } else {
	    const dstdir = path.dirname(dstpath);
	    const relativeToDst = path.join(dstdir, srcpath);
	    return pathExists(relativeToDst, (err, exists) => {
	      if (err) return callback(err)
	      if (exists) {
	        return callback(null, {
	          toCwd: relativeToDst,
	          toDst: srcpath
	        })
	      } else {
	        return fs.lstat(srcpath, (err) => {
	          if (err) {
	            err.message = err.message.replace('lstat', 'ensureSymlink');
	            return callback(err)
	          }
	          return callback(null, {
	            toCwd: srcpath,
	            toDst: path.relative(dstdir, srcpath)
	          })
	        })
	      }
	    })
	  }
	}

	function symlinkPathsSync (srcpath, dstpath) {
	  let exists;
	  if (path.isAbsolute(srcpath)) {
	    exists = fs.existsSync(srcpath);
	    if (!exists) throw new Error('absolute srcpath does not exist')
	    return {
	      toCwd: srcpath,
	      toDst: srcpath
	    }
	  } else {
	    const dstdir = path.dirname(dstpath);
	    const relativeToDst = path.join(dstdir, srcpath);
	    exists = fs.existsSync(relativeToDst);
	    if (exists) {
	      return {
	        toCwd: relativeToDst,
	        toDst: srcpath
	      }
	    } else {
	      exists = fs.existsSync(srcpath);
	      if (!exists) throw new Error('relative srcpath does not exist')
	      return {
	        toCwd: srcpath,
	        toDst: path.relative(dstdir, srcpath)
	      }
	    }
	  }
	}

	symlinkPaths_1 = {
	  symlinkPaths,
	  symlinkPathsSync
	};
	return symlinkPaths_1;
}

var symlinkType_1;
var hasRequiredSymlinkType;

function requireSymlinkType () {
	if (hasRequiredSymlinkType) return symlinkType_1;
	hasRequiredSymlinkType = 1;

	const fs = requireGracefulFs();

	function symlinkType (srcpath, type, callback) {
	  callback = (typeof type === 'function') ? type : callback;
	  type = (typeof type === 'function') ? false : type;
	  if (type) return callback(null, type)
	  fs.lstat(srcpath, (err, stats) => {
	    if (err) return callback(null, 'file')
	    type = (stats && stats.isDirectory()) ? 'dir' : 'file';
	    callback(null, type);
	  });
	}

	function symlinkTypeSync (srcpath, type) {
	  let stats;

	  if (type) return type
	  try {
	    stats = fs.lstatSync(srcpath);
	  } catch {
	    return 'file'
	  }
	  return (stats && stats.isDirectory()) ? 'dir' : 'file'
	}

	symlinkType_1 = {
	  symlinkType,
	  symlinkTypeSync
	};
	return symlinkType_1;
}

var symlink;
var hasRequiredSymlink;

function requireSymlink () {
	if (hasRequiredSymlink) return symlink;
	hasRequiredSymlink = 1;

	const u = requireUniversalify().fromCallback;
	const path = require$$1$4;
	const fs = requireGracefulFs();
	const _mkdirs = requireMkdirs();
	const mkdirs = _mkdirs.mkdirs;
	const mkdirsSync = _mkdirs.mkdirsSync;

	const _symlinkPaths = requireSymlinkPaths();
	const symlinkPaths = _symlinkPaths.symlinkPaths;
	const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;

	const _symlinkType = requireSymlinkType();
	const symlinkType = _symlinkType.symlinkType;
	const symlinkTypeSync = _symlinkType.symlinkTypeSync;

	const pathExists = requirePathExists().pathExists;

	function createSymlink (srcpath, dstpath, type, callback) {
	  callback = (typeof type === 'function') ? type : callback;
	  type = (typeof type === 'function') ? false : type;

	  pathExists(dstpath, (err, destinationExists) => {
	    if (err) return callback(err)
	    if (destinationExists) return callback(null)
	    symlinkPaths(srcpath, dstpath, (err, relative) => {
	      if (err) return callback(err)
	      srcpath = relative.toDst;
	      symlinkType(relative.toCwd, type, (err, type) => {
	        if (err) return callback(err)
	        const dir = path.dirname(dstpath);
	        pathExists(dir, (err, dirExists) => {
	          if (err) return callback(err)
	          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)
	          mkdirs(dir, err => {
	            if (err) return callback(err)
	            fs.symlink(srcpath, dstpath, type, callback);
	          });
	        });
	      });
	    });
	  });
	}

	function createSymlinkSync (srcpath, dstpath, type) {
	  const destinationExists = fs.existsSync(dstpath);
	  if (destinationExists) return undefined

	  const relative = symlinkPathsSync(srcpath, dstpath);
	  srcpath = relative.toDst;
	  type = symlinkTypeSync(relative.toCwd, type);
	  const dir = path.dirname(dstpath);
	  const exists = fs.existsSync(dir);
	  if (exists) return fs.symlinkSync(srcpath, dstpath, type)
	  mkdirsSync(dir);
	  return fs.symlinkSync(srcpath, dstpath, type)
	}

	symlink = {
	  createSymlink: u(createSymlink),
	  createSymlinkSync
	};
	return symlink;
}

var ensure;
var hasRequiredEnsure;

function requireEnsure () {
	if (hasRequiredEnsure) return ensure;
	hasRequiredEnsure = 1;

	const file = requireFile$1();
	const link = requireLink();
	const symlink = requireSymlink();

	ensure = {
	  // file
	  createFile: file.createFile,
	  createFileSync: file.createFileSync,
	  ensureFile: file.createFile,
	  ensureFileSync: file.createFileSync,
	  // link
	  createLink: link.createLink,
	  createLinkSync: link.createLinkSync,
	  ensureLink: link.createLink,
	  ensureLinkSync: link.createLinkSync,
	  // symlink
	  createSymlink: symlink.createSymlink,
	  createSymlinkSync: symlink.createSymlinkSync,
	  ensureSymlink: symlink.createSymlink,
	  ensureSymlinkSync: symlink.createSymlinkSync
	};
	return ensure;
}

var utils$1;
var hasRequiredUtils$1;

function requireUtils$1 () {
	if (hasRequiredUtils$1) return utils$1;
	hasRequiredUtils$1 = 1;
	function stringify (obj, { EOL = '\n', finalEOL = true, replacer = null, spaces } = {}) {
	  const EOF = finalEOL ? EOL : '';
	  const str = JSON.stringify(obj, replacer, spaces);

	  return str.replace(/\n/g, EOL) + EOF
	}

	function stripBom (content) {
	  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
	  if (Buffer.isBuffer(content)) content = content.toString('utf8');
	  return content.replace(/^\uFEFF/, '')
	}

	utils$1 = { stringify, stripBom };
	return utils$1;
}

var jsonfile_1;
var hasRequiredJsonfile$1;

function requireJsonfile$1 () {
	if (hasRequiredJsonfile$1) return jsonfile_1;
	hasRequiredJsonfile$1 = 1;
	let _fs;
	try {
	  _fs = requireGracefulFs();
	} catch (_) {
	  _fs = require$$0$8;
	}
	const universalify = requireUniversalify();
	const { stringify, stripBom } = requireUtils$1();

	async function _readFile (file, options = {}) {
	  if (typeof options === 'string') {
	    options = { encoding: options };
	  }

	  const fs = options.fs || _fs;

	  const shouldThrow = 'throws' in options ? options.throws : true;

	  let data = await universalify.fromCallback(fs.readFile)(file, options);

	  data = stripBom(data);

	  let obj;
	  try {
	    obj = JSON.parse(data, options ? options.reviver : null);
	  } catch (err) {
	    if (shouldThrow) {
	      err.message = `${file}: ${err.message}`;
	      throw err
	    } else {
	      return null
	    }
	  }

	  return obj
	}

	const readFile = universalify.fromPromise(_readFile);

	function readFileSync (file, options = {}) {
	  if (typeof options === 'string') {
	    options = { encoding: options };
	  }

	  const fs = options.fs || _fs;

	  const shouldThrow = 'throws' in options ? options.throws : true;

	  try {
	    let content = fs.readFileSync(file, options);
	    content = stripBom(content);
	    return JSON.parse(content, options.reviver)
	  } catch (err) {
	    if (shouldThrow) {
	      err.message = `${file}: ${err.message}`;
	      throw err
	    } else {
	      return null
	    }
	  }
	}

	async function _writeFile (file, obj, options = {}) {
	  const fs = options.fs || _fs;

	  const str = stringify(obj, options);

	  await universalify.fromCallback(fs.writeFile)(file, str, options);
	}

	const writeFile = universalify.fromPromise(_writeFile);

	function writeFileSync (file, obj, options = {}) {
	  const fs = options.fs || _fs;

	  const str = stringify(obj, options);
	  // not sure if fs.writeFileSync returns anything, but just in case
	  return fs.writeFileSync(file, str, options)
	}

	const jsonfile = {
	  readFile,
	  readFileSync,
	  writeFile,
	  writeFileSync
	};

	jsonfile_1 = jsonfile;
	return jsonfile_1;
}

var jsonfile;
var hasRequiredJsonfile;

function requireJsonfile () {
	if (hasRequiredJsonfile) return jsonfile;
	hasRequiredJsonfile = 1;

	const jsonFile = requireJsonfile$1();

	jsonfile = {
	  // jsonfile exports
	  readJson: jsonFile.readFile,
	  readJsonSync: jsonFile.readFileSync,
	  writeJson: jsonFile.writeFile,
	  writeJsonSync: jsonFile.writeFileSync
	};
	return jsonfile;
}

var output;
var hasRequiredOutput;

function requireOutput () {
	if (hasRequiredOutput) return output;
	hasRequiredOutput = 1;

	const u = requireUniversalify().fromCallback;
	const fs = requireGracefulFs();
	const path = require$$1$4;
	const mkdir = requireMkdirs();
	const pathExists = requirePathExists().pathExists;

	function outputFile (file, data, encoding, callback) {
	  if (typeof encoding === 'function') {
	    callback = encoding;
	    encoding = 'utf8';
	  }

	  const dir = path.dirname(file);
	  pathExists(dir, (err, itDoes) => {
	    if (err) return callback(err)
	    if (itDoes) return fs.writeFile(file, data, encoding, callback)

	    mkdir.mkdirs(dir, err => {
	      if (err) return callback(err)

	      fs.writeFile(file, data, encoding, callback);
	    });
	  });
	}

	function outputFileSync (file, ...args) {
	  const dir = path.dirname(file);
	  if (fs.existsSync(dir)) {
	    return fs.writeFileSync(file, ...args)
	  }
	  mkdir.mkdirsSync(dir);
	  fs.writeFileSync(file, ...args);
	}

	output = {
	  outputFile: u(outputFile),
	  outputFileSync
	};
	return output;
}

var outputJson_1;
var hasRequiredOutputJson;

function requireOutputJson () {
	if (hasRequiredOutputJson) return outputJson_1;
	hasRequiredOutputJson = 1;

	const { stringify } = requireUtils$1();
	const { outputFile } = requireOutput();

	async function outputJson (file, data, options = {}) {
	  const str = stringify(data, options);

	  await outputFile(file, str, options);
	}

	outputJson_1 = outputJson;
	return outputJson_1;
}

var outputJsonSync_1;
var hasRequiredOutputJsonSync;

function requireOutputJsonSync () {
	if (hasRequiredOutputJsonSync) return outputJsonSync_1;
	hasRequiredOutputJsonSync = 1;

	const { stringify } = requireUtils$1();
	const { outputFileSync } = requireOutput();

	function outputJsonSync (file, data, options) {
	  const str = stringify(data, options);

	  outputFileSync(file, str, options);
	}

	outputJsonSync_1 = outputJsonSync;
	return outputJsonSync_1;
}

var json;
var hasRequiredJson;

function requireJson () {
	if (hasRequiredJson) return json;
	hasRequiredJson = 1;

	const u = requireUniversalify().fromPromise;
	const jsonFile = requireJsonfile();

	jsonFile.outputJson = u(requireOutputJson());
	jsonFile.outputJsonSync = requireOutputJsonSync();
	// aliases
	jsonFile.outputJSON = jsonFile.outputJson;
	jsonFile.outputJSONSync = jsonFile.outputJsonSync;
	jsonFile.writeJSON = jsonFile.writeJson;
	jsonFile.writeJSONSync = jsonFile.writeJsonSync;
	jsonFile.readJSON = jsonFile.readJson;
	jsonFile.readJSONSync = jsonFile.readJsonSync;

	json = jsonFile;
	return json;
}

var moveSync_1;
var hasRequiredMoveSync$1;

function requireMoveSync$1 () {
	if (hasRequiredMoveSync$1) return moveSync_1;
	hasRequiredMoveSync$1 = 1;

	const fs = requireGracefulFs();
	const path = require$$1$4;
	const copySync = requireCopySync().copySync;
	const removeSync = requireRemove().removeSync;
	const mkdirpSync = requireMkdirs().mkdirpSync;
	const stat = requireStat();

	function moveSync (src, dest, opts) {
	  opts = opts || {};
	  const overwrite = opts.overwrite || opts.clobber || false;

	  const { srcStat } = stat.checkPathsSync(src, dest, 'move');
	  stat.checkParentPathsSync(src, srcStat, dest, 'move');
	  mkdirpSync(path.dirname(dest));
	  return doRename(src, dest, overwrite)
	}

	function doRename (src, dest, overwrite) {
	  if (overwrite) {
	    removeSync(dest);
	    return rename(src, dest, overwrite)
	  }
	  if (fs.existsSync(dest)) throw new Error('dest already exists.')
	  return rename(src, dest, overwrite)
	}

	function rename (src, dest, overwrite) {
	  try {
	    fs.renameSync(src, dest);
	  } catch (err) {
	    if (err.code !== 'EXDEV') throw err
	    return moveAcrossDevice(src, dest, overwrite)
	  }
	}

	function moveAcrossDevice (src, dest, overwrite) {
	  const opts = {
	    overwrite,
	    errorOnExist: true
	  };
	  copySync(src, dest, opts);
	  return removeSync(src)
	}

	moveSync_1 = moveSync;
	return moveSync_1;
}

var moveSync;
var hasRequiredMoveSync;

function requireMoveSync () {
	if (hasRequiredMoveSync) return moveSync;
	hasRequiredMoveSync = 1;

	moveSync = {
	  moveSync: requireMoveSync$1()
	};
	return moveSync;
}

var move_1;
var hasRequiredMove$2;

function requireMove$2 () {
	if (hasRequiredMove$2) return move_1;
	hasRequiredMove$2 = 1;

	const fs = requireGracefulFs();
	const path = require$$1$4;
	const copy = requireCopy().copy;
	const remove = requireRemove().remove;
	const mkdirp = requireMkdirs().mkdirp;
	const pathExists = requirePathExists().pathExists;
	const stat = requireStat();

	function move (src, dest, opts, cb) {
	  if (typeof opts === 'function') {
	    cb = opts;
	    opts = {};
	  }

	  const overwrite = opts.overwrite || opts.clobber || false;

	  stat.checkPaths(src, dest, 'move', (err, stats) => {
	    if (err) return cb(err)
	    const { srcStat } = stats;
	    stat.checkParentPaths(src, srcStat, dest, 'move', err => {
	      if (err) return cb(err)
	      mkdirp(path.dirname(dest), err => {
	        if (err) return cb(err)
	        return doRename(src, dest, overwrite, cb)
	      });
	    });
	  });
	}

	function doRename (src, dest, overwrite, cb) {
	  if (overwrite) {
	    return remove(dest, err => {
	      if (err) return cb(err)
	      return rename(src, dest, overwrite, cb)
	    })
	  }
	  pathExists(dest, (err, destExists) => {
	    if (err) return cb(err)
	    if (destExists) return cb(new Error('dest already exists.'))
	    return rename(src, dest, overwrite, cb)
	  });
	}

	function rename (src, dest, overwrite, cb) {
	  fs.rename(src, dest, err => {
	    if (!err) return cb()
	    if (err.code !== 'EXDEV') return cb(err)
	    return moveAcrossDevice(src, dest, overwrite, cb)
	  });
	}

	function moveAcrossDevice (src, dest, overwrite, cb) {
	  const opts = {
	    overwrite,
	    errorOnExist: true
	  };
	  copy(src, dest, opts, err => {
	    if (err) return cb(err)
	    return remove(src, cb)
	  });
	}

	move_1 = move;
	return move_1;
}

var move$1;
var hasRequiredMove$1;

function requireMove$1 () {
	if (hasRequiredMove$1) return move$1;
	hasRequiredMove$1 = 1;

	const u = requireUniversalify().fromCallback;
	move$1 = {
	  move: u(requireMove$2())
	};
	return move$1;
}

var hasRequiredLib$1;

function requireLib$1 () {
	if (hasRequiredLib$1) return lib$1.exports;
	hasRequiredLib$1 = 1;
	(function (module) {

		module.exports = {
		  // Export promiseified graceful-fs:
		  ...requireFs(),
		  // Export extra methods:
		  ...requireCopySync(),
		  ...requireCopy(),
		  ...requireEmpty(),
		  ...requireEnsure(),
		  ...requireJson(),
		  ...requireMkdirs(),
		  ...requireMoveSync(),
		  ...requireMove$1(),
		  ...requireOutput(),
		  ...requirePathExists(),
		  ...requireRemove()
		};

		// Export fs.promises as a getter property so that we don't trigger
		// ExperimentalWarning before fs.promises is actually accessed.
		const fs = require$$0$8;
		if (Object.getOwnPropertyDescriptor(fs, 'promises')) {
		  Object.defineProperty(module.exports, 'promises', {
		    get () { return fs.promises }
		  });
		} 
	} (lib$1));
	return lib$1.exports;
}

var ini = {};

var hasRequiredIni;

function requireIni () {
	if (hasRequiredIni) return ini;
	hasRequiredIni = 1;
	ini.parse = ini.decode = decode;

	ini.stringify = ini.encode = encode;

	ini.safe = safe;
	ini.unsafe = unsafe;

	var eol = typeof process !== 'undefined' &&
	  process.platform === 'win32' ? '\r\n' : '\n';

	function encode (obj, opt) {
	  var children = [];
	  var out = '';

	  if (typeof opt === 'string') {
	    opt = {
	      section: opt,
	      whitespace: false,
	    };
	  } else {
	    opt = opt || {};
	    opt.whitespace = opt.whitespace === true;
	  }

	  var separator = opt.whitespace ? ' = ' : '=';

	  Object.keys(obj).forEach(function (k, _, __) {
	    var val = obj[k];
	    if (val && Array.isArray(val)) {
	      val.forEach(function (item) {
	        out += safe(k + '[]') + separator + safe(item) + '\n';
	      });
	    } else if (val && typeof val === 'object')
	      children.push(k);
	    else
	      out += safe(k) + separator + safe(val) + eol;
	  });

	  if (opt.section && out.length)
	    out = '[' + safe(opt.section) + ']' + eol + out;

	  children.forEach(function (k, _, __) {
	    var nk = dotSplit(k).join('\\.');
	    var section = (opt.section ? opt.section + '.' : '') + nk;
	    var child = encode(obj[k], {
	      section: section,
	      whitespace: opt.whitespace,
	    });
	    if (out.length && child.length)
	      out += eol;

	    out += child;
	  });

	  return out
	}

	function dotSplit (str) {
	  return str.replace(/\1/g, '\u0002LITERAL\\1LITERAL\u0002')
	    .replace(/\\\./g, '\u0001')
	    .split(/\./).map(function (part) {
	      return part.replace(/\1/g, '\\.')
	        .replace(/\2LITERAL\\1LITERAL\2/g, '\u0001')
	    })
	}

	function decode (str) {
	  var out = {};
	  var p = out;
	  var section = null;
	  //          section     |key      = value
	  var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
	  var lines = str.split(/[\r\n]+/g);

	  lines.forEach(function (line, _, __) {
	    if (!line || line.match(/^\s*[;#]/))
	      return
	    var match = line.match(re);
	    if (!match)
	      return
	    if (match[1] !== undefined) {
	      section = unsafe(match[1]);
	      if (section === '__proto__') {
	        // not allowed
	        // keep parsing the section, but don't attach it.
	        p = {};
	        return
	      }
	      p = out[section] = out[section] || {};
	      return
	    }
	    var key = unsafe(match[2]);
	    if (key === '__proto__')
	      return
	    var value = match[3] ? unsafe(match[4]) : true;
	    switch (value) {
	      case 'true':
	      case 'false':
	      case 'null': value = JSON.parse(value);
	    }

	    // Convert keys with '[]' suffix to an array
	    if (key.length > 2 && key.slice(-2) === '[]') {
	      key = key.substring(0, key.length - 2);
	      if (key === '__proto__')
	        return
	      if (!p[key])
	        p[key] = [];
	      else if (!Array.isArray(p[key]))
	        p[key] = [p[key]];
	    }

	    // safeguard against resetting a previously defined
	    // array by accidentally forgetting the brackets
	    if (Array.isArray(p[key]))
	      p[key].push(value);
	    else
	      p[key] = value;
	  });

	  // {a:{y:1},"a.b":{x:2}} --> {a:{y:1,b:{x:2}}}
	  // use a filter to return the keys that have to be deleted.
	  Object.keys(out).filter(function (k, _, __) {
	    if (!out[k] ||
	      typeof out[k] !== 'object' ||
	      Array.isArray(out[k]))
	      return false

	    // see if the parent section is also an object.
	    // if so, add it to that, and mark this one for deletion
	    var parts = dotSplit(k);
	    var p = out;
	    var l = parts.pop();
	    var nl = l.replace(/\\\./g, '.');
	    parts.forEach(function (part, _, __) {
	      if (part === '__proto__')
	        return
	      if (!p[part] || typeof p[part] !== 'object')
	        p[part] = {};
	      p = p[part];
	    });
	    if (p === out && nl === l)
	      return false

	    p[nl] = out[k];
	    return true
	  }).forEach(function (del, _, __) {
	    delete out[del];
	  });

	  return out
	}

	function isQuoted (val) {
	  return (val.charAt(0) === '"' && val.slice(-1) === '"') ||
	    (val.charAt(0) === "'" && val.slice(-1) === "'")
	}

	function safe (val) {
	  return (typeof val !== 'string' ||
	    val.match(/[=\r\n]/) ||
	    val.match(/^\[/) ||
	    (val.length > 1 &&
	     isQuoted(val)) ||
	    val !== val.trim())
	    ? JSON.stringify(val)
	    : val.replace(/;/g, '\\;').replace(/#/g, '\\#')
	}

	function unsafe (val, doUnesc) {
	  val = (val || '').trim();
	  if (isQuoted(val)) {
	    // remove the single quotes before calling JSON.parse
	    if (val.charAt(0) === "'")
	      val = val.substr(1, val.length - 2);

	    try {
	      val = JSON.parse(val);
	    } catch (_) {}
	  } else {
	    // walk the val to find the first not-escaped ; character
	    var esc = false;
	    var unesc = '';
	    for (var i = 0, l = val.length; i < l; i++) {
	      var c = val.charAt(i);
	      if (esc) {
	        if ('\\;#'.indexOf(c) !== -1)
	          unesc += c;
	        else
	          unesc += '\\' + c;

	        esc = false;
	      } else if (';#'.indexOf(c) !== -1)
	        break
	      else if (c === '\\')
	        esc = true;
	      else
	        unesc += c;
	    }
	    if (esc)
	      unesc += '\\';

	    return unesc.trim()
	  }
	  return val
	}
	return ini;
}

var hasRequiredConfig$1;

function requireConfig$1 () {
	if (hasRequiredConfig$1) return config$1.exports;
	hasRequiredConfig$1 = 1;
	(function (module) {
		const _ = requireLodash();
		const fse = requireLib$1();
		const ini = requireIni();
		const path = require$$1$4;

		const configFile = path.resolve(process.cwd(), 'config.ini');
		let global = {};

		// NOTE: ONLY EXPORT FUNCTIONS, DO NOT EXPORT FIELDS
		module.exports = {
		  update(commandLineConfigs, filepath = configFile) {
		    /* Update the module with configs read from both config file and command line */
		    // Filter undefined fields
		    commandLineConfigs = _.pickBy(commandLineConfigs, (value) => value !== undefined);
		    // Read configs from file
		    const fileConfigs = this.read(filepath);
		    // Merge both configs
		    const configs = {
		      ...fileConfigs,
		      ...commandLineConfigs,
		      pathPatterns: _.get(fileConfigs, 'paths.path', []),
		    };

		    // Add configs to global and export configs
		    global = _.extend(global, configs);
		    Object.keys(global).forEach((p) => {
		      module.exports[p] = global[p];
		    });
		  },

		  read(filepath) {
		    fse.ensureFileSync(filepath);
		    const fp = fse.readFileSync(filepath, 'utf-8');
		    return ini.parse(fp);
		  },

		  write(filepath, configs) {
		    // Filter undefined and function fields
		    configs = _.pickBy(configs, (value) => !_.isUndefined(value) && !_.isFunction(value));
		    const outputINI = ini.stringify(configs);
		    fse.outputFileSync(filepath, outputINI);
		  },

		  getConfigFile: () => configFile,
		}; 
	} (config$1));
	return config$1.exports;
}

var http;
var hasRequiredHttp;

function requireHttp () {
	if (hasRequiredHttp) return http;
	hasRequiredHttp = 1;
	const _ = requireLodash();
	const fs = require$$0$8;
	const path = require$$1$4;
	const ProgressBar = requireProgress();
	const request = requireRequest();
	const urljoin = requireUrlJoin();

	const { Readable } = require$$0$6;
	const logger = requireLogger();
	const config = requireConfig$1();

	const FILTERED_ERROR_CODE = new Set([400, 401, 403, 404, 500, 502, 503, 504]);
	const PROGRESS_RENDER_THROTTLE = 5000;

	function buildOptions(url, headers, options) {
	  let defaultOptions = {
	    url,
	    headers: headers || {},
	    strictSSL: false,
	  };
	  const { proxy } = config;
	  if (proxy) {
	    defaultOptions = {
	      ...defaultOptions,
	      proxy,
	    };
	  }
	  options = _.merge(defaultOptions, options || {});
	  return options;
	}

	function requestProgress(req, format, options) {
	  req.on('response', (res) => {
	    const total = parseInt(res.headers['content-length'], 10) || 1;

	    const opts = {
	      ...options,
	      total,
	    };

	    const bar = new ProgressBar(format, opts);

	    res.on('data', (chunk) => {
	      bar.tick(chunk.length);
	    });
	  });
	  return req;
	}

	http = {
	  stream(url, filePath, opts = {}) {
	    logger.info(`Downloading from ${url} to ${filePath}.`);
	    const promise = new Promise((resolve) => {
	      const method = 'GET';
	      const options = buildOptions(
	        url,
	        {},
	        {
	          ...opts,
	          method,
	        },
	      );

	      const fileName = path.basename(filePath);
	      const format = `\t ${fileName}\t :percent[:bar]\t :currentB (:rateB/s) | Elapsed: :elapseds | ETA: :etas`;
	      const progressOpts = {
	        complete: '=',
	        incomplete: ' ',
	        width: 20,
	        renderThrottle: PROGRESS_RENDER_THROTTLE,
	      };

	      requestProgress(request(options), format, progressOpts)
	        .pipe(fs.createWriteStream(filePath))
	        .on('finish', () => {
	          logger.info('Finished downloading.');
	          resolve();
	        });
	    });
	    return promise;
	  },

	  request(baseUrl, relativeUrl, options, method) {
	    const headers = {
	      'content-type': 'application/json',
	      accept: 'application/json',
	    };
	    const url = urljoin(baseUrl, relativeUrl);
	    options = buildOptions(url, headers, {
	      ...options,
	      json: true,
	      method,
	    });
	    logger.trace('REQUEST:\n', options);
	    const promise = new Promise((resolve, reject) => {
	      request(options, (error, response, body) => {
	        if (error) {
	          logger.error(error);
	          reject(error);
	        } else {
	          logger.info(`${method} ${response.request.href} ${response.statusCode}.`);

	          const res = { status: response.statusCode, body };
	          if ((body && body.error) || FILTERED_ERROR_CODE.has(res.status)) {
	            logger.error(res);
	            reject(res);
	          }
	          resolve(res);
	        }
	      });
	    }).then((response) => {
	      response.requestUrl = options.url;
	      logger.trace('RESPONSE:\n', response);
	      return response;
	    });
	    return promise;
	  },

	  uploadToS3(signedUrl, filePath) {
	    const stats = fs.statSync(filePath);
	    const headers = {
	      'content-type': 'application/octet-stream',
	      accept: 'application/json',
	      'Content-Length': stats.size,
	    };
	    const method = 'PUT';
	    const options = buildOptions(signedUrl, headers, {
	      method,
	      json: true,
	    });
	    const promise = new Promise((resolve, reject) => {
	      fs.createReadStream(filePath).pipe(
	        request(options, (error, response, body) => {
	          if (error) {
	            logger.error(error);
	            reject(error);
	          } else {
	            logger.info(`${method} ${response.request.href} ${response.statusCode}.`);
	            resolve({ status: response.statusCode, body });
	          }
	        }),
	      );
	    });
	    return promise;
	  },

	  streamToS3(signedUrl, content) {
	    const headers = {
	      'content-type': 'application/octet-stream',
	      'Content-Length': content.length,
	    };
	    const method = 'PUT';
	    const options = buildOptions(signedUrl, headers, {
	      method,
	      json: true,
	    });

	    const strStream = new Readable();
	    strStream.push(content);
	    strStream.push(null);

	    const promise = new Promise((resolve, reject) => {
	      strStream.pipe(
	        request(options, (error, response, body) => {
	          if (error) {
	            logger.error(error);
	            reject(error);
	          } else {
	            logger.info(`${method} ${response.request.href} ${response.statusCode}.`);
	            resolve({ status: response.statusCode, body });
	          }
	        }),
	      );
	    });
	    return promise;
	  },
	};
	return http;
}

var os_1;
var hasRequiredOs;

function requireOs () {
	if (hasRequiredOs) return os_1;
	hasRequiredOs = 1;
	const childProcess = require$$0$b;
	const os = require$$1$5;
	const tmp = requireTmp();

	const defaultLogger = requireLogger();

	os_1 = {
	  getUserHome() {
	    return os.homedir();
	  },

	  getHostName() {
	    return os.hostname();
	  },

	  getVersion() {
	    let version = '';
	    const type = os.type();
	    const arch = os.arch();

	    switch (type) {
	      case 'Linux':
	        version += 'Linux';
	        break;
	      case 'Darwin':
	        version += 'macOS (app)';
	        break;
	      case 'Windows_NT':
	        version += 'Windows';
	        switch (arch) {
	          case 'x32':
	            version += ' 32';
	            break;
	          case 'x64':
	            version += ' 64';
	            break;
	          default:
	            throw new Error(`Unsupported architecture: ${arch}`);
	        }
	        break;
	      default:
	        throw new Error(`Unsupported OS: ${type}`);
	    }
	    return version;
	  },

	  runCommand(command, x11Display, xvfbConfiguration, logger = defaultLogger, tmpDirPath = '') {
	    let cmd;
	    const args = [];
	    const type = os.type();
	    let shell;
	    if (type === 'Windows_NT') {
	      cmd = 'cmd';
	      args.push('/c');
	      args.push(`"${command}"`);
	      shell = true;
	    } else {
	      if (x11Display) {
	        command = `DISPLAY=${x11Display} ${command}`;
	      }
	      if (xvfbConfiguration) {
	        command = `xvfb-run ${xvfbConfiguration} ${command}`;
	      }
	      cmd = 'sh';
	      args.push('-c');
	      args.push(`${command}`);
	      shell = false;
	    }

	    if (!tmpDirPath) {
	      const tmpDir = tmp.dirSync();
	      tmpDirPath = tmpDir.name;
	    }

	    logger.info(`Execute "${cmd} ${args.join(' ')}" in ${tmpDirPath}.`);
	    const promise = new Promise((resolve) => {
	      const cmdProcess = childProcess.spawn(cmd, args, {
	        cwd: tmpDirPath,
	        shell,
	      });
	      cmdProcess.stdout.on('data', (data) => {
	        logger.debug(data.toString());
	      });
	      cmdProcess.stderr.on('data', (data) => {
	        logger.debug(data.toString());
	      });
	      cmdProcess.on('close', (code) => {
	        logger.info(`Exit code: ${code}.`);
	        resolve(code);
	      });
	    });
	    return promise;
	  },
	};
	return os_1;
}

var remoteDownloader = {};

var fileType$2;
var hasRequiredFileType$2;

function requireFileType$2 () {
	if (hasRequiredFileType$2) return fileType$2;
	hasRequiredFileType$2 = 1;

	fileType$2 = input => {
		const buf = new Uint8Array(input);

		if (!(buf && buf.length > 1)) {
			return null;
		}

		const check = (header, opts) => {
			opts = Object.assign({
				offset: 0
			}, opts);

			for (let i = 0; i < header.length; i++) {
				if (header[i] !== buf[i + opts.offset]) {
					return false;
				}
			}

			return true;
		};

		if (check([0xFF, 0xD8, 0xFF])) {
			return {
				ext: 'jpg',
				mime: 'image/jpeg'
			};
		}

		if (check([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A])) {
			return {
				ext: 'png',
				mime: 'image/png'
			};
		}

		if (check([0x47, 0x49, 0x46])) {
			return {
				ext: 'gif',
				mime: 'image/gif'
			};
		}

		if (check([0x57, 0x45, 0x42, 0x50], {offset: 8})) {
			return {
				ext: 'webp',
				mime: 'image/webp'
			};
		}

		if (check([0x46, 0x4C, 0x49, 0x46])) {
			return {
				ext: 'flif',
				mime: 'image/flif'
			};
		}

		// Needs to be before `tif` check
		if (
			(check([0x49, 0x49, 0x2A, 0x0]) || check([0x4D, 0x4D, 0x0, 0x2A])) &&
			check([0x43, 0x52], {offset: 8})
		) {
			return {
				ext: 'cr2',
				mime: 'image/x-canon-cr2'
			};
		}

		if (
			check([0x49, 0x49, 0x2A, 0x0]) ||
			check([0x4D, 0x4D, 0x0, 0x2A])
		) {
			return {
				ext: 'tif',
				mime: 'image/tiff'
			};
		}

		if (check([0x42, 0x4D])) {
			return {
				ext: 'bmp',
				mime: 'image/bmp'
			};
		}

		if (check([0x49, 0x49, 0xBC])) {
			return {
				ext: 'jxr',
				mime: 'image/vnd.ms-photo'
			};
		}

		if (check([0x38, 0x42, 0x50, 0x53])) {
			return {
				ext: 'psd',
				mime: 'image/vnd.adobe.photoshop'
			};
		}

		// Needs to be before the `zip` check
		if (
			check([0x50, 0x4B, 0x3, 0x4]) &&
			check([0x6D, 0x69, 0x6D, 0x65, 0x74, 0x79, 0x70, 0x65, 0x61, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x65, 0x70, 0x75, 0x62, 0x2B, 0x7A, 0x69, 0x70], {offset: 30})
		) {
			return {
				ext: 'epub',
				mime: 'application/epub+zip'
			};
		}

		// Needs to be before `zip` check
		// Assumes signed `.xpi` from addons.mozilla.org
		if (
			check([0x50, 0x4B, 0x3, 0x4]) &&
			check([0x4D, 0x45, 0x54, 0x41, 0x2D, 0x49, 0x4E, 0x46, 0x2F, 0x6D, 0x6F, 0x7A, 0x69, 0x6C, 0x6C, 0x61, 0x2E, 0x72, 0x73, 0x61], {offset: 30})
		) {
			return {
				ext: 'xpi',
				mime: 'application/x-xpinstall'
			};
		}

		if (
			check([0x50, 0x4B]) &&
			(buf[2] === 0x3 || buf[2] === 0x5 || buf[2] === 0x7) &&
			(buf[3] === 0x4 || buf[3] === 0x6 || buf[3] === 0x8)
		) {
			return {
				ext: 'zip',
				mime: 'application/zip'
			};
		}

		if (check([0x75, 0x73, 0x74, 0x61, 0x72], {offset: 257})) {
			return {
				ext: 'tar',
				mime: 'application/x-tar'
			};
		}

		if (
			check([0x52, 0x61, 0x72, 0x21, 0x1A, 0x7]) &&
			(buf[6] === 0x0 || buf[6] === 0x1)
		) {
			return {
				ext: 'rar',
				mime: 'application/x-rar-compressed'
			};
		}

		if (check([0x1F, 0x8B, 0x8])) {
			return {
				ext: 'gz',
				mime: 'application/gzip'
			};
		}

		if (check([0x42, 0x5A, 0x68])) {
			return {
				ext: 'bz2',
				mime: 'application/x-bzip2'
			};
		}

		if (check([0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C])) {
			return {
				ext: '7z',
				mime: 'application/x-7z-compressed'
			};
		}

		if (check([0x78, 0x01])) {
			return {
				ext: 'dmg',
				mime: 'application/x-apple-diskimage'
			};
		}

		if (
			(
				check([0x0, 0x0, 0x0]) &&
				(buf[3] === 0x18 || buf[3] === 0x20) &&
				check([0x66, 0x74, 0x79, 0x70], {offset: 4})
			) ||
			check([0x33, 0x67, 0x70, 0x35]) ||
			(
				check([0x0, 0x0, 0x0, 0x1C, 0x66, 0x74, 0x79, 0x70, 0x6D, 0x70, 0x34, 0x32]) &&
				check([0x6D, 0x70, 0x34, 0x31, 0x6D, 0x70, 0x34, 0x32, 0x69, 0x73, 0x6F, 0x6D], {offset: 16})
			) ||
			check([0x0, 0x0, 0x0, 0x1C, 0x66, 0x74, 0x79, 0x70, 0x69, 0x73, 0x6F, 0x6D]) ||
			check([0x0, 0x0, 0x0, 0x1C, 0x66, 0x74, 0x79, 0x70, 0x6D, 0x70, 0x34, 0x32, 0x0, 0x0, 0x0, 0x0])
		) {
			return {
				ext: 'mp4',
				mime: 'video/mp4'
			};
		}

		if (check([0x0, 0x0, 0x0, 0x1C, 0x66, 0x74, 0x79, 0x70, 0x4D, 0x34, 0x56])) {
			return {
				ext: 'm4v',
				mime: 'video/x-m4v'
			};
		}

		if (check([0x4D, 0x54, 0x68, 0x64])) {
			return {
				ext: 'mid',
				mime: 'audio/midi'
			};
		}

		// https://github.com/threatstack/libmagic/blob/master/magic/Magdir/matroska
		if (check([0x1A, 0x45, 0xDF, 0xA3])) {
			const sliced = buf.subarray(4, 4 + 4096);
			const idPos = sliced.findIndex((el, i, arr) => arr[i] === 0x42 && arr[i + 1] === 0x82);

			if (idPos >= 0) {
				const docTypePos = idPos + 3;
				const findDocType = type => Array.from(type).every((c, i) => sliced[docTypePos + i] === c.charCodeAt(0));

				if (findDocType('matroska')) {
					return {
						ext: 'mkv',
						mime: 'video/x-matroska'
					};
				}

				if (findDocType('webm')) {
					return {
						ext: 'webm',
						mime: 'video/webm'
					};
				}
			}
		}

		if (check([0x0, 0x0, 0x0, 0x14, 0x66, 0x74, 0x79, 0x70, 0x71, 0x74, 0x20, 0x20]) ||
			check([0x66, 0x72, 0x65, 0x65], {offset: 4}) ||
			check([0x66, 0x74, 0x79, 0x70, 0x71, 0x74, 0x20, 0x20], {offset: 4}) ||
			check([0x6D, 0x64, 0x61, 0x74], {offset: 4}) || // MJPEG
			check([0x77, 0x69, 0x64, 0x65], {offset: 4})) {
			return {
				ext: 'mov',
				mime: 'video/quicktime'
			};
		}

		if (
			check([0x52, 0x49, 0x46, 0x46]) &&
			check([0x41, 0x56, 0x49], {offset: 8})
		) {
			return {
				ext: 'avi',
				mime: 'video/x-msvideo'
			};
		}

		if (check([0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xA6, 0xD9])) {
			return {
				ext: 'wmv',
				mime: 'video/x-ms-wmv'
			};
		}

		if (check([0x0, 0x0, 0x1, 0xBA])) {
			return {
				ext: 'mpg',
				mime: 'video/mpeg'
			};
		}

		if (
			check([0x49, 0x44, 0x33]) ||
			check([0xFF, 0xFB])
		) {
			return {
				ext: 'mp3',
				mime: 'audio/mpeg'
			};
		}

		if (
			check([0x66, 0x74, 0x79, 0x70, 0x4D, 0x34, 0x41], {offset: 4}) ||
			check([0x4D, 0x34, 0x41, 0x20])
		) {
			return {
				ext: 'm4a',
				mime: 'audio/m4a'
			};
		}

		// Needs to be before `ogg` check
		if (check([0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64], {offset: 28})) {
			return {
				ext: 'opus',
				mime: 'audio/opus'
			};
		}

		if (check([0x4F, 0x67, 0x67, 0x53])) {
			return {
				ext: 'ogg',
				mime: 'audio/ogg'
			};
		}

		if (check([0x66, 0x4C, 0x61, 0x43])) {
			return {
				ext: 'flac',
				mime: 'audio/x-flac'
			};
		}

		if (
			check([0x52, 0x49, 0x46, 0x46]) &&
			check([0x57, 0x41, 0x56, 0x45], {offset: 8})
		) {
			return {
				ext: 'wav',
				mime: 'audio/x-wav'
			};
		}

		if (check([0x23, 0x21, 0x41, 0x4D, 0x52, 0x0A])) {
			return {
				ext: 'amr',
				mime: 'audio/amr'
			};
		}

		if (check([0x25, 0x50, 0x44, 0x46])) {
			return {
				ext: 'pdf',
				mime: 'application/pdf'
			};
		}

		if (check([0x4D, 0x5A])) {
			return {
				ext: 'exe',
				mime: 'application/x-msdownload'
			};
		}

		if (
			(buf[0] === 0x43 || buf[0] === 0x46) &&
			check([0x57, 0x53], {offset: 1})
		) {
			return {
				ext: 'swf',
				mime: 'application/x-shockwave-flash'
			};
		}

		if (check([0x7B, 0x5C, 0x72, 0x74, 0x66])) {
			return {
				ext: 'rtf',
				mime: 'application/rtf'
			};
		}

		if (check([0x00, 0x61, 0x73, 0x6D])) {
			return {
				ext: 'wasm',
				mime: 'application/wasm'
			};
		}

		if (
			check([0x77, 0x4F, 0x46, 0x46]) &&
			(
				check([0x00, 0x01, 0x00, 0x00], {offset: 4}) ||
				check([0x4F, 0x54, 0x54, 0x4F], {offset: 4})
			)
		) {
			return {
				ext: 'woff',
				mime: 'font/woff'
			};
		}

		if (
			check([0x77, 0x4F, 0x46, 0x32]) &&
			(
				check([0x00, 0x01, 0x00, 0x00], {offset: 4}) ||
				check([0x4F, 0x54, 0x54, 0x4F], {offset: 4})
			)
		) {
			return {
				ext: 'woff2',
				mime: 'font/woff2'
			};
		}

		if (
			check([0x4C, 0x50], {offset: 34}) &&
			(
				check([0x00, 0x00, 0x01], {offset: 8}) ||
				check([0x01, 0x00, 0x02], {offset: 8}) ||
				check([0x02, 0x00, 0x02], {offset: 8})
			)
		) {
			return {
				ext: 'eot',
				mime: 'application/octet-stream'
			};
		}

		if (check([0x00, 0x01, 0x00, 0x00, 0x00])) {
			return {
				ext: 'ttf',
				mime: 'font/ttf'
			};
		}

		if (check([0x4F, 0x54, 0x54, 0x4F, 0x00])) {
			return {
				ext: 'otf',
				mime: 'font/otf'
			};
		}

		if (check([0x00, 0x00, 0x01, 0x00])) {
			return {
				ext: 'ico',
				mime: 'image/x-icon'
			};
		}

		if (check([0x46, 0x4C, 0x56, 0x01])) {
			return {
				ext: 'flv',
				mime: 'video/x-flv'
			};
		}

		if (check([0x25, 0x21])) {
			return {
				ext: 'ps',
				mime: 'application/postscript'
			};
		}

		if (check([0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00])) {
			return {
				ext: 'xz',
				mime: 'application/x-xz'
			};
		}

		if (check([0x53, 0x51, 0x4C, 0x69])) {
			return {
				ext: 'sqlite',
				mime: 'application/x-sqlite3'
			};
		}

		if (check([0x4E, 0x45, 0x53, 0x1A])) {
			return {
				ext: 'nes',
				mime: 'application/x-nintendo-nes-rom'
			};
		}

		if (check([0x43, 0x72, 0x32, 0x34])) {
			return {
				ext: 'crx',
				mime: 'application/x-google-chrome-extension'
			};
		}

		if (
			check([0x4D, 0x53, 0x43, 0x46]) ||
			check([0x49, 0x53, 0x63, 0x28])
		) {
			return {
				ext: 'cab',
				mime: 'application/vnd.ms-cab-compressed'
			};
		}

		// Needs to be before `ar` check
		if (check([0x21, 0x3C, 0x61, 0x72, 0x63, 0x68, 0x3E, 0x0A, 0x64, 0x65, 0x62, 0x69, 0x61, 0x6E, 0x2D, 0x62, 0x69, 0x6E, 0x61, 0x72, 0x79])) {
			return {
				ext: 'deb',
				mime: 'application/x-deb'
			};
		}

		if (check([0x21, 0x3C, 0x61, 0x72, 0x63, 0x68, 0x3E])) {
			return {
				ext: 'ar',
				mime: 'application/x-unix-archive'
			};
		}

		if (check([0xED, 0xAB, 0xEE, 0xDB])) {
			return {
				ext: 'rpm',
				mime: 'application/x-rpm'
			};
		}

		if (
			check([0x1F, 0xA0]) ||
			check([0x1F, 0x9D])
		) {
			return {
				ext: 'Z',
				mime: 'application/x-compress'
			};
		}

		if (check([0x4C, 0x5A, 0x49, 0x50])) {
			return {
				ext: 'lz',
				mime: 'application/x-lzip'
			};
		}

		if (check([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1])) {
			return {
				ext: 'msi',
				mime: 'application/x-msi'
			};
		}

		if (check([0x06, 0x0E, 0x2B, 0x34, 0x02, 0x05, 0x01, 0x01, 0x0D, 0x01, 0x02, 0x01, 0x01, 0x02])) {
			return {
				ext: 'mxf',
				mime: 'application/mxf'
			};
		}

		if (check([0x47], {offset: 4}) && (check([0x47], {offset: 192}) || check([0x47], {offset: 196}))) {
			return {
				ext: 'mts',
				mime: 'video/mp2t'
			};
		}

		if (check([0x42, 0x4C, 0x45, 0x4E, 0x44, 0x45, 0x52])) {
			return {
				ext: 'blend',
				mime: 'application/x-blender'
			};
		}

		if (check([0x42, 0x50, 0x47, 0xFB])) {
			return {
				ext: 'bpg',
				mime: 'image/bpg'
			};
		}

		return null;
	};
	return fileType$2;
}

var isStream = {exports: {}};

var hasRequiredIsStream;

function requireIsStream () {
	if (hasRequiredIsStream) return isStream.exports;
	hasRequiredIsStream = 1;

	var isStream$1 = isStream.exports = function (stream) {
		return stream !== null && typeof stream === 'object' && typeof stream.pipe === 'function';
	};

	isStream$1.writable = function (stream) {
		return isStream$1(stream) && stream.writable !== false && typeof stream._write === 'function' && typeof stream._writableState === 'object';
	};

	isStream$1.readable = function (stream) {
		return isStream$1(stream) && stream.readable !== false && typeof stream._read === 'function' && typeof stream._readableState === 'object';
	};

	isStream$1.duplex = function (stream) {
		return isStream$1.writable(stream) && isStream$1.readable(stream);
	};

	isStream$1.transform = function (stream) {
		return isStream$1.duplex(stream) && typeof stream._transform === 'function' && typeof stream._transformState === 'object';
	};
	return isStream.exports;
}

var tarStream = {};

var readable = {exports: {}};

var processNextickArgs = {exports: {}};

var hasRequiredProcessNextickArgs;

function requireProcessNextickArgs () {
	if (hasRequiredProcessNextickArgs) return processNextickArgs.exports;
	hasRequiredProcessNextickArgs = 1;

	if (typeof process === 'undefined' ||
	    !process.version ||
	    process.version.indexOf('v0.') === 0 ||
	    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
	  processNextickArgs.exports = { nextTick: nextTick };
	} else {
	  processNextickArgs.exports = process;
	}

	function nextTick(fn, arg1, arg2, arg3) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('"callback" argument must be a function');
	  }
	  var len = arguments.length;
	  var args, i;
	  switch (len) {
	  case 0:
	  case 1:
	    return process.nextTick(fn);
	  case 2:
	    return process.nextTick(function afterTickOne() {
	      fn.call(null, arg1);
	    });
	  case 3:
	    return process.nextTick(function afterTickTwo() {
	      fn.call(null, arg1, arg2);
	    });
	  case 4:
	    return process.nextTick(function afterTickThree() {
	      fn.call(null, arg1, arg2, arg3);
	    });
	  default:
	    args = new Array(len - 1);
	    i = 0;
	    while (i < args.length) {
	      args[i++] = arguments[i];
	    }
	    return process.nextTick(function afterTick() {
	      fn.apply(null, args);
	    });
	  }
	}
	return processNextickArgs.exports;
}

var isarray;
var hasRequiredIsarray;

function requireIsarray () {
	if (hasRequiredIsarray) return isarray;
	hasRequiredIsarray = 1;
	var toString = {}.toString;

	isarray = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};
	return isarray;
}

var stream$1;
var hasRequiredStream$1;

function requireStream$1 () {
	if (hasRequiredStream$1) return stream$1;
	hasRequiredStream$1 = 1;
	stream$1 = require$$0$6;
	return stream$1;
}

var safeBuffer = {exports: {}};

/* eslint-disable node/no-deprecated-api */

var hasRequiredSafeBuffer;

function requireSafeBuffer () {
	if (hasRequiredSafeBuffer) return safeBuffer.exports;
	hasRequiredSafeBuffer = 1;
	(function (module, exports) {
		var buffer = require$$0$4;
		var Buffer = buffer.Buffer;

		// alternative to using Object.keys for old browsers
		function copyProps (src, dst) {
		  for (var key in src) {
		    dst[key] = src[key];
		  }
		}
		if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
		  module.exports = buffer;
		} else {
		  // Copy properties from require('buffer')
		  copyProps(buffer, exports);
		  exports.Buffer = SafeBuffer;
		}

		function SafeBuffer (arg, encodingOrOffset, length) {
		  return Buffer(arg, encodingOrOffset, length)
		}

		// Copy static methods from Buffer
		copyProps(Buffer, SafeBuffer);

		SafeBuffer.from = function (arg, encodingOrOffset, length) {
		  if (typeof arg === 'number') {
		    throw new TypeError('Argument must not be a number')
		  }
		  return Buffer(arg, encodingOrOffset, length)
		};

		SafeBuffer.alloc = function (size, fill, encoding) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  var buf = Buffer(size);
		  if (fill !== undefined) {
		    if (typeof encoding === 'string') {
		      buf.fill(fill, encoding);
		    } else {
		      buf.fill(fill);
		    }
		  } else {
		    buf.fill(0);
		  }
		  return buf
		};

		SafeBuffer.allocUnsafe = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return Buffer(size)
		};

		SafeBuffer.allocUnsafeSlow = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return buffer.SlowBuffer(size)
		}; 
	} (safeBuffer, safeBuffer.exports));
	return safeBuffer.exports;
}

var inherits = {exports: {}};

var inherits_browser = {exports: {}};

var hasRequiredInherits_browser;

function requireInherits_browser () {
	if (hasRequiredInherits_browser) return inherits_browser.exports;
	hasRequiredInherits_browser = 1;
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	          value: ctor,
	          enumerable: false,
	          writable: true,
	          configurable: true
	        }
	      });
	    }
	  };
	} else {
	  // old school shim for old browsers
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      var TempCtor = function () {};
	      TempCtor.prototype = superCtor.prototype;
	      ctor.prototype = new TempCtor();
	      ctor.prototype.constructor = ctor;
	    }
	  };
	}
	return inherits_browser.exports;
}

var hasRequiredInherits;

function requireInherits () {
	if (hasRequiredInherits) return inherits.exports;
	hasRequiredInherits = 1;
	try {
	  var util = require('util');
	  /* istanbul ignore next */
	  if (typeof util.inherits !== 'function') throw '';
	  inherits.exports = util.inherits;
	} catch (e) {
	  /* istanbul ignore next */
	  inherits.exports = requireInherits_browser();
	}
	return inherits.exports;
}

var BufferList = {exports: {}};

var hasRequiredBufferList;

function requireBufferList () {
	if (hasRequiredBufferList) return BufferList.exports;
	hasRequiredBufferList = 1;
	(function (module) {

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		var Buffer = requireSafeBuffer().Buffer;
		var util = require$$1$2;

		function copyBuffer(src, target, offset) {
		  src.copy(target, offset);
		}

		module.exports = function () {
		  function BufferList() {
		    _classCallCheck(this, BufferList);

		    this.head = null;
		    this.tail = null;
		    this.length = 0;
		  }

		  BufferList.prototype.push = function push(v) {
		    var entry = { data: v, next: null };
		    if (this.length > 0) this.tail.next = entry;else this.head = entry;
		    this.tail = entry;
		    ++this.length;
		  };

		  BufferList.prototype.unshift = function unshift(v) {
		    var entry = { data: v, next: this.head };
		    if (this.length === 0) this.tail = entry;
		    this.head = entry;
		    ++this.length;
		  };

		  BufferList.prototype.shift = function shift() {
		    if (this.length === 0) return;
		    var ret = this.head.data;
		    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
		    --this.length;
		    return ret;
		  };

		  BufferList.prototype.clear = function clear() {
		    this.head = this.tail = null;
		    this.length = 0;
		  };

		  BufferList.prototype.join = function join(s) {
		    if (this.length === 0) return '';
		    var p = this.head;
		    var ret = '' + p.data;
		    while (p = p.next) {
		      ret += s + p.data;
		    }return ret;
		  };

		  BufferList.prototype.concat = function concat(n) {
		    if (this.length === 0) return Buffer.alloc(0);
		    var ret = Buffer.allocUnsafe(n >>> 0);
		    var p = this.head;
		    var i = 0;
		    while (p) {
		      copyBuffer(p.data, ret, i);
		      i += p.data.length;
		      p = p.next;
		    }
		    return ret;
		  };

		  return BufferList;
		}();

		if (util && util.inspect && util.inspect.custom) {
		  module.exports.prototype[util.inspect.custom] = function () {
		    var obj = util.inspect({ length: this.length });
		    return this.constructor.name + ' ' + obj;
		  };
		} 
	} (BufferList));
	return BufferList.exports;
}

var destroy_1;
var hasRequiredDestroy;

function requireDestroy () {
	if (hasRequiredDestroy) return destroy_1;
	hasRequiredDestroy = 1;

	/*<replacement>*/

	var pna = requireProcessNextickArgs();
	/*</replacement>*/

	// undocumented cb() API, needed for core, not for public API
	function destroy(err, cb) {
	  var _this = this;

	  var readableDestroyed = this._readableState && this._readableState.destroyed;
	  var writableDestroyed = this._writableState && this._writableState.destroyed;

	  if (readableDestroyed || writableDestroyed) {
	    if (cb) {
	      cb(err);
	    } else if (err) {
	      if (!this._writableState) {
	        pna.nextTick(emitErrorNT, this, err);
	      } else if (!this._writableState.errorEmitted) {
	        this._writableState.errorEmitted = true;
	        pna.nextTick(emitErrorNT, this, err);
	      }
	    }

	    return this;
	  }

	  // we set destroyed to true before firing error callbacks in order
	  // to make it re-entrance safe in case destroy() is called within callbacks

	  if (this._readableState) {
	    this._readableState.destroyed = true;
	  }

	  // if this is a duplex stream mark the writable part as destroyed as well
	  if (this._writableState) {
	    this._writableState.destroyed = true;
	  }

	  this._destroy(err || null, function (err) {
	    if (!cb && err) {
	      if (!_this._writableState) {
	        pna.nextTick(emitErrorNT, _this, err);
	      } else if (!_this._writableState.errorEmitted) {
	        _this._writableState.errorEmitted = true;
	        pna.nextTick(emitErrorNT, _this, err);
	      }
	    } else if (cb) {
	      cb(err);
	    }
	  });

	  return this;
	}

	function undestroy() {
	  if (this._readableState) {
	    this._readableState.destroyed = false;
	    this._readableState.reading = false;
	    this._readableState.ended = false;
	    this._readableState.endEmitted = false;
	  }

	  if (this._writableState) {
	    this._writableState.destroyed = false;
	    this._writableState.ended = false;
	    this._writableState.ending = false;
	    this._writableState.finalCalled = false;
	    this._writableState.prefinished = false;
	    this._writableState.finished = false;
	    this._writableState.errorEmitted = false;
	  }
	}

	function emitErrorNT(self, err) {
	  self.emit('error', err);
	}

	destroy_1 = {
	  destroy: destroy,
	  undestroy: undestroy
	};
	return destroy_1;
}

var node;
var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node;
	hasRequiredNode = 1;
	/**
	 * For Node.js, simply re-export the core `util.deprecate` function.
	 */

	node = require$$1$2.deprecate;
	return node;
}

var _stream_writable;
var hasRequired_stream_writable;

function require_stream_writable () {
	if (hasRequired_stream_writable) return _stream_writable;
	hasRequired_stream_writable = 1;

	/*<replacement>*/

	var pna = requireProcessNextickArgs();
	/*</replacement>*/

	_stream_writable = Writable;

	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;

	  this.next = null;
	  this.entry = null;
	  this.finish = function () {
	    onCorkedFinish(_this, state);
	  };
	}
	/* </replacement> */

	/*<replacement>*/
	var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
	/*</replacement>*/

	/*<replacement>*/
	var Duplex;
	/*</replacement>*/

	Writable.WritableState = WritableState;

	/*<replacement>*/
	var util = Object.create(requireUtil$2());
	util.inherits = requireInherits();
	/*</replacement>*/

	/*<replacement>*/
	var internalUtil = {
	  deprecate: requireNode()
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream = requireStream$1();
	/*</replacement>*/

	/*<replacement>*/

	var Buffer = requireSafeBuffer().Buffer;
	var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
	function _uint8ArrayToBuffer(chunk) {
	  return Buffer.from(chunk);
	}
	function _isUint8Array(obj) {
	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	}

	/*</replacement>*/

	var destroyImpl = requireDestroy();

	util.inherits(Writable, Stream);

	function nop() {}

	function WritableState(options, stream) {
	  Duplex = Duplex || require_stream_duplex();

	  options = options || {};

	  // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream.
	  // These options can be provided separately as readableXXX and writableXXX.
	  var isDuplex = stream instanceof Duplex;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var writableHwm = options.writableHighWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

	  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

	  // cast to ints.
	  this.highWaterMark = Math.floor(this.highWaterMark);

	  // if _final has been called
	  this.finalCalled = false;

	  // drain event flag.
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // has it been destroyed
	  this.destroyed = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;

	  // count buffered requests
	  this.bufferedRequestCount = 0;

	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}

	WritableState.prototype.getBuffer = function getBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};

	(function () {
	  try {
	    Object.defineProperty(WritableState.prototype, 'buffer', {
	      get: internalUtil.deprecate(function () {
	        return this.getBuffer();
	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
	    });
	  } catch (_) {}
	})();

	// Test _writableState for inheritance to account for Duplex streams,
	// whose prototype chain only points to Readable.
	var realHasInstance;
	if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
	  realHasInstance = Function.prototype[Symbol.hasInstance];
	  Object.defineProperty(Writable, Symbol.hasInstance, {
	    value: function (object) {
	      if (realHasInstance.call(this, object)) return true;
	      if (this !== Writable) return false;

	      return object && object._writableState instanceof WritableState;
	    }
	  });
	} else {
	  realHasInstance = function (object) {
	    return object instanceof this;
	  };
	}

	function Writable(options) {
	  Duplex = Duplex || require_stream_duplex();

	  // Writable ctor is applied to Duplexes, too.
	  // `realHasInstance` is necessary because using plain `instanceof`
	  // would return false, as no `_writableState` property is attached.

	  // Trying to use the custom `instanceof` for Writable here will also break the
	  // Node.js LazyTransform implementation, which has a non-trivial getter for
	  // `_writableState` that would lead to infinite recursion.
	  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
	    return new Writable(options);
	  }

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;

	    if (typeof options.writev === 'function') this._writev = options.writev;

	    if (typeof options.destroy === 'function') this._destroy = options.destroy;

	    if (typeof options.final === 'function') this._final = options.final;
	  }

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  this.emit('error', new Error('Cannot pipe, not readable'));
	};

	function writeAfterEnd(stream, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  pna.nextTick(cb, er);
	}

	// Checks that a user-supplied chunk is valid, especially for the particular
	// mode the stream is in. Currently this means that `null` is never accepted
	// and undefined/non-string values are only allowed in object mode.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  var er = false;

	  if (chunk === null) {
	    er = new TypeError('May not write null values to stream');
	  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  if (er) {
	    stream.emit('error', er);
	    pna.nextTick(cb, er);
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	  var isBuf = !state.objectMode && _isUint8Array(chunk);

	  if (isBuf && !Buffer.isBuffer(chunk)) {
	    chunk = _uint8ArrayToBuffer(chunk);
	  }

	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

	  if (typeof cb !== 'function') cb = nop;

	  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function () {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function () {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};

	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = Buffer.from(chunk, encoding);
	  }
	  return chunk;
	}

	Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function () {
	    return this._writableState.highWaterMark;
	  }
	});

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
	  if (!isBuf) {
	    var newChunk = decodeChunk(state, chunk, encoding);
	    if (chunk !== newChunk) {
	      isBuf = true;
	      encoding = 'buffer';
	      chunk = newChunk;
	    }
	  }
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;

	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = {
	      chunk: chunk,
	      encoding: encoding,
	      isBuf: isBuf,
	      callback: cb,
	      next: null
	    };
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;

	  if (sync) {
	    // defer the callback if we are being called synchronously
	    // to avoid piling up things on the stack
	    pna.nextTick(cb, er);
	    // this can emit finish, and it will always happen
	    // after error
	    pna.nextTick(finishMaybe, stream, state);
	    stream._writableState.errorEmitted = true;
	    stream.emit('error', er);
	  } else {
	    // the caller expect this to happen before if
	    // it is async
	    cb(er);
	    stream._writableState.errorEmitted = true;
	    stream.emit('error', er);
	    // this can emit finish, but finish must
	    // always follow error
	    finishMaybe(stream, state);
	  }
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state);

	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      /*<replacement>*/
	      asyncWrite(afterWrite, stream, state, finished, cb);
	      /*</replacement>*/
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}

	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;

	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;

	    var count = 0;
	    var allBuffers = true;
	    while (entry) {
	      buffer[count] = entry;
	      if (!entry.isBuf) allBuffers = false;
	      entry = entry.next;
	      count += 1;
	    }
	    buffer.allBuffers = allBuffers;

	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	    state.bufferedRequestCount = 0;
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      state.bufferedRequestCount--;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }

	    if (entry === null) state.lastBufferedRequest = null;
	  }

	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new Error('_write() is not implemented'));
	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;

	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending) endWritable(this, state, cb);
	};

	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}
	function callFinal(stream, state) {
	  stream._final(function (err) {
	    state.pendingcb--;
	    if (err) {
	      stream.emit('error', err);
	    }
	    state.prefinished = true;
	    stream.emit('prefinish');
	    finishMaybe(stream, state);
	  });
	}
	function prefinish(stream, state) {
	  if (!state.prefinished && !state.finalCalled) {
	    if (typeof stream._final === 'function') {
	      state.pendingcb++;
	      state.finalCalled = true;
	      pna.nextTick(callFinal, stream, state);
	    } else {
	      state.prefinished = true;
	      stream.emit('prefinish');
	    }
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    prefinish(stream, state);
	    if (state.pendingcb === 0) {
	      state.finished = true;
	      stream.emit('finish');
	    }
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}

	function onCorkedFinish(corkReq, state, err) {
	  var entry = corkReq.entry;
	  corkReq.entry = null;
	  while (entry) {
	    var cb = entry.callback;
	    state.pendingcb--;
	    cb(err);
	    entry = entry.next;
	  }

	  // reuse the free corkReq.
	  state.corkedRequestsFree.next = corkReq;
	}

	Object.defineProperty(Writable.prototype, 'destroyed', {
	  get: function () {
	    if (this._writableState === undefined) {
	      return false;
	    }
	    return this._writableState.destroyed;
	  },
	  set: function (value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (!this._writableState) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._writableState.destroyed = value;
	  }
	});

	Writable.prototype.destroy = destroyImpl.destroy;
	Writable.prototype._undestroy = destroyImpl.undestroy;
	Writable.prototype._destroy = function (err, cb) {
	  this.end();
	  cb(err);
	};
	return _stream_writable;
}

var _stream_duplex;
var hasRequired_stream_duplex;

function require_stream_duplex () {
	if (hasRequired_stream_duplex) return _stream_duplex;
	hasRequired_stream_duplex = 1;

	/*<replacement>*/

	var pna = requireProcessNextickArgs();
	/*</replacement>*/

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    keys.push(key);
	  }return keys;
	};
	/*</replacement>*/

	_stream_duplex = Duplex;

	/*<replacement>*/
	var util = Object.create(requireUtil$2());
	util.inherits = requireInherits();
	/*</replacement>*/

	var Readable = require_stream_readable();
	var Writable = require_stream_writable();

	util.inherits(Duplex, Readable);

	{
	  // avoid scope creep, the keys array can then be collected
	  var keys = objectKeys(Writable.prototype);
	  for (var v = 0; v < keys.length; v++) {
	    var method = keys[v];
	    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	  }
	}

	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false) this.readable = false;

	  if (options && options.writable === false) this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function () {
	    return this._writableState.highWaterMark;
	  }
	});

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended) return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  pna.nextTick(onEndNT, this);
	}

	function onEndNT(self) {
	  self.end();
	}

	Object.defineProperty(Duplex.prototype, 'destroyed', {
	  get: function () {
	    if (this._readableState === undefined || this._writableState === undefined) {
	      return false;
	    }
	    return this._readableState.destroyed && this._writableState.destroyed;
	  },
	  set: function (value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (this._readableState === undefined || this._writableState === undefined) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._readableState.destroyed = value;
	    this._writableState.destroyed = value;
	  }
	});

	Duplex.prototype._destroy = function (err, cb) {
	  this.push(null);
	  this.end();

	  pna.nextTick(cb, err);
	};
	return _stream_duplex;
}

var string_decoder = {};

var hasRequiredString_decoder;

function requireString_decoder () {
	if (hasRequiredString_decoder) return string_decoder;
	hasRequiredString_decoder = 1;

	/*<replacement>*/

	var Buffer = requireSafeBuffer().Buffer;
	/*</replacement>*/

	var isEncoding = Buffer.isEncoding || function (encoding) {
	  encoding = '' + encoding;
	  switch (encoding && encoding.toLowerCase()) {
	    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
	      return true;
	    default:
	      return false;
	  }
	};

	function _normalizeEncoding(enc) {
	  if (!enc) return 'utf8';
	  var retried;
	  while (true) {
	    switch (enc) {
	      case 'utf8':
	      case 'utf-8':
	        return 'utf8';
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return 'utf16le';
	      case 'latin1':
	      case 'binary':
	        return 'latin1';
	      case 'base64':
	      case 'ascii':
	      case 'hex':
	        return enc;
	      default:
	        if (retried) return; // undefined
	        enc = ('' + enc).toLowerCase();
	        retried = true;
	    }
	  }
	}
	// Do not cache `Buffer.isEncoding` when checking encoding names as some
	// modules monkey-patch it to support additional encodings
	function normalizeEncoding(enc) {
	  var nenc = _normalizeEncoding(enc);
	  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
	  return nenc || enc;
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters.
	string_decoder.StringDecoder = StringDecoder;
	function StringDecoder(encoding) {
	  this.encoding = normalizeEncoding(encoding);
	  var nb;
	  switch (this.encoding) {
	    case 'utf16le':
	      this.text = utf16Text;
	      this.end = utf16End;
	      nb = 4;
	      break;
	    case 'utf8':
	      this.fillLast = utf8FillLast;
	      nb = 4;
	      break;
	    case 'base64':
	      this.text = base64Text;
	      this.end = base64End;
	      nb = 3;
	      break;
	    default:
	      this.write = simpleWrite;
	      this.end = simpleEnd;
	      return;
	  }
	  this.lastNeed = 0;
	  this.lastTotal = 0;
	  this.lastChar = Buffer.allocUnsafe(nb);
	}

	StringDecoder.prototype.write = function (buf) {
	  if (buf.length === 0) return '';
	  var r;
	  var i;
	  if (this.lastNeed) {
	    r = this.fillLast(buf);
	    if (r === undefined) return '';
	    i = this.lastNeed;
	    this.lastNeed = 0;
	  } else {
	    i = 0;
	  }
	  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
	  return r || '';
	};

	StringDecoder.prototype.end = utf8End;

	// Returns only complete characters in a Buffer
	StringDecoder.prototype.text = utf8Text;

	// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
	StringDecoder.prototype.fillLast = function (buf) {
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
	  this.lastNeed -= buf.length;
	};

	// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
	// continuation byte. If an invalid byte is detected, -2 is returned.
	function utf8CheckByte(byte) {
	  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
	  return byte >> 6 === 0x02 ? -1 : -2;
	}

	// Checks at most 3 bytes at the end of a Buffer in order to detect an
	// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
	// needed to complete the UTF-8 character (if applicable) are returned.
	function utf8CheckIncomplete(self, buf, i) {
	  var j = buf.length - 1;
	  if (j < i) return 0;
	  var nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 1;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 2;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) {
	      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
	    }
	    return nb;
	  }
	  return 0;
	}

	// Validates as many continuation bytes for a multi-byte UTF-8 character as
	// needed or are available. If we see a non-continuation byte where we expect
	// one, we "replace" the validated continuation bytes we've seen so far with
	// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
	// behavior. The continuation byte check is included three times in the case
	// where all of the continuation bytes for a character exist in the same buffer.
	// It is also done this way as a slight performance increase instead of using a
	// loop.
	function utf8CheckExtraBytes(self, buf, p) {
	  if ((buf[0] & 0xC0) !== 0x80) {
	    self.lastNeed = 0;
	    return '\ufffd';
	  }
	  if (self.lastNeed > 1 && buf.length > 1) {
	    if ((buf[1] & 0xC0) !== 0x80) {
	      self.lastNeed = 1;
	      return '\ufffd';
	    }
	    if (self.lastNeed > 2 && buf.length > 2) {
	      if ((buf[2] & 0xC0) !== 0x80) {
	        self.lastNeed = 2;
	        return '\ufffd';
	      }
	    }
	  }
	}

	// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
	function utf8FillLast(buf) {
	  var p = this.lastTotal - this.lastNeed;
	  var r = utf8CheckExtraBytes(this, buf);
	  if (r !== undefined) return r;
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, p, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, p, 0, buf.length);
	  this.lastNeed -= buf.length;
	}

	// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
	// partial character, the character's bytes are buffered until the required
	// number of bytes are available.
	function utf8Text(buf, i) {
	  var total = utf8CheckIncomplete(this, buf, i);
	  if (!this.lastNeed) return buf.toString('utf8', i);
	  this.lastTotal = total;
	  var end = buf.length - (total - this.lastNeed);
	  buf.copy(this.lastChar, 0, end);
	  return buf.toString('utf8', i, end);
	}

	// For UTF-8, a replacement character is added when ending on a partial
	// character.
	function utf8End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + '\ufffd';
	  return r;
	}

	// UTF-16LE typically needs two bytes per character, but even if we have an even
	// number of bytes available, we need to check if we end on a leading/high
	// surrogate. In that case, we need to wait for the next two bytes in order to
	// decode the last character properly.
	function utf16Text(buf, i) {
	  if ((buf.length - i) % 2 === 0) {
	    var r = buf.toString('utf16le', i);
	    if (r) {
	      var c = r.charCodeAt(r.length - 1);
	      if (c >= 0xD800 && c <= 0xDBFF) {
	        this.lastNeed = 2;
	        this.lastTotal = 4;
	        this.lastChar[0] = buf[buf.length - 2];
	        this.lastChar[1] = buf[buf.length - 1];
	        return r.slice(0, -1);
	      }
	    }
	    return r;
	  }
	  this.lastNeed = 1;
	  this.lastTotal = 2;
	  this.lastChar[0] = buf[buf.length - 1];
	  return buf.toString('utf16le', i, buf.length - 1);
	}

	// For UTF-16LE we do not explicitly append special replacement characters if we
	// end on a partial character, we simply let v8 handle that.
	function utf16End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) {
	    var end = this.lastTotal - this.lastNeed;
	    return r + this.lastChar.toString('utf16le', 0, end);
	  }
	  return r;
	}

	function base64Text(buf, i) {
	  var n = (buf.length - i) % 3;
	  if (n === 0) return buf.toString('base64', i);
	  this.lastNeed = 3 - n;
	  this.lastTotal = 3;
	  if (n === 1) {
	    this.lastChar[0] = buf[buf.length - 1];
	  } else {
	    this.lastChar[0] = buf[buf.length - 2];
	    this.lastChar[1] = buf[buf.length - 1];
	  }
	  return buf.toString('base64', i, buf.length - n);
	}

	function base64End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
	  return r;
	}

	// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
	function simpleWrite(buf) {
	  return buf.toString(this.encoding);
	}

	function simpleEnd(buf) {
	  return buf && buf.length ? this.write(buf) : '';
	}
	return string_decoder;
}

var _stream_readable;
var hasRequired_stream_readable;

function require_stream_readable () {
	if (hasRequired_stream_readable) return _stream_readable;
	hasRequired_stream_readable = 1;

	/*<replacement>*/

	var pna = requireProcessNextickArgs();
	/*</replacement>*/

	_stream_readable = Readable;

	/*<replacement>*/
	var isArray = requireIsarray();
	/*</replacement>*/

	/*<replacement>*/
	var Duplex;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	/*<replacement>*/
	require$$4$2.EventEmitter;

	var EElistenerCount = function (emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream = requireStream$1();
	/*</replacement>*/

	/*<replacement>*/

	var Buffer = requireSafeBuffer().Buffer;
	var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
	function _uint8ArrayToBuffer(chunk) {
	  return Buffer.from(chunk);
	}
	function _isUint8Array(obj) {
	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	}

	/*</replacement>*/

	/*<replacement>*/
	var util = Object.create(requireUtil$2());
	util.inherits = requireInherits();
	/*</replacement>*/

	/*<replacement>*/
	var debugUtil = require$$1$2;
	var debug = void 0;
	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/

	var BufferList = requireBufferList();
	var destroyImpl = requireDestroy();
	var StringDecoder;

	util.inherits(Readable, Stream);

	var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

	  // This is a hack to make sure that our error handler is attached before any
	  // userland ones.  NEVER DO THIS. This is here only because this code needs
	  // to continue to work with older versions of Node.js that do not include
	  // the prependListener() method. The goal is to eventually remove this hack.
	  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	}

	function ReadableState(options, stream) {
	  Duplex = Duplex || require_stream_duplex();

	  options = options || {};

	  // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream.
	  // These options can be provided separately as readableXXX and writableXXX.
	  var isDuplex = stream instanceof Duplex;

	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var readableHwm = options.readableHighWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

	  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

	  // cast to ints.
	  this.highWaterMark = Math.floor(this.highWaterMark);

	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the event 'readable'/'data' is emitted
	  // immediately, or on a later tick.  We set this to true at first, because
	  // any actions that shouldn't happen until "later" should generally also
	  // not happen before the first read call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;

	  // has it been destroyed
	  this.destroyed = false;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  Duplex = Duplex || require_stream_duplex();

	  if (!(this instanceof Readable)) return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  if (options) {
	    if (typeof options.read === 'function') this._read = options.read;

	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
	  }

	  Stream.call(this);
	}

	Object.defineProperty(Readable.prototype, 'destroyed', {
	  get: function () {
	    if (this._readableState === undefined) {
	      return false;
	    }
	    return this._readableState.destroyed;
	  },
	  set: function (value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (!this._readableState) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._readableState.destroyed = value;
	  }
	});

	Readable.prototype.destroy = destroyImpl.destroy;
	Readable.prototype._undestroy = destroyImpl.undestroy;
	Readable.prototype._destroy = function (err, cb) {
	  this.push(null);
	  cb(err);
	};

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;
	  var skipChunkCheck;

	  if (!state.objectMode) {
	    if (typeof chunk === 'string') {
	      encoding = encoding || state.defaultEncoding;
	      if (encoding !== state.encoding) {
	        chunk = Buffer.from(chunk, encoding);
	        encoding = '';
	      }
	      skipChunkCheck = true;
	    }
	  } else {
	    skipChunkCheck = true;
	  }

	  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  return readableAddChunk(this, chunk, null, true, false);
	};

	function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
	  var state = stream._readableState;
	  if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else {
	    var er;
	    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
	    if (er) {
	      stream.emit('error', er);
	    } else if (state.objectMode || chunk && chunk.length > 0) {
	      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
	        chunk = _uint8ArrayToBuffer(chunk);
	      }

	      if (addToFront) {
	        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
	      } else if (state.ended) {
	        stream.emit('error', new Error('stream.push() after EOF'));
	      } else {
	        state.reading = false;
	        if (state.decoder && !encoding) {
	          chunk = state.decoder.write(chunk);
	          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
	        } else {
	          addChunk(stream, state, chunk, false);
	        }
	      }
	    } else if (!addToFront) {
	      state.reading = false;
	    }
	  }

	  return needMoreData(state);
	}

	function addChunk(stream, state, chunk, addToFront) {
	  if (state.flowing && state.length === 0 && !state.sync) {
	    stream.emit('data', chunk);
	    stream.read(0);
	  } else {
	    // update the buffer info.
	    state.length += state.objectMode ? 1 : chunk.length;
	    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

	    if (state.needReadable) emitReadable(stream);
	  }
	  maybeReadMore(stream, state);
	}

	function chunkInvalid(state, chunk) {
	  var er;
	  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}

	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
	}

	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};

	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 8MB
	var MAX_HWM = 0x800000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}

	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;

	  if (n !== 0) state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }

	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;

	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  } else {
	    state.length -= n;
	  }

	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;

	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }

	  if (ret !== null) this.emit('data', ret);

	  return ret;
	};

	function onEofChunk(stream, state) {
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}

	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    pna.nextTick(maybeReadMore_, stream, state);
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;else len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  this.emit('error', new Error('_read() is not implemented'));
	};

	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

	  var endFn = doEnd ? onend : unpipe;
	  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable, unpipeInfo) {
	    debug('onunpipe');
	    if (readable === src) {
	      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
	        unpipeInfo.hasUnpiped = true;
	        cleanup();
	      }
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', unpipe);
	    src.removeListener('data', ondata);

	    cleanedUp = true;

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }

	  // If the user pushes more data while we're writing to dest then we'll end up
	  // in ondata again. However, we only want to increase awaitDrain once because
	  // dest will only emit one 'drain' event for the multiple writes.
	  // => Introduce a guard on increasing awaitDrain.
	  var increasedAwaitDrain = false;
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    increasedAwaitDrain = false;
	    var ret = dest.write(chunk);
	    if (false === ret && !increasedAwaitDrain) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug('false write response, pause', state.awaitDrain);
	        state.awaitDrain++;
	        increasedAwaitDrain = true;
	      }
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
	  }

	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);

	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function () {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}

	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;
	  var unpipeInfo = { hasUnpiped: false };

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;

	    if (!dest) dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this, unpipeInfo);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var i = 0; i < len; i++) {
	      dests[i].emit('unpipe', this, { hasUnpiped: false });
	    }return this;
	  }

	  // try to find the right one.
	  var index = indexOf(state.pipes, dest);
	  if (index === -1) return this;

	  state.pipes.splice(index, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];

	  dest.emit('unpipe', this, unpipeInfo);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  if (ev === 'data') {
	    // Start flowing on next tick if stream isn't explicitly paused
	    if (this._readableState.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    var state = this._readableState;
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.emittedReadable = false;
	      if (!state.reading) {
	        pna.nextTick(nReadingNextTick, this);
	      } else if (state.length) {
	        emitReadable(this);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    pna.nextTick(resume_, stream, state);
	  }
	}

	function resume_(stream, state) {
	  if (!state.reading) {
	    debug('resume read 0');
	    stream.read(0);
	  }

	  state.resumeScheduled = false;
	  state.awaitDrain = 0;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}

	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null) {}
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var _this = this;

	  var state = this._readableState;
	  var paused = false;

	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) _this.push(chunk);
	    }

	    _this.push(null);
	  });

	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

	    var ret = _this.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function (method) {
	        return function () {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }

	  // proxy certain important events.
	  for (var n = 0; n < kProxyEvents.length; n++) {
	    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
	  }

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  this._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return this;
	};

	Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function () {
	    return this._readableState.highWaterMark;
	  }
	});

	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;

	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = fromListPartial(n, state.buffer, state.decoder);
	  }

	  return ret;
	}

	// Extracts only enough buffered data to satisfy the amount requested.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromListPartial(n, list, hasStrings) {
	  var ret;
	  if (n < list.head.data.length) {
	    // slice is the same for buffers and strings
	    ret = list.head.data.slice(0, n);
	    list.head.data = list.head.data.slice(n);
	  } else if (n === list.head.data.length) {
	    // first chunk is a perfect match
	    ret = list.shift();
	  } else {
	    // result spans more than one buffer
	    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
	  }
	  return ret;
	}

	// Copies a specified amount of characters from the list of buffered data
	// chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBufferString(n, list) {
	  var p = list.head;
	  var c = 1;
	  var ret = p.data;
	  n -= ret.length;
	  while (p = p.next) {
	    var str = p.data;
	    var nb = n > str.length ? str.length : n;
	    if (nb === str.length) ret += str;else ret += str.slice(0, n);
	    n -= nb;
	    if (n === 0) {
	      if (nb === str.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = str.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}

	// Copies a specified amount of bytes from the list of buffered data chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBuffer(n, list) {
	  var ret = Buffer.allocUnsafe(n);
	  var p = list.head;
	  var c = 1;
	  p.data.copy(ret);
	  n -= p.data.length;
	  while (p = p.next) {
	    var buf = p.data;
	    var nb = n > buf.length ? buf.length : n;
	    buf.copy(ret, ret.length - n, 0, nb);
	    n -= nb;
	    if (n === 0) {
	      if (nb === buf.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = buf.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    pna.nextTick(endReadableNT, state, stream);
	  }
	}

	function endReadableNT(state, stream) {
	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	  }
	}

	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	return _stream_readable;
}

var _stream_transform;
var hasRequired_stream_transform;

function require_stream_transform () {
	if (hasRequired_stream_transform) return _stream_transform;
	hasRequired_stream_transform = 1;

	_stream_transform = Transform;

	var Duplex = require_stream_duplex();

	/*<replacement>*/
	var util = Object.create(requireUtil$2());
	util.inherits = requireInherits();
	/*</replacement>*/

	util.inherits(Transform, Duplex);

	function afterTransform(er, data) {
	  var ts = this._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb) {
	    return this.emit('error', new Error('write callback called multiple times'));
	  }

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (data != null) // single equals check for both `null` and `undefined`
	    this.push(data);

	  cb(er);

	  var rs = this._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    this._read(rs.highWaterMark);
	  }
	}

	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = {
	    afterTransform: afterTransform.bind(this),
	    needTransform: false,
	    transforming: false,
	    writecb: null,
	    writechunk: null,
	    writeencoding: null
	  };

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;

	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }

	  // When the writable side finishes, then flush out anything remaining.
	  this.on('prefinish', prefinish);
	}

	function prefinish() {
	  var _this = this;

	  if (typeof this._flush === 'function') {
	    this._flush(function (er, data) {
	      done(_this, er, data);
	    });
	  } else {
	    done(this, null, null);
	  }
	}

	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  throw new Error('_transform() is not implemented');
	};

	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;

	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};

	Transform.prototype._destroy = function (err, cb) {
	  var _this2 = this;

	  Duplex.prototype._destroy.call(this, err, function (err2) {
	    cb(err2);
	    _this2.emit('close');
	  });
	};

	function done(stream, er, data) {
	  if (er) return stream.emit('error', er);

	  if (data != null) // single equals check for both `null` and `undefined`
	    stream.push(data);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

	  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

	  return stream.push(null);
	}
	return _stream_transform;
}

var _stream_passthrough;
var hasRequired_stream_passthrough;

function require_stream_passthrough () {
	if (hasRequired_stream_passthrough) return _stream_passthrough;
	hasRequired_stream_passthrough = 1;

	_stream_passthrough = PassThrough;

	var Transform = require_stream_transform();

	/*<replacement>*/
	var util = Object.create(requireUtil$2());
	util.inherits = requireInherits();
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};
	return _stream_passthrough;
}

var hasRequiredReadable;

function requireReadable () {
	if (hasRequiredReadable) return readable.exports;
	hasRequiredReadable = 1;
	(function (module, exports) {
		var Stream = require$$0$6;
		if (process.env.READABLE_STREAM === 'disable' && Stream) {
		  module.exports = Stream;
		  exports = module.exports = Stream.Readable;
		  exports.Readable = Stream.Readable;
		  exports.Writable = Stream.Writable;
		  exports.Duplex = Stream.Duplex;
		  exports.Transform = Stream.Transform;
		  exports.PassThrough = Stream.PassThrough;
		  exports.Stream = Stream;
		} else {
		  exports = module.exports = require_stream_readable();
		  exports.Stream = Stream || exports;
		  exports.Readable = exports;
		  exports.Writable = require_stream_writable();
		  exports.Duplex = require_stream_duplex();
		  exports.Transform = require_stream_transform();
		  exports.PassThrough = require_stream_passthrough();
		} 
	} (readable, readable.exports));
	return readable.exports;
}

var duplex;
var hasRequiredDuplex;

function requireDuplex () {
	if (hasRequiredDuplex) return duplex;
	hasRequiredDuplex = 1;
	duplex = requireReadable().Duplex;
	return duplex;
}

var bl;
var hasRequiredBl;

function requireBl () {
	if (hasRequiredBl) return bl;
	hasRequiredBl = 1;
	var DuplexStream = requireDuplex()
	  , util         = require$$1$2
	  , Buffer       = requireSafeBuffer().Buffer;


	function BufferList (callback) {
	  if (!(this instanceof BufferList))
	    return new BufferList(callback)

	  this._bufs  = [];
	  this.length = 0;

	  if (typeof callback == 'function') {
	    this._callback = callback;

	    var piper = function piper (err) {
	      if (this._callback) {
	        this._callback(err);
	        this._callback = null;
	      }
	    }.bind(this);

	    this.on('pipe', function onPipe (src) {
	      src.on('error', piper);
	    });
	    this.on('unpipe', function onUnpipe (src) {
	      src.removeListener('error', piper);
	    });
	  } else {
	    this.append(callback);
	  }

	  DuplexStream.call(this);
	}


	util.inherits(BufferList, DuplexStream);


	BufferList.prototype._offset = function _offset (offset) {
	  var tot = 0, i = 0, _t;
	  if (offset === 0) return [ 0, 0 ]
	  for (; i < this._bufs.length; i++) {
	    _t = tot + this._bufs[i].length;
	    if (offset < _t || i == this._bufs.length - 1)
	      return [ i, offset - tot ]
	    tot = _t;
	  }
	};


	BufferList.prototype.append = function append (buf) {
	  var i = 0;

	  if (Buffer.isBuffer(buf)) {
	    this._appendBuffer(buf);
	  } else if (Array.isArray(buf)) {
	    for (; i < buf.length; i++)
	      this.append(buf[i]);
	  } else if (buf instanceof BufferList) {
	    // unwrap argument into individual BufferLists
	    for (; i < buf._bufs.length; i++)
	      this.append(buf._bufs[i]);
	  } else if (buf != null) {
	    // coerce number arguments to strings, since Buffer(number) does
	    // uninitialized memory allocation
	    if (typeof buf == 'number')
	      buf = buf.toString();

	    this._appendBuffer(Buffer.from(buf));
	  }

	  return this
	};


	BufferList.prototype._appendBuffer = function appendBuffer (buf) {
	  this._bufs.push(buf);
	  this.length += buf.length;
	};


	BufferList.prototype._write = function _write (buf, encoding, callback) {
	  this._appendBuffer(buf);

	  if (typeof callback == 'function')
	    callback();
	};


	BufferList.prototype._read = function _read (size) {
	  if (!this.length)
	    return this.push(null)

	  size = Math.min(size, this.length);
	  this.push(this.slice(0, size));
	  this.consume(size);
	};


	BufferList.prototype.end = function end (chunk) {
	  DuplexStream.prototype.end.call(this, chunk);

	  if (this._callback) {
	    this._callback(null, this.slice());
	    this._callback = null;
	  }
	};


	BufferList.prototype.get = function get (index) {
	  return this.slice(index, index + 1)[0]
	};


	BufferList.prototype.slice = function slice (start, end) {
	  if (typeof start == 'number' && start < 0)
	    start += this.length;
	  if (typeof end == 'number' && end < 0)
	    end += this.length;
	  return this.copy(null, 0, start, end)
	};


	BufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {
	  if (typeof srcStart != 'number' || srcStart < 0)
	    srcStart = 0;
	  if (typeof srcEnd != 'number' || srcEnd > this.length)
	    srcEnd = this.length;
	  if (srcStart >= this.length)
	    return dst || Buffer.alloc(0)
	  if (srcEnd <= 0)
	    return dst || Buffer.alloc(0)

	  var copy   = !!dst
	    , off    = this._offset(srcStart)
	    , len    = srcEnd - srcStart
	    , bytes  = len
	    , bufoff = (copy && dstStart) || 0
	    , start  = off[1]
	    , l
	    , i;

	  // copy/slice everything
	  if (srcStart === 0 && srcEnd == this.length) {
	    if (!copy) { // slice, but full concat if multiple buffers
	      return this._bufs.length === 1
	        ? this._bufs[0]
	        : Buffer.concat(this._bufs, this.length)
	    }

	    // copy, need to copy individual buffers
	    for (i = 0; i < this._bufs.length; i++) {
	      this._bufs[i].copy(dst, bufoff);
	      bufoff += this._bufs[i].length;
	    }

	    return dst
	  }

	  // easy, cheap case where it's a subset of one of the buffers
	  if (bytes <= this._bufs[off[0]].length - start) {
	    return copy
	      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
	      : this._bufs[off[0]].slice(start, start + bytes)
	  }

	  if (!copy) // a slice, we need something to copy in to
	    dst = Buffer.allocUnsafe(len);

	  for (i = off[0]; i < this._bufs.length; i++) {
	    l = this._bufs[i].length - start;

	    if (bytes > l) {
	      this._bufs[i].copy(dst, bufoff, start);
	      bufoff += l;
	    } else {
	      this._bufs[i].copy(dst, bufoff, start, start + bytes);
	      bufoff += l;
	      break
	    }

	    bytes -= l;

	    if (start)
	      start = 0;
	  }

	  // safeguard so that we don't return uninitialized memory
	  if (dst.length > bufoff) return dst.slice(0, bufoff)

	  return dst
	};

	BufferList.prototype.shallowSlice = function shallowSlice (start, end) {
	  start = start || 0;
	  end = end || this.length;

	  if (start < 0)
	    start += this.length;
	  if (end < 0)
	    end += this.length;

	  var startOffset = this._offset(start)
	    , endOffset = this._offset(end)
	    , buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);

	  if (endOffset[1] == 0)
	    buffers.pop();
	  else
	    buffers[buffers.length-1] = buffers[buffers.length-1].slice(0, endOffset[1]);

	  if (startOffset[1] != 0)
	    buffers[0] = buffers[0].slice(startOffset[1]);

	  return new BufferList(buffers)
	};

	BufferList.prototype.toString = function toString (encoding, start, end) {
	  return this.slice(start, end).toString(encoding)
	};

	BufferList.prototype.consume = function consume (bytes) {
	  // first, normalize the argument, in accordance with how Buffer does it
	  bytes = Math.trunc(bytes);
	  // do nothing if not a positive number
	  if (Number.isNaN(bytes) || bytes <= 0) return this

	  while (this._bufs.length) {
	    if (bytes >= this._bufs[0].length) {
	      bytes -= this._bufs[0].length;
	      this.length -= this._bufs[0].length;
	      this._bufs.shift();
	    } else {
	      this._bufs[0] = this._bufs[0].slice(bytes);
	      this.length -= bytes;
	      break
	    }
	  }
	  return this
	};


	BufferList.prototype.duplicate = function duplicate () {
	  var i = 0
	    , copy = new BufferList();

	  for (; i < this._bufs.length; i++)
	    copy.append(this._bufs[i]);

	  return copy
	};


	BufferList.prototype.destroy = function destroy () {
	  this._bufs.length = 0;
	  this.length = 0;
	  this.push(null);
	}


	;(function () {
	  var methods = {
	      'readDoubleBE' : 8
	    , 'readDoubleLE' : 8
	    , 'readFloatBE'  : 4
	    , 'readFloatLE'  : 4
	    , 'readInt32BE'  : 4
	    , 'readInt32LE'  : 4
	    , 'readUInt32BE' : 4
	    , 'readUInt32LE' : 4
	    , 'readInt16BE'  : 2
	    , 'readInt16LE'  : 2
	    , 'readUInt16BE' : 2
	    , 'readUInt16LE' : 2
	    , 'readInt8'     : 1
	    , 'readUInt8'    : 1
	  };

	  for (var m in methods) {
	    (function (m) {
	      BufferList.prototype[m] = function (offset) {
	        return this.slice(offset, offset + methods[m])[m](0)
	      };
	    }(m));
	  }
	}());


	bl = BufferList;
	return bl;
}

var immutable;
var hasRequiredImmutable;

function requireImmutable () {
	if (hasRequiredImmutable) return immutable;
	hasRequiredImmutable = 1;
	immutable = extend;

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	function extend() {
	    var target = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var source = arguments[i];

	        for (var key in source) {
	            if (hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }

	    return target
	}
	return immutable;
}

var headers = {};

var toBuffer_1;
var hasRequiredToBuffer;

function requireToBuffer () {
	if (hasRequiredToBuffer) return toBuffer_1;
	hasRequiredToBuffer = 1;
	toBuffer_1 = toBuffer;

	var makeBuffer = Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from : bufferFrom;

	function bufferFrom (buf, enc) {
	  return new Buffer(buf, enc)
	}

	function toBuffer (buf, enc) {
	  if (Buffer.isBuffer(buf)) return buf
	  if (typeof buf === 'string') return makeBuffer(buf, enc)
	  if (Array.isArray(buf)) return makeBuffer(buf)
	  throw new Error('Input should be a buffer or a string')
	}
	return toBuffer_1;
}

/* Node.js 6.4.0 and up has full support */

var bufferFill;
var hasRequiredBufferFill;

function requireBufferFill () {
	if (hasRequiredBufferFill) return bufferFill;
	hasRequiredBufferFill = 1;
	var hasFullSupport = (function () {
	  try {
	    if (!Buffer.isEncoding('latin1')) {
	      return false
	    }

	    var buf = Buffer.alloc ? Buffer.alloc(4) : new Buffer(4);

	    buf.fill('ab', 'ucs2');

	    return (buf.toString('hex') === '61006200')
	  } catch (_) {
	    return false
	  }
	}());

	function isSingleByte (val) {
	  return (val.length === 1 && val.charCodeAt(0) < 256)
	}

	function fillWithNumber (buffer, val, start, end) {
	  if (start < 0 || end > buffer.length) {
	    throw new RangeError('Out of range index')
	  }

	  start = start >>> 0;
	  end = end === undefined ? buffer.length : end >>> 0;

	  if (end > start) {
	    buffer.fill(val, start, end);
	  }

	  return buffer
	}

	function fillWithBuffer (buffer, val, start, end) {
	  if (start < 0 || end > buffer.length) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return buffer
	  }

	  start = start >>> 0;
	  end = end === undefined ? buffer.length : end >>> 0;

	  var pos = start;
	  var len = val.length;
	  while (pos <= (end - len)) {
	    val.copy(buffer, pos);
	    pos += len;
	  }

	  if (pos !== end) {
	    val.copy(buffer, pos, 0, end - pos);
	  }

	  return buffer
	}

	function fill (buffer, val, start, end, encoding) {
	  if (hasFullSupport) {
	    return buffer.fill(val, start, end, encoding)
	  }

	  if (typeof val === 'number') {
	    return fillWithNumber(buffer, val, start, end)
	  }

	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start;
	      start = 0;
	      end = buffer.length;
	    } else if (typeof end === 'string') {
	      encoding = end;
	      end = buffer.length;
	    }

	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }

	    if (encoding === 'latin1') {
	      encoding = 'binary';
	    }

	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }

	    if (val === '') {
	      return fillWithNumber(buffer, 0, start, end)
	    }

	    if (isSingleByte(val)) {
	      return fillWithNumber(buffer, val.charCodeAt(0), start, end)
	    }

	    val = new Buffer(val, encoding);
	  }

	  if (Buffer.isBuffer(val)) {
	    return fillWithBuffer(buffer, val, start, end)
	  }

	  // Other values (e.g. undefined, boolean, object) results in zero-fill
	  return fillWithNumber(buffer, 0, start, end)
	}

	bufferFill = fill;
	return bufferFill;
}

var bufferAllocUnsafe;
var hasRequiredBufferAllocUnsafe;

function requireBufferAllocUnsafe () {
	if (hasRequiredBufferAllocUnsafe) return bufferAllocUnsafe;
	hasRequiredBufferAllocUnsafe = 1;
	function allocUnsafe (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  }

	  if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }

	  if (Buffer.allocUnsafe) {
	    return Buffer.allocUnsafe(size)
	  } else {
	    return new Buffer(size)
	  }
	}

	bufferAllocUnsafe = allocUnsafe;
	return bufferAllocUnsafe;
}

var bufferAlloc;
var hasRequiredBufferAlloc;

function requireBufferAlloc () {
	if (hasRequiredBufferAlloc) return bufferAlloc;
	hasRequiredBufferAlloc = 1;
	var bufferFill = requireBufferFill();
	var allocUnsafe = requireBufferAllocUnsafe();

	bufferAlloc = function alloc (size, fill, encoding) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  }

	  if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }

	  if (Buffer.alloc) {
	    return Buffer.alloc(size, fill, encoding)
	  }

	  var buffer = allocUnsafe(size);

	  if (size === 0) {
	    return buffer
	  }

	  if (fill === undefined) {
	    return bufferFill(buffer, 0)
	  }

	  if (typeof encoding !== 'string') {
	    encoding = undefined;
	  }

	  return bufferFill(buffer, fill, encoding)
	};
	return bufferAlloc;
}

var hasRequiredHeaders;

function requireHeaders () {
	if (hasRequiredHeaders) return headers;
	hasRequiredHeaders = 1;
	var toBuffer = requireToBuffer();
	var alloc = requireBufferAlloc();

	var ZEROS = '0000000000000000000';
	var SEVENS = '7777777777777777777';
	var ZERO_OFFSET = '0'.charCodeAt(0);
	var USTAR = 'ustar\x0000';
	var MASK = parseInt('7777', 8);

	var clamp = function (index, len, defaultValue) {
	  if (typeof index !== 'number') return defaultValue
	  index = ~~index; // Coerce to integer.
	  if (index >= len) return len
	  if (index >= 0) return index
	  index += len;
	  if (index >= 0) return index
	  return 0
	};

	var toType = function (flag) {
	  switch (flag) {
	    case 0:
	      return 'file'
	    case 1:
	      return 'link'
	    case 2:
	      return 'symlink'
	    case 3:
	      return 'character-device'
	    case 4:
	      return 'block-device'
	    case 5:
	      return 'directory'
	    case 6:
	      return 'fifo'
	    case 7:
	      return 'contiguous-file'
	    case 72:
	      return 'pax-header'
	    case 55:
	      return 'pax-global-header'
	    case 27:
	      return 'gnu-long-link-path'
	    case 28:
	    case 30:
	      return 'gnu-long-path'
	  }

	  return null
	};

	var toTypeflag = function (flag) {
	  switch (flag) {
	    case 'file':
	      return 0
	    case 'link':
	      return 1
	    case 'symlink':
	      return 2
	    case 'character-device':
	      return 3
	    case 'block-device':
	      return 4
	    case 'directory':
	      return 5
	    case 'fifo':
	      return 6
	    case 'contiguous-file':
	      return 7
	    case 'pax-header':
	      return 72
	  }

	  return 0
	};

	var indexOf = function (block, num, offset, end) {
	  for (; offset < end; offset++) {
	    if (block[offset] === num) return offset
	  }
	  return end
	};

	var cksum = function (block) {
	  var sum = 8 * 32;
	  for (var i = 0; i < 148; i++) sum += block[i];
	  for (var j = 156; j < 512; j++) sum += block[j];
	  return sum
	};

	var encodeOct = function (val, n) {
	  val = val.toString(8);
	  if (val.length > n) return SEVENS.slice(0, n) + ' '
	  else return ZEROS.slice(0, n - val.length) + val + ' '
	};

	/* Copied from the node-tar repo and modified to meet
	 * tar-stream coding standard.
	 *
	 * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349
	 */
	function parse256 (buf) {
	  // first byte MUST be either 80 or FF
	  // 80 for positive, FF for 2's comp
	  var positive;
	  if (buf[0] === 0x80) positive = true;
	  else if (buf[0] === 0xFF) positive = false;
	  else return null
	  var tuple = [];
	  for (var i = buf.length - 1; i > 0; i--) {
	    var byte = buf[i];
	    if (positive) tuple.push(byte);
	    else tuple.push(0xFF - byte);
	  }

	  var sum = 0;
	  var l = tuple.length;
	  for (i = 0; i < l; i++) {
	    sum += tuple[i] * Math.pow(256, i);
	  }

	  return positive ? sum : -1 * sum
	}

	var decodeOct = function (val, offset, length) {
	  val = val.slice(offset, offset + length);
	  offset = 0;

	  // If prefixed with 0x80 then parse as a base-256 integer
	  if (val[offset] & 0x80) {
	    return parse256(val)
	  } else {
	    // Older versions of tar can prefix with spaces
	    while (offset < val.length && val[offset] === 32) offset++;
	    var end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
	    while (offset < end && val[offset] === 0) offset++;
	    if (end === offset) return 0
	    return parseInt(val.slice(offset, end).toString(), 8)
	  }
	};

	var decodeStr = function (val, offset, length, encoding) {
	  return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding)
	};

	var addLength = function (str) {
	  var len = Buffer.byteLength(str);
	  var digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
	  if (len + digits >= Math.pow(10, digits)) digits++;

	  return (len + digits) + str
	};

	headers.decodeLongPath = function (buf, encoding) {
	  return decodeStr(buf, 0, buf.length, encoding)
	};

	headers.encodePax = function (opts) { // TODO: encode more stuff in pax
	  var result = '';
	  if (opts.name) result += addLength(' path=' + opts.name + '\n');
	  if (opts.linkname) result += addLength(' linkpath=' + opts.linkname + '\n');
	  var pax = opts.pax;
	  if (pax) {
	    for (var key in pax) {
	      result += addLength(' ' + key + '=' + pax[key] + '\n');
	    }
	  }
	  return toBuffer(result)
	};

	headers.decodePax = function (buf) {
	  var result = {};

	  while (buf.length) {
	    var i = 0;
	    while (i < buf.length && buf[i] !== 32) i++;
	    var len = parseInt(buf.slice(0, i).toString(), 10);
	    if (!len) return result

	    var b = buf.slice(i + 1, len - 1).toString();
	    var keyIndex = b.indexOf('=');
	    if (keyIndex === -1) return result
	    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);

	    buf = buf.slice(len);
	  }

	  return result
	};

	headers.encode = function (opts) {
	  var buf = alloc(512);
	  var name = opts.name;
	  var prefix = '';

	  if (opts.typeflag === 5 && name[name.length - 1] !== '/') name += '/';
	  if (Buffer.byteLength(name) !== name.length) return null // utf-8

	  while (Buffer.byteLength(name) > 100) {
	    var i = name.indexOf('/');
	    if (i === -1) return null
	    prefix += prefix ? '/' + name.slice(0, i) : name.slice(0, i);
	    name = name.slice(i + 1);
	  }

	  if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155) return null
	  if (opts.linkname && Buffer.byteLength(opts.linkname) > 100) return null

	  buf.write(name);
	  buf.write(encodeOct(opts.mode & MASK, 6), 100);
	  buf.write(encodeOct(opts.uid, 6), 108);
	  buf.write(encodeOct(opts.gid, 6), 116);
	  buf.write(encodeOct(opts.size, 11), 124);
	  buf.write(encodeOct((opts.mtime.getTime() / 1000) | 0, 11), 136);

	  buf[156] = ZERO_OFFSET + toTypeflag(opts.type);

	  if (opts.linkname) buf.write(opts.linkname, 157);

	  buf.write(USTAR, 257);
	  if (opts.uname) buf.write(opts.uname, 265);
	  if (opts.gname) buf.write(opts.gname, 297);
	  buf.write(encodeOct(opts.devmajor || 0, 6), 329);
	  buf.write(encodeOct(opts.devminor || 0, 6), 337);

	  if (prefix) buf.write(prefix, 345);

	  buf.write(encodeOct(cksum(buf), 6), 148);

	  return buf
	};

	headers.decode = function (buf, filenameEncoding) {
	  var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;

	  var name = decodeStr(buf, 0, 100, filenameEncoding);
	  var mode = decodeOct(buf, 100, 8);
	  var uid = decodeOct(buf, 108, 8);
	  var gid = decodeOct(buf, 116, 8);
	  var size = decodeOct(buf, 124, 12);
	  var mtime = decodeOct(buf, 136, 12);
	  var type = toType(typeflag);
	  var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
	  var uname = decodeStr(buf, 265, 32);
	  var gname = decodeStr(buf, 297, 32);
	  var devmajor = decodeOct(buf, 329, 8);
	  var devminor = decodeOct(buf, 337, 8);

	  if (buf[345]) name = decodeStr(buf, 345, 155, filenameEncoding) + '/' + name;

	  // to support old tar versions that use trailing / to indicate dirs
	  if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5;

	  var c = cksum(buf);

	  // checksum is still initial value if header was null.
	  if (c === 8 * 32) return null

	  // valid checksum
	  if (c !== decodeOct(buf, 148, 8)) throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?')

	  return {
	    name: name,
	    mode: mode,
	    uid: uid,
	    gid: gid,
	    size: size,
	    mtime: new Date(1000 * mtime),
	    type: type,
	    linkname: linkname,
	    uname: uname,
	    gname: gname,
	    devmajor: devmajor,
	    devminor: devminor
	  }
	};
	return headers;
}

var extract;
var hasRequiredExtract;

function requireExtract () {
	if (hasRequiredExtract) return extract;
	hasRequiredExtract = 1;
	var util = require$$1$2;
	var bl = requireBl();
	var xtend = requireImmutable();
	var headers = requireHeaders();

	var Writable = requireReadable().Writable;
	var PassThrough = requireReadable().PassThrough;

	var noop = function () {};

	var overflow = function (size) {
	  size &= 511;
	  return size && 512 - size
	};

	var emptyStream = function (self, offset) {
	  var s = new Source(self, offset);
	  s.end();
	  return s
	};

	var mixinPax = function (header, pax) {
	  if (pax.path) header.name = pax.path;
	  if (pax.linkpath) header.linkname = pax.linkpath;
	  if (pax.size) header.size = parseInt(pax.size, 10);
	  header.pax = pax;
	  return header
	};

	var Source = function (self, offset) {
	  this._parent = self;
	  this.offset = offset;
	  PassThrough.call(this);
	};

	util.inherits(Source, PassThrough);

	Source.prototype.destroy = function (err) {
	  this._parent.destroy(err);
	};

	var Extract = function (opts) {
	  if (!(this instanceof Extract)) return new Extract(opts)
	  Writable.call(this, opts);

	  opts = opts || {};

	  this._offset = 0;
	  this._buffer = bl();
	  this._missing = 0;
	  this._partial = false;
	  this._onparse = noop;
	  this._header = null;
	  this._stream = null;
	  this._overflow = null;
	  this._cb = null;
	  this._locked = false;
	  this._destroyed = false;
	  this._pax = null;
	  this._paxGlobal = null;
	  this._gnuLongPath = null;
	  this._gnuLongLinkPath = null;

	  var self = this;
	  var b = self._buffer;

	  var oncontinue = function () {
	    self._continue();
	  };

	  var onunlock = function (err) {
	    self._locked = false;
	    if (err) return self.destroy(err)
	    if (!self._stream) oncontinue();
	  };

	  var onstreamend = function () {
	    self._stream = null;
	    var drain = overflow(self._header.size);
	    if (drain) self._parse(drain, ondrain);
	    else self._parse(512, onheader);
	    if (!self._locked) oncontinue();
	  };

	  var ondrain = function () {
	    self._buffer.consume(overflow(self._header.size));
	    self._parse(512, onheader);
	    oncontinue();
	  };

	  var onpaxglobalheader = function () {
	    var size = self._header.size;
	    self._paxGlobal = headers.decodePax(b.slice(0, size));
	    b.consume(size);
	    onstreamend();
	  };

	  var onpaxheader = function () {
	    var size = self._header.size;
	    self._pax = headers.decodePax(b.slice(0, size));
	    if (self._paxGlobal) self._pax = xtend(self._paxGlobal, self._pax);
	    b.consume(size);
	    onstreamend();
	  };

	  var ongnulongpath = function () {
	    var size = self._header.size;
	    this._gnuLongPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
	    b.consume(size);
	    onstreamend();
	  };

	  var ongnulonglinkpath = function () {
	    var size = self._header.size;
	    this._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
	    b.consume(size);
	    onstreamend();
	  };

	  var onheader = function () {
	    var offset = self._offset;
	    var header;
	    try {
	      header = self._header = headers.decode(b.slice(0, 512), opts.filenameEncoding);
	    } catch (err) {
	      self.emit('error', err);
	    }
	    b.consume(512);

	    if (!header) {
	      self._parse(512, onheader);
	      oncontinue();
	      return
	    }
	    if (header.type === 'gnu-long-path') {
	      self._parse(header.size, ongnulongpath);
	      oncontinue();
	      return
	    }
	    if (header.type === 'gnu-long-link-path') {
	      self._parse(header.size, ongnulonglinkpath);
	      oncontinue();
	      return
	    }
	    if (header.type === 'pax-global-header') {
	      self._parse(header.size, onpaxglobalheader);
	      oncontinue();
	      return
	    }
	    if (header.type === 'pax-header') {
	      self._parse(header.size, onpaxheader);
	      oncontinue();
	      return
	    }

	    if (self._gnuLongPath) {
	      header.name = self._gnuLongPath;
	      self._gnuLongPath = null;
	    }

	    if (self._gnuLongLinkPath) {
	      header.linkname = self._gnuLongLinkPath;
	      self._gnuLongLinkPath = null;
	    }

	    if (self._pax) {
	      self._header = header = mixinPax(header, self._pax);
	      self._pax = null;
	    }

	    self._locked = true;

	    if (!header.size || header.type === 'directory') {
	      self._parse(512, onheader);
	      self.emit('entry', header, emptyStream(self, offset), onunlock);
	      return
	    }

	    self._stream = new Source(self, offset);

	    self.emit('entry', header, self._stream, onunlock);
	    self._parse(header.size, onstreamend);
	    oncontinue();
	  };

	  this._onheader = onheader;
	  this._parse(512, onheader);
	};

	util.inherits(Extract, Writable);

	Extract.prototype.destroy = function (err) {
	  if (this._destroyed) return
	  this._destroyed = true;

	  if (err) this.emit('error', err);
	  this.emit('close');
	  if (this._stream) this._stream.emit('close');
	};

	Extract.prototype._parse = function (size, onparse) {
	  if (this._destroyed) return
	  this._offset += size;
	  this._missing = size;
	  if (onparse === this._onheader) this._partial = false;
	  this._onparse = onparse;
	};

	Extract.prototype._continue = function () {
	  if (this._destroyed) return
	  var cb = this._cb;
	  this._cb = noop;
	  if (this._overflow) this._write(this._overflow, undefined, cb);
	  else cb();
	};

	Extract.prototype._write = function (data, enc, cb) {
	  if (this._destroyed) return

	  var s = this._stream;
	  var b = this._buffer;
	  var missing = this._missing;
	  if (data.length) this._partial = true;

	  // we do not reach end-of-chunk now. just forward it

	  if (data.length < missing) {
	    this._missing -= data.length;
	    this._overflow = null;
	    if (s) return s.write(data, cb)
	    b.append(data);
	    return cb()
	  }

	  // end-of-chunk. the parser should call cb.

	  this._cb = cb;
	  this._missing = 0;

	  var overflow = null;
	  if (data.length > missing) {
	    overflow = data.slice(missing);
	    data = data.slice(0, missing);
	  }

	  if (s) s.end(data);
	  else b.append(data);

	  this._overflow = overflow;
	  this._onparse();
	};

	Extract.prototype._final = function (cb) {
	  if (this._partial) return this.destroy(new Error('Unexpected end of data'))
	  cb();
	};

	extract = Extract;
	return extract;
}

var fsConstants;
var hasRequiredFsConstants;

function requireFsConstants () {
	if (hasRequiredFsConstants) return fsConstants;
	hasRequiredFsConstants = 1;
	fsConstants = require$$0$8.constants || require$$0$a;
	return fsConstants;
}

var once = {exports: {}};

var wrappy_1;
var hasRequiredWrappy;

function requireWrappy () {
	if (hasRequiredWrappy) return wrappy_1;
	hasRequiredWrappy = 1;
	// Returns a wrapper function that returns a wrapped callback
	// The wrapper function should do some stuff, and return a
	// presumably different callback function.
	// This makes sure that own properties are retained, so that
	// decorations and such are not lost along the way.
	wrappy_1 = wrappy;
	function wrappy (fn, cb) {
	  if (fn && cb) return wrappy(fn)(cb)

	  if (typeof fn !== 'function')
	    throw new TypeError('need wrapper function')

	  Object.keys(fn).forEach(function (k) {
	    wrapper[k] = fn[k];
	  });

	  return wrapper

	  function wrapper() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    var ret = fn.apply(this, args);
	    var cb = args[args.length-1];
	    if (typeof ret === 'function' && ret !== cb) {
	      Object.keys(cb).forEach(function (k) {
	        ret[k] = cb[k];
	      });
	    }
	    return ret
	  }
	}
	return wrappy_1;
}

var hasRequiredOnce;

function requireOnce () {
	if (hasRequiredOnce) return once.exports;
	hasRequiredOnce = 1;
	var wrappy = requireWrappy();
	once.exports = wrappy(once$1);
	once.exports.strict = wrappy(onceStrict);

	once$1.proto = once$1(function () {
	  Object.defineProperty(Function.prototype, 'once', {
	    value: function () {
	      return once$1(this)
	    },
	    configurable: true
	  });

	  Object.defineProperty(Function.prototype, 'onceStrict', {
	    value: function () {
	      return onceStrict(this)
	    },
	    configurable: true
	  });
	});

	function once$1 (fn) {
	  var f = function () {
	    if (f.called) return f.value
	    f.called = true;
	    return f.value = fn.apply(this, arguments)
	  };
	  f.called = false;
	  return f
	}

	function onceStrict (fn) {
	  var f = function () {
	    if (f.called)
	      throw new Error(f.onceError)
	    f.called = true;
	    return f.value = fn.apply(this, arguments)
	  };
	  var name = fn.name || 'Function wrapped with `once`';
	  f.onceError = name + " shouldn't be called more than once";
	  f.called = false;
	  return f
	}
	return once.exports;
}

var endOfStream;
var hasRequiredEndOfStream;

function requireEndOfStream () {
	if (hasRequiredEndOfStream) return endOfStream;
	hasRequiredEndOfStream = 1;
	var once = requireOnce();

	var noop = function() {};

	var isRequest = function(stream) {
		return stream.setHeader && typeof stream.abort === 'function';
	};

	var isChildProcess = function(stream) {
		return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
	};

	var eos = function(stream, opts, callback) {
		if (typeof opts === 'function') return eos(stream, null, opts);
		if (!opts) opts = {};

		callback = once(callback || noop);

		var ws = stream._writableState;
		var rs = stream._readableState;
		var readable = opts.readable || (opts.readable !== false && stream.readable);
		var writable = opts.writable || (opts.writable !== false && stream.writable);
		var cancelled = false;

		var onlegacyfinish = function() {
			if (!stream.writable) onfinish();
		};

		var onfinish = function() {
			writable = false;
			if (!readable) callback.call(stream);
		};

		var onend = function() {
			readable = false;
			if (!writable) callback.call(stream);
		};

		var onexit = function(exitCode) {
			callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
		};

		var onerror = function(err) {
			callback.call(stream, err);
		};

		var onclose = function() {
			process.nextTick(onclosenexttick);
		};

		var onclosenexttick = function() {
			if (cancelled) return;
			if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));
			if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));
		};

		var onrequest = function() {
			stream.req.on('finish', onfinish);
		};

		if (isRequest(stream)) {
			stream.on('complete', onfinish);
			stream.on('abort', onclose);
			if (stream.req) onrequest();
			else stream.on('request', onrequest);
		} else if (writable && !ws) { // legacy streams
			stream.on('end', onlegacyfinish);
			stream.on('close', onlegacyfinish);
		}

		if (isChildProcess(stream)) stream.on('exit', onexit);

		stream.on('end', onend);
		stream.on('finish', onfinish);
		if (opts.error !== false) stream.on('error', onerror);
		stream.on('close', onclose);

		return function() {
			cancelled = true;
			stream.removeListener('complete', onfinish);
			stream.removeListener('abort', onclose);
			stream.removeListener('request', onrequest);
			if (stream.req) stream.req.removeListener('finish', onfinish);
			stream.removeListener('end', onlegacyfinish);
			stream.removeListener('close', onlegacyfinish);
			stream.removeListener('finish', onfinish);
			stream.removeListener('exit', onexit);
			stream.removeListener('end', onend);
			stream.removeListener('error', onerror);
			stream.removeListener('close', onclose);
		};
	};

	endOfStream = eos;
	return endOfStream;
}

var pack;
var hasRequiredPack;

function requirePack () {
	if (hasRequiredPack) return pack;
	hasRequiredPack = 1;
	var constants = requireFsConstants();
	var eos = requireEndOfStream();
	var util = require$$1$2;
	var alloc = requireBufferAlloc();
	var toBuffer = requireToBuffer();

	var Readable = requireReadable().Readable;
	var Writable = requireReadable().Writable;
	var StringDecoder = require$$6$1.StringDecoder;

	var headers = requireHeaders();

	var DMODE = parseInt('755', 8);
	var FMODE = parseInt('644', 8);

	var END_OF_TAR = alloc(1024);

	var noop = function () {};

	var overflow = function (self, size) {
	  size &= 511;
	  if (size) self.push(END_OF_TAR.slice(0, 512 - size));
	};

	function modeToType (mode) {
	  switch (mode & constants.S_IFMT) {
	    case constants.S_IFBLK: return 'block-device'
	    case constants.S_IFCHR: return 'character-device'
	    case constants.S_IFDIR: return 'directory'
	    case constants.S_IFIFO: return 'fifo'
	    case constants.S_IFLNK: return 'symlink'
	  }

	  return 'file'
	}

	var Sink = function (to) {
	  Writable.call(this);
	  this.written = 0;
	  this._to = to;
	  this._destroyed = false;
	};

	util.inherits(Sink, Writable);

	Sink.prototype._write = function (data, enc, cb) {
	  this.written += data.length;
	  if (this._to.push(data)) return cb()
	  this._to._drain = cb;
	};

	Sink.prototype.destroy = function () {
	  if (this._destroyed) return
	  this._destroyed = true;
	  this.emit('close');
	};

	var LinkSink = function () {
	  Writable.call(this);
	  this.linkname = '';
	  this._decoder = new StringDecoder('utf-8');
	  this._destroyed = false;
	};

	util.inherits(LinkSink, Writable);

	LinkSink.prototype._write = function (data, enc, cb) {
	  this.linkname += this._decoder.write(data);
	  cb();
	};

	LinkSink.prototype.destroy = function () {
	  if (this._destroyed) return
	  this._destroyed = true;
	  this.emit('close');
	};

	var Void = function () {
	  Writable.call(this);
	  this._destroyed = false;
	};

	util.inherits(Void, Writable);

	Void.prototype._write = function (data, enc, cb) {
	  cb(new Error('No body allowed for this entry'));
	};

	Void.prototype.destroy = function () {
	  if (this._destroyed) return
	  this._destroyed = true;
	  this.emit('close');
	};

	var Pack = function (opts) {
	  if (!(this instanceof Pack)) return new Pack(opts)
	  Readable.call(this, opts);

	  this._drain = noop;
	  this._finalized = false;
	  this._finalizing = false;
	  this._destroyed = false;
	  this._stream = null;
	};

	util.inherits(Pack, Readable);

	Pack.prototype.entry = function (header, buffer, callback) {
	  if (this._stream) throw new Error('already piping an entry')
	  if (this._finalized || this._destroyed) return

	  if (typeof buffer === 'function') {
	    callback = buffer;
	    buffer = null;
	  }

	  if (!callback) callback = noop;

	  var self = this;

	  if (!header.size || header.type === 'symlink') header.size = 0;
	  if (!header.type) header.type = modeToType(header.mode);
	  if (!header.mode) header.mode = header.type === 'directory' ? DMODE : FMODE;
	  if (!header.uid) header.uid = 0;
	  if (!header.gid) header.gid = 0;
	  if (!header.mtime) header.mtime = new Date();

	  if (typeof buffer === 'string') buffer = toBuffer(buffer);
	  if (Buffer.isBuffer(buffer)) {
	    header.size = buffer.length;
	    this._encode(header);
	    this.push(buffer);
	    overflow(self, header.size);
	    process.nextTick(callback);
	    return new Void()
	  }

	  if (header.type === 'symlink' && !header.linkname) {
	    var linkSink = new LinkSink();
	    eos(linkSink, function (err) {
	      if (err) { // stream was closed
	        self.destroy();
	        return callback(err)
	      }

	      header.linkname = linkSink.linkname;
	      self._encode(header);
	      callback();
	    });

	    return linkSink
	  }

	  this._encode(header);

	  if (header.type !== 'file' && header.type !== 'contiguous-file') {
	    process.nextTick(callback);
	    return new Void()
	  }

	  var sink = new Sink(this);

	  this._stream = sink;

	  eos(sink, function (err) {
	    self._stream = null;

	    if (err) { // stream was closed
	      self.destroy();
	      return callback(err)
	    }

	    if (sink.written !== header.size) { // corrupting tar
	      self.destroy();
	      return callback(new Error('size mismatch'))
	    }

	    overflow(self, header.size);
	    if (self._finalizing) self.finalize();
	    callback();
	  });

	  return sink
	};

	Pack.prototype.finalize = function () {
	  if (this._stream) {
	    this._finalizing = true;
	    return
	  }

	  if (this._finalized) return
	  this._finalized = true;
	  this.push(END_OF_TAR);
	  this.push(null);
	};

	Pack.prototype.destroy = function (err) {
	  if (this._destroyed) return
	  this._destroyed = true;

	  if (err) this.emit('error', err);
	  this.emit('close');
	  if (this._stream && this._stream.destroy) this._stream.destroy();
	};

	Pack.prototype._encode = function (header) {
	  if (!header.pax) {
	    var buf = headers.encode(header);
	    if (buf) {
	      this.push(buf);
	      return
	    }
	  }
	  this._encodePax(header);
	};

	Pack.prototype._encodePax = function (header) {
	  var paxHeader = headers.encodePax({
	    name: header.name,
	    linkname: header.linkname,
	    pax: header.pax
	  });

	  var newHeader = {
	    name: 'PaxHeader',
	    mode: header.mode,
	    uid: header.uid,
	    gid: header.gid,
	    size: paxHeader.length,
	    mtime: header.mtime,
	    type: 'pax-header',
	    linkname: header.linkname && 'PaxHeader',
	    uname: header.uname,
	    gname: header.gname,
	    devmajor: header.devmajor,
	    devminor: header.devminor
	  };

	  this.push(headers.encode(newHeader));
	  this.push(paxHeader);
	  overflow(this, paxHeader.length);

	  newHeader.size = header.size;
	  newHeader.type = header.type;
	  this.push(headers.encode(newHeader));
	};

	Pack.prototype._read = function (n) {
	  var drain = this._drain;
	  this._drain = noop;
	  drain();
	};

	pack = Pack;
	return pack;
}

var hasRequiredTarStream;

function requireTarStream () {
	if (hasRequiredTarStream) return tarStream;
	hasRequiredTarStream = 1;
	tarStream.extract = requireExtract();
	tarStream.pack = requirePack();
	return tarStream;
}

var decompressTar;
var hasRequiredDecompressTar;

function requireDecompressTar () {
	if (hasRequiredDecompressTar) return decompressTar;
	hasRequiredDecompressTar = 1;
	const fileType = requireFileType$2();
	const isStream = requireIsStream();
	const tarStream = requireTarStream();

	decompressTar = () => input => {
		if (!Buffer.isBuffer(input) && !isStream(input)) {
			return Promise.reject(new TypeError(`Expected a Buffer or Stream, got ${typeof input}`));
		}

		if (Buffer.isBuffer(input) && (!fileType(input) || fileType(input).ext !== 'tar')) {
			return Promise.resolve([]);
		}

		const extract = tarStream.extract();
		const files = [];

		extract.on('entry', (header, stream, cb) => {
			const chunk = [];

			stream.on('data', data => chunk.push(data));
			stream.on('end', () => {
				const file = {
					data: Buffer.concat(chunk),
					mode: header.mode,
					mtime: header.mtime,
					path: header.name,
					type: header.type
				};

				if (header.type === 'symlink' || header.type === 'link') {
					file.linkname = header.linkname;
				}

				files.push(file);
				cb();
			});
		});

		const promise = new Promise((resolve, reject) => {
			if (!Buffer.isBuffer(input)) {
				input.on('error', reject);
			}

			extract.on('finish', () => resolve(files));
			extract.on('error', reject);
		});

		extract.then = promise.then.bind(promise);
		extract.catch = promise.catch.bind(promise);

		if (Buffer.isBuffer(input)) {
			extract.end(input);
		} else {
			input.pipe(extract);
		}

		return extract;
	};
	return decompressTar;
}

var fileType$1;
var hasRequiredFileType$1;

function requireFileType$1 () {
	if (hasRequiredFileType$1) return fileType$1;
	hasRequiredFileType$1 = 1;
	const toBytes = s => Array.from(s).map(c => c.charCodeAt(0));
	const xpiZipFilename = toBytes('META-INF/mozilla.rsa');
	const oxmlContentTypes = toBytes('[Content_Types].xml');
	const oxmlRels = toBytes('_rels/.rels');

	fileType$1 = input => {
		const buf = new Uint8Array(input);

		if (!(buf && buf.length > 1)) {
			return null;
		}

		const check = (header, opts) => {
			opts = Object.assign({
				offset: 0
			}, opts);

			for (let i = 0; i < header.length; i++) {
				// If a bitmask is set
				if (opts.mask) {
					// If header doesn't equal `buf` with bits masked off
					if (header[i] !== (opts.mask[i] & buf[i + opts.offset])) {
						return false;
					}
				} else if (header[i] !== buf[i + opts.offset]) {
					return false;
				}
			}

			return true;
		};

		if (check([0xFF, 0xD8, 0xFF])) {
			return {
				ext: 'jpg',
				mime: 'image/jpeg'
			};
		}

		if (check([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A])) {
			return {
				ext: 'png',
				mime: 'image/png'
			};
		}

		if (check([0x47, 0x49, 0x46])) {
			return {
				ext: 'gif',
				mime: 'image/gif'
			};
		}

		if (check([0x57, 0x45, 0x42, 0x50], {offset: 8})) {
			return {
				ext: 'webp',
				mime: 'image/webp'
			};
		}

		if (check([0x46, 0x4C, 0x49, 0x46])) {
			return {
				ext: 'flif',
				mime: 'image/flif'
			};
		}

		// Needs to be before `tif` check
		if (
			(check([0x49, 0x49, 0x2A, 0x0]) || check([0x4D, 0x4D, 0x0, 0x2A])) &&
			check([0x43, 0x52], {offset: 8})
		) {
			return {
				ext: 'cr2',
				mime: 'image/x-canon-cr2'
			};
		}

		if (
			check([0x49, 0x49, 0x2A, 0x0]) ||
			check([0x4D, 0x4D, 0x0, 0x2A])
		) {
			return {
				ext: 'tif',
				mime: 'image/tiff'
			};
		}

		if (check([0x42, 0x4D])) {
			return {
				ext: 'bmp',
				mime: 'image/bmp'
			};
		}

		if (check([0x49, 0x49, 0xBC])) {
			return {
				ext: 'jxr',
				mime: 'image/vnd.ms-photo'
			};
		}

		if (check([0x38, 0x42, 0x50, 0x53])) {
			return {
				ext: 'psd',
				mime: 'image/vnd.adobe.photoshop'
			};
		}

		// Zip-based file formats
		// Need to be before the `zip` check
		if (check([0x50, 0x4B, 0x3, 0x4])) {
			if (
				check([0x6D, 0x69, 0x6D, 0x65, 0x74, 0x79, 0x70, 0x65, 0x61, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x65, 0x70, 0x75, 0x62, 0x2B, 0x7A, 0x69, 0x70], {offset: 30})
			) {
				return {
					ext: 'epub',
					mime: 'application/epub+zip'
				};
			}

			// Assumes signed `.xpi` from addons.mozilla.org
			if (check(xpiZipFilename, {offset: 30})) {
				return {
					ext: 'xpi',
					mime: 'application/x-xpinstall'
				};
			}

			// https://github.com/file/file/blob/master/magic/Magdir/msooxml
			if (check(oxmlContentTypes, {offset: 30}) || check(oxmlRels, {offset: 30})) {
				const sliced = buf.subarray(4, 4 + 2000);
				const nextZipHeaderIndex = arr => arr.findIndex((el, i, arr) => arr[i] === 0x50 && arr[i + 1] === 0x4B && arr[i + 2] === 0x3 && arr[i + 3] === 0x4);
				const header2Pos = nextZipHeaderIndex(sliced);

				if (header2Pos !== -1) {
					const slicedAgain = buf.subarray(header2Pos + 8, header2Pos + 8 + 1000);
					const header3Pos = nextZipHeaderIndex(slicedAgain);

					if (header3Pos !== -1) {
						const offset = 8 + header2Pos + header3Pos + 30;

						if (check(toBytes('word/'), {offset})) {
							return {
								ext: 'docx',
								mime: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
							};
						}

						if (check(toBytes('ppt/'), {offset})) {
							return {
								ext: 'pptx',
								mime: 'application/vnd.openxmlformats-officedocument.presentationml.presentation'
							};
						}

						if (check(toBytes('xl/'), {offset})) {
							return {
								ext: 'xlsx',
								mime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
							};
						}
					}
				}
			}
		}

		if (
			check([0x50, 0x4B]) &&
			(buf[2] === 0x3 || buf[2] === 0x5 || buf[2] === 0x7) &&
			(buf[3] === 0x4 || buf[3] === 0x6 || buf[3] === 0x8)
		) {
			return {
				ext: 'zip',
				mime: 'application/zip'
			};
		}

		if (check([0x75, 0x73, 0x74, 0x61, 0x72], {offset: 257})) {
			return {
				ext: 'tar',
				mime: 'application/x-tar'
			};
		}

		if (
			check([0x52, 0x61, 0x72, 0x21, 0x1A, 0x7]) &&
			(buf[6] === 0x0 || buf[6] === 0x1)
		) {
			return {
				ext: 'rar',
				mime: 'application/x-rar-compressed'
			};
		}

		if (check([0x1F, 0x8B, 0x8])) {
			return {
				ext: 'gz',
				mime: 'application/gzip'
			};
		}

		if (check([0x42, 0x5A, 0x68])) {
			return {
				ext: 'bz2',
				mime: 'application/x-bzip2'
			};
		}

		if (check([0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C])) {
			return {
				ext: '7z',
				mime: 'application/x-7z-compressed'
			};
		}

		if (check([0x78, 0x01])) {
			return {
				ext: 'dmg',
				mime: 'application/x-apple-diskimage'
			};
		}

		if (check([0x33, 0x67, 0x70, 0x35]) || // 3gp5
			(
				check([0x0, 0x0, 0x0]) && check([0x66, 0x74, 0x79, 0x70], {offset: 4}) &&
					(
						check([0x6D, 0x70, 0x34, 0x31], {offset: 8}) || // MP41
						check([0x6D, 0x70, 0x34, 0x32], {offset: 8}) || // MP42
						check([0x69, 0x73, 0x6F, 0x6D], {offset: 8}) || // ISOM
						check([0x69, 0x73, 0x6F, 0x32], {offset: 8}) || // ISO2
						check([0x6D, 0x6D, 0x70, 0x34], {offset: 8}) || // MMP4
						check([0x4D, 0x34, 0x56], {offset: 8}) || // M4V
						check([0x64, 0x61, 0x73, 0x68], {offset: 8}) // DASH
					)
			)) {
			return {
				ext: 'mp4',
				mime: 'video/mp4'
			};
		}

		if (check([0x4D, 0x54, 0x68, 0x64])) {
			return {
				ext: 'mid',
				mime: 'audio/midi'
			};
		}

		// https://github.com/threatstack/libmagic/blob/master/magic/Magdir/matroska
		if (check([0x1A, 0x45, 0xDF, 0xA3])) {
			const sliced = buf.subarray(4, 4 + 4096);
			const idPos = sliced.findIndex((el, i, arr) => arr[i] === 0x42 && arr[i + 1] === 0x82);

			if (idPos !== -1) {
				const docTypePos = idPos + 3;
				const findDocType = type => Array.from(type).every((c, i) => sliced[docTypePos + i] === c.charCodeAt(0));

				if (findDocType('matroska')) {
					return {
						ext: 'mkv',
						mime: 'video/x-matroska'
					};
				}

				if (findDocType('webm')) {
					return {
						ext: 'webm',
						mime: 'video/webm'
					};
				}
			}
		}

		if (check([0x0, 0x0, 0x0, 0x14, 0x66, 0x74, 0x79, 0x70, 0x71, 0x74, 0x20, 0x20]) ||
			check([0x66, 0x72, 0x65, 0x65], {offset: 4}) ||
			check([0x66, 0x74, 0x79, 0x70, 0x71, 0x74, 0x20, 0x20], {offset: 4}) ||
			check([0x6D, 0x64, 0x61, 0x74], {offset: 4}) || // MJPEG
			check([0x77, 0x69, 0x64, 0x65], {offset: 4})) {
			return {
				ext: 'mov',
				mime: 'video/quicktime'
			};
		}

		if (
			check([0x52, 0x49, 0x46, 0x46]) &&
			check([0x41, 0x56, 0x49], {offset: 8})
		) {
			return {
				ext: 'avi',
				mime: 'video/x-msvideo'
			};
		}

		if (check([0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xA6, 0xD9])) {
			return {
				ext: 'wmv',
				mime: 'video/x-ms-wmv'
			};
		}

		if (check([0x0, 0x0, 0x1, 0xBA])) {
			return {
				ext: 'mpg',
				mime: 'video/mpeg'
			};
		}

		// Check for MP3 header at different starting offsets
		for (let start = 0; start < 2 && start < (buf.length - 16); start++) {
			if (
				check([0x49, 0x44, 0x33], {offset: start}) || // ID3 header
				check([0xFF, 0xE2], {offset: start, mask: [0xFF, 0xE2]}) // MPEG 1 or 2 Layer 3 header
			) {
				return {
					ext: 'mp3',
					mime: 'audio/mpeg'
				};
			}
		}

		if (
			check([0x66, 0x74, 0x79, 0x70, 0x4D, 0x34, 0x41], {offset: 4}) ||
			check([0x4D, 0x34, 0x41, 0x20])
		) {
			return {
				ext: 'm4a',
				mime: 'audio/m4a'
			};
		}

		// Needs to be before `ogg` check
		if (check([0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64], {offset: 28})) {
			return {
				ext: 'opus',
				mime: 'audio/opus'
			};
		}

		if (check([0x4F, 0x67, 0x67, 0x53])) {
			return {
				ext: 'ogg',
				mime: 'audio/ogg'
			};
		}

		if (check([0x66, 0x4C, 0x61, 0x43])) {
			return {
				ext: 'flac',
				mime: 'audio/x-flac'
			};
		}

		if (
			check([0x52, 0x49, 0x46, 0x46]) &&
			check([0x57, 0x41, 0x56, 0x45], {offset: 8})
		) {
			return {
				ext: 'wav',
				mime: 'audio/x-wav'
			};
		}

		if (check([0x23, 0x21, 0x41, 0x4D, 0x52, 0x0A])) {
			return {
				ext: 'amr',
				mime: 'audio/amr'
			};
		}

		if (check([0x25, 0x50, 0x44, 0x46])) {
			return {
				ext: 'pdf',
				mime: 'application/pdf'
			};
		}

		if (check([0x4D, 0x5A])) {
			return {
				ext: 'exe',
				mime: 'application/x-msdownload'
			};
		}

		if (
			(buf[0] === 0x43 || buf[0] === 0x46) &&
			check([0x57, 0x53], {offset: 1})
		) {
			return {
				ext: 'swf',
				mime: 'application/x-shockwave-flash'
			};
		}

		if (check([0x7B, 0x5C, 0x72, 0x74, 0x66])) {
			return {
				ext: 'rtf',
				mime: 'application/rtf'
			};
		}

		if (check([0x00, 0x61, 0x73, 0x6D])) {
			return {
				ext: 'wasm',
				mime: 'application/wasm'
			};
		}

		if (
			check([0x77, 0x4F, 0x46, 0x46]) &&
			(
				check([0x00, 0x01, 0x00, 0x00], {offset: 4}) ||
				check([0x4F, 0x54, 0x54, 0x4F], {offset: 4})
			)
		) {
			return {
				ext: 'woff',
				mime: 'font/woff'
			};
		}

		if (
			check([0x77, 0x4F, 0x46, 0x32]) &&
			(
				check([0x00, 0x01, 0x00, 0x00], {offset: 4}) ||
				check([0x4F, 0x54, 0x54, 0x4F], {offset: 4})
			)
		) {
			return {
				ext: 'woff2',
				mime: 'font/woff2'
			};
		}

		if (
			check([0x4C, 0x50], {offset: 34}) &&
			(
				check([0x00, 0x00, 0x01], {offset: 8}) ||
				check([0x01, 0x00, 0x02], {offset: 8}) ||
				check([0x02, 0x00, 0x02], {offset: 8})
			)
		) {
			return {
				ext: 'eot',
				mime: 'application/octet-stream'
			};
		}

		if (check([0x00, 0x01, 0x00, 0x00, 0x00])) {
			return {
				ext: 'ttf',
				mime: 'font/ttf'
			};
		}

		if (check([0x4F, 0x54, 0x54, 0x4F, 0x00])) {
			return {
				ext: 'otf',
				mime: 'font/otf'
			};
		}

		if (check([0x00, 0x00, 0x01, 0x00])) {
			return {
				ext: 'ico',
				mime: 'image/x-icon'
			};
		}

		if (check([0x46, 0x4C, 0x56, 0x01])) {
			return {
				ext: 'flv',
				mime: 'video/x-flv'
			};
		}

		if (check([0x25, 0x21])) {
			return {
				ext: 'ps',
				mime: 'application/postscript'
			};
		}

		if (check([0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00])) {
			return {
				ext: 'xz',
				mime: 'application/x-xz'
			};
		}

		if (check([0x53, 0x51, 0x4C, 0x69])) {
			return {
				ext: 'sqlite',
				mime: 'application/x-sqlite3'
			};
		}

		if (check([0x4E, 0x45, 0x53, 0x1A])) {
			return {
				ext: 'nes',
				mime: 'application/x-nintendo-nes-rom'
			};
		}

		if (check([0x43, 0x72, 0x32, 0x34])) {
			return {
				ext: 'crx',
				mime: 'application/x-google-chrome-extension'
			};
		}

		if (
			check([0x4D, 0x53, 0x43, 0x46]) ||
			check([0x49, 0x53, 0x63, 0x28])
		) {
			return {
				ext: 'cab',
				mime: 'application/vnd.ms-cab-compressed'
			};
		}

		// Needs to be before `ar` check
		if (check([0x21, 0x3C, 0x61, 0x72, 0x63, 0x68, 0x3E, 0x0A, 0x64, 0x65, 0x62, 0x69, 0x61, 0x6E, 0x2D, 0x62, 0x69, 0x6E, 0x61, 0x72, 0x79])) {
			return {
				ext: 'deb',
				mime: 'application/x-deb'
			};
		}

		if (check([0x21, 0x3C, 0x61, 0x72, 0x63, 0x68, 0x3E])) {
			return {
				ext: 'ar',
				mime: 'application/x-unix-archive'
			};
		}

		if (check([0xED, 0xAB, 0xEE, 0xDB])) {
			return {
				ext: 'rpm',
				mime: 'application/x-rpm'
			};
		}

		if (
			check([0x1F, 0xA0]) ||
			check([0x1F, 0x9D])
		) {
			return {
				ext: 'Z',
				mime: 'application/x-compress'
			};
		}

		if (check([0x4C, 0x5A, 0x49, 0x50])) {
			return {
				ext: 'lz',
				mime: 'application/x-lzip'
			};
		}

		if (check([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1])) {
			return {
				ext: 'msi',
				mime: 'application/x-msi'
			};
		}

		if (check([0x06, 0x0E, 0x2B, 0x34, 0x02, 0x05, 0x01, 0x01, 0x0D, 0x01, 0x02, 0x01, 0x01, 0x02])) {
			return {
				ext: 'mxf',
				mime: 'application/mxf'
			};
		}

		if (check([0x47], {offset: 4}) && (check([0x47], {offset: 192}) || check([0x47], {offset: 196}))) {
			return {
				ext: 'mts',
				mime: 'video/mp2t'
			};
		}

		if (check([0x42, 0x4C, 0x45, 0x4E, 0x44, 0x45, 0x52])) {
			return {
				ext: 'blend',
				mime: 'application/x-blender'
			};
		}

		if (check([0x42, 0x50, 0x47, 0xFB])) {
			return {
				ext: 'bpg',
				mime: 'image/bpg'
			};
		}

		return null;
	};
	return fileType$1;
}

/*
node-bzip - a pure-javascript Node.JS module for decoding bzip2 data

Copyright (C) 2012 Eli Skeggs

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Adapted from bzip2.js, copyright 2011 antimatter15 (antimatter15@gmail.com).

Based on micro-bunzip by Rob Landley (rob@landley.net).

Based on bzip2 decompression code by Julian R Seward (jseward@acm.org),
which also acknowledges contributions by Mike Burrows, David Wheeler,
Peter Fenwick, Alistair Moffat, Radford Neal, Ian H. Witten,
Robert Sedgewick, and Jon L. Bentley.
*/

var bitreader;
var hasRequiredBitreader;

function requireBitreader () {
	if (hasRequiredBitreader) return bitreader;
	hasRequiredBitreader = 1;
	var BITMASK = [0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF];

	// offset in bytes
	var BitReader = function(stream) {
	  this.stream = stream;
	  this.bitOffset = 0;
	  this.curByte = 0;
	  this.hasByte = false;
	};

	BitReader.prototype._ensureByte = function() {
	  if (!this.hasByte) {
	    this.curByte = this.stream.readByte();
	    this.hasByte = true;
	  }
	};

	// reads bits from the buffer
	BitReader.prototype.read = function(bits) {
	  var result = 0;
	  while (bits > 0) {
	    this._ensureByte();
	    var remaining = 8 - this.bitOffset;
	    // if we're in a byte
	    if (bits >= remaining) {
	      result <<= remaining;
	      result |= BITMASK[remaining] & this.curByte;
	      this.hasByte = false;
	      this.bitOffset = 0;
	      bits -= remaining;
	    } else {
	      result <<= bits;
	      var shift = remaining - bits;
	      result |= (this.curByte & (BITMASK[bits] << shift)) >> shift;
	      this.bitOffset += bits;
	      bits = 0;
	    }
	  }
	  return result;
	};

	// seek to an arbitrary point in the buffer (expressed in bits)
	BitReader.prototype.seek = function(pos) {
	  var n_bit = pos % 8;
	  var n_byte = (pos - n_bit) / 8;
	  this.bitOffset = n_bit;
	  this.stream.seek(n_byte);
	  this.hasByte = false;
	};

	// reads 6 bytes worth of data using the read method
	BitReader.prototype.pi = function() {
	  var buf = new Buffer(6), i;
	  for (i = 0; i < buf.length; i++) {
	    buf[i] = this.read(8);
	  }
	  return buf.toString('hex');
	};

	bitreader = BitReader;
	return bitreader;
}

/* very simple input/output stream interface */

var stream;
var hasRequiredStream;

function requireStream () {
	if (hasRequiredStream) return stream;
	hasRequiredStream = 1;
	var Stream = function() {
	};

	// input streams //////////////
	/** Returns the next byte, or -1 for EOF. */
	Stream.prototype.readByte = function() {
	  throw new Error("abstract method readByte() not implemented");
	};
	/** Attempts to fill the buffer; returns number of bytes read, or
	 *  -1 for EOF. */
	Stream.prototype.read = function(buffer, bufOffset, length) {
	  var bytesRead = 0;
	  while (bytesRead < length) {
	    var c = this.readByte();
	    if (c < 0) { // EOF
	      return (bytesRead===0) ? -1 : bytesRead;
	    }
	    buffer[bufOffset++] = c;
	    bytesRead++;
	  }
	  return bytesRead;
	};
	Stream.prototype.seek = function(new_pos) {
	  throw new Error("abstract method seek() not implemented");
	};

	// output streams ///////////
	Stream.prototype.writeByte = function(_byte) {
	  throw new Error("abstract method readByte() not implemented");
	};
	Stream.prototype.write = function(buffer, bufOffset, length) {
	  var i;
	  for (i=0; i<length; i++) {
	    this.writeByte(buffer[bufOffset++]);
	  }
	  return length;
	};
	Stream.prototype.flush = function() {
	};

	stream = Stream;
	return stream;
}

/* CRC32, used in Bzip2 implementation.
 * This is a port of CRC32.java from the jbzip2 implementation at
 *   https://code.google.com/p/jbzip2
 * which is:
 *   Copyright (c) 2011 Matthew Francis
 *
 *   Permission is hereby granted, free of charge, to any person
 *   obtaining a copy of this software and associated documentation
 *   files (the "Software"), to deal in the Software without
 *   restriction, including without limitation the rights to use,
 *   copy, modify, merge, publish, distribute, sublicense, and/or sell
 *   copies of the Software, and to permit persons to whom the
 *   Software is furnished to do so, subject to the following
 *   conditions:
 *
 *   The above copyright notice and this permission notice shall be
 *   included in all copies or substantial portions of the Software.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 *   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 *   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 *   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 *   OTHER DEALINGS IN THE SOFTWARE.
 * This JavaScript implementation is:
 *   Copyright (c) 2013 C. Scott Ananian
 * with the same licensing terms as Matthew Francis' original implementation.
 */

var crc32;
var hasRequiredCrc32;

function requireCrc32 () {
	if (hasRequiredCrc32) return crc32;
	hasRequiredCrc32 = 1;
	crc32 = (function() {

	  /**
	   * A static CRC lookup table
	   */
	  var crc32Lookup = new Uint32Array([
	    0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
	    0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
	    0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
	    0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
	    0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039, 0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
	    0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
	    0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
	    0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
	    0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
	    0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
	    0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
	    0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
	    0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
	    0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
	    0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
	    0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
	    0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
	    0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
	    0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
	    0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff, 0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
	    0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
	    0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
	    0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
	    0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
	    0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
	    0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
	    0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
	    0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
	    0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
	    0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
	    0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
	    0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
	  ]);

	  var CRC32 = function() {
	    /**
	     * The current CRC
	     */
	    var crc = 0xffffffff;

	    /**
	     * @return The current CRC
	     */
	    this.getCRC = function() {
	      return (~crc) >>> 0; // return an unsigned value
	    };

	    /**
	     * Update the CRC with a single byte
	     * @param value The value to update the CRC with
	     */
	    this.updateCRC = function(value) {
	      crc = (crc << 8) ^ crc32Lookup[((crc >>> 24) ^ value) & 0xff];
	    };

	    /**
	     * Update the CRC with a sequence of identical bytes
	     * @param value The value to update the CRC with
	     * @param count The number of bytes
	     */
	    this.updateCRCRun = function(value, count) {
	      while (count-- > 0) {
	        crc = (crc << 8) ^ crc32Lookup[((crc >>> 24) ^ value) & 0xff];
	      }
	    };
	  };
	  return CRC32;
	})();
	return crc32;
}

var name = "seek-bzip";
var version = "1.0.6";
var contributors = [
	"C. Scott Ananian (http://cscott.net)",
	"Eli Skeggs",
	"Kevin Kwok",
	"Rob Landley (http://landley.net)"
];
var description = "a pure-JavaScript Node.JS module for random-access decoding bzip2 data";
var main = "./lib/index.js";
var repository = {
	type: "git",
	url: "https://github.com/cscott/seek-bzip.git"
};
var license = "MIT";
var bin = {
	"seek-bunzip": "./bin/seek-bunzip",
	"seek-table": "./bin/seek-bzip-table"
};
var directories = {
	test: "test"
};
var dependencies = {
	commander: "^2.8.1"
};
var devDependencies = {
	fibers: "~1.0.6",
	mocha: "~2.2.5"
};
var scripts = {
	test: "mocha"
};
var require$$3 = {
	name: name,
	version: version,
	contributors: contributors,
	description: description,
	main: main,
	repository: repository,
	license: license,
	bin: bin,
	directories: directories,
	dependencies: dependencies,
	devDependencies: devDependencies,
	scripts: scripts
};

/*
seek-bzip - a pure-javascript module for seeking within bzip2 data

Copyright (C) 2013 C. Scott Ananian
Copyright (C) 2012 Eli Skeggs
Copyright (C) 2011 Kevin Kwok

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Adapted from node-bzip, copyright 2012 Eli Skeggs.
Adapted from bzip2.js, copyright 2011 Kevin Kwok (antimatter15@gmail.com).

Based on micro-bunzip by Rob Landley (rob@landley.net).

Based on bzip2 decompression code by Julian R Seward (jseward@acm.org),
which also acknowledges contributions by Mike Burrows, David Wheeler,
Peter Fenwick, Alistair Moffat, Radford Neal, Ian H. Witten,
Robert Sedgewick, and Jon L. Bentley.
*/

var lib;
var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;
	var BitReader = requireBitreader();
	var Stream = requireStream();
	var CRC32 = requireCrc32();
	var pjson = require$$3;

	var MAX_HUFCODE_BITS = 20;
	var MAX_SYMBOLS = 258;
	var SYMBOL_RUNA = 0;
	var SYMBOL_RUNB = 1;
	var MIN_GROUPS = 2;
	var MAX_GROUPS = 6;
	var GROUP_SIZE = 50;

	var WHOLEPI = "314159265359";
	var SQRTPI = "177245385090";

	var mtf = function(array, index) {
	  var src = array[index], i;
	  for (i = index; i > 0; i--) {
	    array[i] = array[i-1];
	  }
	  array[0] = src;
	  return src;
	};

	var Err = {
	  OK: 0,
	  LAST_BLOCK: -1,
	  NOT_BZIP_DATA: -2,
	  UNEXPECTED_INPUT_EOF: -3,
	  UNEXPECTED_OUTPUT_EOF: -4,
	  DATA_ERROR: -5,
	  OUT_OF_MEMORY: -6,
	  OBSOLETE_INPUT: -7,
	  END_OF_BLOCK: -8
	};
	var ErrorMessages = {};
	ErrorMessages[Err.LAST_BLOCK] =            "Bad file checksum";
	ErrorMessages[Err.NOT_BZIP_DATA] =         "Not bzip data";
	ErrorMessages[Err.UNEXPECTED_INPUT_EOF] =  "Unexpected input EOF";
	ErrorMessages[Err.UNEXPECTED_OUTPUT_EOF] = "Unexpected output EOF";
	ErrorMessages[Err.DATA_ERROR] =            "Data error";
	ErrorMessages[Err.OUT_OF_MEMORY] =         "Out of memory";
	ErrorMessages[Err.OBSOLETE_INPUT] = "Obsolete (pre 0.9.5) bzip format not supported.";

	var _throw = function(status, optDetail) {
	  var msg = ErrorMessages[status] || 'unknown error';
	  if (optDetail) { msg += ': '+optDetail; }
	  var e = new TypeError(msg);
	  e.errorCode = status;
	  throw e;
	};

	var Bunzip = function(inputStream, outputStream) {
	  this.writePos = this.writeCurrent = this.writeCount = 0;

	  this._start_bunzip(inputStream, outputStream);
	};
	Bunzip.prototype._init_block = function() {
	  var moreBlocks = this._get_next_block();
	  if ( !moreBlocks ) {
	    this.writeCount = -1;
	    return false; /* no more blocks */
	  }
	  this.blockCRC = new CRC32();
	  return true;
	};
	/* XXX micro-bunzip uses (inputStream, inputBuffer, len) as arguments */
	Bunzip.prototype._start_bunzip = function(inputStream, outputStream) {
	  /* Ensure that file starts with "BZh['1'-'9']." */
	  var buf = new Buffer(4);
	  if (inputStream.read(buf, 0, 4) !== 4 ||
	      String.fromCharCode(buf[0], buf[1], buf[2]) !== 'BZh')
	    _throw(Err.NOT_BZIP_DATA, 'bad magic');

	  var level = buf[3] - 0x30;
	  if (level < 1 || level > 9)
	    _throw(Err.NOT_BZIP_DATA, 'level out of range');

	  this.reader = new BitReader(inputStream);

	  /* Fourth byte (ascii '1'-'9'), indicates block size in units of 100k of
	     uncompressed data.  Allocate intermediate buffer for block. */
	  this.dbufSize = 100000 * level;
	  this.nextoutput = 0;
	  this.outputStream = outputStream;
	  this.streamCRC = 0;
	};
	Bunzip.prototype._get_next_block = function() {
	  var i, j, k;
	  var reader = this.reader;
	  // this is get_next_block() function from micro-bunzip:
	  /* Read in header signature and CRC, then validate signature.
	     (last block signature means CRC is for whole file, return now) */
	  var h = reader.pi();
	  if (h === SQRTPI) { // last block
	    return false; /* no more blocks */
	  }
	  if (h !== WHOLEPI)
	    _throw(Err.NOT_BZIP_DATA);
	  this.targetBlockCRC = reader.read(32) >>> 0; // (convert to unsigned)
	  this.streamCRC = (this.targetBlockCRC ^
	                    ((this.streamCRC << 1) | (this.streamCRC>>>31))) >>> 0;
	  /* We can add support for blockRandomised if anybody complains.  There was
	     some code for this in busybox 1.0.0-pre3, but nobody ever noticed that
	     it didn't actually work. */
	  if (reader.read(1))
	    _throw(Err.OBSOLETE_INPUT);
	  var origPointer = reader.read(24);
	  if (origPointer > this.dbufSize)
	    _throw(Err.DATA_ERROR, 'initial position out of bounds');
	  /* mapping table: if some byte values are never used (encoding things
	     like ascii text), the compression code removes the gaps to have fewer
	     symbols to deal with, and writes a sparse bitfield indicating which
	     values were present.  We make a translation table to convert the symbols
	     back to the corresponding bytes. */
	  var t = reader.read(16);
	  var symToByte = new Buffer(256), symTotal = 0;
	  for (i = 0; i < 16; i++) {
	    if (t & (1 << (0xF - i))) {
	      var o = i * 16;
	      k = reader.read(16);
	      for (j = 0; j < 16; j++)
	        if (k & (1 << (0xF - j)))
	          symToByte[symTotal++] = o + j;
	    }
	  }

	  /* How many different huffman coding groups does this block use? */
	  var groupCount = reader.read(3);
	  if (groupCount < MIN_GROUPS || groupCount > MAX_GROUPS)
	    _throw(Err.DATA_ERROR);
	  /* nSelectors: Every GROUP_SIZE many symbols we select a new huffman coding
	     group.  Read in the group selector list, which is stored as MTF encoded
	     bit runs.  (MTF=Move To Front, as each value is used it's moved to the
	     start of the list.) */
	  var nSelectors = reader.read(15);
	  if (nSelectors === 0)
	    _throw(Err.DATA_ERROR);

	  var mtfSymbol = new Buffer(256);
	  for (i = 0; i < groupCount; i++)
	    mtfSymbol[i] = i;

	  var selectors = new Buffer(nSelectors); // was 32768...

	  for (i = 0; i < nSelectors; i++) {
	    /* Get next value */
	    for (j = 0; reader.read(1); j++)
	      if (j >= groupCount) _throw(Err.DATA_ERROR);
	    /* Decode MTF to get the next selector */
	    selectors[i] = mtf(mtfSymbol, j);
	  }

	  /* Read the huffman coding tables for each group, which code for symTotal
	     literal symbols, plus two run symbols (RUNA, RUNB) */
	  var symCount = symTotal + 2;
	  var groups = [], hufGroup;
	  for (j = 0; j < groupCount; j++) {
	    var length = new Buffer(symCount), temp = new Uint16Array(MAX_HUFCODE_BITS + 1);
	    /* Read huffman code lengths for each symbol.  They're stored in
	       a way similar to mtf; record a starting value for the first symbol,
	       and an offset from the previous value for everys symbol after that. */
	    t = reader.read(5); // lengths
	    for (i = 0; i < symCount; i++) {
	      for (;;) {
	        if (t < 1 || t > MAX_HUFCODE_BITS) _throw(Err.DATA_ERROR);
	        /* If first bit is 0, stop.  Else second bit indicates whether
	           to increment or decrement the value. */
	        if(!reader.read(1))
	          break;
	        if(!reader.read(1))
	          t++;
	        else
	          t--;
	      }
	      length[i] = t;
	    }

	    /* Find largest and smallest lengths in this group */
	    var minLen,  maxLen;
	    minLen = maxLen = length[0];
	    for (i = 1; i < symCount; i++) {
	      if (length[i] > maxLen)
	        maxLen = length[i];
	      else if (length[i] < minLen)
	        minLen = length[i];
	    }

	    /* Calculate permute[], base[], and limit[] tables from length[].
	     *
	     * permute[] is the lookup table for converting huffman coded symbols
	     * into decoded symbols.  base[] is the amount to subtract from the
	     * value of a huffman symbol of a given length when using permute[].
	     *
	     * limit[] indicates the largest numerical value a symbol with a given
	     * number of bits can have.  This is how the huffman codes can vary in
	     * length: each code with a value>limit[length] needs another bit.
	     */
	    hufGroup = {};
	    groups.push(hufGroup);
	    hufGroup.permute = new Uint16Array(MAX_SYMBOLS);
	    hufGroup.limit = new Uint32Array(MAX_HUFCODE_BITS + 2);
	    hufGroup.base = new Uint32Array(MAX_HUFCODE_BITS + 1);
	    hufGroup.minLen = minLen;
	    hufGroup.maxLen = maxLen;
	    /* Calculate permute[].  Concurently, initialize temp[] and limit[]. */
	    var pp = 0;
	    for (i = minLen; i <= maxLen; i++) {
	      temp[i] = hufGroup.limit[i] = 0;
	      for (t = 0; t < symCount; t++)
	        if (length[t] === i)
	          hufGroup.permute[pp++] = t;
	    }
	    /* Count symbols coded for at each bit length */
	    for (i = 0; i < symCount; i++)
	      temp[length[i]]++;
	    /* Calculate limit[] (the largest symbol-coding value at each bit
	     * length, which is (previous limit<<1)+symbols at this level), and
	     * base[] (number of symbols to ignore at each bit length, which is
	     * limit minus the cumulative count of symbols coded for already). */
	    pp = t = 0;
	    for (i = minLen; i < maxLen; i++) {
	      pp += temp[i];
	      /* We read the largest possible symbol size and then unget bits
	         after determining how many we need, and those extra bits could
	         be set to anything.  (They're noise from future symbols.)  At
	         each level we're really only interested in the first few bits,
	         so here we set all the trailing to-be-ignored bits to 1 so they
	         don't affect the value>limit[length] comparison. */
	      hufGroup.limit[i] = pp - 1;
	      pp <<= 1;
	      t += temp[i];
	      hufGroup.base[i + 1] = pp - t;
	    }
	    hufGroup.limit[maxLen + 1] = Number.MAX_VALUE; /* Sentinal value for reading next sym. */
	    hufGroup.limit[maxLen] = pp + temp[maxLen] - 1;
	    hufGroup.base[minLen] = 0;
	  }
	  /* We've finished reading and digesting the block header.  Now read this
	     block's huffman coded symbols from the file and undo the huffman coding
	     and run length encoding, saving the result into dbuf[dbufCount++]=uc */

	  /* Initialize symbol occurrence counters and symbol Move To Front table */
	  var byteCount = new Uint32Array(256);
	  for (i = 0; i < 256; i++)
	    mtfSymbol[i] = i;
	  /* Loop through compressed symbols. */
	  var runPos = 0, dbufCount = 0, selector = 0, uc;
	  var dbuf = this.dbuf = new Uint32Array(this.dbufSize);
	  symCount = 0;
	  for (;;) {
	    /* Determine which huffman coding group to use. */
	    if (!(symCount--)) {
	      symCount = GROUP_SIZE - 1;
	      if (selector >= nSelectors) { _throw(Err.DATA_ERROR); }
	      hufGroup = groups[selectors[selector++]];
	    }
	    /* Read next huffman-coded symbol. */
	    i = hufGroup.minLen;
	    j = reader.read(i);
	    for (;;i++) {
	      if (i > hufGroup.maxLen) { _throw(Err.DATA_ERROR); }
	      if (j <= hufGroup.limit[i])
	        break;
	      j = (j << 1) | reader.read(1);
	    }
	    /* Huffman decode value to get nextSym (with bounds checking) */
	    j -= hufGroup.base[i];
	    if (j < 0 || j >= MAX_SYMBOLS) { _throw(Err.DATA_ERROR); }
	    var nextSym = hufGroup.permute[j];
	    /* We have now decoded the symbol, which indicates either a new literal
	       byte, or a repeated run of the most recent literal byte.  First,
	       check if nextSym indicates a repeated run, and if so loop collecting
	       how many times to repeat the last literal. */
	    if (nextSym === SYMBOL_RUNA || nextSym === SYMBOL_RUNB) {
	      /* If this is the start of a new run, zero out counter */
	      if (!runPos){
	        runPos = 1;
	        t = 0;
	      }
	      /* Neat trick that saves 1 symbol: instead of or-ing 0 or 1 at
	         each bit position, add 1 or 2 instead.  For example,
	         1011 is 1<<0 + 1<<1 + 2<<2.  1010 is 2<<0 + 2<<1 + 1<<2.
	         You can make any bit pattern that way using 1 less symbol than
	         the basic or 0/1 method (except all bits 0, which would use no
	         symbols, but a run of length 0 doesn't mean anything in this
	         context).  Thus space is saved. */
	      if (nextSym === SYMBOL_RUNA)
	        t += runPos;
	      else
	        t += 2 * runPos;
	      runPos <<= 1;
	      continue;
	    }
	    /* When we hit the first non-run symbol after a run, we now know
	       how many times to repeat the last literal, so append that many
	       copies to our buffer of decoded symbols (dbuf) now.  (The last
	       literal used is the one at the head of the mtfSymbol array.) */
	    if (runPos){
	      runPos = 0;
	      if (dbufCount + t > this.dbufSize) { _throw(Err.DATA_ERROR); }
	      uc = symToByte[mtfSymbol[0]];
	      byteCount[uc] += t;
	      while (t--)
	        dbuf[dbufCount++] = uc;
	    }
	    /* Is this the terminating symbol? */
	    if (nextSym > symTotal)
	      break;
	    /* At this point, nextSym indicates a new literal character.  Subtract
	       one to get the position in the MTF array at which this literal is
	       currently to be found.  (Note that the result can't be -1 or 0,
	       because 0 and 1 are RUNA and RUNB.  But another instance of the
	       first symbol in the mtf array, position 0, would have been handled
	       as part of a run above.  Therefore 1 unused mtf position minus
	       2 non-literal nextSym values equals -1.) */
	    if (dbufCount >= this.dbufSize) { _throw(Err.DATA_ERROR); }
	    i = nextSym - 1;
	    uc = mtf(mtfSymbol, i);
	    uc = symToByte[uc];
	    /* We have our literal byte.  Save it into dbuf. */
	    byteCount[uc]++;
	    dbuf[dbufCount++] = uc;
	  }
	  /* At this point, we've read all the huffman-coded symbols (and repeated
	     runs) for this block from the input stream, and decoded them into the
	     intermediate buffer.  There are dbufCount many decoded bytes in dbuf[].
	     Now undo the Burrows-Wheeler transform on dbuf.
	     See http://dogma.net/markn/articles/bwt/bwt.htm
	  */
	  if (origPointer < 0 || origPointer >= dbufCount) { _throw(Err.DATA_ERROR); }
	  /* Turn byteCount into cumulative occurrence counts of 0 to n-1. */
	  j = 0;
	  for (i = 0; i < 256; i++) {
	    k = j + byteCount[i];
	    byteCount[i] = j;
	    j = k;
	  }
	  /* Figure out what order dbuf would be in if we sorted it. */
	  for (i = 0; i < dbufCount; i++) {
	    uc = dbuf[i] & 0xff;
	    dbuf[byteCount[uc]] |= (i << 8);
	    byteCount[uc]++;
	  }
	  /* Decode first byte by hand to initialize "previous" byte.  Note that it
	     doesn't get output, and if the first three characters are identical
	     it doesn't qualify as a run (hence writeRunCountdown=5). */
	  var pos = 0, current = 0, run = 0;
	  if (dbufCount) {
	    pos = dbuf[origPointer];
	    current = (pos & 0xff);
	    pos >>= 8;
	    run = -1;
	  }
	  this.writePos = pos;
	  this.writeCurrent = current;
	  this.writeCount = dbufCount;
	  this.writeRun = run;

	  return true; /* more blocks to come */
	};
	/* Undo burrows-wheeler transform on intermediate buffer to produce output.
	   If start_bunzip was initialized with out_fd=-1, then up to len bytes of
	   data are written to outbuf.  Return value is number of bytes written or
	   error (all errors are negative numbers).  If out_fd!=-1, outbuf and len
	   are ignored, data is written to out_fd and return is RETVAL_OK or error.
	*/
	Bunzip.prototype._read_bunzip = function(outputBuffer, len) {
	    var copies, previous, outbyte;
	    /* james@jamestaylor.org: writeCount goes to -1 when the buffer is fully
	       decoded, which results in this returning RETVAL_LAST_BLOCK, also
	       equal to -1... Confusing, I'm returning 0 here to indicate no
	       bytes written into the buffer */
	  if (this.writeCount < 0) { return 0; }
	  var dbuf = this.dbuf, pos = this.writePos, current = this.writeCurrent;
	  var dbufCount = this.writeCount; this.outputsize;
	  var run = this.writeRun;

	  while (dbufCount) {
	    dbufCount--;
	    previous = current;
	    pos = dbuf[pos];
	    current = pos & 0xff;
	    pos >>= 8;
	    if (run++ === 3){
	      copies = current;
	      outbyte = previous;
	      current = -1;
	    } else {
	      copies = 1;
	      outbyte = current;
	    }
	    this.blockCRC.updateCRCRun(outbyte, copies);
	    while (copies--) {
	      this.outputStream.writeByte(outbyte);
	      this.nextoutput++;
	    }
	    if (current != previous)
	      run = 0;
	  }
	  this.writeCount = dbufCount;
	  // check CRC
	  if (this.blockCRC.getCRC() !== this.targetBlockCRC) {
	    _throw(Err.DATA_ERROR, "Bad block CRC "+
	           "(got "+this.blockCRC.getCRC().toString(16)+
	           " expected "+this.targetBlockCRC.toString(16)+")");
	  }
	  return this.nextoutput;
	};

	var coerceInputStream = function(input) {
	  if ('readByte' in input) { return input; }
	  var inputStream = new Stream();
	  inputStream.pos = 0;
	  inputStream.readByte = function() { return input[this.pos++]; };
	  inputStream.seek = function(pos) { this.pos = pos; };
	  inputStream.eof = function() { return this.pos >= input.length; };
	  return inputStream;
	};
	var coerceOutputStream = function(output) {
	  var outputStream = new Stream();
	  var resizeOk = true;
	  if (output) {
	    if (typeof(output)==='number') {
	      outputStream.buffer = new Buffer(output);
	      resizeOk = false;
	    } else if ('writeByte' in output) {
	      return output;
	    } else {
	      outputStream.buffer = output;
	      resizeOk = false;
	    }
	  } else {
	    outputStream.buffer = new Buffer(16384);
	  }
	  outputStream.pos = 0;
	  outputStream.writeByte = function(_byte) {
	    if (resizeOk && this.pos >= this.buffer.length) {
	      var newBuffer = new Buffer(this.buffer.length*2);
	      this.buffer.copy(newBuffer);
	      this.buffer = newBuffer;
	    }
	    this.buffer[this.pos++] = _byte;
	  };
	  outputStream.getBuffer = function() {
	    // trim buffer
	    if (this.pos !== this.buffer.length) {
	      if (!resizeOk)
	        throw new TypeError('outputsize does not match decoded input');
	      var newBuffer = new Buffer(this.pos);
	      this.buffer.copy(newBuffer, 0, 0, this.pos);
	      this.buffer = newBuffer;
	    }
	    return this.buffer;
	  };
	  outputStream._coerced = true;
	  return outputStream;
	};

	/* Static helper functions */
	Bunzip.Err = Err;
	// 'input' can be a stream or a buffer
	// 'output' can be a stream or a buffer or a number (buffer size)
	Bunzip.decode = function(input, output, multistream) {
	  // make a stream from a buffer, if necessary
	  var inputStream = coerceInputStream(input);
	  var outputStream = coerceOutputStream(output);

	  var bz = new Bunzip(inputStream, outputStream);
	  while (true) {
	    if ('eof' in inputStream && inputStream.eof()) break;
	    if (bz._init_block()) {
	      bz._read_bunzip();
	    } else {
	      var targetStreamCRC = bz.reader.read(32) >>> 0; // (convert to unsigned)
	      if (targetStreamCRC !== bz.streamCRC) {
	        _throw(Err.DATA_ERROR, "Bad stream CRC "+
	               "(got "+bz.streamCRC.toString(16)+
	               " expected "+targetStreamCRC.toString(16)+")");
	      }
	      if (multistream &&
	          'eof' in inputStream &&
	          !inputStream.eof()) {
	        // note that start_bunzip will also resync the bit reader to next byte
	        bz._start_bunzip(inputStream, outputStream);
	      } else break;
	    }
	  }
	  if ('getBuffer' in outputStream)
	    return outputStream.getBuffer();
	};
	Bunzip.decodeBlock = function(input, pos, output) {
	  // make a stream from a buffer, if necessary
	  var inputStream = coerceInputStream(input);
	  var outputStream = coerceOutputStream(output);
	  var bz = new Bunzip(inputStream, outputStream);
	  bz.reader.seek(pos);
	  /* Fill the decode buffer for the block */
	  var moreBlocks = bz._get_next_block();
	  if (moreBlocks) {
	    /* Init the CRC for writing */
	    bz.blockCRC = new CRC32();

	    /* Zero this so the current byte from before the seek is not written */
	    bz.writeCopies = 0;

	    /* Decompress the block and write to stdout */
	    bz._read_bunzip();
	    // XXX keep writing?
	  }
	  if ('getBuffer' in outputStream)
	    return outputStream.getBuffer();
	};
	/* Reads bzip2 file from stream or buffer `input`, and invoke
	 * `callback(position, size)` once for each bzip2 block,
	 * where position gives the starting position (in *bits*)
	 * and size gives uncompressed size of the block (in *bytes*). */
	Bunzip.table = function(input, callback, multistream) {
	  // make a stream from a buffer, if necessary
	  var inputStream = new Stream();
	  inputStream.delegate = coerceInputStream(input);
	  inputStream.pos = 0;
	  inputStream.readByte = function() {
	    this.pos++;
	    return this.delegate.readByte();
	  };
	  if (inputStream.delegate.eof) {
	    inputStream.eof = inputStream.delegate.eof.bind(inputStream.delegate);
	  }
	  var outputStream = new Stream();
	  outputStream.pos = 0;
	  outputStream.writeByte = function() { this.pos++; };

	  var bz = new Bunzip(inputStream, outputStream);
	  var blockSize = bz.dbufSize;
	  while (true) {
	    if ('eof' in inputStream && inputStream.eof()) break;

	    var position = inputStream.pos*8 + bz.reader.bitOffset;
	    if (bz.reader.hasByte) { position -= 8; }

	    if (bz._init_block()) {
	      var start = outputStream.pos;
	      bz._read_bunzip();
	      callback(position, outputStream.pos - start);
	    } else {
	      bz.reader.read(32); // (but we ignore the crc)
	      if (multistream &&
	          'eof' in inputStream &&
	          !inputStream.eof()) {
	        // note that start_bunzip will also resync the bit reader to next byte
	        bz._start_bunzip(inputStream, outputStream);
	        console.assert(bz.dbufSize === blockSize,
	                       "shouldn't change block size within multistream file");
	      } else break;
	    }
	  }
	};

	Bunzip.Stream = Stream;

	Bunzip.version = pjson.version;
	Bunzip.license = pjson.license;

	lib = Bunzip;
	return lib;
}

var through = {exports: {}};

var hasRequiredThrough;

function requireThrough () {
	if (hasRequiredThrough) return through.exports;
	hasRequiredThrough = 1;
	(function (module, exports) {
		var Stream = require$$0$6;

		// through
		//
		// a stream that does nothing but re-emit the input.
		// useful for aggregating a series of changing but not ending streams into one stream)

		module.exports = through;
		through.through = through;

		//create a readable writable stream.

		function through (write, end, opts) {
		  write = write || function (data) { this.queue(data); };
		  end = end || function () { this.queue(null); };

		  var ended = false, destroyed = false, buffer = [], _ended = false;
		  var stream = new Stream();
		  stream.readable = stream.writable = true;
		  stream.paused = false;

		//  stream.autoPause   = !(opts && opts.autoPause   === false)
		  stream.autoDestroy = !(opts && opts.autoDestroy === false);

		  stream.write = function (data) {
		    write.call(this, data);
		    return !stream.paused
		  };

		  function drain() {
		    while(buffer.length && !stream.paused) {
		      var data = buffer.shift();
		      if(null === data)
		        return stream.emit('end')
		      else
		        stream.emit('data', data);
		    }
		  }

		  stream.queue = stream.push = function (data) {
		//    console.error(ended)
		    if(_ended) return stream
		    if(data === null) _ended = true;
		    buffer.push(data);
		    drain();
		    return stream
		  };

		  //this will be registered as the first 'end' listener
		  //must call destroy next tick, to make sure we're after any
		  //stream piped from here.
		  //this is only a problem if end is not emitted synchronously.
		  //a nicer way to do this is to make sure this is the last listener for 'end'

		  stream.on('end', function () {
		    stream.readable = false;
		    if(!stream.writable && stream.autoDestroy)
		      process.nextTick(function () {
		        stream.destroy();
		      });
		  });

		  function _end () {
		    stream.writable = false;
		    end.call(stream);
		    if(!stream.readable && stream.autoDestroy)
		      stream.destroy();
		  }

		  stream.end = function (data) {
		    if(ended) return
		    ended = true;
		    if(arguments.length) stream.write(data);
		    _end(); // will emit or queue
		    return stream
		  };

		  stream.destroy = function () {
		    if(destroyed) return
		    destroyed = true;
		    ended = true;
		    buffer.length = 0;
		    stream.writable = stream.readable = false;
		    stream.emit('close');
		    return stream
		  };

		  stream.pause = function () {
		    if(stream.paused) return
		    stream.paused = true;
		    return stream
		  };

		  stream.resume = function () {
		    if(stream.paused) {
		      stream.paused = false;
		      stream.emit('resume');
		    }
		    drain();
		    //may have become paused again,
		    //as drain emits 'data'.
		    if(!stream.paused)
		      stream.emit('drain');
		    return stream
		  };
		  return stream
		} 
	} (through));
	return through.exports;
}

/* 
  bzip2.js - a small bzip2 decompression implementation
  
  Copyright 2011 by antimatter15 (antimatter15@gmail.com)
  
  Based on micro-bunzip by Rob Landley (rob@landley.net).

  Copyright (c) 2011 by antimatter15 (antimatter15@gmail.com).

  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  and/or sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included
  in all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
  THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

var bzip2_1;
var hasRequiredBzip2;

function requireBzip2 () {
	if (hasRequiredBzip2) return bzip2_1;
	hasRequiredBzip2 = 1;
	function Bzip2Error(message) {
	    this.name = 'Bzip2Error';
	    this.message = message;
	    this.stack = (new Error()).stack;
	}
	Bzip2Error.prototype = new Error;
	 
	var message = {
	    Error: function(message) {throw new Bzip2Error(message);}
	};

	var bzip2 = {};
	bzip2.Bzip2Error = Bzip2Error;

	bzip2.crcTable =
	[
	   0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,
	   0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
	   0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
	   0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
	   0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,
	   0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
	   0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,
	   0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
	   0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
	   0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
	   0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,
	   0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
	   0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,
	   0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
	   0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
	   0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
	   0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,
	   0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
	   0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
	   0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
	   0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
	   0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
	   0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,
	   0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
	   0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,
	   0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
	   0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
	   0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
	   0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
	   0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
	   0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,
	   0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
	   0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
	   0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
	   0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,
	   0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
	   0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,
	   0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
	   0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
	   0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
	   0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,
	   0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
	   0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,
	   0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
	   0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
	   0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
	   0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,
	   0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
	   0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
	   0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
	   0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
	   0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
	   0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,
	   0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
	   0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,
	   0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
	   0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
	   0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
	   0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
	   0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
	   0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,
	   0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
	   0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
	   0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
	];

	bzip2.array = function(bytes) {
	    var bit = 0, byte = 0;
	    var BITMASK = [0, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF ];
	    return function(n) {
	        var result = 0;
	        while(n > 0) {
	            var left = 8 - bit;
	            if (n >= left) {
	                result <<= left;
	                result |= (BITMASK[left] & bytes[byte++]);
	                bit = 0;
	                n -= left;
	            } else {
	                result <<= n;
	                result |= ((bytes[byte] & (BITMASK[n] << (8 - n - bit))) >> (8 - n - bit));
	                bit += n;
	                n = 0;
	            }
	        }
	        return result;
	    }
	};

	    
	bzip2.simple = function(srcbuffer, stream) {
	    var bits = bzip2.array(srcbuffer);
	    var size = bzip2.header(bits);
	    var ret = false;
	    var bufsize = 100000 * size;
	    var buf = new Int32Array(bufsize);
	    
	    do {
	        ret = bzip2.decompress(bits, stream, buf, bufsize);        
	    } while(!ret);
	};

	bzip2.header = function(bits) {
	    this.byteCount = new Int32Array(256);
	    this.symToByte = new Uint8Array(256);
	    this.mtfSymbol = new Int32Array(256);
	    this.selectors = new Uint8Array(0x8000);

	    if (bits(8*3) != 4348520) message.Error("No magic number found");

	    var i = bits(8) - 48;
	    if (i < 1 || i > 9) message.Error("Not a BZIP archive");
	    return i;
	};


	//takes a function for reading the block data (starting with 0x314159265359)
	//a block size (0-9) (optional, defaults to 9)
	//a length at which to stop decompressing and return the output
	bzip2.decompress = function(bits, stream, buf, bufsize, streamCRC) {
	    var MAX_HUFCODE_BITS = 20;
	    var MAX_SYMBOLS = 258;
	    var SYMBOL_RUNA = 0;
	    var SYMBOL_RUNB = 1;
	    var GROUP_SIZE = 50;
	    var crc = 0 ^ (-1);
	    
	    for(var h = '', i = 0; i < 6; i++) h += bits(8).toString(16);
	    if (h == "177245385090") {
	      var finalCRC = bits(32)|0;
	      if (finalCRC !== streamCRC) message.Error("Error in bzip2: crc32 do not match");
	      // align stream to byte
	      bits(null);
	      return null; // reset streamCRC for next call
	    }
	    if (h != "314159265359") message.Error("eek not valid bzip data");
	    var crcblock = bits(32)|0; // CRC code
	    if (bits(1)) message.Error("unsupported obsolete version");
	    var origPtr = bits(24);
	    if (origPtr > bufsize) message.Error("Initial position larger than buffer size");
	    var t = bits(16);
	    var symTotal = 0;
	    for (i = 0; i < 16; i++) {
	        if (t & (1 << (15 - i))) {
	            var k = bits(16);
	            for(j = 0; j < 16; j++) {
	                if (k & (1 << (15 - j))) {
	                    this.symToByte[symTotal++] = (16 * i) + j;
	                }
	            }
	        }
	    }

	    var groupCount = bits(3);
	    if (groupCount < 2 || groupCount > 6) message.Error("another error");
	    var nSelectors = bits(15);
	    if (nSelectors == 0) message.Error("meh");
	    for(var i = 0; i < groupCount; i++) this.mtfSymbol[i] = i;

	    for(var i = 0; i < nSelectors; i++) {
	        for(var j = 0; bits(1); j++) if (j >= groupCount) message.Error("whoops another error");
	        var uc = this.mtfSymbol[j];
	        for(var k = j-1; k>=0; k--) {
	            this.mtfSymbol[k+1] = this.mtfSymbol[k];
	        }
	        this.mtfSymbol[0] = uc;
	        this.selectors[i] = uc;
	    }

	    var symCount = symTotal + 2;
	    var groups = [];
	    var length = new Uint8Array(MAX_SYMBOLS),
	    temp = new Uint16Array(MAX_HUFCODE_BITS+1);

	    var hufGroup;

	    for(var j = 0; j < groupCount; j++) {
	        t = bits(5); //lengths
	        for(var i = 0; i < symCount; i++) {
	            while(true){
	                if (t < 1 || t > MAX_HUFCODE_BITS) message.Error("I gave up a while ago on writing error messages");
	                if (!bits(1)) break;
	                if (!bits(1)) t++;
	                else t--;
	            }
	            length[i] = t;
	        }
	        var  minLen,  maxLen;
	        minLen = maxLen = length[0];
	        for(var i = 1; i < symCount; i++) {
	            if (length[i] > maxLen) maxLen = length[i];
	            else if (length[i] < minLen) minLen = length[i];
	        }
	        hufGroup = groups[j] = {};
	        hufGroup.permute = new Int32Array(MAX_SYMBOLS);
	        hufGroup.limit = new Int32Array(MAX_HUFCODE_BITS + 1);
	        hufGroup.base = new Int32Array(MAX_HUFCODE_BITS + 1);

	        hufGroup.minLen = minLen;
	        hufGroup.maxLen = maxLen;
	        var base = hufGroup.base;
	        var limit = hufGroup.limit;
	        var pp = 0;
	        for(var i = minLen; i <= maxLen; i++)
	        for(var t = 0; t < symCount; t++)
	        if (length[t] == i) hufGroup.permute[pp++] = t;
	        for(i = minLen; i <= maxLen; i++) temp[i] = limit[i] = 0;
	        for(i = 0; i < symCount; i++) temp[length[i]]++;
	        pp = t = 0;
	        for(i = minLen; i < maxLen; i++) {
	            pp += temp[i];
	            limit[i] = pp - 1;
	            pp <<= 1;
	            base[i+1] = pp - (t += temp[i]);
	        }
	        limit[maxLen] = pp + temp[maxLen] - 1;
	        base[minLen] = 0;
	    }

	    for(var i = 0; i < 256; i++) { 
	        this.mtfSymbol[i] = i;
	        this.byteCount[i] = 0;
	    }
	    var runPos, count, symCount, selector;
	    runPos = count = symCount = selector = 0;    
	    while(true) {
	        if (!(symCount--)) {
	            symCount = GROUP_SIZE - 1;
	            if (selector >= nSelectors) message.Error("meow i'm a kitty, that's an error");
	            hufGroup = groups[this.selectors[selector++]];
	            base = hufGroup.base;
	            limit = hufGroup.limit;
	        }
	        i = hufGroup.minLen;
	        j = bits(i);
	        while(true) {
	            if (i > hufGroup.maxLen) message.Error("rawr i'm a dinosaur");
	            if (j <= limit[i]) break;
	            i++;
	            j = (j << 1) | bits(1);
	        }
	        j -= base[i];
	        if (j < 0 || j >= MAX_SYMBOLS) message.Error("moo i'm a cow");
	        var nextSym = hufGroup.permute[j];
	        if (nextSym == SYMBOL_RUNA || nextSym == SYMBOL_RUNB) {
	            if (!runPos){
	                runPos = 1;
	                t = 0;
	            }
	            if (nextSym == SYMBOL_RUNA) t += runPos;
	            else t += 2 * runPos;
	            runPos <<= 1;
	            continue;
	        }
	        if (runPos) {
	            runPos = 0;
	            if (count + t > bufsize) message.Error("Boom.");
	            uc = this.symToByte[this.mtfSymbol[0]];
	            this.byteCount[uc] += t;
	            while(t--) buf[count++] = uc;
	        }
	        if (nextSym > symTotal) break;
	        if (count >= bufsize) message.Error("I can't think of anything. Error");
	        i = nextSym - 1;
	        uc = this.mtfSymbol[i];
	        for(var k = i-1; k>=0; k--) {
	            this.mtfSymbol[k+1] = this.mtfSymbol[k];
	        }
	        this.mtfSymbol[0] = uc;
	        uc = this.symToByte[uc];
	        this.byteCount[uc]++;
	        buf[count++] = uc;
	    }
	    if (origPtr < 0 || origPtr >= count) message.Error("I'm a monkey and I'm throwing something at someone, namely you");
	    var j = 0;
	    for(var i = 0; i < 256; i++) {
	        k = j + this.byteCount[i];
	        this.byteCount[i] = j;
	        j = k;
	    }
	    for(var i = 0; i < count; i++) {
	        uc = buf[i] & 0xff;
	        buf[this.byteCount[uc]] |= (i << 8);
	        this.byteCount[uc]++;
	    }
	    var pos = 0, current = 0, run = 0;
	    if (count) {
	        pos = buf[origPtr];
	        current = (pos & 0xff);
	        pos >>= 8;
	        run = -1;
	    }
	    count = count;
	    var copies, previous, outbyte;
	    while(count) {
	        count--;
	        previous = current;
	        pos = buf[pos];
	        current = pos & 0xff;
	        pos >>= 8;
	        if (run++ == 3) {
	            copies = current;
	            outbyte = previous;
	            current = -1;
	        } else {
	            copies = 1;
	            outbyte = current;
	        }
	        while(copies--) {
	            crc = ((crc << 8) ^ this.crcTable[((crc>>24) ^ outbyte) & 0xFF])&0xFFFFFFFF; // crc32
	            stream(outbyte);
	        }
	        if (current != previous) run = 0;
	    }

	    crc = (crc ^ (-1)) >>> 0;
	    if ((crc|0) != (crcblock|0)) message.Error("Error in bzip2: crc32 do not match");
	    streamCRC = (crc ^ ((streamCRC << 1) | (streamCRC >>> 31))) & 0xFFFFFFFF;
	    return streamCRC;
	};

	bzip2_1 = bzip2;
	return bzip2_1;
}

var bit_iterator;
var hasRequiredBit_iterator;

function requireBit_iterator () {
	if (hasRequiredBit_iterator) return bit_iterator;
	hasRequiredBit_iterator = 1;
	var BITMASK = [0, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF];

	// returns a function that reads bits.
	// takes a buffer iterator as input
	bit_iterator = function bitIterator(nextBuffer) {
	    var bit = 0, byte = 0;
	    var bytes = nextBuffer();
	    var f = function(n) {
	        if (n === null && bit != 0) {  // align to byte boundary
	            bit = 0;
	            byte++;
	            return;
	        }
	        var result = 0;
	        while(n > 0) {
	            if (byte >= bytes.length) {
	                byte = 0;
	                bytes = nextBuffer();
	            }
	            var left = 8 - bit;
	            if (bit === 0 && n > 0)
	                f.bytesRead++;
	            if (n >= left) {
	                result <<= left;
	                result |= (BITMASK[left] & bytes[byte++]);
	                bit = 0;
	                n -= left;
	            } else {
	                result <<= n;
	                result |= ((bytes[byte] & (BITMASK[n] << (8 - n - bit))) >> (8 - n - bit));
	                bit += n;
	                n = 0;
	            }
	        }
	        return result;
	    };
	    f.bytesRead = 0;
	    return f;
	};
	return bit_iterator;
}

var unbzip2Stream_1;
var hasRequiredUnbzip2Stream;

function requireUnbzip2Stream () {
	if (hasRequiredUnbzip2Stream) return unbzip2Stream_1;
	hasRequiredUnbzip2Stream = 1;
	var through = requireThrough();
	var bz2 = requireBzip2();
	var bitIterator = requireBit_iterator();

	unbzip2Stream_1 = unbzip2Stream;

	function unbzip2Stream() {
	    var bufferQueue = [];
	    var hasBytes = 0;
	    var blockSize = 0;
	    var broken = false;
	    var bitReader = null;
	    var streamCRC = null;

	    function decompressBlock(push){
	        if(!blockSize){
	            blockSize = bz2.header(bitReader);
	            //console.error("got header of", blockSize);
	            streamCRC = 0;
	            return true;
	        }else {
	            var bufsize = 100000 * blockSize;
	            var buf = new Int32Array(bufsize);
	            
	            var chunk = [];
	            var f = function(b) {
	                chunk.push(b);
	            };

	            streamCRC = bz2.decompress(bitReader, f, buf, bufsize, streamCRC);
	            if (streamCRC === null) {
	                // reset for next bzip2 header
	                blockSize = 0;
	                return false;
	            }else {
	                //console.error('decompressed', chunk.length,'bytes');
	                push(Buffer.from(chunk));
	                return true;
	            }
	        }
	    }

	    var outlength = 0;
	    function decompressAndQueue(stream) {
	        if (broken) return;
	        try {
	            return decompressBlock(function(d) {
	                stream.queue(d);
	                if (d !== null) {
	                    //console.error('write at', outlength.toString(16));
	                    outlength += d.length;
	                } else {
	                    //console.error('written EOS');
	                }
	            });
	        } catch(e) {
	            //console.error(e);
	            stream.emit('error', e);
	            broken = true;
	            return false;
	        }
	    }

	    return through(
	        function write(data) {
	            //console.error('received', data.length,'bytes in', typeof data);
	            bufferQueue.push(data);
	            hasBytes += data.length;
	            if (bitReader === null) {
	                bitReader = bitIterator(function() {
	                    return bufferQueue.shift();
	                });
	            }
	            while (!broken && hasBytes - bitReader.bytesRead + 1 >= ((25000 + 100000 * blockSize) || 4)){
	                //console.error('decompressing with', hasBytes - bitReader.bytesRead + 1, 'bytes in buffer');
	                decompressAndQueue(this);
	            }
	        },
	        function end(x) {
	            //console.error(x,'last compressing with', hasBytes, 'bytes in buffer');
	            while (!broken && bitReader && hasBytes > bitReader.bytesRead){
	                decompressAndQueue(this);
	            }
	            if (!broken) {
	                if (streamCRC !== null)
	                    this.emit('error', new Error("input stream ended prematurely"));
	                this.queue(null);
	            }
	        }
	    );
	}
	return unbzip2Stream_1;
}

var decompressTarbz2;
var hasRequiredDecompressTarbz2;

function requireDecompressTarbz2 () {
	if (hasRequiredDecompressTarbz2) return decompressTarbz2;
	hasRequiredDecompressTarbz2 = 1;
	const decompressTar = requireDecompressTar();
	const fileType = requireFileType$1();
	const isStream = requireIsStream();
	const seekBzip = requireLib();
	const unbzip2Stream = requireUnbzip2Stream();

	decompressTarbz2 = () => input => {
		if (!Buffer.isBuffer(input) && !isStream(input)) {
			return Promise.reject(new TypeError(`Expected a Buffer or Stream, got ${typeof input}`));
		}

		if (Buffer.isBuffer(input) && (!fileType(input) || fileType(input).ext !== 'bz2')) {
			return Promise.resolve([]);
		}

		if (Buffer.isBuffer(input)) {
			return decompressTar()(seekBzip.decode(input));
		}

		return decompressTar()(input.pipe(unbzip2Stream()));
	};
	return decompressTarbz2;
}

var decompressTargz;
var hasRequiredDecompressTargz;

function requireDecompressTargz () {
	if (hasRequiredDecompressTargz) return decompressTargz;
	hasRequiredDecompressTargz = 1;
	const zlib = require$$5$1;
	const decompressTar = requireDecompressTar();
	const fileType = requireFileType$2();
	const isStream = requireIsStream();

	decompressTargz = () => input => {
		if (!Buffer.isBuffer(input) && !isStream(input)) {
			return Promise.reject(new TypeError(`Expected a Buffer or Stream, got ${typeof input}`));
		}

		if (Buffer.isBuffer(input) && (!fileType(input) || fileType(input).ext !== 'gz')) {
			return Promise.resolve([]);
		}

		const unzip = zlib.createGunzip();
		const result = decompressTar()(unzip);

		if (Buffer.isBuffer(input)) {
			unzip.end(input);
		} else {
			input.pipe(unzip);
		}

		return result;
	};
	return decompressTargz;
}

var fileType;
var hasRequiredFileType;

function requireFileType () {
	if (hasRequiredFileType) return fileType;
	hasRequiredFileType = 1;
	fileType = function (buf) {
		if (!(buf && buf.length > 1)) {
			return null;
		}

		if (buf[0] === 0xFF && buf[1] === 0xD8 && buf[2] === 0xFF) {
			return {
				ext: 'jpg',
				mime: 'image/jpeg'
			};
		}

		if (buf[0] === 0x89 && buf[1] === 0x50 && buf[2] === 0x4E && buf[3] === 0x47) {
			return {
				ext: 'png',
				mime: 'image/png'
			};
		}

		if (buf[0] === 0x47 && buf[1] === 0x49 && buf[2] === 0x46) {
			return {
				ext: 'gif',
				mime: 'image/gif'
			};
		}

		if (buf[8] === 0x57 && buf[9] === 0x45 && buf[10] === 0x42 && buf[11] === 0x50) {
			return {
				ext: 'webp',
				mime: 'image/webp'
			};
		}

		if (buf[0] === 0x46 && buf[1] === 0x4C && buf[2] === 0x49 && buf[3] === 0x46) {
			return {
				ext: 'flif',
				mime: 'image/flif'
			};
		}

		// needs to be before `tif` check
		if (((buf[0] === 0x49 && buf[1] === 0x49 && buf[2] === 0x2A && buf[3] === 0x0) || (buf[0] === 0x4D && buf[1] === 0x4D && buf[2] === 0x0 && buf[3] === 0x2A)) && buf[8] === 0x43 && buf[9] === 0x52) {
			return {
				ext: 'cr2',
				mime: 'image/x-canon-cr2'
			};
		}

		if ((buf[0] === 0x49 && buf[1] === 0x49 && buf[2] === 0x2A && buf[3] === 0x0) || (buf[0] === 0x4D && buf[1] === 0x4D && buf[2] === 0x0 && buf[3] === 0x2A)) {
			return {
				ext: 'tif',
				mime: 'image/tiff'
			};
		}

		if (buf[0] === 0x42 && buf[1] === 0x4D) {
			return {
				ext: 'bmp',
				mime: 'image/bmp'
			};
		}

		if (buf[0] === 0x49 && buf[1] === 0x49 && buf[2] === 0xBC) {
			return {
				ext: 'jxr',
				mime: 'image/vnd.ms-photo'
			};
		}

		if (buf[0] === 0x38 && buf[1] === 0x42 && buf[2] === 0x50 && buf[3] === 0x53) {
			return {
				ext: 'psd',
				mime: 'image/vnd.adobe.photoshop'
			};
		}

		// needs to be before `zip` check
		if (buf[0] === 0x50 && buf[1] === 0x4B && buf[2] === 0x3 && buf[3] === 0x4 && buf[30] === 0x6D && buf[31] === 0x69 && buf[32] === 0x6D && buf[33] === 0x65 && buf[34] === 0x74 && buf[35] === 0x79 && buf[36] === 0x70 && buf[37] === 0x65 && buf[38] === 0x61 && buf[39] === 0x70 && buf[40] === 0x70 && buf[41] === 0x6C && buf[42] === 0x69 && buf[43] === 0x63 && buf[44] === 0x61 && buf[45] === 0x74 && buf[46] === 0x69 && buf[47] === 0x6F && buf[48] === 0x6E && buf[49] === 0x2F && buf[50] === 0x65 && buf[51] === 0x70 && buf[52] === 0x75 && buf[53] === 0x62 && buf[54] === 0x2B && buf[55] === 0x7A && buf[56] === 0x69 && buf[57] === 0x70) {
			return {
				ext: 'epub',
				mime: 'application/epub+zip'
			};
		}

		// needs to be before `zip` check
		// assumes signed .xpi from addons.mozilla.org
		if (buf[0] === 0x50 && buf[1] === 0x4B && buf[2] === 0x3 && buf[3] === 0x4 && buf[30] === 0x4D && buf[31] === 0x45 && buf[32] === 0x54 && buf[33] === 0x41 && buf[34] === 0x2D && buf[35] === 0x49 && buf[36] === 0x4E && buf[37] === 0x46 && buf[38] === 0x2F && buf[39] === 0x6D && buf[40] === 0x6F && buf[41] === 0x7A && buf[42] === 0x69 && buf[43] === 0x6C && buf[44] === 0x6C && buf[45] === 0x61 && buf[46] === 0x2E && buf[47] === 0x72 && buf[48] === 0x73 && buf[49] === 0x61) {
			return {
				ext: 'xpi',
				mime: 'application/x-xpinstall'
			};
		}

		if (buf[0] === 0x50 && buf[1] === 0x4B && (buf[2] === 0x3 || buf[2] === 0x5 || buf[2] === 0x7) && (buf[3] === 0x4 || buf[3] === 0x6 || buf[3] === 0x8)) {
			return {
				ext: 'zip',
				mime: 'application/zip'
			};
		}

		if (buf[257] === 0x75 && buf[258] === 0x73 && buf[259] === 0x74 && buf[260] === 0x61 && buf[261] === 0x72) {
			return {
				ext: 'tar',
				mime: 'application/x-tar'
			};
		}

		if (buf[0] === 0x52 && buf[1] === 0x61 && buf[2] === 0x72 && buf[3] === 0x21 && buf[4] === 0x1A && buf[5] === 0x7 && (buf[6] === 0x0 || buf[6] === 0x1)) {
			return {
				ext: 'rar',
				mime: 'application/x-rar-compressed'
			};
		}

		if (buf[0] === 0x1F && buf[1] === 0x8B && buf[2] === 0x8) {
			return {
				ext: 'gz',
				mime: 'application/gzip'
			};
		}

		if (buf[0] === 0x42 && buf[1] === 0x5A && buf[2] === 0x68) {
			return {
				ext: 'bz2',
				mime: 'application/x-bzip2'
			};
		}

		if (buf[0] === 0x37 && buf[1] === 0x7A && buf[2] === 0xBC && buf[3] === 0xAF && buf[4] === 0x27 && buf[5] === 0x1C) {
			return {
				ext: '7z',
				mime: 'application/x-7z-compressed'
			};
		}

		if (buf[0] === 0x78 && buf[1] === 0x01) {
			return {
				ext: 'dmg',
				mime: 'application/x-apple-diskimage'
			};
		}

		if (
			(buf[0] === 0x0 && buf[1] === 0x0 && buf[2] === 0x0 && (buf[3] === 0x18 || buf[3] === 0x20) && buf[4] === 0x66 && buf[5] === 0x74 && buf[6] === 0x79 && buf[7] === 0x70) ||
			(buf[0] === 0x33 && buf[1] === 0x67 && buf[2] === 0x70 && buf[3] === 0x35) ||
			(buf[0] === 0x0 && buf[1] === 0x0 && buf[2] === 0x0 && buf[3] === 0x1C && buf[4] === 0x66 && buf[5] === 0x74 && buf[6] === 0x79 && buf[7] === 0x70 && buf[8] === 0x6D && buf[9] === 0x70 && buf[10] === 0x34 && buf[11] === 0x32 && buf[16] === 0x6D && buf[17] === 0x70 && buf[18] === 0x34 && buf[19] === 0x31 && buf[20] === 0x6D && buf[21] === 0x70 && buf[22] === 0x34 && buf[23] === 0x32 && buf[24] === 0x69 && buf[25] === 0x73 && buf[26] === 0x6F && buf[27] === 0x6D) ||
			(buf[0] === 0x0 && buf[1] === 0x0 && buf[2] === 0x0 && buf[3] === 0x1C && buf[4] === 0x66 && buf[5] === 0x74 && buf[6] === 0x79 && buf[7] === 0x70 && buf[8] === 0x69 && buf[9] === 0x73 && buf[10] === 0x6F && buf[11] === 0x6D) ||
			(buf[0] === 0x0 && buf[1] === 0x0 && buf[2] === 0x0 && buf[3] === 0x1c && buf[4] === 0x66 && buf[5] === 0x74 && buf[6] === 0x79 && buf[7] === 0x70 && buf[8] === 0x6D && buf[9] === 0x70 && buf[10] === 0x34 && buf[11] === 0x32 && buf[12] === 0x0 && buf[13] === 0x0 && buf[14] === 0x0 && buf[15] === 0x0)
		) {
			return {
				ext: 'mp4',
				mime: 'video/mp4'
			};
		}

		if ((buf[0] === 0x0 && buf[1] === 0x0 && buf[2] === 0x0 && buf[3] === 0x1C && buf[4] === 0x66 && buf[5] === 0x74 && buf[6] === 0x79 && buf[7] === 0x70 && buf[8] === 0x4D && buf[9] === 0x34 && buf[10] === 0x56)) {
			return {
				ext: 'm4v',
				mime: 'video/x-m4v'
			};
		}

		if (buf[0] === 0x4D && buf[1] === 0x54 && buf[2] === 0x68 && buf[3] === 0x64) {
			return {
				ext: 'mid',
				mime: 'audio/midi'
			};
		}

		// needs to be before the `webm` check
		if (buf[31] === 0x6D && buf[32] === 0x61 && buf[33] === 0x74 && buf[34] === 0x72 && buf[35] === 0x6f && buf[36] === 0x73 && buf[37] === 0x6B && buf[38] === 0x61) {
			return {
				ext: 'mkv',
				mime: 'video/x-matroska'
			};
		}

		if (buf[0] === 0x1A && buf[1] === 0x45 && buf[2] === 0xDF && buf[3] === 0xA3) {
			return {
				ext: 'webm',
				mime: 'video/webm'
			};
		}

		if (buf[0] === 0x0 && buf[1] === 0x0 && buf[2] === 0x0 && buf[3] === 0x14 && buf[4] === 0x66 && buf[5] === 0x74 && buf[6] === 0x79 && buf[7] === 0x70) {
			return {
				ext: 'mov',
				mime: 'video/quicktime'
			};
		}

		if (buf[0] === 0x52 && buf[1] === 0x49 && buf[2] === 0x46 && buf[3] === 0x46 && buf[8] === 0x41 && buf[9] === 0x56 && buf[10] === 0x49) {
			return {
				ext: 'avi',
				mime: 'video/x-msvideo'
			};
		}

		if (buf[0] === 0x30 && buf[1] === 0x26 && buf[2] === 0xB2 && buf[3] === 0x75 && buf[4] === 0x8E && buf[5] === 0x66 && buf[6] === 0xCF && buf[7] === 0x11 && buf[8] === 0xA6 && buf[9] === 0xD9) {
			return {
				ext: 'wmv',
				mime: 'video/x-ms-wmv'
			};
		}

		if (buf[0] === 0x0 && buf[1] === 0x0 && buf[2] === 0x1 && buf[3].toString(16)[0] === 'b') {
			return {
				ext: 'mpg',
				mime: 'video/mpeg'
			};
		}

		if ((buf[0] === 0x49 && buf[1] === 0x44 && buf[2] === 0x33) || (buf[0] === 0xFF && buf[1] === 0xfb)) {
			return {
				ext: 'mp3',
				mime: 'audio/mpeg'
			};
		}

		if ((buf[4] === 0x66 && buf[5] === 0x74 && buf[6] === 0x79 && buf[7] === 0x70 && buf[8] === 0x4D && buf[9] === 0x34 && buf[10] === 0x41) || (buf[0] === 0x4D && buf[1] === 0x34 && buf[2] === 0x41 && buf[3] === 0x20)) {
			return {
				ext: 'm4a',
				mime: 'audio/m4a'
			};
		}

		// needs to be before `ogg` check
		if (buf[28] === 0x4F && buf[29] === 0x70 && buf[30] === 0x75 && buf[31] === 0x73 && buf[32] === 0x48 && buf[33] === 0x65 && buf[34] === 0x61 && buf[35] === 0x64) {
			return {
				ext: 'opus',
				mime: 'audio/opus'
			};
		}

		if (buf[0] === 0x4F && buf[1] === 0x67 && buf[2] === 0x67 && buf[3] === 0x53) {
			return {
				ext: 'ogg',
				mime: 'audio/ogg'
			};
		}

		if (buf[0] === 0x66 && buf[1] === 0x4C && buf[2] === 0x61 && buf[3] === 0x43) {
			return {
				ext: 'flac',
				mime: 'audio/x-flac'
			};
		}

		if (buf[0] === 0x52 && buf[1] === 0x49 && buf[2] === 0x46 && buf[3] === 0x46 && buf[8] === 0x57 && buf[9] === 0x41 && buf[10] === 0x56 && buf[11] === 0x45) {
			return {
				ext: 'wav',
				mime: 'audio/x-wav'
			};
		}

		if (buf[0] === 0x23 && buf[1] === 0x21 && buf[2] === 0x41 && buf[3] === 0x4D && buf[4] === 0x52 && buf[5] === 0x0A) {
			return {
				ext: 'amr',
				mime: 'audio/amr'
			};
		}

		if (buf[0] === 0x25 && buf[1] === 0x50 && buf[2] === 0x44 && buf[3] === 0x46) {
			return {
				ext: 'pdf',
				mime: 'application/pdf'
			};
		}

		if (buf[0] === 0x4D && buf[1] === 0x5A) {
			return {
				ext: 'exe',
				mime: 'application/x-msdownload'
			};
		}

		if ((buf[0] === 0x43 || buf[0] === 0x46) && buf[1] === 0x57 && buf[2] === 0x53) {
			return {
				ext: 'swf',
				mime: 'application/x-shockwave-flash'
			};
		}

		if (buf[0] === 0x7B && buf[1] === 0x5C && buf[2] === 0x72 && buf[3] === 0x74 && buf[4] === 0x66) {
			return {
				ext: 'rtf',
				mime: 'application/rtf'
			};
		}

		if (
			(buf[0] === 0x77 && buf[1] === 0x4F && buf[2] === 0x46 && buf[3] === 0x46) &&
			(
				(buf[4] === 0x00 && buf[5] === 0x01 && buf[6] === 0x00 && buf[7] === 0x00) ||
				(buf[4] === 0x4F && buf[5] === 0x54 && buf[6] === 0x54 && buf[7] === 0x4F)
			)
		) {
			return {
				ext: 'woff',
				mime: 'application/font-woff'
			};
		}

		if (
			(buf[0] === 0x77 && buf[1] === 0x4F && buf[2] === 0x46 && buf[3] === 0x32) &&
			(
				(buf[4] === 0x00 && buf[5] === 0x01 && buf[6] === 0x00 && buf[7] === 0x00) ||
				(buf[4] === 0x4F && buf[5] === 0x54 && buf[6] === 0x54 && buf[7] === 0x4F)
			)
		) {
			return {
				ext: 'woff2',
				mime: 'application/font-woff'
			};
		}

		if (
			(buf[34] === 0x4C && buf[35] === 0x50) &&
			(
				(buf[8] === 0x00 && buf[9] === 0x00 && buf[10] === 0x01) ||
				(buf[8] === 0x01 && buf[9] === 0x00 && buf[10] === 0x02) ||
				(buf[8] === 0x02 && buf[9] === 0x00 && buf[10] === 0x02)
			)
		) {
			return {
				ext: 'eot',
				mime: 'application/octet-stream'
			};
		}

		if (buf[0] === 0x00 && buf[1] === 0x01 && buf[2] === 0x00 && buf[3] === 0x00 && buf[4] === 0x00) {
			return {
				ext: 'ttf',
				mime: 'application/font-sfnt'
			};
		}

		if (buf[0] === 0x4F && buf[1] === 0x54 && buf[2] === 0x54 && buf[3] === 0x4F && buf[4] === 0x00) {
			return {
				ext: 'otf',
				mime: 'application/font-sfnt'
			};
		}

		if (buf[0] === 0x00 && buf[1] === 0x00 && buf[2] === 0x01 && buf[3] === 0x00) {
			return {
				ext: 'ico',
				mime: 'image/x-icon'
			};
		}

		if (buf[0] === 0x46 && buf[1] === 0x4C && buf[2] === 0x56 && buf[3] === 0x01) {
			return {
				ext: 'flv',
				mime: 'video/x-flv'
			};
		}

		if (buf[0] === 0x25 && buf[1] === 0x21) {
			return {
				ext: 'ps',
				mime: 'application/postscript'
			};
		}

		if (buf[0] === 0xFD && buf[1] === 0x37 && buf[2] === 0x7A && buf[3] === 0x58 && buf[4] === 0x5A && buf[5] === 0x00) {
			return {
				ext: 'xz',
				mime: 'application/x-xz'
			};
		}

		if (buf[0] === 0x53 && buf[1] === 0x51 && buf[2] === 0x4C && buf[3] === 0x69) {
			return {
				ext: 'sqlite',
				mime: 'application/x-sqlite3'
			};
		}

		if (buf[0] === 0x4E && buf[1] === 0x45 && buf[2] === 0x53 && buf[3] === 0x1A) {
			return {
				ext: 'nes',
				mime: 'application/x-nintendo-nes-rom'
			};
		}

		if (buf[0] === 0x43 && buf[1] === 0x72 && buf[2] === 0x32 && buf[3] === 0x34) {
			return {
				ext: 'crx',
				mime: 'application/x-google-chrome-extension'
			};
		}

		if (
			(buf[0] === 0x4D && buf[1] === 0x53 && buf[2] === 0x43 && buf[3] === 0x46) ||
			(buf[0] === 0x49 && buf[1] === 0x53 && buf[2] === 0x63 && buf[3] === 0x28)
		) {
			return {
				ext: 'cab',
				mime: 'application/vnd.ms-cab-compressed'
			};
		}

		// needs to be before `ar` check
		if (buf[0] === 0x21 && buf[1] === 0x3C && buf[2] === 0x61 && buf[3] === 0x72 && buf[4] === 0x63 && buf[5] === 0x68 && buf[6] === 0x3E && buf[7] === 0x0A && buf[8] === 0x64 && buf[9] === 0x65 && buf[10] === 0x62 && buf[11] === 0x69 && buf[12] === 0x61 && buf[13] === 0x6E && buf[14] === 0x2D && buf[15] === 0x62 && buf[16] === 0x69 && buf[17] === 0x6E && buf[18] === 0x61 && buf[19] === 0x72 && buf[20] === 0x79) {
			return {
				ext: 'deb',
				mime: 'application/x-deb'
			};
		}

		if (buf[0] === 0x21 && buf[1] === 0x3C && buf[2] === 0x61 && buf[3] === 0x72 && buf[4] === 0x63 && buf[5] === 0x68 && buf[6] === 0x3E) {
			return {
				ext: 'ar',
				mime: 'application/x-unix-archive'
			};
		}

		if (buf[0] === 0xED && buf[1] === 0xAB && buf[2] === 0xEE && buf[3] === 0xDB) {
			return {
				ext: 'rpm',
				mime: 'application/x-rpm'
			};
		}

		if (
			(buf[0] === 0x1F && buf[1] === 0xA0) ||
			(buf[0] === 0x1F && buf[1] === 0x9D)
		) {
			return {
				ext: 'Z',
				mime: 'application/x-compress'
			};
		}

		if (buf[0] === 0x4C && buf[1] === 0x5A && buf[2] === 0x49 && buf[3] === 0x50) {
			return {
				ext: 'lz',
				mime: 'application/x-lzip'
			};
		}

		if (buf[0] === 0xD0 && buf[1] === 0xCF && buf[2] === 0x11 && buf[3] === 0xE0 && buf[4] === 0xA1 && buf[5] === 0xB1 && buf[6] === 0x1A && buf[7] === 0xE1) {
			return {
				ext: 'msi',
				mime: 'application/x-msi'
			};
		}

		return null;
	};
	return fileType;
}

var getStream = {exports: {}};

var pinkie;
var hasRequiredPinkie;

function requirePinkie () {
	if (hasRequiredPinkie) return pinkie;
	hasRequiredPinkie = 1;

	var PENDING = 'pending';
	var SETTLED = 'settled';
	var FULFILLED = 'fulfilled';
	var REJECTED = 'rejected';
	var NOOP = function () {};
	var isNode = typeof commonjsGlobal !== 'undefined' && typeof commonjsGlobal.process !== 'undefined' && typeof commonjsGlobal.process.emit === 'function';

	var asyncSetTimer = typeof setImmediate === 'undefined' ? setTimeout : setImmediate;
	var asyncQueue = [];
	var asyncTimer;

	function asyncFlush() {
		// run promise callbacks
		for (var i = 0; i < asyncQueue.length; i++) {
			asyncQueue[i][0](asyncQueue[i][1]);
		}

		// reset async asyncQueue
		asyncQueue = [];
		asyncTimer = false;
	}

	function asyncCall(callback, arg) {
		asyncQueue.push([callback, arg]);

		if (!asyncTimer) {
			asyncTimer = true;
			asyncSetTimer(asyncFlush, 0);
		}
	}

	function invokeResolver(resolver, promise) {
		function resolvePromise(value) {
			resolve(promise, value);
		}

		function rejectPromise(reason) {
			reject(promise, reason);
		}

		try {
			resolver(resolvePromise, rejectPromise);
		} catch (e) {
			rejectPromise(e);
		}
	}

	function invokeCallback(subscriber) {
		var owner = subscriber.owner;
		var settled = owner._state;
		var value = owner._data;
		var callback = subscriber[settled];
		var promise = subscriber.then;

		if (typeof callback === 'function') {
			settled = FULFILLED;
			try {
				value = callback(value);
			} catch (e) {
				reject(promise, e);
			}
		}

		if (!handleThenable(promise, value)) {
			if (settled === FULFILLED) {
				resolve(promise, value);
			}

			if (settled === REJECTED) {
				reject(promise, value);
			}
		}
	}

	function handleThenable(promise, value) {
		var resolved;

		try {
			if (promise === value) {
				throw new TypeError('A promises callback cannot return that same promise.');
			}

			if (value && (typeof value === 'function' || typeof value === 'object')) {
				// then should be retrieved only once
				var then = value.then;

				if (typeof then === 'function') {
					then.call(value, function (val) {
						if (!resolved) {
							resolved = true;

							if (value === val) {
								fulfill(promise, val);
							} else {
								resolve(promise, val);
							}
						}
					}, function (reason) {
						if (!resolved) {
							resolved = true;

							reject(promise, reason);
						}
					});

					return true;
				}
			}
		} catch (e) {
			if (!resolved) {
				reject(promise, e);
			}

			return true;
		}

		return false;
	}

	function resolve(promise, value) {
		if (promise === value || !handleThenable(promise, value)) {
			fulfill(promise, value);
		}
	}

	function fulfill(promise, value) {
		if (promise._state === PENDING) {
			promise._state = SETTLED;
			promise._data = value;

			asyncCall(publishFulfillment, promise);
		}
	}

	function reject(promise, reason) {
		if (promise._state === PENDING) {
			promise._state = SETTLED;
			promise._data = reason;

			asyncCall(publishRejection, promise);
		}
	}

	function publish(promise) {
		promise._then = promise._then.forEach(invokeCallback);
	}

	function publishFulfillment(promise) {
		promise._state = FULFILLED;
		publish(promise);
	}

	function publishRejection(promise) {
		promise._state = REJECTED;
		publish(promise);
		if (!promise._handled && isNode) {
			commonjsGlobal.process.emit('unhandledRejection', promise._data, promise);
		}
	}

	function notifyRejectionHandled(promise) {
		commonjsGlobal.process.emit('rejectionHandled', promise);
	}

	/**
	 * @class
	 */
	function Promise(resolver) {
		if (typeof resolver !== 'function') {
			throw new TypeError('Promise resolver ' + resolver + ' is not a function');
		}

		if (this instanceof Promise === false) {
			throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
		}

		this._then = [];

		invokeResolver(resolver, this);
	}

	Promise.prototype = {
		constructor: Promise,

		_state: PENDING,
		_then: null,
		_data: undefined,
		_handled: false,

		then: function (onFulfillment, onRejection) {
			var subscriber = {
				owner: this,
				then: new this.constructor(NOOP),
				fulfilled: onFulfillment,
				rejected: onRejection
			};

			if ((onRejection || onFulfillment) && !this._handled) {
				this._handled = true;
				if (this._state === REJECTED && isNode) {
					asyncCall(notifyRejectionHandled, this);
				}
			}

			if (this._state === FULFILLED || this._state === REJECTED) {
				// already resolved, call callback async
				asyncCall(invokeCallback, subscriber);
			} else {
				// subscribe
				this._then.push(subscriber);
			}

			return subscriber.then;
		},

		catch: function (onRejection) {
			return this.then(null, onRejection);
		}
	};

	Promise.all = function (promises) {
		if (!Array.isArray(promises)) {
			throw new TypeError('You must pass an array to Promise.all().');
		}

		return new Promise(function (resolve, reject) {
			var results = [];
			var remaining = 0;

			function resolver(index) {
				remaining++;
				return function (value) {
					results[index] = value;
					if (!--remaining) {
						resolve(results);
					}
				};
			}

			for (var i = 0, promise; i < promises.length; i++) {
				promise = promises[i];

				if (promise && typeof promise.then === 'function') {
					promise.then(resolver(i), reject);
				} else {
					results[i] = promise;
				}
			}

			if (!remaining) {
				resolve(results);
			}
		});
	};

	Promise.race = function (promises) {
		if (!Array.isArray(promises)) {
			throw new TypeError('You must pass an array to Promise.race().');
		}

		return new Promise(function (resolve, reject) {
			for (var i = 0, promise; i < promises.length; i++) {
				promise = promises[i];

				if (promise && typeof promise.then === 'function') {
					promise.then(resolve, reject);
				} else {
					resolve(promise);
				}
			}
		});
	};

	Promise.resolve = function (value) {
		if (value && typeof value === 'object' && value.constructor === Promise) {
			return value;
		}

		return new Promise(function (resolve) {
			resolve(value);
		});
	};

	Promise.reject = function (reason) {
		return new Promise(function (resolve, reject) {
			reject(reason);
		});
	};

	pinkie = Promise;
	return pinkie;
}

var pinkiePromise;
var hasRequiredPinkiePromise;

function requirePinkiePromise () {
	if (hasRequiredPinkiePromise) return pinkiePromise;
	hasRequiredPinkiePromise = 1;

	pinkiePromise = typeof Promise === 'function' ? Promise : requirePinkie();
	return pinkiePromise;
}

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

var objectAssign;
var hasRequiredObjectAssign;

function requireObjectAssign () {
	if (hasRequiredObjectAssign) return objectAssign;
	hasRequiredObjectAssign = 1;
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};
	return objectAssign;
}

var bufferStream;
var hasRequiredBufferStream;

function requireBufferStream () {
	if (hasRequiredBufferStream) return bufferStream;
	hasRequiredBufferStream = 1;
	var PassThrough = require$$0$6.PassThrough;
	var objectAssign = requireObjectAssign();

	bufferStream = function (opts) {
		opts = objectAssign({}, opts);

		var array = opts.array;
		var encoding = opts.encoding;

		var buffer = encoding === 'buffer';
		var objectMode = false;

		if (array) {
			objectMode = !(encoding || buffer);
		} else {
			encoding = encoding || 'utf8';
		}

		if (buffer) {
			encoding = null;
		}

		var len = 0;
		var ret = [];

		var stream = new PassThrough({objectMode: objectMode});

		if (encoding) {
			stream.setEncoding(encoding);
		}

		stream.on('data', function (chunk) {
			ret.push(chunk);

			if (objectMode) {
				len = ret.length;
			} else {
				len += chunk.length;
			}
		});

		stream.getBufferedValue = function () {
			if (array) {
				return ret;
			}
			return buffer ? Buffer.concat(ret, len) : ret.join('');
		};

		stream.getBufferedLength = function () {
			return len;
		};

		return stream;
	};
	return bufferStream;
}

var hasRequiredGetStream;

function requireGetStream () {
	if (hasRequiredGetStream) return getStream.exports;
	hasRequiredGetStream = 1;
	var Promise = requirePinkiePromise();
	var objectAssign = requireObjectAssign();
	var bufferStream = requireBufferStream();

	function getStream$1(inputStream, opts) {
		if (!inputStream) {
			return Promise.reject(new Error('Expected a stream'));
		}

		opts = objectAssign({maxBuffer: Infinity}, opts);
		var maxBuffer = opts.maxBuffer;
		var stream;
		var clean;

		var p = new Promise(function (resolve, reject) {
			stream = bufferStream(opts);
			inputStream.once('error', error);
			inputStream.pipe(stream);

			stream.on('data', function () {
				if (stream.getBufferedLength() > maxBuffer) {
					reject(new Error('maxBuffer exceeded'));
				}
			});
			stream.once('error', error);
			stream.on('end', resolve);

			clean = function () {
				// some streams doesn't implement the stream.Readable interface correctly
				if (inputStream.unpipe) {
					inputStream.unpipe(stream);
				}
			};

			function error(err) {
				if (err) { // null check
					err.bufferedData = stream.getBufferedValue();
				}
				reject(err);
			}
		});

		p.then(clean, clean);

		return p.then(function () {
			return stream.getBufferedValue();
		});
	}

	getStream.exports = getStream$1;

	getStream.exports.buffer = function (stream, opts) {
		return getStream$1(stream, objectAssign({}, opts, {encoding: 'buffer'}));
	};

	getStream.exports.array = function (stream, opts) {
		return getStream$1(stream, objectAssign({}, opts, {array: true}));
	};
	return getStream.exports;
}

var pify$1 = {exports: {}};

var hasRequiredPify$1;

function requirePify$1 () {
	if (hasRequiredPify$1) return pify$1.exports;
	hasRequiredPify$1 = 1;

	var processFn = function (fn, P, opts) {
		return function () {
			var that = this;
			var args = new Array(arguments.length);

			for (var i = 0; i < arguments.length; i++) {
				args[i] = arguments[i];
			}

			return new P(function (resolve, reject) {
				args.push(function (err, result) {
					if (err) {
						reject(err);
					} else if (opts.multiArgs) {
						var results = new Array(arguments.length - 1);

						for (var i = 1; i < arguments.length; i++) {
							results[i - 1] = arguments[i];
						}

						resolve(results);
					} else {
						resolve(result);
					}
				});

				fn.apply(that, args);
			});
		};
	};

	var pify = pify$1.exports = function (obj, P, opts) {
		if (typeof P !== 'function') {
			opts = P;
			P = Promise;
		}

		opts = opts || {};
		opts.exclude = opts.exclude || [/.+Sync$/];

		var filter = function (key) {
			var match = function (pattern) {
				return typeof pattern === 'string' ? key === pattern : pattern.test(key);
			};

			return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
		};

		var ret = typeof obj === 'function' ? function () {
			if (opts.excludeMain) {
				return obj.apply(this, arguments);
			}

			return processFn(obj, P, opts).apply(this, arguments);
		} : {};

		return Object.keys(obj).reduce(function (ret, key) {
			var x = obj[key];

			ret[key] = typeof x === 'function' && filter(key) ? processFn(x, P, opts) : x;

			return ret;
		}, ret);
	};

	pify.all = pify;
	return pify$1.exports;
}

var yauzl = {};

var fdSlicer = {};

var pend;
var hasRequiredPend;

function requirePend () {
	if (hasRequiredPend) return pend;
	hasRequiredPend = 1;
	pend = Pend;

	function Pend() {
	  this.pending = 0;
	  this.max = Infinity;
	  this.listeners = [];
	  this.waiting = [];
	  this.error = null;
	}

	Pend.prototype.go = function(fn) {
	  if (this.pending < this.max) {
	    pendGo(this, fn);
	  } else {
	    this.waiting.push(fn);
	  }
	};

	Pend.prototype.wait = function(cb) {
	  if (this.pending === 0) {
	    cb(this.error);
	  } else {
	    this.listeners.push(cb);
	  }
	};

	Pend.prototype.hold = function() {
	  return pendHold(this);
	};

	function pendHold(self) {
	  self.pending += 1;
	  var called = false;
	  return onCb;
	  function onCb(err) {
	    if (called) throw new Error("callback called twice");
	    called = true;
	    self.error = self.error || err;
	    self.pending -= 1;
	    if (self.waiting.length > 0 && self.pending < self.max) {
	      pendGo(self, self.waiting.shift());
	    } else if (self.pending === 0) {
	      var listeners = self.listeners;
	      self.listeners = [];
	      listeners.forEach(cbListener);
	    }
	  }
	  function cbListener(listener) {
	    listener(self.error);
	  }
	}

	function pendGo(self, fn) {
	  fn(pendHold(self));
	}
	return pend;
}

var hasRequiredFdSlicer;

function requireFdSlicer () {
	if (hasRequiredFdSlicer) return fdSlicer;
	hasRequiredFdSlicer = 1;
	var fs = require$$0$8;
	var util = require$$1$2;
	var stream = require$$0$6;
	var Readable = stream.Readable;
	var Writable = stream.Writable;
	var PassThrough = stream.PassThrough;
	var Pend = requirePend();
	var EventEmitter = require$$4$2.EventEmitter;

	fdSlicer.createFromBuffer = createFromBuffer;
	fdSlicer.createFromFd = createFromFd;
	fdSlicer.BufferSlicer = BufferSlicer;
	fdSlicer.FdSlicer = FdSlicer;

	util.inherits(FdSlicer, EventEmitter);
	function FdSlicer(fd, options) {
	  options = options || {};
	  EventEmitter.call(this);

	  this.fd = fd;
	  this.pend = new Pend();
	  this.pend.max = 1;
	  this.refCount = 0;
	  this.autoClose = !!options.autoClose;
	}

	FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
	  var self = this;
	  self.pend.go(function(cb) {
	    fs.read(self.fd, buffer, offset, length, position, function(err, bytesRead, buffer) {
	      cb();
	      callback(err, bytesRead, buffer);
	    });
	  });
	};

	FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
	  var self = this;
	  self.pend.go(function(cb) {
	    fs.write(self.fd, buffer, offset, length, position, function(err, written, buffer) {
	      cb();
	      callback(err, written, buffer);
	    });
	  });
	};

	FdSlicer.prototype.createReadStream = function(options) {
	  return new ReadStream(this, options);
	};

	FdSlicer.prototype.createWriteStream = function(options) {
	  return new WriteStream(this, options);
	};

	FdSlicer.prototype.ref = function() {
	  this.refCount += 1;
	};

	FdSlicer.prototype.unref = function() {
	  var self = this;
	  self.refCount -= 1;

	  if (self.refCount > 0) return;
	  if (self.refCount < 0) throw new Error("invalid unref");

	  if (self.autoClose) {
	    fs.close(self.fd, onCloseDone);
	  }

	  function onCloseDone(err) {
	    if (err) {
	      self.emit('error', err);
	    } else {
	      self.emit('close');
	    }
	  }
	};

	util.inherits(ReadStream, Readable);
	function ReadStream(context, options) {
	  options = options || {};
	  Readable.call(this, options);

	  this.context = context;
	  this.context.ref();

	  this.start = options.start || 0;
	  this.endOffset = options.end;
	  this.pos = this.start;
	  this.destroyed = false;
	}

	ReadStream.prototype._read = function(n) {
	  var self = this;
	  if (self.destroyed) return;

	  var toRead = Math.min(self._readableState.highWaterMark, n);
	  if (self.endOffset != null) {
	    toRead = Math.min(toRead, self.endOffset - self.pos);
	  }
	  if (toRead <= 0) {
	    self.destroyed = true;
	    self.push(null);
	    self.context.unref();
	    return;
	  }
	  self.context.pend.go(function(cb) {
	    if (self.destroyed) return cb();
	    var buffer = new Buffer(toRead);
	    fs.read(self.context.fd, buffer, 0, toRead, self.pos, function(err, bytesRead) {
	      if (err) {
	        self.destroy(err);
	      } else if (bytesRead === 0) {
	        self.destroyed = true;
	        self.push(null);
	        self.context.unref();
	      } else {
	        self.pos += bytesRead;
	        self.push(buffer.slice(0, bytesRead));
	      }
	      cb();
	    });
	  });
	};

	ReadStream.prototype.destroy = function(err) {
	  if (this.destroyed) return;
	  err = err || new Error("stream destroyed");
	  this.destroyed = true;
	  this.emit('error', err);
	  this.context.unref();
	};

	util.inherits(WriteStream, Writable);
	function WriteStream(context, options) {
	  options = options || {};
	  Writable.call(this, options);

	  this.context = context;
	  this.context.ref();

	  this.start = options.start || 0;
	  this.endOffset = (options.end == null) ? Infinity : +options.end;
	  this.bytesWritten = 0;
	  this.pos = this.start;
	  this.destroyed = false;

	  this.on('finish', this.destroy.bind(this));
	}

	WriteStream.prototype._write = function(buffer, encoding, callback) {
	  var self = this;
	  if (self.destroyed) return;

	  if (self.pos + buffer.length > self.endOffset) {
	    var err = new Error("maximum file length exceeded");
	    err.code = 'ETOOBIG';
	    self.destroy();
	    callback(err);
	    return;
	  }
	  self.context.pend.go(function(cb) {
	    if (self.destroyed) return cb();
	    fs.write(self.context.fd, buffer, 0, buffer.length, self.pos, function(err, bytes) {
	      if (err) {
	        self.destroy();
	        cb();
	        callback(err);
	      } else {
	        self.bytesWritten += bytes;
	        self.pos += bytes;
	        self.emit('progress');
	        cb();
	        callback();
	      }
	    });
	  });
	};

	WriteStream.prototype.destroy = function() {
	  if (this.destroyed) return;
	  this.destroyed = true;
	  this.context.unref();
	};

	util.inherits(BufferSlicer, EventEmitter);
	function BufferSlicer(buffer, options) {
	  EventEmitter.call(this);

	  options = options || {};
	  this.refCount = 0;
	  this.buffer = buffer;
	  this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
	}

	BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
	  var end = position + length;
	  var delta = end - this.buffer.length;
	  var written = (delta > 0) ? delta : length;
	  this.buffer.copy(buffer, offset, position, end);
	  setImmediate(function() {
	    callback(null, written);
	  });
	};

	BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
	  buffer.copy(this.buffer, position, offset, offset + length);
	  setImmediate(function() {
	    callback(null, length, buffer);
	  });
	};

	BufferSlicer.prototype.createReadStream = function(options) {
	  options = options || {};
	  var readStream = new PassThrough(options);
	  readStream.destroyed = false;
	  readStream.start = options.start || 0;
	  readStream.endOffset = options.end;
	  // by the time this function returns, we'll be done.
	  readStream.pos = readStream.endOffset || this.buffer.length;

	  // respect the maxChunkSize option to slice up the chunk into smaller pieces.
	  var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
	  var offset = 0;
	  while (true) {
	    var nextOffset = offset + this.maxChunkSize;
	    if (nextOffset >= entireSlice.length) {
	      // last chunk
	      if (offset < entireSlice.length) {
	        readStream.write(entireSlice.slice(offset, entireSlice.length));
	      }
	      break;
	    }
	    readStream.write(entireSlice.slice(offset, nextOffset));
	    offset = nextOffset;
	  }

	  readStream.end();
	  readStream.destroy = function() {
	    readStream.destroyed = true;
	  };
	  return readStream;
	};

	BufferSlicer.prototype.createWriteStream = function(options) {
	  var bufferSlicer = this;
	  options = options || {};
	  var writeStream = new Writable(options);
	  writeStream.start = options.start || 0;
	  writeStream.endOffset = (options.end == null) ? this.buffer.length : +options.end;
	  writeStream.bytesWritten = 0;
	  writeStream.pos = writeStream.start;
	  writeStream.destroyed = false;
	  writeStream._write = function(buffer, encoding, callback) {
	    if (writeStream.destroyed) return;

	    var end = writeStream.pos + buffer.length;
	    if (end > writeStream.endOffset) {
	      var err = new Error("maximum file length exceeded");
	      err.code = 'ETOOBIG';
	      writeStream.destroyed = true;
	      callback(err);
	      return;
	    }
	    buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);

	    writeStream.bytesWritten += buffer.length;
	    writeStream.pos = end;
	    writeStream.emit('progress');
	    callback();
	  };
	  writeStream.destroy = function() {
	    writeStream.destroyed = true;
	  };
	  return writeStream;
	};

	BufferSlicer.prototype.ref = function() {
	  this.refCount += 1;
	};

	BufferSlicer.prototype.unref = function() {
	  this.refCount -= 1;

	  if (this.refCount < 0) {
	    throw new Error("invalid unref");
	  }
	};

	function createFromBuffer(buffer, options) {
	  return new BufferSlicer(buffer, options);
	}

	function createFromFd(fd, options) {
	  return new FdSlicer(fd, options);
	}
	return fdSlicer;
}

var bufferCrc32;
var hasRequiredBufferCrc32;

function requireBufferCrc32 () {
	if (hasRequiredBufferCrc32) return bufferCrc32;
	hasRequiredBufferCrc32 = 1;
	var Buffer = require$$0$4.Buffer;

	var CRC_TABLE = [
	  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
	  0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
	  0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
	  0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
	  0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
	  0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
	  0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
	  0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
	  0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
	  0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
	  0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
	  0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
	  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
	  0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
	  0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
	  0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
	  0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
	  0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
	  0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
	  0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
	  0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
	  0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
	  0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
	  0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
	  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
	  0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
	  0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
	  0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
	  0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
	  0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
	  0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
	  0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
	  0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
	  0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
	  0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
	  0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
	  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
	  0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
	  0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
	  0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
	  0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
	  0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
	  0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
	  0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
	  0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
	  0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
	  0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
	  0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
	  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
	  0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
	  0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
	  0x2d02ef8d
	];

	if (typeof Int32Array !== 'undefined') {
	  CRC_TABLE = new Int32Array(CRC_TABLE);
	}

	function ensureBuffer(input) {
	  if (Buffer.isBuffer(input)) {
	    return input;
	  }

	  var hasNewBufferAPI =
	      typeof Buffer.alloc === "function" &&
	      typeof Buffer.from === "function";

	  if (typeof input === "number") {
	    return hasNewBufferAPI ? Buffer.alloc(input) : new Buffer(input);
	  }
	  else if (typeof input === "string") {
	    return hasNewBufferAPI ? Buffer.from(input) : new Buffer(input);
	  }
	  else {
	    throw new Error("input must be buffer, number, or string, received " +
	                    typeof input);
	  }
	}

	function bufferizeInt(num) {
	  var tmp = ensureBuffer(4);
	  tmp.writeInt32BE(num, 0);
	  return tmp;
	}

	function _crc32(buf, previous) {
	  buf = ensureBuffer(buf);
	  if (Buffer.isBuffer(previous)) {
	    previous = previous.readUInt32BE(0);
	  }
	  var crc = ~~previous ^ -1;
	  for (var n = 0; n < buf.length; n++) {
	    crc = CRC_TABLE[(crc ^ buf[n]) & 0xff] ^ (crc >>> 8);
	  }
	  return (crc ^ -1);
	}

	function crc32() {
	  return bufferizeInt(_crc32.apply(null, arguments));
	}
	crc32.signed = function () {
	  return _crc32.apply(null, arguments);
	};
	crc32.unsigned = function () {
	  return _crc32.apply(null, arguments) >>> 0;
	};

	bufferCrc32 = crc32;
	return bufferCrc32;
}

var hasRequiredYauzl;

function requireYauzl () {
	if (hasRequiredYauzl) return yauzl;
	hasRequiredYauzl = 1;
	var fs = require$$0$8;
	var zlib = require$$5$1;
	var fd_slicer = requireFdSlicer();
	var crc32 = requireBufferCrc32();
	var util = require$$1$2;
	var EventEmitter = require$$4$2.EventEmitter;
	var Transform = require$$0$6.Transform;
	var PassThrough = require$$0$6.PassThrough;
	var Writable = require$$0$6.Writable;

	yauzl.open = open;
	yauzl.fromFd = fromFd;
	yauzl.fromBuffer = fromBuffer;
	yauzl.fromRandomAccessReader = fromRandomAccessReader;
	yauzl.dosDateTimeToDate = dosDateTimeToDate;
	yauzl.validateFileName = validateFileName;
	yauzl.ZipFile = ZipFile;
	yauzl.Entry = Entry;
	yauzl.RandomAccessReader = RandomAccessReader;

	function open(path, options, callback) {
	  if (typeof options === "function") {
	    callback = options;
	    options = null;
	  }
	  if (options == null) options = {};
	  if (options.autoClose == null) options.autoClose = true;
	  if (options.lazyEntries == null) options.lazyEntries = false;
	  if (options.decodeStrings == null) options.decodeStrings = true;
	  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
	  if (options.strictFileNames == null) options.strictFileNames = false;
	  if (callback == null) callback = defaultCallback;
	  fs.open(path, "r", function(err, fd) {
	    if (err) return callback(err);
	    fromFd(fd, options, function(err, zipfile) {
	      if (err) fs.close(fd, defaultCallback);
	      callback(err, zipfile);
	    });
	  });
	}

	function fromFd(fd, options, callback) {
	  if (typeof options === "function") {
	    callback = options;
	    options = null;
	  }
	  if (options == null) options = {};
	  if (options.autoClose == null) options.autoClose = false;
	  if (options.lazyEntries == null) options.lazyEntries = false;
	  if (options.decodeStrings == null) options.decodeStrings = true;
	  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
	  if (options.strictFileNames == null) options.strictFileNames = false;
	  if (callback == null) callback = defaultCallback;
	  fs.fstat(fd, function(err, stats) {
	    if (err) return callback(err);
	    var reader = fd_slicer.createFromFd(fd, {autoClose: true});
	    fromRandomAccessReader(reader, stats.size, options, callback);
	  });
	}

	function fromBuffer(buffer, options, callback) {
	  if (typeof options === "function") {
	    callback = options;
	    options = null;
	  }
	  if (options == null) options = {};
	  options.autoClose = false;
	  if (options.lazyEntries == null) options.lazyEntries = false;
	  if (options.decodeStrings == null) options.decodeStrings = true;
	  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
	  if (options.strictFileNames == null) options.strictFileNames = false;
	  // limit the max chunk size. see https://github.com/thejoshwolfe/yauzl/issues/87
	  var reader = fd_slicer.createFromBuffer(buffer, {maxChunkSize: 0x10000});
	  fromRandomAccessReader(reader, buffer.length, options, callback);
	}

	function fromRandomAccessReader(reader, totalSize, options, callback) {
	  if (typeof options === "function") {
	    callback = options;
	    options = null;
	  }
	  if (options == null) options = {};
	  if (options.autoClose == null) options.autoClose = true;
	  if (options.lazyEntries == null) options.lazyEntries = false;
	  if (options.decodeStrings == null) options.decodeStrings = true;
	  var decodeStrings = !!options.decodeStrings;
	  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
	  if (options.strictFileNames == null) options.strictFileNames = false;
	  if (callback == null) callback = defaultCallback;
	  if (typeof totalSize !== "number") throw new Error("expected totalSize parameter to be a number");
	  if (totalSize > Number.MAX_SAFE_INTEGER) {
	    throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
	  }

	  // the matching unref() call is in zipfile.close()
	  reader.ref();

	  // eocdr means End of Central Directory Record.
	  // search backwards for the eocdr signature.
	  // the last field of the eocdr is a variable-length comment.
	  // the comment size is encoded in a 2-byte field in the eocdr, which we can't find without trudging backwards through the comment to find it.
	  // as a consequence of this design decision, it's possible to have ambiguous zip file metadata if a coherent eocdr was in the comment.
	  // we search backwards for a eocdr signature, and hope that whoever made the zip file was smart enough to forbid the eocdr signature in the comment.
	  var eocdrWithoutCommentSize = 22;
	  var maxCommentSize = 0xffff; // 2-byte size
	  var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
	  var buffer = newBuffer(bufferSize);
	  var bufferReadStart = totalSize - buffer.length;
	  readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
	    if (err) return callback(err);
	    for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
	      if (buffer.readUInt32LE(i) !== 0x06054b50) continue;
	      // found eocdr
	      var eocdrBuffer = buffer.slice(i);

	      // 0 - End of central directory signature = 0x06054b50
	      // 4 - Number of this disk
	      var diskNumber = eocdrBuffer.readUInt16LE(4);
	      if (diskNumber !== 0) {
	        return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
	      }
	      // 6 - Disk where central directory starts
	      // 8 - Number of central directory records on this disk
	      // 10 - Total number of central directory records
	      var entryCount = eocdrBuffer.readUInt16LE(10);
	      // 12 - Size of central directory (bytes)
	      // 16 - Offset of start of central directory, relative to start of archive
	      var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
	      // 20 - Comment length
	      var commentLength = eocdrBuffer.readUInt16LE(20);
	      var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
	      if (commentLength !== expectedCommentLength) {
	        return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
	      }
	      // 22 - Comment
	      // the encoding is always cp437.
	      var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false)
	                                  : eocdrBuffer.slice(22);

	      if (!(entryCount === 0xffff || centralDirectoryOffset === 0xffffffff)) {
	        return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
	      }

	      // ZIP64 format

	      // ZIP64 Zip64 end of central directory locator
	      var zip64EocdlBuffer = newBuffer(20);
	      var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
	      readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err) {
	        if (err) return callback(err);

	        // 0 - zip64 end of central dir locator signature = 0x07064b50
	        if (zip64EocdlBuffer.readUInt32LE(0) !== 0x07064b50) {
	          return callback(new Error("invalid zip64 end of central directory locator signature"));
	        }
	        // 4 - number of the disk with the start of the zip64 end of central directory
	        // 8 - relative offset of the zip64 end of central directory record
	        var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
	        // 16 - total number of disks

	        // ZIP64 end of central directory record
	        var zip64EocdrBuffer = newBuffer(56);
	        readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err) {
	          if (err) return callback(err);

	          // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)
	          if (zip64EocdrBuffer.readUInt32LE(0) !== 0x06064b50) {
	            return callback(new Error("invalid zip64 end of central directory record signature"));
	          }
	          // 4 - size of zip64 end of central directory record                8 bytes
	          // 12 - version made by                                             2 bytes
	          // 14 - version needed to extract                                   2 bytes
	          // 16 - number of this disk                                         4 bytes
	          // 20 - number of the disk with the start of the central directory  4 bytes
	          // 24 - total number of entries in the central directory on this disk         8 bytes
	          // 32 - total number of entries in the central directory            8 bytes
	          entryCount = readUInt64LE(zip64EocdrBuffer, 32);
	          // 40 - size of the central directory                               8 bytes
	          // 48 - offset of start of central directory with respect to the starting disk number     8 bytes
	          centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
	          // 56 - zip64 extensible data sector                                (variable size)
	          return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
	        });
	      });
	      return;
	    }
	    callback(new Error("end of central directory record signature not found"));
	  });
	}

	util.inherits(ZipFile, EventEmitter);
	function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
	  var self = this;
	  EventEmitter.call(self);
	  self.reader = reader;
	  // forward close events
	  self.reader.on("error", function(err) {
	    // error closing the fd
	    emitError(self, err);
	  });
	  self.reader.once("close", function() {
	    self.emit("close");
	  });
	  self.readEntryCursor = centralDirectoryOffset;
	  self.fileSize = fileSize;
	  self.entryCount = entryCount;
	  self.comment = comment;
	  self.entriesRead = 0;
	  self.autoClose = !!autoClose;
	  self.lazyEntries = !!lazyEntries;
	  self.decodeStrings = !!decodeStrings;
	  self.validateEntrySizes = !!validateEntrySizes;
	  self.strictFileNames = !!strictFileNames;
	  self.isOpen = true;
	  self.emittedError = false;

	  if (!self.lazyEntries) self._readEntry();
	}
	ZipFile.prototype.close = function() {
	  if (!this.isOpen) return;
	  this.isOpen = false;
	  this.reader.unref();
	};

	function emitErrorAndAutoClose(self, err) {
	  if (self.autoClose) self.close();
	  emitError(self, err);
	}
	function emitError(self, err) {
	  if (self.emittedError) return;
	  self.emittedError = true;
	  self.emit("error", err);
	}

	ZipFile.prototype.readEntry = function() {
	  if (!this.lazyEntries) throw new Error("readEntry() called without lazyEntries:true");
	  this._readEntry();
	};
	ZipFile.prototype._readEntry = function() {
	  var self = this;
	  if (self.entryCount === self.entriesRead) {
	    // done with metadata
	    setImmediate(function() {
	      if (self.autoClose) self.close();
	      if (self.emittedError) return;
	      self.emit("end");
	    });
	    return;
	  }
	  if (self.emittedError) return;
	  var buffer = newBuffer(46);
	  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {
	    if (err) return emitErrorAndAutoClose(self, err);
	    if (self.emittedError) return;
	    var entry = new Entry();
	    // 0 - Central directory file header signature
	    var signature = buffer.readUInt32LE(0);
	    if (signature !== 0x02014b50) return emitErrorAndAutoClose(self, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
	    // 4 - Version made by
	    entry.versionMadeBy = buffer.readUInt16LE(4);
	    // 6 - Version needed to extract (minimum)
	    entry.versionNeededToExtract = buffer.readUInt16LE(6);
	    // 8 - General purpose bit flag
	    entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
	    // 10 - Compression method
	    entry.compressionMethod = buffer.readUInt16LE(10);
	    // 12 - File last modification time
	    entry.lastModFileTime = buffer.readUInt16LE(12);
	    // 14 - File last modification date
	    entry.lastModFileDate = buffer.readUInt16LE(14);
	    // 16 - CRC-32
	    entry.crc32 = buffer.readUInt32LE(16);
	    // 20 - Compressed size
	    entry.compressedSize = buffer.readUInt32LE(20);
	    // 24 - Uncompressed size
	    entry.uncompressedSize = buffer.readUInt32LE(24);
	    // 28 - File name length (n)
	    entry.fileNameLength = buffer.readUInt16LE(28);
	    // 30 - Extra field length (m)
	    entry.extraFieldLength = buffer.readUInt16LE(30);
	    // 32 - File comment length (k)
	    entry.fileCommentLength = buffer.readUInt16LE(32);
	    // 34 - Disk number where file starts
	    // 36 - Internal file attributes
	    entry.internalFileAttributes = buffer.readUInt16LE(36);
	    // 38 - External file attributes
	    entry.externalFileAttributes = buffer.readUInt32LE(38);
	    // 42 - Relative offset of local file header
	    entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);

	    if (entry.generalPurposeBitFlag & 0x40) return emitErrorAndAutoClose(self, new Error("strong encryption is not supported"));

	    self.readEntryCursor += 46;

	    buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
	    readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {
	      if (err) return emitErrorAndAutoClose(self, err);
	      if (self.emittedError) return;
	      // 46 - File name
	      var isUtf8 = (entry.generalPurposeBitFlag & 0x800) !== 0;
	      entry.fileName = self.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8)
	                                          : buffer.slice(0, entry.fileNameLength);

	      // 46+n - Extra field
	      var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
	      var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
	      entry.extraFields = [];
	      var i = 0;
	      while (i < extraFieldBuffer.length - 3) {
	        var headerId = extraFieldBuffer.readUInt16LE(i + 0);
	        var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
	        var dataStart = i + 4;
	        var dataEnd = dataStart + dataSize;
	        if (dataEnd > extraFieldBuffer.length) return emitErrorAndAutoClose(self, new Error("extra field length exceeds extra field buffer size"));
	        var dataBuffer = newBuffer(dataSize);
	        extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
	        entry.extraFields.push({
	          id: headerId,
	          data: dataBuffer,
	        });
	        i = dataEnd;
	      }

	      // 46+n+m - File comment
	      entry.fileComment = self.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8)
	                                             : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
	      // compatibility hack for https://github.com/thejoshwolfe/yauzl/issues/47
	      entry.comment = entry.fileComment;

	      self.readEntryCursor += buffer.length;
	      self.entriesRead += 1;

	      if (entry.uncompressedSize            === 0xffffffff ||
	          entry.compressedSize              === 0xffffffff ||
	          entry.relativeOffsetOfLocalHeader === 0xffffffff) {
	        // ZIP64 format
	        // find the Zip64 Extended Information Extra Field
	        var zip64EiefBuffer = null;
	        for (var i = 0; i < entry.extraFields.length; i++) {
	          var extraField = entry.extraFields[i];
	          if (extraField.id === 0x0001) {
	            zip64EiefBuffer = extraField.data;
	            break;
	          }
	        }
	        if (zip64EiefBuffer == null) {
	          return emitErrorAndAutoClose(self, new Error("expected zip64 extended information extra field"));
	        }
	        var index = 0;
	        // 0 - Original Size          8 bytes
	        if (entry.uncompressedSize === 0xffffffff) {
	          if (index + 8 > zip64EiefBuffer.length) {
	            return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include uncompressed size"));
	          }
	          entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
	          index += 8;
	        }
	        // 8 - Compressed Size        8 bytes
	        if (entry.compressedSize === 0xffffffff) {
	          if (index + 8 > zip64EiefBuffer.length) {
	            return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include compressed size"));
	          }
	          entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
	          index += 8;
	        }
	        // 16 - Relative Header Offset 8 bytes
	        if (entry.relativeOffsetOfLocalHeader === 0xffffffff) {
	          if (index + 8 > zip64EiefBuffer.length) {
	            return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include relative header offset"));
	          }
	          entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
	          index += 8;
	        }
	        // 24 - Disk Start Number      4 bytes
	      }

	      // check for Info-ZIP Unicode Path Extra Field (0x7075)
	      // see https://github.com/thejoshwolfe/yauzl/issues/33
	      if (self.decodeStrings) {
	        for (var i = 0; i < entry.extraFields.length; i++) {
	          var extraField = entry.extraFields[i];
	          if (extraField.id === 0x7075) {
	            if (extraField.data.length < 6) {
	              // too short to be meaningful
	              continue;
	            }
	            // Version       1 byte      version of this extra field, currently 1
	            if (extraField.data.readUInt8(0) !== 1) {
	              // > Changes may not be backward compatible so this extra
	              // > field should not be used if the version is not recognized.
	              continue;
	            }
	            // NameCRC32     4 bytes     File Name Field CRC32 Checksum
	            var oldNameCrc32 = extraField.data.readUInt32LE(1);
	            if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
	              // > If the CRC check fails, this UTF-8 Path Extra Field should be
	              // > ignored and the File Name field in the header should be used instead.
	              continue;
	            }
	            // UnicodeName   Variable    UTF-8 version of the entry File Name
	            entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
	            break;
	          }
	        }
	      }

	      // validate file size
	      if (self.validateEntrySizes && entry.compressionMethod === 0) {
	        var expectedCompressedSize = entry.uncompressedSize;
	        if (entry.isEncrypted()) {
	          // traditional encryption prefixes the file data with a header
	          expectedCompressedSize += 12;
	        }
	        if (entry.compressedSize !== expectedCompressedSize) {
	          var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
	          return emitErrorAndAutoClose(self, new Error(msg));
	        }
	      }

	      if (self.decodeStrings) {
	        if (!self.strictFileNames) {
	          // allow backslash
	          entry.fileName = entry.fileName.replace(/\\/g, "/");
	        }
	        var errorMessage = validateFileName(entry.fileName, self.validateFileNameOptions);
	        if (errorMessage != null) return emitErrorAndAutoClose(self, new Error(errorMessage));
	      }
	      self.emit("entry", entry);

	      if (!self.lazyEntries) self._readEntry();
	    });
	  });
	};

	ZipFile.prototype.openReadStream = function(entry, options, callback) {
	  var self = this;
	  // parameter validation
	  var relativeStart = 0;
	  var relativeEnd = entry.compressedSize;
	  if (callback == null) {
	    callback = options;
	    options = {};
	  } else {
	    // validate options that the caller has no excuse to get wrong
	    if (options.decrypt != null) {
	      if (!entry.isEncrypted()) {
	        throw new Error("options.decrypt can only be specified for encrypted entries");
	      }
	      if (options.decrypt !== false) throw new Error("invalid options.decrypt value: " + options.decrypt);
	      if (entry.isCompressed()) {
	        if (options.decompress !== false) throw new Error("entry is encrypted and compressed, and options.decompress !== false");
	      }
	    }
	    if (options.decompress != null) {
	      if (!entry.isCompressed()) {
	        throw new Error("options.decompress can only be specified for compressed entries");
	      }
	      if (!(options.decompress === false || options.decompress === true)) {
	        throw new Error("invalid options.decompress value: " + options.decompress);
	      }
	    }
	    if (options.start != null || options.end != null) {
	      if (entry.isCompressed() && options.decompress !== false) {
	        throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
	      }
	      if (entry.isEncrypted() && options.decrypt !== false) {
	        throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
	      }
	    }
	    if (options.start != null) {
	      relativeStart = options.start;
	      if (relativeStart < 0) throw new Error("options.start < 0");
	      if (relativeStart > entry.compressedSize) throw new Error("options.start > entry.compressedSize");
	    }
	    if (options.end != null) {
	      relativeEnd = options.end;
	      if (relativeEnd < 0) throw new Error("options.end < 0");
	      if (relativeEnd > entry.compressedSize) throw new Error("options.end > entry.compressedSize");
	      if (relativeEnd < relativeStart) throw new Error("options.end < options.start");
	    }
	  }
	  // any further errors can either be caused by the zipfile,
	  // or were introduced in a minor version of yauzl,
	  // so should be passed to the client rather than thrown.
	  if (!self.isOpen) return callback(new Error("closed"));
	  if (entry.isEncrypted()) {
	    if (options.decrypt !== false) return callback(new Error("entry is encrypted, and options.decrypt !== false"));
	  }
	  // make sure we don't lose the fd before we open the actual read stream
	  self.reader.ref();
	  var buffer = newBuffer(30);
	  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
	    try {
	      if (err) return callback(err);
	      // 0 - Local file header signature = 0x04034b50
	      var signature = buffer.readUInt32LE(0);
	      if (signature !== 0x04034b50) {
	        return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
	      }
	      // all this should be redundant
	      // 4 - Version needed to extract (minimum)
	      // 6 - General purpose bit flag
	      // 8 - Compression method
	      // 10 - File last modification time
	      // 12 - File last modification date
	      // 14 - CRC-32
	      // 18 - Compressed size
	      // 22 - Uncompressed size
	      // 26 - File name length (n)
	      var fileNameLength = buffer.readUInt16LE(26);
	      // 28 - Extra field length (m)
	      var extraFieldLength = buffer.readUInt16LE(28);
	      // 30 - File name
	      // 30+n - Extra field
	      var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
	      var decompress;
	      if (entry.compressionMethod === 0) {
	        // 0 - The file is stored (no compression)
	        decompress = false;
	      } else if (entry.compressionMethod === 8) {
	        // 8 - The file is Deflated
	        decompress = options.decompress != null ? options.decompress : true;
	      } else {
	        return callback(new Error("unsupported compression method: " + entry.compressionMethod));
	      }
	      var fileDataStart = localFileHeaderEnd;
	      var fileDataEnd = fileDataStart + entry.compressedSize;
	      if (entry.compressedSize !== 0) {
	        // bounds check now, because the read streams will probably not complain loud enough.
	        // since we're dealing with an unsigned offset plus an unsigned size,
	        // we only have 1 thing to check for.
	        if (fileDataEnd > self.fileSize) {
	          return callback(new Error("file data overflows file bounds: " +
	              fileDataStart + " + " + entry.compressedSize + " > " + self.fileSize));
	        }
	      }
	      var readStream = self.reader.createReadStream({
	        start: fileDataStart + relativeStart,
	        end: fileDataStart + relativeEnd,
	      });
	      var endpointStream = readStream;
	      if (decompress) {
	        var destroyed = false;
	        var inflateFilter = zlib.createInflateRaw();
	        readStream.on("error", function(err) {
	          // setImmediate here because errors can be emitted during the first call to pipe()
	          setImmediate(function() {
	            if (!destroyed) inflateFilter.emit("error", err);
	          });
	        });
	        readStream.pipe(inflateFilter);

	        if (self.validateEntrySizes) {
	          endpointStream = new AssertByteCountStream(entry.uncompressedSize);
	          inflateFilter.on("error", function(err) {
	            // forward zlib errors to the client-visible stream
	            setImmediate(function() {
	              if (!destroyed) endpointStream.emit("error", err);
	            });
	          });
	          inflateFilter.pipe(endpointStream);
	        } else {
	          // the zlib filter is the client-visible stream
	          endpointStream = inflateFilter;
	        }
	        // this is part of yauzl's API, so implement this function on the client-visible stream
	        endpointStream.destroy = function() {
	          destroyed = true;
	          if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);
	          readStream.unpipe(inflateFilter);
	          // TODO: the inflateFilter may cause a memory leak. see Issue #27.
	          readStream.destroy();
	        };
	      }
	      callback(null, endpointStream);
	    } finally {
	      self.reader.unref();
	    }
	  });
	};

	function Entry() {
	}
	Entry.prototype.getLastModDate = function() {
	  return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
	};
	Entry.prototype.isEncrypted = function() {
	  return (this.generalPurposeBitFlag & 0x1) !== 0;
	};
	Entry.prototype.isCompressed = function() {
	  return this.compressionMethod === 8;
	};

	function dosDateTimeToDate(date, time) {
	  var day = date & 0x1f; // 1-31
	  var month = (date >> 5 & 0xf) - 1; // 1-12, 0-11
	  var year = (date >> 9 & 0x7f) + 1980; // 0-128, 1980-2108

	  var millisecond = 0;
	  var second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)
	  var minute = time >> 5 & 0x3f; // 0-59
	  var hour = time >> 11 & 0x1f; // 0-23

	  return new Date(year, month, day, hour, minute, second, millisecond);
	}

	function validateFileName(fileName) {
	  if (fileName.indexOf("\\") !== -1) {
	    return "invalid characters in fileName: " + fileName;
	  }
	  if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
	    return "absolute path: " + fileName;
	  }
	  if (fileName.split("/").indexOf("..") !== -1) {
	    return "invalid relative path: " + fileName;
	  }
	  // all good
	  return null;
	}

	function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
	  if (length === 0) {
	    // fs.read will throw an out-of-bounds error if you try to read 0 bytes from a 0 byte file
	    return setImmediate(function() { callback(null, newBuffer(0)); });
	  }
	  reader.read(buffer, offset, length, position, function(err, bytesRead) {
	    if (err) return callback(err);
	    if (bytesRead < length) {
	      return callback(new Error("unexpected EOF"));
	    }
	    callback();
	  });
	}

	util.inherits(AssertByteCountStream, Transform);
	function AssertByteCountStream(byteCount) {
	  Transform.call(this);
	  this.actualByteCount = 0;
	  this.expectedByteCount = byteCount;
	}
	AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
	  this.actualByteCount += chunk.length;
	  if (this.actualByteCount > this.expectedByteCount) {
	    var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
	    return cb(new Error(msg));
	  }
	  cb(null, chunk);
	};
	AssertByteCountStream.prototype._flush = function(cb) {
	  if (this.actualByteCount < this.expectedByteCount) {
	    var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
	    return cb(new Error(msg));
	  }
	  cb();
	};

	util.inherits(RandomAccessReader, EventEmitter);
	function RandomAccessReader() {
	  EventEmitter.call(this);
	  this.refCount = 0;
	}
	RandomAccessReader.prototype.ref = function() {
	  this.refCount += 1;
	};
	RandomAccessReader.prototype.unref = function() {
	  var self = this;
	  self.refCount -= 1;

	  if (self.refCount > 0) return;
	  if (self.refCount < 0) throw new Error("invalid unref");

	  self.close(onCloseDone);

	  function onCloseDone(err) {
	    if (err) return self.emit('error', err);
	    self.emit('close');
	  }
	};
	RandomAccessReader.prototype.createReadStream = function(options) {
	  var start = options.start;
	  var end = options.end;
	  if (start === end) {
	    var emptyStream = new PassThrough();
	    setImmediate(function() {
	      emptyStream.end();
	    });
	    return emptyStream;
	  }
	  var stream = this._readStreamForRange(start, end);

	  var destroyed = false;
	  var refUnrefFilter = new RefUnrefFilter(this);
	  stream.on("error", function(err) {
	    setImmediate(function() {
	      if (!destroyed) refUnrefFilter.emit("error", err);
	    });
	  });
	  refUnrefFilter.destroy = function() {
	    stream.unpipe(refUnrefFilter);
	    refUnrefFilter.unref();
	    stream.destroy();
	  };

	  var byteCounter = new AssertByteCountStream(end - start);
	  refUnrefFilter.on("error", function(err) {
	    setImmediate(function() {
	      if (!destroyed) byteCounter.emit("error", err);
	    });
	  });
	  byteCounter.destroy = function() {
	    destroyed = true;
	    refUnrefFilter.unpipe(byteCounter);
	    refUnrefFilter.destroy();
	  };

	  return stream.pipe(refUnrefFilter).pipe(byteCounter);
	};
	RandomAccessReader.prototype._readStreamForRange = function(start, end) {
	  throw new Error("not implemented");
	};
	RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
	  var readStream = this.createReadStream({start: position, end: position + length});
	  var writeStream = new Writable();
	  var written = 0;
	  writeStream._write = function(chunk, encoding, cb) {
	    chunk.copy(buffer, offset + written, 0, chunk.length);
	    written += chunk.length;
	    cb();
	  };
	  writeStream.on("finish", callback);
	  readStream.on("error", function(error) {
	    callback(error);
	  });
	  readStream.pipe(writeStream);
	};
	RandomAccessReader.prototype.close = function(callback) {
	  setImmediate(callback);
	};

	util.inherits(RefUnrefFilter, PassThrough);
	function RefUnrefFilter(context) {
	  PassThrough.call(this);
	  this.context = context;
	  this.context.ref();
	  this.unreffedYet = false;
	}
	RefUnrefFilter.prototype._flush = function(cb) {
	  this.unref();
	  cb();
	};
	RefUnrefFilter.prototype.unref = function(cb) {
	  if (this.unreffedYet) return;
	  this.unreffedYet = true;
	  this.context.unref();
	};

	var cp437 = '\u0000☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ';
	function decodeBuffer(buffer, start, end, isUtf8) {
	  if (isUtf8) {
	    return buffer.toString("utf8", start, end);
	  } else {
	    var result = "";
	    for (var i = start; i < end; i++) {
	      result += cp437[buffer[i]];
	    }
	    return result;
	  }
	}

	function readUInt64LE(buffer, offset) {
	  // there is no native function for this, because we can't actually store 64-bit integers precisely.
	  // after 53 bits, JavaScript's Number type (IEEE 754 double) can't store individual integers anymore.
	  // but since 53 bits is a whole lot more than 32 bits, we do our best anyway.
	  var lower32 = buffer.readUInt32LE(offset);
	  var upper32 = buffer.readUInt32LE(offset + 4);
	  // we can't use bitshifting here, because JavaScript bitshifting only works on 32-bit integers.
	  return upper32 * 0x100000000 + lower32;
	  // as long as we're bounds checking the result of this function against the total file size,
	  // we'll catch any overflow errors, because we already made sure the total file size was within reason.
	}

	// Node 10 deprecated new Buffer().
	var newBuffer;
	if (typeof Buffer.allocUnsafe === "function") {
	  newBuffer = function(len) {
	    return Buffer.allocUnsafe(len);
	  };
	} else {
	  newBuffer = function(len) {
	    return new Buffer(len);
	  };
	}

	function defaultCallback(err) {
	  if (err) throw err;
	}
	return yauzl;
}

var decompressUnzip;
var hasRequiredDecompressUnzip;

function requireDecompressUnzip () {
	if (hasRequiredDecompressUnzip) return decompressUnzip;
	hasRequiredDecompressUnzip = 1;
	const fileType = requireFileType();
	const getStream = requireGetStream();
	const pify = requirePify$1();
	const yauzl = requireYauzl();

	const getType = (entry, mode) => {
		const IFMT = 61440;
		const IFDIR = 16384;
		const IFLNK = 40960;
		const madeBy = entry.versionMadeBy >> 8;

		if ((mode & IFMT) === IFLNK) {
			return 'symlink';
		}

		if ((mode & IFMT) === IFDIR || (madeBy === 0 && entry.externalFileAttributes === 16)) {
			return 'directory';
		}

		return 'file';
	};

	const extractEntry = (entry, zip) => {
		const file = {
			mode: (entry.externalFileAttributes >> 16) & 0xFFFF,
			mtime: entry.getLastModDate(),
			path: entry.fileName
		};

		file.type = getType(entry, file.mode);

		if (file.mode === 0 && file.type === 'directory') {
			file.mode = 493;
		}

		if (file.mode === 0) {
			file.mode = 420;
		}

		return pify(zip.openReadStream.bind(zip))(entry)
			.then(getStream.buffer)
			.then(buf => {
				file.data = buf;

				if (file.type === 'symlink') {
					file.linkname = buf.toString();
				}

				return file;
			})
			.catch(err => {
				zip.close();
				throw err;
			});
	};

	const extractFile = zip => new Promise((resolve, reject) => {
		const files = [];

		zip.readEntry();

		zip.on('entry', entry => {
			extractEntry(entry, zip)
				.catch(reject)
				.then(file => {
					files.push(file);
					zip.readEntry();
				});
		});

		zip.on('error', reject);
		zip.on('end', () => resolve(files));
	});

	decompressUnzip = () => buf => {
		if (!Buffer.isBuffer(buf)) {
			return Promise.reject(new TypeError(`Expected a Buffer, got ${typeof buf}`));
		}

		if (!fileType(buf) || fileType(buf).ext !== 'zip') {
			return Promise.resolve([]);
		}

		return pify(yauzl.fromBuffer)(buf, {lazyEntries: true}).then(extractFile);
	};
	return decompressUnzip;
}

var makeDir = {exports: {}};

var pify;
var hasRequiredPify;

function requirePify () {
	if (hasRequiredPify) return pify;
	hasRequiredPify = 1;

	const processFn = (fn, opts) => function () {
		const P = opts.promiseModule;
		const args = new Array(arguments.length);

		for (let i = 0; i < arguments.length; i++) {
			args[i] = arguments[i];
		}

		return new P((resolve, reject) => {
			if (opts.errorFirst) {
				args.push(function (err, result) {
					if (opts.multiArgs) {
						const results = new Array(arguments.length - 1);

						for (let i = 1; i < arguments.length; i++) {
							results[i - 1] = arguments[i];
						}

						if (err) {
							results.unshift(err);
							reject(results);
						} else {
							resolve(results);
						}
					} else if (err) {
						reject(err);
					} else {
						resolve(result);
					}
				});
			} else {
				args.push(function (result) {
					if (opts.multiArgs) {
						const results = new Array(arguments.length - 1);

						for (let i = 0; i < arguments.length; i++) {
							results[i] = arguments[i];
						}

						resolve(results);
					} else {
						resolve(result);
					}
				});
			}

			fn.apply(this, args);
		});
	};

	pify = (obj, opts) => {
		opts = Object.assign({
			exclude: [/.+(Sync|Stream)$/],
			errorFirst: true,
			promiseModule: Promise
		}, opts);

		const filter = key => {
			const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
			return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
		};

		let ret;
		if (typeof obj === 'function') {
			ret = function () {
				if (opts.excludeMain) {
					return obj.apply(this, arguments);
				}

				return processFn(obj, opts).apply(this, arguments);
			};
		} else {
			ret = Object.create(Object.getPrototypeOf(obj));
		}

		for (const key in obj) { // eslint-disable-line guard-for-in
			const x = obj[key];
			ret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;
		}

		return ret;
	};
	return pify;
}

var hasRequiredMakeDir;

function requireMakeDir () {
	if (hasRequiredMakeDir) return makeDir.exports;
	hasRequiredMakeDir = 1;
	const fs = require$$0$8;
	const path = require$$1$4;
	const pify = requirePify();

	const defaults = {
		mode: 0o777 & (~process.umask()),
		fs
	};

	// https://github.com/nodejs/node/issues/8987
	// https://github.com/libuv/libuv/pull/1088
	const checkPath = pth => {
		if (process.platform === 'win32') {
			const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ''));

			if (pathHasInvalidWinCharacters) {
				const err = new Error(`Path contains invalid characters: ${pth}`);
				err.code = 'EINVAL';
				throw err;
			}
		}
	};

	makeDir.exports = (input, opts) => Promise.resolve().then(() => {
		checkPath(input);
		opts = Object.assign({}, defaults, opts);

		const mkdir = pify(opts.fs.mkdir);
		const stat = pify(opts.fs.stat);

		const make = pth => {
			return mkdir(pth, opts.mode)
				.then(() => pth)
				.catch(err => {
					if (err.code === 'ENOENT') {
						if (err.message.includes('null bytes') || path.dirname(pth) === pth) {
							throw err;
						}

						return make(path.dirname(pth)).then(() => make(pth));
					}

					return stat(pth)
						.then(stats => stats.isDirectory() ? pth : Promise.reject())
						.catch(() => {
							throw err;
						});
				});
		};

		return make(path.resolve(input));
	});

	makeDir.exports.sync = (input, opts) => {
		checkPath(input);
		opts = Object.assign({}, defaults, opts);

		const make = pth => {
			try {
				opts.fs.mkdirSync(pth, opts.mode);
			} catch (err) {
				if (err.code === 'ENOENT') {
					if (err.message.includes('null bytes') || path.dirname(pth) === pth) {
						throw err;
					}

					make(path.dirname(pth));
					return make(pth);
				}

				try {
					if (!opts.fs.statSync(pth).isDirectory()) {
						throw new Error('The path is not a directory');
					}
				} catch (_) {
					throw err;
				}
			}

			return pth;
		};

		return make(path.resolve(input));
	};
	return makeDir.exports;
}

/*!
 * is-natural-number.js | MIT (c) Shinnosuke Watanabe
 * https://github.com/shinnn/is-natural-number.js
*/

var isNaturalNumber;
var hasRequiredIsNaturalNumber;

function requireIsNaturalNumber () {
	if (hasRequiredIsNaturalNumber) return isNaturalNumber;
	hasRequiredIsNaturalNumber = 1;

	isNaturalNumber = function isNaturalNumber(val, option) {
	  if (option) {
	    if (typeof option !== 'object') {
	      throw new TypeError(
	        String(option) +
	        ' is not an object. Expected an object that has boolean `includeZero` property.'
	      );
	    }

	    if ('includeZero' in option) {
	      if (typeof option.includeZero !== 'boolean') {
	        throw new TypeError(
	          String(option.includeZero) +
	          ' is neither true nor false. `includeZero` option must be a Boolean value.'
	        );
	      }

	      if (option.includeZero && val === 0) {
	        return true;
	      }
	    }
	  }

	  return Number.isSafeInteger(val) && val >= 1;
	};
	return isNaturalNumber;
}

/*!
 * strip-dirs | MIT (c) Shinnosuke Watanabe
 * https://github.com/shinnn/node-strip-dirs
*/

var stripDirs;
var hasRequiredStripDirs;

function requireStripDirs () {
	if (hasRequiredStripDirs) return stripDirs;
	hasRequiredStripDirs = 1;

	const path = require$$1$4;
	const util = require$$1$2;

	const isNaturalNumber = requireIsNaturalNumber();

	stripDirs = function stripDirs(pathStr, count, option) {
	  if (typeof pathStr !== 'string') {
	    throw new TypeError(
	      util.inspect(pathStr) +
	      ' is not a string. First argument to strip-dirs must be a path string.'
	    );
	  }

	  if (path.posix.isAbsolute(pathStr) || path.win32.isAbsolute(pathStr)) {
	    throw new Error(`${pathStr} is an absolute path. strip-dirs requires a relative path.`);
	  }

	  if (!isNaturalNumber(count, {includeZero: true})) {
	    throw new Error(
	      'The Second argument of strip-dirs must be a natural number or 0, but received ' +
	      util.inspect(count) +
	      '.'
	    );
	  }

	  if (option) {
	    if (typeof option !== 'object') {
	      throw new TypeError(
	        util.inspect(option) +
	        ' is not an object. Expected an object with a boolean `disallowOverflow` property.'
	      );
	    }

	    if (Array.isArray(option)) {
	      throw new TypeError(
	        util.inspect(option) +
	        ' is an array. Expected an object with a boolean `disallowOverflow` property.'
	      );
	    }

	    if ('disallowOverflow' in option && typeof option.disallowOverflow !== 'boolean') {
	      throw new TypeError(
	        util.inspect(option.disallowOverflow) +
	        ' is neither true nor false. `disallowOverflow` option must be a Boolean value.'
	      );
	    }
	  } else {
	    option = {disallowOverflow: false};
	  }

	  const pathComponents = path.normalize(pathStr).split(path.sep);

	  if (pathComponents.length > 1 && pathComponents[0] === '.') {
	    pathComponents.shift();
	  }

	  if (count > pathComponents.length - 1) {
	    if (option.disallowOverflow) {
	      throw new RangeError('Cannot strip more directories than there are.');
	    }

	    count = pathComponents.length - 1;
	  }

	  return path.join.apply(null, pathComponents.slice(count));
	};
	return stripDirs;
}

var decompress;
var hasRequiredDecompress;

function requireDecompress () {
	if (hasRequiredDecompress) return decompress;
	hasRequiredDecompress = 1;
	const path = require$$1$4;
	const fs = requireGracefulFs();
	const decompressTar = requireDecompressTar();
	const decompressTarbz2 = requireDecompressTarbz2();
	const decompressTargz = requireDecompressTargz();
	const decompressUnzip = requireDecompressUnzip();
	const makeDir = requireMakeDir();
	const pify = requirePify$1();
	const stripDirs = requireStripDirs();

	const fsP = pify(fs);

	const runPlugins = (input, opts) => {
		if (opts.plugins.length === 0) {
			return Promise.resolve([]);
		}

		return Promise.all(opts.plugins.map(x => x(input, opts))).then(files => files.reduce((a, b) => a.concat(b)));
	};

	const safeMakeDir = (dir, realOutputPath) => {
		return fsP.realpath(dir)
			.catch(_ => {
				const parent = path.dirname(dir);
				return safeMakeDir(parent, realOutputPath);
			})
			.then(realParentPath => {
				if (realParentPath.indexOf(realOutputPath) !== 0) {
					throw (new Error('Refusing to create a directory outside the output path.'));
				}

				return makeDir(dir).then(fsP.realpath);
			});
	};

	const preventWritingThroughSymlink = (destination, realOutputPath) => {
		return fsP.readlink(destination)
			.catch(_ => {
				// Either no file exists, or it's not a symlink. In either case, this is
				// not an escape we need to worry about in this phase.
				return null;
			})
			.then(symlinkPointsTo => {
				if (symlinkPointsTo) {
					throw new Error('Refusing to write into a symlink');
				}

				// No symlink exists at `destination`, so we can continue
				return realOutputPath;
			});
	};

	const extractFile = (input, output, opts) => runPlugins(input, opts).then(files => {
		if (opts.strip > 0) {
			files = files
				.map(x => {
					x.path = stripDirs(x.path, opts.strip);
					return x;
				})
				.filter(x => x.path !== '.');
		}

		if (typeof opts.filter === 'function') {
			files = files.filter(opts.filter);
		}

		if (typeof opts.map === 'function') {
			files = files.map(opts.map);
		}

		if (!output) {
			return files;
		}

		return Promise.all(files.map(x => {
			const dest = path.join(output, x.path);
			const mode = x.mode & ~process.umask();
			const now = new Date();

			if (x.type === 'directory') {
				return makeDir(output)
					.then(outputPath => fsP.realpath(outputPath))
					.then(realOutputPath => safeMakeDir(dest, realOutputPath))
					.then(() => fsP.utimes(dest, now, x.mtime))
					.then(() => x);
			}

			return makeDir(output)
				.then(outputPath => fsP.realpath(outputPath))
				.then(realOutputPath => {
					// Attempt to ensure parent directory exists (failing if it's outside the output dir)
					return safeMakeDir(path.dirname(dest), realOutputPath)
						.then(() => realOutputPath);
				})
				.then(realOutputPath => {
					if (x.type === 'file') {
						return preventWritingThroughSymlink(dest, realOutputPath);
					}

					return realOutputPath;
				})
				.then(realOutputPath => {
					return fsP.realpath(path.dirname(dest))
						.then(realDestinationDir => {
							if (realDestinationDir.indexOf(realOutputPath) !== 0) {
								throw (new Error('Refusing to write outside output directory: ' + realDestinationDir));
							}
						});
				})
				.then(() => {
					if (x.type === 'link') {
						return fsP.link(x.linkname, dest);
					}

					if (x.type === 'symlink' && process.platform === 'win32') {
						return fsP.link(x.linkname, dest);
					}

					if (x.type === 'symlink') {
						return fsP.symlink(x.linkname, dest);
					}

					return fsP.writeFile(dest, x.data, {mode});
				})
				.then(() => x.type === 'file' && fsP.utimes(dest, now, x.mtime))
				.then(() => x);
		}));
	});

	decompress = (input, output, opts) => {
		if (typeof input !== 'string' && !Buffer.isBuffer(input)) {
			return Promise.reject(new TypeError('Input file required'));
		}

		if (typeof output === 'object') {
			opts = output;
			output = null;
		}

		opts = Object.assign({plugins: [
			decompressTar(),
			decompressTarbz2(),
			decompressTargz(),
			decompressUnzip()
		]}, opts);

		const read = typeof input === 'string' ? fsP.readFile(input) : Promise.resolve(input);

		return read.then(buf => extractFile(buf, output, opts));
	};
	return decompress;
}

var gitFactory = {};

var api = {};

var gitConstructError = {};

var gitError = {};

var hasRequiredGitError;

function requireGitError () {
	if (hasRequiredGitError) return gitError;
	hasRequiredGitError = 1;
	Object.defineProperty(gitError, "__esModule", { value: true });
	gitError.GitError = void 0;
	/**
	 * The `GitError` is thrown when the underlying `git` process throws a
	 * fatal exception (eg an `ENOENT` exception when attempting to use a
	 * non-writable directory as the root for your repo), and acts as the
	 * base class for more specific errors thrown by the parsing of the
	 * git response or errors in the configuration of the task about to
	 * be run.
	 *
	 * When an exception is thrown, pending tasks in the same instance will
	 * not be executed. The recommended way to run a series of tasks that
	 * can independently fail without needing to prevent future tasks from
	 * running is to catch them individually:
	 *
	 * ```typescript
	 import { gitP, SimpleGit, GitError, PullResult } from 'simple-git';

	 function catchTask (e: GitError) {
	   return e.
	 }

	 const git = gitP(repoWorkingDir);
	 const pulled: PullResult | GitError = await git.pull().catch(catchTask);
	 const pushed: string | GitError = await git.pushTags().catch(catchTask);
	 ```
	 */
	class GitError extends Error {
	    constructor(task, message) {
	        super(message);
	        this.task = task;
	        Object.setPrototypeOf(this, new.target.prototype);
	    }
	}
	gitError.GitError = GitError;
	
	return gitError;
}

var hasRequiredGitConstructError;

function requireGitConstructError () {
	if (hasRequiredGitConstructError) return gitConstructError;
	hasRequiredGitConstructError = 1;
	Object.defineProperty(gitConstructError, "__esModule", { value: true });
	gitConstructError.GitConstructError = void 0;
	const git_error_1 = requireGitError();
	/**
	 * The `GitConstructError` is thrown when an error occurs in the constructor
	 * of the `simple-git` instance itself. Most commonly as a result of using
	 * a `baseDir` option that points to a folder that either does not exist,
	 * or cannot be read by the user the node script is running as.
	 *
	 * Check the `.message` property for more detail including the properties
	 * passed to the constructor.
	 */
	class GitConstructError extends git_error_1.GitError {
	    constructor(config, message) {
	        super(undefined, message);
	        this.config = config;
	    }
	}
	gitConstructError.GitConstructError = GitConstructError;
	
	return gitConstructError;
}

var gitPluginError = {};

var hasRequiredGitPluginError;

function requireGitPluginError () {
	if (hasRequiredGitPluginError) return gitPluginError;
	hasRequiredGitPluginError = 1;
	Object.defineProperty(gitPluginError, "__esModule", { value: true });
	gitPluginError.GitPluginError = void 0;
	const git_error_1 = requireGitError();
	class GitPluginError extends git_error_1.GitError {
	    constructor(task, plugin, message) {
	        super(task, message);
	        this.task = task;
	        this.plugin = plugin;
	        Object.setPrototypeOf(this, new.target.prototype);
	    }
	}
	gitPluginError.GitPluginError = GitPluginError;
	
	return gitPluginError;
}

var gitResponseError = {};

var hasRequiredGitResponseError;

function requireGitResponseError () {
	if (hasRequiredGitResponseError) return gitResponseError;
	hasRequiredGitResponseError = 1;
	Object.defineProperty(gitResponseError, "__esModule", { value: true });
	gitResponseError.GitResponseError = void 0;
	const git_error_1 = requireGitError();
	/**
	 * The `GitResponseError` is the wrapper for a parsed response that is treated as
	 * a fatal error, for example attempting a `merge` can leave the repo in a corrupted
	 * state when there are conflicts so the task will reject rather than resolve.
	 *
	 * For example, catching the merge conflict exception:
	 *
	 * ```typescript
	 import { gitP, SimpleGit, GitResponseError, MergeSummary } from 'simple-git';

	 const git = gitP(repoRoot);
	 const mergeOptions: string[] = ['--no-ff', 'other-branch'];
	 const mergeSummary: MergeSummary = await git.merge(mergeOptions)
	      .catch((e: GitResponseError<MergeSummary>) => e.git);

	 if (mergeSummary.failed) {
	   // deal with the error
	 }
	 ```
	 */
	class GitResponseError extends git_error_1.GitError {
	    constructor(
	    /**
	     * `.git` access the parsed response that is treated as being an error
	     */
	    git, message) {
	        super(undefined, message || String(git));
	        this.git = git;
	    }
	}
	gitResponseError.GitResponseError = GitResponseError;
	
	return gitResponseError;
}

var taskConfigurationError = {};

var hasRequiredTaskConfigurationError;

function requireTaskConfigurationError () {
	if (hasRequiredTaskConfigurationError) return taskConfigurationError;
	hasRequiredTaskConfigurationError = 1;
	Object.defineProperty(taskConfigurationError, "__esModule", { value: true });
	taskConfigurationError.TaskConfigurationError = void 0;
	const git_error_1 = requireGitError();
	/**
	 * The `TaskConfigurationError` is thrown when a command was incorrectly
	 * configured. An error of this kind means that no attempt was made to
	 * run your command through the underlying `git` binary.
	 *
	 * Check the `.message` property for more detail on why your configuration
	 * resulted in an error.
	 */
	class TaskConfigurationError extends git_error_1.GitError {
	    constructor(message) {
	        super(undefined, message);
	    }
	}
	taskConfigurationError.TaskConfigurationError = TaskConfigurationError;
	
	return taskConfigurationError;
}

var checkIsRepo = {};

var utils = {};

var argumentFilters = {};

var util = {};

var dist$2 = {};

var src = {};

var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src;
	hasRequiredSrc = 1;
	(function (exports) {
		var __importDefault = (src && src.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		const fs_1 = require$$0$8;
		const debug_1 = __importDefault(requireSrc$1());
		const log = debug_1.default('@kwsites/file-exists');
		function check(path, isFile, isDirectory) {
		    log(`checking %s`, path);
		    try {
		        const stat = fs_1.statSync(path);
		        if (stat.isFile() && isFile) {
		            log(`[OK] path represents a file`);
		            return true;
		        }
		        if (stat.isDirectory() && isDirectory) {
		            log(`[OK] path represents a directory`);
		            return true;
		        }
		        log(`[FAIL] path represents something other than a file or directory`);
		        return false;
		    }
		    catch (e) {
		        if (e.code === 'ENOENT') {
		            log(`[FAIL] path is not accessible: %o`, e);
		            return false;
		        }
		        log(`[FATAL] %o`, e);
		        throw e;
		    }
		}
		/**
		 * Synchronous validation of a path existing either as a file or as a directory.
		 *
		 * @param {string} path The path to check
		 * @param {number} type One or both of the exported numeric constants
		 */
		function exists(path, type = exports.READABLE) {
		    return check(path, (type & exports.FILE) > 0, (type & exports.FOLDER) > 0);
		}
		exports.exists = exists;
		/**
		 * Constant representing a file
		 */
		exports.FILE = 1;
		/**
		 * Constant representing a folder
		 */
		exports.FOLDER = 2;
		/**
		 * Constant representing either a file or a folder
		 */
		exports.READABLE = exports.FILE + exports.FOLDER;
		
	} (src));
	return src;
}

var hasRequiredDist$1;

function requireDist$1 () {
	if (hasRequiredDist$1) return dist$2;
	hasRequiredDist$1 = 1;
	(function (exports) {
		function __export(m) {
		    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
		}
		Object.defineProperty(exports, "__esModule", { value: true });
		__export(requireSrc());
		
	} (dist$2));
	return dist$2;
}

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.delay = exports.pick = exports.bufferToString = exports.prefixedArray = exports.asNumber = exports.asStringArray = exports.asArray = exports.objectToString = exports.remove = exports.including = exports.append = exports.folderExists = exports.forEachLineWithContent = exports.toLinesWithContent = exports.last = exports.first = exports.splitOn = exports.isUserFunction = exports.asFunction = exports.NOOP = exports.NULL = void 0;
		const file_exists_1 = requireDist$1();
		exports.NULL = '\0';
		const NOOP = () => {
		};
		exports.NOOP = NOOP;
		/**
		 * Returns either the source argument when it is a `Function`, or the default
		 * `NOOP` function constant
		 */
		function asFunction(source) {
		    return typeof source === 'function' ? source : exports.NOOP;
		}
		exports.asFunction = asFunction;
		/**
		 * Determines whether the supplied argument is both a function, and is not
		 * the `NOOP` function.
		 */
		function isUserFunction(source) {
		    return (typeof source === 'function' && source !== exports.NOOP);
		}
		exports.isUserFunction = isUserFunction;
		function splitOn(input, char) {
		    const index = input.indexOf(char);
		    if (index <= 0) {
		        return [input, ''];
		    }
		    return [
		        input.substr(0, index),
		        input.substr(index + 1),
		    ];
		}
		exports.splitOn = splitOn;
		function first(input, offset = 0) {
		    return isArrayLike(input) && input.length > offset ? input[offset] : undefined;
		}
		exports.first = first;
		function last(input, offset = 0) {
		    if (isArrayLike(input) && input.length > offset) {
		        return input[input.length - 1 - offset];
		    }
		}
		exports.last = last;
		function isArrayLike(input) {
		    return !!(input && typeof input.length === 'number');
		}
		function toLinesWithContent(input, trimmed = true, separator = '\n') {
		    return input.split(separator)
		        .reduce((output, line) => {
		        const lineContent = trimmed ? line.trim() : line;
		        if (lineContent) {
		            output.push(lineContent);
		        }
		        return output;
		    }, []);
		}
		exports.toLinesWithContent = toLinesWithContent;
		function forEachLineWithContent(input, callback) {
		    return toLinesWithContent(input, true).map(line => callback(line));
		}
		exports.forEachLineWithContent = forEachLineWithContent;
		function folderExists(path) {
		    return file_exists_1.exists(path, file_exists_1.FOLDER);
		}
		exports.folderExists = folderExists;
		/**
		 * Adds `item` into the `target` `Array` or `Set` when it is not already present and returns the `item`.
		 */
		function append(target, item) {
		    if (Array.isArray(target)) {
		        if (!target.includes(item)) {
		            target.push(item);
		        }
		    }
		    else {
		        target.add(item);
		    }
		    return item;
		}
		exports.append = append;
		/**
		 * Adds `item` into the `target` `Array` when it is not already present and returns the `target`.
		 */
		function including(target, item) {
		    if (Array.isArray(target) && !target.includes(item)) {
		        target.push(item);
		    }
		    return target;
		}
		exports.including = including;
		function remove(target, item) {
		    if (Array.isArray(target)) {
		        const index = target.indexOf(item);
		        if (index >= 0) {
		            target.splice(index, 1);
		        }
		    }
		    else {
		        target.delete(item);
		    }
		    return item;
		}
		exports.remove = remove;
		exports.objectToString = Object.prototype.toString.call.bind(Object.prototype.toString);
		function asArray(source) {
		    return Array.isArray(source) ? source : [source];
		}
		exports.asArray = asArray;
		function asStringArray(source) {
		    return asArray(source).map(String);
		}
		exports.asStringArray = asStringArray;
		function asNumber(source, onNaN = 0) {
		    if (source == null) {
		        return onNaN;
		    }
		    const num = parseInt(source, 10);
		    return isNaN(num) ? onNaN : num;
		}
		exports.asNumber = asNumber;
		function prefixedArray(input, prefix) {
		    const output = [];
		    for (let i = 0, max = input.length; i < max; i++) {
		        output.push(prefix, input[i]);
		    }
		    return output;
		}
		exports.prefixedArray = prefixedArray;
		function bufferToString(input) {
		    return (Array.isArray(input) ? Buffer.concat(input) : input).toString('utf-8');
		}
		exports.bufferToString = bufferToString;
		/**
		 * Get a new object from a source object with only the listed properties.
		 */
		function pick(source, properties) {
		    return Object.assign({}, ...properties.map((property) => property in source ? { [property]: source[property] } : {}));
		}
		exports.pick = pick;
		function delay(duration = 0) {
		    return new Promise(done => setTimeout(done, duration));
		}
		exports.delay = delay;
		
	} (util));
	return util;
}

var hasRequiredArgumentFilters;

function requireArgumentFilters () {
	if (hasRequiredArgumentFilters) return argumentFilters;
	hasRequiredArgumentFilters = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.filterHasLength = exports.filterFunction = exports.filterPlainObject = exports.filterStringOrStringArray = exports.filterStringArray = exports.filterString = exports.filterPrimitives = exports.filterArray = exports.filterType = void 0;
		const util_1 = requireUtil();
		function filterType(input, filter, def) {
		    if (filter(input)) {
		        return input;
		    }
		    return (arguments.length > 2) ? def : undefined;
		}
		exports.filterType = filterType;
		const filterArray = (input) => {
		    return Array.isArray(input);
		};
		exports.filterArray = filterArray;
		function filterPrimitives(input, omit) {
		    return /number|string|boolean/.test(typeof input) && (!omit || !omit.includes((typeof input)));
		}
		exports.filterPrimitives = filterPrimitives;
		const filterString = (input) => {
		    return typeof input === 'string';
		};
		exports.filterString = filterString;
		const filterStringArray = (input) => {
		    return Array.isArray(input) && input.every(exports.filterString);
		};
		exports.filterStringArray = filterStringArray;
		const filterStringOrStringArray = (input) => {
		    return exports.filterString(input) || (Array.isArray(input) && input.every(exports.filterString));
		};
		exports.filterStringOrStringArray = filterStringOrStringArray;
		function filterPlainObject(input) {
		    return !!input && util_1.objectToString(input) === '[object Object]';
		}
		exports.filterPlainObject = filterPlainObject;
		function filterFunction(input) {
		    return typeof input === 'function';
		}
		exports.filterFunction = filterFunction;
		const filterHasLength = (input) => {
		    if (input == null || 'number|boolean|function'.includes(typeof input)) {
		        return false;
		    }
		    return Array.isArray(input) || typeof input === 'string' || typeof input.length === 'number';
		};
		exports.filterHasLength = filterHasLength;
		
	} (argumentFilters));
	return argumentFilters;
}

var exitCodes = {};

var hasRequiredExitCodes;

function requireExitCodes () {
	if (hasRequiredExitCodes) return exitCodes;
	hasRequiredExitCodes = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ExitCodes = void 0;
		(function (ExitCodes) {
		    ExitCodes[ExitCodes["SUCCESS"] = 0] = "SUCCESS";
		    ExitCodes[ExitCodes["ERROR"] = 1] = "ERROR";
		    ExitCodes[ExitCodes["UNCLEAN"] = 128] = "UNCLEAN";
		})(exports.ExitCodes || (exports.ExitCodes = {}));
		
	} (exitCodes));
	return exitCodes;
}

var gitOutputStreams = {};

var hasRequiredGitOutputStreams;

function requireGitOutputStreams () {
	if (hasRequiredGitOutputStreams) return gitOutputStreams;
	hasRequiredGitOutputStreams = 1;
	Object.defineProperty(gitOutputStreams, "__esModule", { value: true });
	gitOutputStreams.GitOutputStreams = void 0;
	class GitOutputStreams {
	    constructor(stdOut, stdErr) {
	        this.stdOut = stdOut;
	        this.stdErr = stdErr;
	    }
	    asStrings() {
	        return new GitOutputStreams(this.stdOut.toString('utf8'), this.stdErr.toString('utf8'));
	    }
	}
	gitOutputStreams.GitOutputStreams = GitOutputStreams;
	
	return gitOutputStreams;
}

var lineParser = {};

var hasRequiredLineParser;

function requireLineParser () {
	if (hasRequiredLineParser) return lineParser;
	hasRequiredLineParser = 1;
	Object.defineProperty(lineParser, "__esModule", { value: true });
	lineParser.RemoteLineParser = lineParser.LineParser = void 0;
	class LineParser {
	    constructor(regExp, useMatches) {
	        this.matches = [];
	        this.parse = (line, target) => {
	            this.resetMatches();
	            if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {
	                return false;
	            }
	            return this.useMatches(target, this.prepareMatches()) !== false;
	        };
	        this._regExp = Array.isArray(regExp) ? regExp : [regExp];
	        if (useMatches) {
	            this.useMatches = useMatches;
	        }
	    }
	    // @ts-ignore
	    useMatches(target, match) {
	        throw new Error(`LineParser:useMatches not implemented`);
	    }
	    resetMatches() {
	        this.matches.length = 0;
	    }
	    prepareMatches() {
	        return this.matches;
	    }
	    addMatch(reg, index, line) {
	        const matched = line && reg.exec(line);
	        if (matched) {
	            this.pushMatch(index, matched);
	        }
	        return !!matched;
	    }
	    pushMatch(_index, matched) {
	        this.matches.push(...matched.slice(1));
	    }
	}
	lineParser.LineParser = LineParser;
	class RemoteLineParser extends LineParser {
	    addMatch(reg, index, line) {
	        return /^remote:\s/.test(String(line)) && super.addMatch(reg, index, line);
	    }
	    pushMatch(index, matched) {
	        if (index > 0 || matched.length > 1) {
	            super.pushMatch(index, matched);
	        }
	    }
	}
	lineParser.RemoteLineParser = RemoteLineParser;
	
	return lineParser;
}

var simpleGitOptions = {};

var hasRequiredSimpleGitOptions;

function requireSimpleGitOptions () {
	if (hasRequiredSimpleGitOptions) return simpleGitOptions;
	hasRequiredSimpleGitOptions = 1;
	Object.defineProperty(simpleGitOptions, "__esModule", { value: true });
	simpleGitOptions.createInstanceConfig = void 0;
	const defaultOptions = {
	    binary: 'git',
	    maxConcurrentProcesses: 5,
	    config: [],
	};
	function createInstanceConfig(...options) {
	    const baseDir = process.cwd();
	    const config = Object.assign(Object.assign({ baseDir }, defaultOptions), ...(options.filter(o => typeof o === 'object' && o)));
	    config.baseDir = config.baseDir || baseDir;
	    return config;
	}
	simpleGitOptions.createInstanceConfig = createInstanceConfig;
	
	return simpleGitOptions;
}

var taskOptions = {};

var hasRequiredTaskOptions;

function requireTaskOptions () {
	if (hasRequiredTaskOptions) return taskOptions;
	hasRequiredTaskOptions = 1;
	Object.defineProperty(taskOptions, "__esModule", { value: true });
	taskOptions.trailingFunctionArgument = taskOptions.trailingOptionsArgument = taskOptions.getTrailingOptions = taskOptions.appendTaskOptions = void 0;
	const argument_filters_1 = requireArgumentFilters();
	const util_1 = requireUtil();
	function appendTaskOptions(options, commands = []) {
	    if (!argument_filters_1.filterPlainObject(options)) {
	        return commands;
	    }
	    return Object.keys(options).reduce((commands, key) => {
	        const value = options[key];
	        if (argument_filters_1.filterPrimitives(value, ['boolean'])) {
	            commands.push(key + '=' + value);
	        }
	        else {
	            commands.push(key);
	        }
	        return commands;
	    }, commands);
	}
	taskOptions.appendTaskOptions = appendTaskOptions;
	function getTrailingOptions(args, initialPrimitive = 0, objectOnly = false) {
	    const command = [];
	    for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {
	        if ('string|number'.includes(typeof args[i])) {
	            command.push(String(args[i]));
	        }
	    }
	    appendTaskOptions(trailingOptionsArgument(args), command);
	    if (!objectOnly) {
	        command.push(...trailingArrayArgument(args));
	    }
	    return command;
	}
	taskOptions.getTrailingOptions = getTrailingOptions;
	function trailingArrayArgument(args) {
	    const hasTrailingCallback = typeof util_1.last(args) === 'function';
	    return argument_filters_1.filterType(util_1.last(args, hasTrailingCallback ? 1 : 0), argument_filters_1.filterArray, []);
	}
	/**
	 * Given any number of arguments, returns the trailing options argument, ignoring a trailing function argument
	 * if there is one. When not found, the return value is null.
	 */
	function trailingOptionsArgument(args) {
	    const hasTrailingCallback = argument_filters_1.filterFunction(util_1.last(args));
	    return argument_filters_1.filterType(util_1.last(args, hasTrailingCallback ? 1 : 0), argument_filters_1.filterPlainObject);
	}
	taskOptions.trailingOptionsArgument = trailingOptionsArgument;
	/**
	 * Returns either the source argument when it is a `Function`, or the default
	 * `NOOP` function constant
	 */
	function trailingFunctionArgument(args, includeNoop = true) {
	    const callback = util_1.asFunction(util_1.last(args));
	    return includeNoop || util_1.isUserFunction(callback) ? callback : undefined;
	}
	taskOptions.trailingFunctionArgument = trailingFunctionArgument;
	
	return taskOptions;
}

var taskParser = {};

var hasRequiredTaskParser;

function requireTaskParser () {
	if (hasRequiredTaskParser) return taskParser;
	hasRequiredTaskParser = 1;
	Object.defineProperty(taskParser, "__esModule", { value: true });
	taskParser.parseStringResponse = taskParser.callTaskParser = void 0;
	const util_1 = requireUtil();
	function callTaskParser(parser, streams) {
	    return parser(streams.stdOut, streams.stdErr);
	}
	taskParser.callTaskParser = callTaskParser;
	function parseStringResponse(result, parsers, ...texts) {
	    texts.forEach(text => {
	        for (let lines = util_1.toLinesWithContent(text), i = 0, max = lines.length; i < max; i++) {
	            const line = (offset = 0) => {
	                if ((i + offset) >= max) {
	                    return;
	                }
	                return lines[i + offset];
	            };
	            parsers.some(({ parse }) => parse(line, result));
	        }
	    });
	    return result;
	}
	taskParser.parseStringResponse = parseStringResponse;
	
	return taskParser;
}

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;
	(function (exports) {
		var __createBinding = (utils && utils.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (utils && utils.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(requireArgumentFilters(), exports);
		__exportStar(requireExitCodes(), exports);
		__exportStar(requireGitOutputStreams(), exports);
		__exportStar(requireLineParser(), exports);
		__exportStar(requireSimpleGitOptions(), exports);
		__exportStar(requireTaskOptions(), exports);
		__exportStar(requireTaskParser(), exports);
		__exportStar(requireUtil(), exports);
		
	} (utils));
	return utils;
}

var hasRequiredCheckIsRepo;

function requireCheckIsRepo () {
	if (hasRequiredCheckIsRepo) return checkIsRepo;
	hasRequiredCheckIsRepo = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.checkIsBareRepoTask = exports.checkIsRepoRootTask = exports.checkIsRepoTask = exports.CheckRepoActions = void 0;
		const utils_1 = requireUtils();
		var CheckRepoActions;
		(function (CheckRepoActions) {
		    CheckRepoActions["BARE"] = "bare";
		    CheckRepoActions["IN_TREE"] = "tree";
		    CheckRepoActions["IS_REPO_ROOT"] = "root";
		})(CheckRepoActions = exports.CheckRepoActions || (exports.CheckRepoActions = {}));
		const onError = ({ exitCode }, error, done, fail) => {
		    if (exitCode === utils_1.ExitCodes.UNCLEAN && isNotRepoMessage(error)) {
		        return done(Buffer.from('false'));
		    }
		    fail(error);
		};
		const parser = (text) => {
		    return text.trim() === 'true';
		};
		function checkIsRepoTask(action) {
		    switch (action) {
		        case CheckRepoActions.BARE:
		            return checkIsBareRepoTask();
		        case CheckRepoActions.IS_REPO_ROOT:
		            return checkIsRepoRootTask();
		    }
		    const commands = ['rev-parse', '--is-inside-work-tree'];
		    return {
		        commands,
		        format: 'utf-8',
		        onError,
		        parser,
		    };
		}
		exports.checkIsRepoTask = checkIsRepoTask;
		function checkIsRepoRootTask() {
		    const commands = ['rev-parse', '--git-dir'];
		    return {
		        commands,
		        format: 'utf-8',
		        onError,
		        parser(path) {
		            return /^\.(git)?$/.test(path.trim());
		        },
		    };
		}
		exports.checkIsRepoRootTask = checkIsRepoRootTask;
		function checkIsBareRepoTask() {
		    const commands = ['rev-parse', '--is-bare-repository'];
		    return {
		        commands,
		        format: 'utf-8',
		        onError,
		        parser,
		    };
		}
		exports.checkIsBareRepoTask = checkIsBareRepoTask;
		function isNotRepoMessage(error) {
		    return /(Not a git repository|Kein Git-Repository)/i.test(String(error));
		}
		
	} (checkIsRepo));
	return checkIsRepo;
}

var clean = {};

var CleanSummary = {};

var hasRequiredCleanSummary;

function requireCleanSummary () {
	if (hasRequiredCleanSummary) return CleanSummary;
	hasRequiredCleanSummary = 1;
	Object.defineProperty(CleanSummary, "__esModule", { value: true });
	CleanSummary.cleanSummaryParser = CleanSummary.CleanResponse = void 0;
	const utils_1 = requireUtils();
	class CleanResponse {
	    constructor(dryRun) {
	        this.dryRun = dryRun;
	        this.paths = [];
	        this.files = [];
	        this.folders = [];
	    }
	}
	CleanSummary.CleanResponse = CleanResponse;
	const removalRegexp = /^[a-z]+\s*/i;
	const dryRunRemovalRegexp = /^[a-z]+\s+[a-z]+\s*/i;
	const isFolderRegexp = /\/$/;
	function cleanSummaryParser(dryRun, text) {
	    const summary = new CleanResponse(dryRun);
	    const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;
	    utils_1.toLinesWithContent(text).forEach(line => {
	        const removed = line.replace(regexp, '');
	        summary.paths.push(removed);
	        (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);
	    });
	    return summary;
	}
	CleanSummary.cleanSummaryParser = cleanSummaryParser;
	
	return CleanSummary;
}

var task = {};

var hasRequiredTask;

function requireTask () {
	if (hasRequiredTask) return task;
	hasRequiredTask = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.isEmptyTask = exports.isBufferTask = exports.straightThroughBufferTask = exports.straightThroughStringTask = exports.configurationErrorTask = exports.adhocExecTask = exports.EMPTY_COMMANDS = void 0;
		const task_configuration_error_1 = requireTaskConfigurationError();
		exports.EMPTY_COMMANDS = [];
		function adhocExecTask(parser) {
		    return {
		        commands: exports.EMPTY_COMMANDS,
		        format: 'empty',
		        parser,
		    };
		}
		exports.adhocExecTask = adhocExecTask;
		function configurationErrorTask(error) {
		    return {
		        commands: exports.EMPTY_COMMANDS,
		        format: 'empty',
		        parser() {
		            throw typeof error === 'string' ? new task_configuration_error_1.TaskConfigurationError(error) : error;
		        }
		    };
		}
		exports.configurationErrorTask = configurationErrorTask;
		function straightThroughStringTask(commands, trimmed = false) {
		    return {
		        commands,
		        format: 'utf-8',
		        parser(text) {
		            return trimmed ? String(text).trim() : text;
		        },
		    };
		}
		exports.straightThroughStringTask = straightThroughStringTask;
		function straightThroughBufferTask(commands) {
		    return {
		        commands,
		        format: 'buffer',
		        parser(buffer) {
		            return buffer;
		        },
		    };
		}
		exports.straightThroughBufferTask = straightThroughBufferTask;
		function isBufferTask(task) {
		    return task.format === 'buffer';
		}
		exports.isBufferTask = isBufferTask;
		function isEmptyTask(task) {
		    return task.format === 'empty' || !task.commands.length;
		}
		exports.isEmptyTask = isEmptyTask;
		
	} (task));
	return task;
}

var hasRequiredClean;

function requireClean () {
	if (hasRequiredClean) return clean;
	hasRequiredClean = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.isCleanOptionsArray = exports.cleanTask = exports.cleanWithOptionsTask = exports.CleanOptions = exports.CONFIG_ERROR_UNKNOWN_OPTION = exports.CONFIG_ERROR_MODE_REQUIRED = exports.CONFIG_ERROR_INTERACTIVE_MODE = void 0;
		const CleanSummary_1 = requireCleanSummary();
		const utils_1 = requireUtils();
		const task_1 = requireTask();
		exports.CONFIG_ERROR_INTERACTIVE_MODE = 'Git clean interactive mode is not supported';
		exports.CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter ("n" or "f") is required';
		exports.CONFIG_ERROR_UNKNOWN_OPTION = 'Git clean unknown option found in: ';
		/**
		 * All supported option switches available for use in a `git.clean` operation
		 */
		var CleanOptions;
		(function (CleanOptions) {
		    CleanOptions["DRY_RUN"] = "n";
		    CleanOptions["FORCE"] = "f";
		    CleanOptions["IGNORED_INCLUDED"] = "x";
		    CleanOptions["IGNORED_ONLY"] = "X";
		    CleanOptions["EXCLUDING"] = "e";
		    CleanOptions["QUIET"] = "q";
		    CleanOptions["RECURSIVE"] = "d";
		})(CleanOptions = exports.CleanOptions || (exports.CleanOptions = {}));
		const CleanOptionValues = new Set(['i', ...utils_1.asStringArray(Object.values(CleanOptions))]);
		function cleanWithOptionsTask(mode, customArgs) {
		    const { cleanMode, options, valid } = getCleanOptions(mode);
		    if (!cleanMode) {
		        return task_1.configurationErrorTask(exports.CONFIG_ERROR_MODE_REQUIRED);
		    }
		    if (!valid.options) {
		        return task_1.configurationErrorTask(exports.CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));
		    }
		    options.push(...customArgs);
		    if (options.some(isInteractiveMode)) {
		        return task_1.configurationErrorTask(exports.CONFIG_ERROR_INTERACTIVE_MODE);
		    }
		    return cleanTask(cleanMode, options);
		}
		exports.cleanWithOptionsTask = cleanWithOptionsTask;
		function cleanTask(mode, customArgs) {
		    const commands = ['clean', `-${mode}`, ...customArgs];
		    return {
		        commands,
		        format: 'utf-8',
		        parser(text) {
		            return CleanSummary_1.cleanSummaryParser(mode === CleanOptions.DRY_RUN, text);
		        }
		    };
		}
		exports.cleanTask = cleanTask;
		function isCleanOptionsArray(input) {
		    return Array.isArray(input) && input.every(test => CleanOptionValues.has(test));
		}
		exports.isCleanOptionsArray = isCleanOptionsArray;
		function getCleanOptions(input) {
		    let cleanMode;
		    let options = [];
		    let valid = { cleanMode: false, options: true };
		    input.replace(/[^a-z]i/g, '').split('').forEach(char => {
		        if (isCleanMode(char)) {
		            cleanMode = char;
		            valid.cleanMode = true;
		        }
		        else {
		            valid.options = valid.options && isKnownOption(options[options.length] = (`-${char}`));
		        }
		    });
		    return {
		        cleanMode,
		        options,
		        valid,
		    };
		}
		function isCleanMode(cleanMode) {
		    return cleanMode === CleanOptions.FORCE || cleanMode === CleanOptions.DRY_RUN;
		}
		function isKnownOption(option) {
		    return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));
		}
		function isInteractiveMode(option) {
		    if (/^-[^\-]/.test(option)) {
		        return option.indexOf('i') > 0;
		    }
		    return option === '--interactive';
		}
		
	} (clean));
	return clean;
}

var config = {};

var ConfigList = {};

var hasRequiredConfigList;

function requireConfigList () {
	if (hasRequiredConfigList) return ConfigList;
	hasRequiredConfigList = 1;
	Object.defineProperty(ConfigList, "__esModule", { value: true });
	ConfigList.configGetParser = ConfigList.configListParser = ConfigList.ConfigList = void 0;
	const utils_1 = requireUtils();
	let ConfigList$1 = class ConfigList {
	    constructor() {
	        this.files = [];
	        this.values = Object.create(null);
	    }
	    get all() {
	        if (!this._all) {
	            this._all = this.files.reduce((all, file) => {
	                return Object.assign(all, this.values[file]);
	            }, {});
	        }
	        return this._all;
	    }
	    addFile(file) {
	        if (!(file in this.values)) {
	            const latest = utils_1.last(this.files);
	            this.values[file] = latest ? Object.create(this.values[latest]) : {};
	            this.files.push(file);
	        }
	        return this.values[file];
	    }
	    addValue(file, key, value) {
	        const values = this.addFile(file);
	        if (!values.hasOwnProperty(key)) {
	            values[key] = value;
	        }
	        else if (Array.isArray(values[key])) {
	            values[key].push(value);
	        }
	        else {
	            values[key] = [values[key], value];
	        }
	        this._all = undefined;
	    }
	};
	ConfigList.ConfigList = ConfigList$1;
	function configListParser(text) {
	    const config = new ConfigList$1();
	    for (const item of configParser(text)) {
	        config.addValue(item.file, String(item.key), item.value);
	    }
	    return config;
	}
	ConfigList.configListParser = configListParser;
	function configGetParser(text, key) {
	    let value = null;
	    const values = [];
	    const scopes = new Map();
	    for (const item of configParser(text, key)) {
	        if (item.key !== key) {
	            continue;
	        }
	        values.push(value = item.value);
	        if (!scopes.has(item.file)) {
	            scopes.set(item.file, []);
	        }
	        scopes.get(item.file).push(value);
	    }
	    return {
	        key,
	        paths: Array.from(scopes.keys()),
	        scopes,
	        value,
	        values
	    };
	}
	ConfigList.configGetParser = configGetParser;
	function configFilePath(filePath) {
	    return filePath.replace(/^(file):/, '');
	}
	function* configParser(text, requestedKey = null) {
	    const lines = text.split('\0');
	    for (let i = 0, max = lines.length - 1; i < max;) {
	        const file = configFilePath(lines[i++]);
	        let value = lines[i++];
	        let key = requestedKey;
	        if (value.includes('\n')) {
	            const line = utils_1.splitOn(value, '\n');
	            key = line[0];
	            value = line[1];
	        }
	        yield { file, key, value };
	    }
	}
	
	return ConfigList;
}

var hasRequiredConfig;

function requireConfig () {
	if (hasRequiredConfig) return config;
	hasRequiredConfig = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.GitConfigScope = void 0;
		const ConfigList_1 = requireConfigList();
		const utils_1 = requireUtils();
		var GitConfigScope;
		(function (GitConfigScope) {
		    GitConfigScope["system"] = "system";
		    GitConfigScope["global"] = "global";
		    GitConfigScope["local"] = "local";
		    GitConfigScope["worktree"] = "worktree";
		})(GitConfigScope = exports.GitConfigScope || (exports.GitConfigScope = {}));
		function asConfigScope(scope, fallback) {
		    if (typeof scope === 'string' && GitConfigScope.hasOwnProperty(scope)) {
		        return scope;
		    }
		    return fallback;
		}
		function addConfigTask(key, value, append, scope) {
		    const commands = ['config', `--${scope}`];
		    if (append) {
		        commands.push('--add');
		    }
		    commands.push(key, value);
		    return {
		        commands,
		        format: 'utf-8',
		        parser(text) {
		            return text;
		        }
		    };
		}
		function getConfigTask(key, scope) {
		    const commands = ['config', '--null', '--show-origin', '--get-all', key];
		    if (scope) {
		        commands.splice(1, 0, `--${scope}`);
		    }
		    return {
		        commands,
		        format: 'utf-8',
		        parser(text) {
		            return ConfigList_1.configGetParser(text, key);
		        }
		    };
		}
		function listConfigTask(scope) {
		    const commands = ['config', '--list', '--show-origin', '--null'];
		    if (scope) {
		        commands.push(`--${scope}`);
		    }
		    return {
		        commands,
		        format: 'utf-8',
		        parser(text) {
		            return ConfigList_1.configListParser(text);
		        },
		    };
		}
		function default_1() {
		    return {
		        addConfig(key, value, ...rest) {
		            return this._runTask(addConfigTask(key, value, rest[0] === true, asConfigScope(rest[1], GitConfigScope.local)), utils_1.trailingFunctionArgument(arguments));
		        },
		        getConfig(key, scope) {
		            return this._runTask(getConfigTask(key, asConfigScope(scope, undefined)), utils_1.trailingFunctionArgument(arguments));
		        },
		        listConfig(...rest) {
		            return this._runTask(listConfigTask(asConfigScope(rest[0], undefined)), utils_1.trailingFunctionArgument(arguments));
		        },
		    };
		}
		exports.default = default_1;
		
	} (config));
	return config;
}

var grep = {};

var hasRequiredGrep;

function requireGrep () {
	if (hasRequiredGrep) return grep;
	hasRequiredGrep = 1;
	var _a;
	Object.defineProperty(grep, "__esModule", { value: true });
	grep.grepQueryBuilder = void 0;
	const utils_1 = requireUtils();
	const task_1 = requireTask();
	const disallowedOptions = ['-h'];
	const Query = Symbol('grepQuery');
	class GrepQuery {
	    constructor() {
	        this[_a] = [];
	    }
	    *[(_a = Query, Symbol.iterator)]() {
	        for (const query of this[Query]) {
	            yield query;
	        }
	    }
	    and(...and) {
	        and.length && this[Query].push('--and', '(', ...utils_1.prefixedArray(and, '-e'), ')');
	        return this;
	    }
	    param(...param) {
	        this[Query].push(...utils_1.prefixedArray(param, '-e'));
	        return this;
	    }
	}
	/**
	 * Creates a new builder for a `git.grep` query with optional params
	 */
	function grepQueryBuilder(...params) {
	    return new GrepQuery().param(...params);
	}
	grep.grepQueryBuilder = grepQueryBuilder;
	function parseGrep(grep) {
	    const paths = new Set();
	    const results = {};
	    utils_1.forEachLineWithContent(grep, (input) => {
	        const [path, line, preview] = input.split(utils_1.NULL);
	        paths.add(path);
	        (results[path] = results[path] || []).push({
	            line: utils_1.asNumber(line),
	            path,
	            preview,
	        });
	    });
	    return {
	        paths,
	        results,
	    };
	}
	function default_1() {
	    return {
	        grep(searchTerm) {
	            const then = utils_1.trailingFunctionArgument(arguments);
	            const options = utils_1.getTrailingOptions(arguments);
	            for (const option of disallowedOptions) {
	                if (options.includes(option)) {
	                    return this._runTask(task_1.configurationErrorTask(`git.grep: use of "${option}" is not supported.`), then);
	                }
	            }
	            if (typeof searchTerm === 'string') {
	                searchTerm = grepQueryBuilder().param(searchTerm);
	            }
	            const commands = ['grep', '--null', '-n', '--full-name', ...options, ...searchTerm];
	            return this._runTask({
	                commands,
	                format: 'utf-8',
	                parser(stdOut) {
	                    return parseGrep(stdOut);
	                },
	            }, then);
	        }
	    };
	}
	grep.default = default_1;
	
	return grep;
}

var reset = {};

var hasRequiredReset;

function requireReset () {
	if (hasRequiredReset) return reset;
	hasRequiredReset = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getResetMode = exports.resetTask = exports.ResetMode = void 0;
		const task_1 = requireTask();
		var ResetMode;
		(function (ResetMode) {
		    ResetMode["MIXED"] = "mixed";
		    ResetMode["SOFT"] = "soft";
		    ResetMode["HARD"] = "hard";
		    ResetMode["MERGE"] = "merge";
		    ResetMode["KEEP"] = "keep";
		})(ResetMode = exports.ResetMode || (exports.ResetMode = {}));
		const ResetModes = Array.from(Object.values(ResetMode));
		function resetTask(mode, customArgs) {
		    const commands = ['reset'];
		    if (isValidResetMode(mode)) {
		        commands.push(`--${mode}`);
		    }
		    commands.push(...customArgs);
		    return task_1.straightThroughStringTask(commands);
		}
		exports.resetTask = resetTask;
		function getResetMode(mode) {
		    if (isValidResetMode(mode)) {
		        return mode;
		    }
		    switch (typeof mode) {
		        case 'string':
		        case 'undefined':
		            return ResetMode.SOFT;
		    }
		    return;
		}
		exports.getResetMode = getResetMode;
		function isValidResetMode(mode) {
		    return ResetModes.includes(mode);
		}
		
	} (reset));
	return reset;
}

var hasRequiredApi;

function requireApi () {
	if (hasRequiredApi) return api;
	hasRequiredApi = 1;
	Object.defineProperty(api, "__esModule", { value: true });
	const git_construct_error_1 = requireGitConstructError();
	const git_error_1 = requireGitError();
	const git_plugin_error_1 = requireGitPluginError();
	const git_response_error_1 = requireGitResponseError();
	const task_configuration_error_1 = requireTaskConfigurationError();
	const check_is_repo_1 = requireCheckIsRepo();
	const clean_1 = requireClean();
	const config_1 = requireConfig();
	const grep_1 = requireGrep();
	const reset_1 = requireReset();
	const api$1 = {
	    CheckRepoActions: check_is_repo_1.CheckRepoActions,
	    CleanOptions: clean_1.CleanOptions,
	    GitConfigScope: config_1.GitConfigScope,
	    GitConstructError: git_construct_error_1.GitConstructError,
	    GitError: git_error_1.GitError,
	    GitPluginError: git_plugin_error_1.GitPluginError,
	    GitResponseError: git_response_error_1.GitResponseError,
	    ResetMode: reset_1.ResetMode,
	    TaskConfigurationError: task_configuration_error_1.TaskConfigurationError,
	    grepQueryBuilder: grep_1.grepQueryBuilder,
	};
	api.default = api$1;
	
	return api;
}

var plugins = {};

var commandConfigPrefixingPlugin = {};

var hasRequiredCommandConfigPrefixingPlugin;

function requireCommandConfigPrefixingPlugin () {
	if (hasRequiredCommandConfigPrefixingPlugin) return commandConfigPrefixingPlugin;
	hasRequiredCommandConfigPrefixingPlugin = 1;
	Object.defineProperty(commandConfigPrefixingPlugin, "__esModule", { value: true });
	commandConfigPrefixingPlugin.commandConfigPrefixingPlugin = void 0;
	const utils_1 = requireUtils();
	function commandConfigPrefixingPlugin$1(configuration) {
	    const prefix = utils_1.prefixedArray(configuration, '-c');
	    return {
	        type: 'spawn.args',
	        action(data) {
	            return [...prefix, ...data];
	        },
	    };
	}
	commandConfigPrefixingPlugin.commandConfigPrefixingPlugin = commandConfigPrefixingPlugin$1;
	
	return commandConfigPrefixingPlugin;
}

var completionDetection_plugin = {};

var dist$1 = {};

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist$1;
	hasRequiredDist = 1;
	Object.defineProperty(dist$1, "__esModule", { value: true });
	dist$1.createDeferred = dist$1.deferred = void 0;
	/**
	 * Creates a new `DeferredPromise`
	 *
	 * ```typescript
	 import {deferred} from '@kwsites/promise-deferred`;
	 ```
	 */
	function deferred() {
	    let done;
	    let fail;
	    let status = 'pending';
	    const promise = new Promise((_done, _fail) => {
	        done = _done;
	        fail = _fail;
	    });
	    return {
	        promise,
	        done(result) {
	            if (status === 'pending') {
	                status = 'resolved';
	                done(result);
	            }
	        },
	        fail(error) {
	            if (status === 'pending') {
	                status = 'rejected';
	                fail(error);
	            }
	        },
	        get fulfilled() {
	            return status !== 'pending';
	        },
	        get status() {
	            return status;
	        },
	    };
	}
	dist$1.deferred = deferred;
	/**
	 * Alias of the exported `deferred` function, to help consumers wanting to use `deferred` as the
	 * local variable name rather than the factory import name, without needing to rename on import.
	 *
	 * ```typescript
	 import {createDeferred} from '@kwsites/promise-deferred`;
	 ```
	 */
	dist$1.createDeferred = deferred;
	/**
	 * Default export allows use as:
	 *
	 * ```typescript
	 import deferred from '@kwsites/promise-deferred`;
	 ```
	 */
	dist$1.default = deferred;
	
	return dist$1;
}

var hasRequiredCompletionDetection_plugin;

function requireCompletionDetection_plugin () {
	if (hasRequiredCompletionDetection_plugin) return completionDetection_plugin;
	hasRequiredCompletionDetection_plugin = 1;
	var __awaiter = (completionDetection_plugin && completionDetection_plugin.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(completionDetection_plugin, "__esModule", { value: true });
	completionDetection_plugin.completionDetectionPlugin = void 0;
	const promise_deferred_1 = requireDist();
	const utils_1 = requireUtils();
	const never = promise_deferred_1.default().promise;
	function completionDetectionPlugin({ onClose = true, onExit = 50 } = {}) {
	    function createEvents() {
	        let exitCode = -1;
	        const events = {
	            close: promise_deferred_1.default(),
	            closeTimeout: promise_deferred_1.default(),
	            exit: promise_deferred_1.default(),
	            exitTimeout: promise_deferred_1.default(),
	        };
	        const result = Promise.race([
	            onClose === false ? never : events.closeTimeout.promise,
	            onExit === false ? never : events.exitTimeout.promise,
	        ]);
	        configureTimeout(onClose, events.close, events.closeTimeout);
	        configureTimeout(onExit, events.exit, events.exitTimeout);
	        return {
	            close(code) {
	                exitCode = code;
	                events.close.done();
	            },
	            exit(code) {
	                exitCode = code;
	                events.exit.done();
	            },
	            get exitCode() {
	                return exitCode;
	            },
	            result,
	        };
	    }
	    function configureTimeout(flag, event, timeout) {
	        if (flag === false) {
	            return;
	        }
	        (flag === true ? event.promise : event.promise.then(() => utils_1.delay(flag))).then(timeout.done);
	    }
	    return {
	        type: 'spawn.after',
	        action(_data, { spawned, close }) {
	            var _a, _b;
	            return __awaiter(this, void 0, void 0, function* () {
	                const events = createEvents();
	                let deferClose = true;
	                let quickClose = () => void (deferClose = false);
	                (_a = spawned.stdout) === null || _a === void 0 ? void 0 : _a.on('data', quickClose);
	                (_b = spawned.stderr) === null || _b === void 0 ? void 0 : _b.on('data', quickClose);
	                spawned.on('error', quickClose);
	                spawned.on('close', (code) => events.close(code));
	                spawned.on('exit', (code) => events.exit(code));
	                try {
	                    yield events.result;
	                    if (deferClose) {
	                        yield utils_1.delay(50);
	                    }
	                    close(events.exitCode);
	                }
	                catch (err) {
	                    close(events.exitCode, err);
	                }
	            });
	        }
	    };
	}
	completionDetection_plugin.completionDetectionPlugin = completionDetectionPlugin;
	
	return completionDetection_plugin;
}

var errorDetection_plugin = {};

var hasRequiredErrorDetection_plugin;

function requireErrorDetection_plugin () {
	if (hasRequiredErrorDetection_plugin) return errorDetection_plugin;
	hasRequiredErrorDetection_plugin = 1;
	Object.defineProperty(errorDetection_plugin, "__esModule", { value: true });
	errorDetection_plugin.errorDetectionPlugin = errorDetection_plugin.errorDetectionHandler = void 0;
	const git_error_1 = requireGitError();
	function isTaskError(result) {
	    return !!(result.exitCode && result.stdErr.length);
	}
	function getErrorMessage(result) {
	    return Buffer.concat([...result.stdOut, ...result.stdErr]);
	}
	function errorDetectionHandler(overwrite = false, isError = isTaskError, errorMessage = getErrorMessage) {
	    return (error, result) => {
	        if ((!overwrite && error) || !isError(result)) {
	            return error;
	        }
	        return errorMessage(result);
	    };
	}
	errorDetection_plugin.errorDetectionHandler = errorDetectionHandler;
	function errorDetectionPlugin(config) {
	    return {
	        type: 'task.error',
	        action(data, context) {
	            const error = config(data.error, {
	                stdErr: context.stdErr,
	                stdOut: context.stdOut,
	                exitCode: context.exitCode
	            });
	            if (Buffer.isBuffer(error)) {
	                return { error: new git_error_1.GitError(undefined, error.toString('utf-8')) };
	            }
	            return {
	                error
	            };
	        },
	    };
	}
	errorDetection_plugin.errorDetectionPlugin = errorDetectionPlugin;
	
	return errorDetection_plugin;
}

var pluginStore = {};

var hasRequiredPluginStore;

function requirePluginStore () {
	if (hasRequiredPluginStore) return pluginStore;
	hasRequiredPluginStore = 1;
	Object.defineProperty(pluginStore, "__esModule", { value: true });
	pluginStore.PluginStore = void 0;
	const utils_1 = requireUtils();
	class PluginStore {
	    constructor() {
	        this.plugins = new Set();
	    }
	    add(plugin) {
	        const plugins = [];
	        utils_1.asArray(plugin).forEach(plugin => plugin && this.plugins.add(utils_1.append(plugins, plugin)));
	        return () => {
	            plugins.forEach(plugin => this.plugins.delete(plugin));
	        };
	    }
	    exec(type, data, context) {
	        let output = data;
	        const contextual = Object.freeze(Object.create(context));
	        for (const plugin of this.plugins) {
	            if (plugin.type === type) {
	                output = plugin.action(output, contextual);
	            }
	        }
	        return output;
	    }
	}
	pluginStore.PluginStore = PluginStore;
	
	return pluginStore;
}

var progressMonitorPlugin = {};

var hasRequiredProgressMonitorPlugin;

function requireProgressMonitorPlugin () {
	if (hasRequiredProgressMonitorPlugin) return progressMonitorPlugin;
	hasRequiredProgressMonitorPlugin = 1;
	Object.defineProperty(progressMonitorPlugin, "__esModule", { value: true });
	progressMonitorPlugin.progressMonitorPlugin = void 0;
	const utils_1 = requireUtils();
	function progressMonitorPlugin$1(progress) {
	    const progressCommand = '--progress';
	    const progressMethods = ['checkout', 'clone', 'fetch', 'pull', 'push'];
	    const onProgress = {
	        type: 'spawn.after',
	        action(_data, context) {
	            var _a;
	            if (!context.commands.includes(progressCommand)) {
	                return;
	            }
	            (_a = context.spawned.stderr) === null || _a === void 0 ? void 0 : _a.on('data', (chunk) => {
	                const message = /^([\s\S]+?):\s*(\d+)% \((\d+)\/(\d+)\)/.exec(chunk.toString('utf8'));
	                if (!message) {
	                    return;
	                }
	                progress({
	                    method: context.method,
	                    stage: progressEventStage(message[1]),
	                    progress: utils_1.asNumber(message[2]),
	                    processed: utils_1.asNumber(message[3]),
	                    total: utils_1.asNumber(message[4]),
	                });
	            });
	        }
	    };
	    const onArgs = {
	        type: 'spawn.args',
	        action(args, context) {
	            if (!progressMethods.includes(context.method)) {
	                return args;
	            }
	            return utils_1.including(args, progressCommand);
	        }
	    };
	    return [onArgs, onProgress];
	}
	progressMonitorPlugin.progressMonitorPlugin = progressMonitorPlugin$1;
	function progressEventStage(input) {
	    return String(input.toLowerCase().split(' ', 1)) || 'unknown';
	}
	
	return progressMonitorPlugin;
}

var simpleGitPlugin = {};

var hasRequiredSimpleGitPlugin;

function requireSimpleGitPlugin () {
	if (hasRequiredSimpleGitPlugin) return simpleGitPlugin;
	hasRequiredSimpleGitPlugin = 1;
	Object.defineProperty(simpleGitPlugin, "__esModule", { value: true });
	
	return simpleGitPlugin;
}

var spawnOptionsPlugin = {};

var hasRequiredSpawnOptionsPlugin;

function requireSpawnOptionsPlugin () {
	if (hasRequiredSpawnOptionsPlugin) return spawnOptionsPlugin;
	hasRequiredSpawnOptionsPlugin = 1;
	Object.defineProperty(spawnOptionsPlugin, "__esModule", { value: true });
	spawnOptionsPlugin.spawnOptionsPlugin = void 0;
	const utils_1 = requireUtils();
	function spawnOptionsPlugin$1(spawnOptions) {
	    const options = utils_1.pick(spawnOptions, ['uid', 'gid']);
	    return {
	        type: 'spawn.options',
	        action(data) {
	            return Object.assign(Object.assign({}, options), data);
	        },
	    };
	}
	spawnOptionsPlugin.spawnOptionsPlugin = spawnOptionsPlugin$1;
	
	return spawnOptionsPlugin;
}

var timoutPlugin = {};

var hasRequiredTimoutPlugin;

function requireTimoutPlugin () {
	if (hasRequiredTimoutPlugin) return timoutPlugin;
	hasRequiredTimoutPlugin = 1;
	Object.defineProperty(timoutPlugin, "__esModule", { value: true });
	timoutPlugin.timeoutPlugin = void 0;
	const git_plugin_error_1 = requireGitPluginError();
	function timeoutPlugin({ block }) {
	    if (block > 0) {
	        return {
	            type: 'spawn.after',
	            action(_data, context) {
	                var _a, _b;
	                let timeout;
	                function wait() {
	                    timeout && clearTimeout(timeout);
	                    timeout = setTimeout(kill, block);
	                }
	                function stop() {
	                    var _a, _b;
	                    (_a = context.spawned.stdout) === null || _a === void 0 ? void 0 : _a.off('data', wait);
	                    (_b = context.spawned.stderr) === null || _b === void 0 ? void 0 : _b.off('data', wait);
	                    context.spawned.off('exit', stop);
	                    context.spawned.off('close', stop);
	                }
	                function kill() {
	                    stop();
	                    context.kill(new git_plugin_error_1.GitPluginError(undefined, 'timeout', `block timeout reached`));
	                }
	                (_a = context.spawned.stdout) === null || _a === void 0 ? void 0 : _a.on('data', wait);
	                (_b = context.spawned.stderr) === null || _b === void 0 ? void 0 : _b.on('data', wait);
	                context.spawned.on('exit', stop);
	                context.spawned.on('close', stop);
	                wait();
	            }
	        };
	    }
	}
	timoutPlugin.timeoutPlugin = timeoutPlugin;
	
	return timoutPlugin;
}

var hasRequiredPlugins;

function requirePlugins () {
	if (hasRequiredPlugins) return plugins;
	hasRequiredPlugins = 1;
	(function (exports) {
		var __createBinding = (plugins && plugins.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (plugins && plugins.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(requireCommandConfigPrefixingPlugin(), exports);
		__exportStar(requireCompletionDetection_plugin(), exports);
		__exportStar(requireErrorDetection_plugin(), exports);
		__exportStar(requirePluginStore(), exports);
		__exportStar(requireProgressMonitorPlugin(), exports);
		__exportStar(requireSimpleGitPlugin(), exports);
		__exportStar(requireSpawnOptionsPlugin(), exports);
		__exportStar(requireTimoutPlugin(), exports);
		
	} (plugins));
	return plugins;
}

var gitExecutor = {};

var gitExecutorChain = {};

var tasksPendingQueue = {};

var gitLogger = {};

var hasRequiredGitLogger;

function requireGitLogger () {
	if (hasRequiredGitLogger) return gitLogger;
	hasRequiredGitLogger = 1;
	Object.defineProperty(gitLogger, "__esModule", { value: true });
	gitLogger.GitLogger = gitLogger.createLogger = void 0;
	const debug_1 = requireSrc$1();
	const utils_1 = requireUtils();
	debug_1.default.formatters.L = (value) => String(utils_1.filterHasLength(value) ? value.length : '-');
	debug_1.default.formatters.B = (value) => {
	    if (Buffer.isBuffer(value)) {
	        return value.toString('utf8');
	    }
	    return utils_1.objectToString(value);
	};
	function createLog() {
	    return debug_1.default('simple-git');
	}
	function prefixedLogger(to, prefix, forward) {
	    if (!prefix || !String(prefix).replace(/\s*/, '')) {
	        return !forward ? to : (message, ...args) => {
	            to(message, ...args);
	            forward(message, ...args);
	        };
	    }
	    return (message, ...args) => {
	        to(`%s ${message}`, prefix, ...args);
	        if (forward) {
	            forward(message, ...args);
	        }
	    };
	}
	function childLoggerName(name, childDebugger, { namespace: parentNamespace }) {
	    if (typeof name === 'string') {
	        return name;
	    }
	    const childNamespace = childDebugger && childDebugger.namespace || '';
	    if (childNamespace.startsWith(parentNamespace)) {
	        return childNamespace.substr(parentNamespace.length + 1);
	    }
	    return childNamespace || parentNamespace;
	}
	function createLogger(label, verbose, initialStep, infoDebugger = createLog()) {
	    const labelPrefix = label && `[${label}]` || '';
	    const spawned = [];
	    const debugDebugger = (typeof verbose === 'string') ? infoDebugger.extend(verbose) : verbose;
	    const key = childLoggerName(utils_1.filterType(verbose, utils_1.filterString), debugDebugger, infoDebugger);
	    return step(initialStep);
	    function sibling(name, initial) {
	        return utils_1.append(spawned, createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger));
	    }
	    function step(phase) {
	        const stepPrefix = phase && `[${phase}]` || '';
	        const debug = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || utils_1.NOOP;
	        const info = prefixedLogger(infoDebugger, `${labelPrefix} ${stepPrefix}`, debug);
	        return Object.assign(debugDebugger ? debug : info, {
	            label,
	            sibling,
	            info,
	            step,
	        });
	    }
	}
	gitLogger.createLogger = createLogger;
	/**
	 * The `GitLogger` is used by the main `SimpleGit` runner to handle logging
	 * any warnings or errors.
	 */
	class GitLogger {
	    constructor(_out = createLog()) {
	        this._out = _out;
	        this.error = prefixedLogger(_out, '[ERROR]');
	        this.warn = prefixedLogger(_out, '[WARN]');
	    }
	    silent(silence = false) {
	        if (silence !== this._out.enabled) {
	            return;
	        }
	        const { namespace } = this._out;
	        const env = (process.env.DEBUG || '').split(',').filter(s => !!s);
	        const hasOn = env.includes(namespace);
	        const hasOff = env.includes(`-${namespace}`);
	        // enabling the log
	        if (!silence) {
	            if (hasOff) {
	                utils_1.remove(env, `-${namespace}`);
	            }
	            else {
	                env.push(namespace);
	            }
	        }
	        else {
	            if (hasOn) {
	                utils_1.remove(env, namespace);
	            }
	            else {
	                env.push(`-${namespace}`);
	            }
	        }
	        debug_1.default.enable(env.join(','));
	    }
	}
	gitLogger.GitLogger = GitLogger;
	
	return gitLogger;
}

var hasRequiredTasksPendingQueue;

function requireTasksPendingQueue () {
	if (hasRequiredTasksPendingQueue) return tasksPendingQueue;
	hasRequiredTasksPendingQueue = 1;
	Object.defineProperty(tasksPendingQueue, "__esModule", { value: true });
	tasksPendingQueue.TasksPendingQueue = void 0;
	const git_error_1 = requireGitError();
	const git_logger_1 = requireGitLogger();
	class TasksPendingQueue {
	    constructor(logLabel = 'GitExecutor') {
	        this.logLabel = logLabel;
	        this._queue = new Map();
	    }
	    withProgress(task) {
	        return this._queue.get(task);
	    }
	    createProgress(task) {
	        const name = TasksPendingQueue.getName(task.commands[0]);
	        const logger = git_logger_1.createLogger(this.logLabel, name);
	        return {
	            task,
	            logger,
	            name,
	        };
	    }
	    push(task) {
	        const progress = this.createProgress(task);
	        progress.logger('Adding task to the queue, commands = %o', task.commands);
	        this._queue.set(task, progress);
	        return progress;
	    }
	    fatal(err) {
	        for (const [task, { logger }] of Array.from(this._queue.entries())) {
	            if (task === err.task) {
	                logger.info(`Failed %o`, err);
	                logger(`Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`);
	            }
	            else {
	                logger.info(`A fatal exception occurred in a previous task, the queue has been purged: %o`, err.message);
	            }
	            this.complete(task);
	        }
	        if (this._queue.size !== 0) {
	            throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);
	        }
	    }
	    complete(task) {
	        const progress = this.withProgress(task);
	        if (progress) {
	            this._queue.delete(task);
	        }
	    }
	    attempt(task) {
	        const progress = this.withProgress(task);
	        if (!progress) {
	            throw new git_error_1.GitError(undefined, 'TasksPendingQueue: attempt called for an unknown task');
	        }
	        progress.logger('Starting task');
	        return progress;
	    }
	    static getName(name = 'empty') {
	        return `task:${name}:${++TasksPendingQueue.counter}`;
	    }
	}
	tasksPendingQueue.TasksPendingQueue = TasksPendingQueue;
	TasksPendingQueue.counter = 0;
	
	return tasksPendingQueue;
}

var hasRequiredGitExecutorChain;

function requireGitExecutorChain () {
	if (hasRequiredGitExecutorChain) return gitExecutorChain;
	hasRequiredGitExecutorChain = 1;
	var __awaiter = (gitExecutorChain && gitExecutorChain.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(gitExecutorChain, "__esModule", { value: true });
	gitExecutorChain.GitExecutorChain = void 0;
	const child_process_1 = require$$0$b;
	const git_error_1 = requireGitError();
	const task_1 = requireTask();
	const utils_1 = requireUtils();
	const tasks_pending_queue_1 = requireTasksPendingQueue();
	class GitExecutorChain {
	    constructor(_executor, _scheduler, _plugins) {
	        this._executor = _executor;
	        this._scheduler = _scheduler;
	        this._plugins = _plugins;
	        this._chain = Promise.resolve();
	        this._queue = new tasks_pending_queue_1.TasksPendingQueue();
	    }
	    get binary() {
	        return this._executor.binary;
	    }
	    get cwd() {
	        return this._cwd || this._executor.cwd;
	    }
	    set cwd(cwd) {
	        this._cwd = cwd;
	    }
	    get env() {
	        return this._executor.env;
	    }
	    get outputHandler() {
	        return this._executor.outputHandler;
	    }
	    chain() {
	        return this;
	    }
	    push(task) {
	        this._queue.push(task);
	        return this._chain = this._chain.then(() => this.attemptTask(task));
	    }
	    attemptTask(task) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const onScheduleComplete = yield this._scheduler.next();
	            const onQueueComplete = () => this._queue.complete(task);
	            try {
	                const { logger } = this._queue.attempt(task);
	                return yield (task_1.isEmptyTask(task)
	                    ? this.attemptEmptyTask(task, logger)
	                    : this.attemptRemoteTask(task, logger));
	            }
	            catch (e) {
	                throw this.onFatalException(task, e);
	            }
	            finally {
	                onQueueComplete();
	                onScheduleComplete();
	            }
	        });
	    }
	    onFatalException(task, e) {
	        const gitError = (e instanceof git_error_1.GitError) ? Object.assign(e, { task }) : new git_error_1.GitError(task, e && String(e));
	        this._chain = Promise.resolve();
	        this._queue.fatal(gitError);
	        return gitError;
	    }
	    attemptRemoteTask(task, logger) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const args = this._plugins.exec('spawn.args', [...task.commands], pluginContext(task, task.commands));
	            const raw = yield this.gitResponse(task, this.binary, args, this.outputHandler, logger.step('SPAWN'));
	            const outputStreams = yield this.handleTaskData(task, args, raw, logger.step('HANDLE'));
	            logger(`passing response to task's parser as a %s`, task.format);
	            if (task_1.isBufferTask(task)) {
	                return utils_1.callTaskParser(task.parser, outputStreams);
	            }
	            return utils_1.callTaskParser(task.parser, outputStreams.asStrings());
	        });
	    }
	    attemptEmptyTask(task, logger) {
	        return __awaiter(this, void 0, void 0, function* () {
	            logger(`empty task bypassing child process to call to task's parser`);
	            return task.parser(this);
	        });
	    }
	    handleTaskData(task, args, result, logger) {
	        const { exitCode, rejection, stdOut, stdErr } = result;
	        return new Promise((done, fail) => {
	            logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);
	            const { error } = this._plugins.exec('task.error', { error: rejection }, Object.assign(Object.assign({}, pluginContext(task, args)), result));
	            if (error && task.onError) {
	                logger.info(`exitCode=%s handling with custom error handler`);
	                return task.onError(result, error, (newStdOut) => {
	                    logger.info(`custom error handler treated as success`);
	                    logger(`custom error returned a %s`, utils_1.objectToString(newStdOut));
	                    done(new utils_1.GitOutputStreams(Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut, Buffer.concat(stdErr)));
	                }, fail);
	            }
	            if (error) {
	                logger.info(`handling as error: exitCode=%s stdErr=%s rejection=%o`, exitCode, stdErr.length, rejection);
	                return fail(error);
	            }
	            logger.info(`retrieving task output complete`);
	            done(new utils_1.GitOutputStreams(Buffer.concat(stdOut), Buffer.concat(stdErr)));
	        });
	    }
	    gitResponse(task, command, args, outputHandler, logger) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const outputLogger = logger.sibling('output');
	            const spawnOptions = this._plugins.exec('spawn.options', {
	                cwd: this.cwd,
	                env: this.env,
	                windowsHide: true,
	            }, pluginContext(task, task.commands));
	            return new Promise((done) => {
	                const stdOut = [];
	                const stdErr = [];
	                let rejection;
	                logger.info(`%s %o`, command, args);
	                logger('%O', spawnOptions);
	                const spawned = child_process_1.spawn(command, args, spawnOptions);
	                spawned.stdout.on('data', onDataReceived(stdOut, 'stdOut', logger, outputLogger.step('stdOut')));
	                spawned.stderr.on('data', onDataReceived(stdErr, 'stdErr', logger, outputLogger.step('stdErr')));
	                spawned.on('error', onErrorReceived(stdErr, logger));
	                if (outputHandler) {
	                    logger(`Passing child process stdOut/stdErr to custom outputHandler`);
	                    outputHandler(command, spawned.stdout, spawned.stderr, [...args]);
	                }
	                this._plugins.exec('spawn.after', undefined, Object.assign(Object.assign({}, pluginContext(task, args)), { spawned, close(exitCode, reason) {
	                        done({
	                            stdOut,
	                            stdErr,
	                            exitCode,
	                            rejection: rejection || reason,
	                        });
	                    },
	                    kill(reason) {
	                        if (spawned.killed) {
	                            return;
	                        }
	                        rejection = reason;
	                        spawned.kill('SIGINT');
	                    } }));
	            });
	        });
	    }
	}
	gitExecutorChain.GitExecutorChain = GitExecutorChain;
	function pluginContext(task, commands) {
	    return {
	        method: utils_1.first(task.commands) || '',
	        commands,
	    };
	}
	function onErrorReceived(target, logger) {
	    return (err) => {
	        logger(`[ERROR] child process exception %o`, err);
	        target.push(Buffer.from(String(err.stack), 'ascii'));
	    };
	}
	function onDataReceived(target, name, logger, output) {
	    return (buffer) => {
	        logger(`%s received %L bytes`, name, buffer);
	        output(`%B`, buffer);
	        target.push(buffer);
	    };
	}
	
	return gitExecutorChain;
}

var hasRequiredGitExecutor;

function requireGitExecutor () {
	if (hasRequiredGitExecutor) return gitExecutor;
	hasRequiredGitExecutor = 1;
	Object.defineProperty(gitExecutor, "__esModule", { value: true });
	gitExecutor.GitExecutor = void 0;
	const git_executor_chain_1 = requireGitExecutorChain();
	class GitExecutor {
	    constructor(binary = 'git', cwd, _scheduler, _plugins) {
	        this.binary = binary;
	        this.cwd = cwd;
	        this._scheduler = _scheduler;
	        this._plugins = _plugins;
	        this._chain = new git_executor_chain_1.GitExecutorChain(this, this._scheduler, this._plugins);
	    }
	    chain() {
	        return new git_executor_chain_1.GitExecutorChain(this, this._scheduler, this._plugins);
	    }
	    push(task) {
	        return this._chain.push(task);
	    }
	}
	gitExecutor.GitExecutor = GitExecutor;
	
	return gitExecutor;
}

var simpleGitApi = {};

var taskCallback = {};

var hasRequiredTaskCallback;

function requireTaskCallback () {
	if (hasRequiredTaskCallback) return taskCallback;
	hasRequiredTaskCallback = 1;
	Object.defineProperty(taskCallback, "__esModule", { value: true });
	taskCallback.taskCallback = void 0;
	const git_response_error_1 = requireGitResponseError();
	const utils_1 = requireUtils();
	function taskCallback$1(task, response, callback = utils_1.NOOP) {
	    const onSuccess = (data) => {
	        callback(null, data);
	    };
	    const onError = (err) => {
	        if ((err === null || err === void 0 ? void 0 : err.task) === task) {
	            callback((err instanceof git_response_error_1.GitResponseError) ? addDeprecationNoticeToError(err) : err, undefined);
	        }
	    };
	    response.then(onSuccess, onError);
	}
	taskCallback.taskCallback = taskCallback$1;
	function addDeprecationNoticeToError(err) {
	    let log = (name) => {
	        console.warn(`simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`);
	        log = utils_1.NOOP;
	    };
	    return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));
	    function descriptorReducer(all, name) {
	        if (name in err) {
	            return all;
	        }
	        all[name] = {
	            enumerable: false,
	            configurable: false,
	            get() {
	                log(name);
	                return err.git[name];
	            },
	        };
	        return all;
	    }
	}
	
	return taskCallback;
}

var changeWorkingDirectory = {};

var hasRequiredChangeWorkingDirectory;

function requireChangeWorkingDirectory () {
	if (hasRequiredChangeWorkingDirectory) return changeWorkingDirectory;
	hasRequiredChangeWorkingDirectory = 1;
	Object.defineProperty(changeWorkingDirectory, "__esModule", { value: true });
	changeWorkingDirectory.changeWorkingDirectoryTask = void 0;
	const utils_1 = requireUtils();
	const task_1 = requireTask();
	function changeWorkingDirectoryTask(directory, root) {
	    return task_1.adhocExecTask((instance) => {
	        if (!utils_1.folderExists(directory)) {
	            throw new Error(`Git.cwd: cannot change to non-directory "${directory}"`);
	        }
	        return ((root || instance).cwd = directory);
	    });
	}
	changeWorkingDirectory.changeWorkingDirectoryTask = changeWorkingDirectoryTask;
	
	return changeWorkingDirectory;
}

var hashObject = {};

var hasRequiredHashObject;

function requireHashObject () {
	if (hasRequiredHashObject) return hashObject;
	hasRequiredHashObject = 1;
	Object.defineProperty(hashObject, "__esModule", { value: true });
	hashObject.hashObjectTask = void 0;
	const task_1 = requireTask();
	/**
	 * Task used by `git.hashObject`
	 */
	function hashObjectTask(filePath, write) {
	    const commands = ['hash-object', filePath];
	    if (write) {
	        commands.push('-w');
	    }
	    return task_1.straightThroughStringTask(commands, true);
	}
	hashObject.hashObjectTask = hashObjectTask;
	
	return hashObject;
}

var init = {};

var InitSummary = {};

var hasRequiredInitSummary;

function requireInitSummary () {
	if (hasRequiredInitSummary) return InitSummary;
	hasRequiredInitSummary = 1;
	Object.defineProperty(InitSummary, "__esModule", { value: true });
	InitSummary.parseInit = InitSummary.InitSummary = void 0;
	let InitSummary$1 = class InitSummary {
	    constructor(bare, path, existing, gitDir) {
	        this.bare = bare;
	        this.path = path;
	        this.existing = existing;
	        this.gitDir = gitDir;
	    }
	};
	InitSummary.InitSummary = InitSummary$1;
	const initResponseRegex = /^Init.+ repository in (.+)$/;
	const reInitResponseRegex = /^Rein.+ in (.+)$/;
	function parseInit(bare, path, text) {
	    const response = String(text).trim();
	    let result;
	    if ((result = initResponseRegex.exec(response))) {
	        return new InitSummary$1(bare, path, false, result[1]);
	    }
	    if ((result = reInitResponseRegex.exec(response))) {
	        return new InitSummary$1(bare, path, true, result[1]);
	    }
	    let gitDir = '';
	    const tokens = response.split(' ');
	    while (tokens.length) {
	        const token = tokens.shift();
	        if (token === 'in') {
	            gitDir = tokens.join(' ');
	            break;
	        }
	    }
	    return new InitSummary$1(bare, path, /^re/i.test(response), gitDir);
	}
	InitSummary.parseInit = parseInit;
	
	return InitSummary;
}

var hasRequiredInit;

function requireInit () {
	if (hasRequiredInit) return init;
	hasRequiredInit = 1;
	Object.defineProperty(init, "__esModule", { value: true });
	init.initTask = void 0;
	const InitSummary_1 = requireInitSummary();
	const bareCommand = '--bare';
	function hasBareCommand(command) {
	    return command.includes(bareCommand);
	}
	function initTask(bare = false, path, customArgs) {
	    const commands = ['init', ...customArgs];
	    if (bare && !hasBareCommand(commands)) {
	        commands.splice(1, 0, bareCommand);
	    }
	    return {
	        commands,
	        format: 'utf-8',
	        parser(text) {
	            return InitSummary_1.parseInit(commands.includes('--bare'), path, text);
	        }
	    };
	}
	init.initTask = initTask;
	
	return init;
}

var log = {};

var parseListLogSummary = {};

var parseDiffSummary = {};

var DiffSummary = {};

var hasRequiredDiffSummary;

function requireDiffSummary () {
	if (hasRequiredDiffSummary) return DiffSummary;
	hasRequiredDiffSummary = 1;
	Object.defineProperty(DiffSummary, "__esModule", { value: true });
	DiffSummary.DiffSummary = void 0;
	/***
	 * The DiffSummary is returned as a response to getting `git().status()`
	 */
	let DiffSummary$1 = class DiffSummary {
	    constructor() {
	        this.changed = 0;
	        this.deletions = 0;
	        this.insertions = 0;
	        this.files = [];
	    }
	};
	DiffSummary.DiffSummary = DiffSummary$1;
	
	return DiffSummary;
}

var hasRequiredParseDiffSummary;

function requireParseDiffSummary () {
	if (hasRequiredParseDiffSummary) return parseDiffSummary;
	hasRequiredParseDiffSummary = 1;
	Object.defineProperty(parseDiffSummary, "__esModule", { value: true });
	parseDiffSummary.parseDiffResult = void 0;
	const DiffSummary_1 = requireDiffSummary();
	function parseDiffResult(stdOut) {
	    const lines = stdOut.trim().split('\n');
	    const status = new DiffSummary_1.DiffSummary();
	    readSummaryLine(status, lines.pop());
	    for (let i = 0, max = lines.length; i < max; i++) {
	        const line = lines[i];
	        textFileChange(line, status) || binaryFileChange(line, status);
	    }
	    return status;
	}
	parseDiffSummary.parseDiffResult = parseDiffResult;
	function readSummaryLine(status, summary) {
	    (summary || '')
	        .trim()
	        .split(', ')
	        .forEach(function (text) {
	        const summary = /(\d+)\s([a-z]+)/.exec(text);
	        if (!summary) {
	            return;
	        }
	        summaryType(status, summary[2], parseInt(summary[1], 10));
	    });
	}
	function summaryType(status, key, value) {
	    const match = (/([a-z]+?)s?\b/.exec(key));
	    if (!match || !statusUpdate[match[1]]) {
	        return;
	    }
	    statusUpdate[match[1]](status, value);
	}
	const statusUpdate = {
	    file(status, value) {
	        status.changed = value;
	    },
	    deletion(status, value) {
	        status.deletions = value;
	    },
	    insertion(status, value) {
	        status.insertions = value;
	    }
	};
	function textFileChange(input, { files }) {
	    const line = input.trim().match(/^(.+)\s+\|\s+(\d+)(\s+[+\-]+)?$/);
	    if (line) {
	        var alterations = (line[3] || '').trim();
	        files.push({
	            file: line[1].trim(),
	            changes: parseInt(line[2], 10),
	            insertions: alterations.replace(/-/g, '').length,
	            deletions: alterations.replace(/\+/g, '').length,
	            binary: false
	        });
	        return true;
	    }
	    return false;
	}
	function binaryFileChange(input, { files }) {
	    const line = input.match(/^(.+) \|\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)$/);
	    if (line) {
	        files.push({
	            file: line[1].trim(),
	            before: +line[2],
	            after: +line[3],
	            binary: true
	        });
	        return true;
	    }
	    return false;
	}
	
	return parseDiffSummary;
}

var hasRequiredParseListLogSummary;

function requireParseListLogSummary () {
	if (hasRequiredParseListLogSummary) return parseListLogSummary;
	hasRequiredParseListLogSummary = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.createListLogSummaryParser = exports.SPLITTER = exports.COMMIT_BOUNDARY = exports.START_BOUNDARY = void 0;
		const utils_1 = requireUtils();
		const parse_diff_summary_1 = requireParseDiffSummary();
		exports.START_BOUNDARY = 'òòòòòò ';
		exports.COMMIT_BOUNDARY = ' òò';
		exports.SPLITTER = ' ò ';
		const defaultFieldNames = ['hash', 'date', 'message', 'refs', 'author_name', 'author_email'];
		function lineBuilder(tokens, fields) {
		    return fields.reduce((line, field, index) => {
		        line[field] = tokens[index] || '';
		        return line;
		    }, Object.create({ diff: null }));
		}
		function createListLogSummaryParser(splitter = exports.SPLITTER, fields = defaultFieldNames) {
		    return function (stdOut) {
		        const all = utils_1.toLinesWithContent(stdOut, true, exports.START_BOUNDARY)
		            .map(function (item) {
		            const lineDetail = item.trim().split(exports.COMMIT_BOUNDARY);
		            const listLogLine = lineBuilder(lineDetail[0].trim().split(splitter), fields);
		            if (lineDetail.length > 1 && !!lineDetail[1].trim()) {
		                listLogLine.diff = parse_diff_summary_1.parseDiffResult(lineDetail[1]);
		            }
		            return listLogLine;
		        });
		        return {
		            all,
		            latest: all.length && all[0] || null,
		            total: all.length,
		        };
		    };
		}
		exports.createListLogSummaryParser = createListLogSummaryParser;
		
	} (parseListLogSummary));
	return parseListLogSummary;
}

var hasRequiredLog;

function requireLog () {
	if (hasRequiredLog) return log;
	hasRequiredLog = 1;
	Object.defineProperty(log, "__esModule", { value: true });
	log.logTask = log.parseLogOptions = void 0;
	const parse_list_log_summary_1 = requireParseListLogSummary();
	const utils_1 = requireUtils();
	const task_1 = requireTask();
	var excludeOptions;
	(function (excludeOptions) {
	    excludeOptions[excludeOptions["--pretty"] = 0] = "--pretty";
	    excludeOptions[excludeOptions["max-count"] = 1] = "max-count";
	    excludeOptions[excludeOptions["maxCount"] = 2] = "maxCount";
	    excludeOptions[excludeOptions["n"] = 3] = "n";
	    excludeOptions[excludeOptions["file"] = 4] = "file";
	    excludeOptions[excludeOptions["format"] = 5] = "format";
	    excludeOptions[excludeOptions["from"] = 6] = "from";
	    excludeOptions[excludeOptions["to"] = 7] = "to";
	    excludeOptions[excludeOptions["splitter"] = 8] = "splitter";
	    excludeOptions[excludeOptions["symmetric"] = 9] = "symmetric";
	    excludeOptions[excludeOptions["mailMap"] = 10] = "mailMap";
	    excludeOptions[excludeOptions["multiLine"] = 11] = "multiLine";
	    excludeOptions[excludeOptions["strictDate"] = 12] = "strictDate";
	})(excludeOptions || (excludeOptions = {}));
	function prettyFormat(format, splitter) {
	    const fields = [];
	    const formatStr = [];
	    Object.keys(format).forEach((field) => {
	        fields.push(field);
	        formatStr.push(String(format[field]));
	    });
	    return [
	        fields, formatStr.join(splitter)
	    ];
	}
	function userOptions(input) {
	    const output = Object.assign({}, input);
	    Object.keys(input).forEach(key => {
	        if (key in excludeOptions) {
	            delete output[key];
	        }
	    });
	    return output;
	}
	function parseLogOptions(opt = {}, customArgs = []) {
	    const splitter = opt.splitter || parse_list_log_summary_1.SPLITTER;
	    const format = opt.format || {
	        hash: '%H',
	        date: opt.strictDate === false ? '%ai' : '%aI',
	        message: '%s',
	        refs: '%D',
	        body: opt.multiLine ? '%B' : '%b',
	        author_name: opt.mailMap !== false ? '%aN' : '%an',
	        author_email: opt.mailMap !== false ? '%aE' : '%ae'
	    };
	    const [fields, formatStr] = prettyFormat(format, splitter);
	    const suffix = [];
	    const command = [
	        `--pretty=format:${parse_list_log_summary_1.START_BOUNDARY}${formatStr}${parse_list_log_summary_1.COMMIT_BOUNDARY}`,
	        ...customArgs,
	    ];
	    const maxCount = opt.n || opt['max-count'] || opt.maxCount;
	    if (maxCount) {
	        command.push(`--max-count=${maxCount}`);
	    }
	    if (opt.from && opt.to) {
	        const rangeOperator = (opt.symmetric !== false) ? '...' : '..';
	        suffix.push(`${opt.from}${rangeOperator}${opt.to}`);
	    }
	    if (opt.file) {
	        suffix.push('--follow', opt.file);
	    }
	    utils_1.appendTaskOptions(userOptions(opt), command);
	    return {
	        fields,
	        splitter,
	        commands: [
	            ...command,
	            ...suffix,
	        ],
	    };
	}
	log.parseLogOptions = parseLogOptions;
	function logTask(splitter, fields, customArgs) {
	    return {
	        commands: ['log', ...customArgs],
	        format: 'utf-8',
	        parser: parse_list_log_summary_1.createListLogSummaryParser(splitter, fields),
	    };
	}
	log.logTask = logTask;
	function default_1() {
	    return {
	        log(...rest) {
	            const next = utils_1.trailingFunctionArgument(arguments);
	            const task = rejectDeprecatedSignatures(...rest) ||
	                createLogTask(parseLogOptions(utils_1.trailingOptionsArgument(arguments), utils_1.filterType(arguments[0], utils_1.filterArray)));
	            return this._runTask(task, next);
	        }
	    };
	    function createLogTask(options) {
	        return logTask(options.splitter, options.fields, options.commands);
	    }
	    function rejectDeprecatedSignatures(from, to) {
	        return (utils_1.filterString(from) &&
	            utils_1.filterString(to) &&
	            task_1.configurationErrorTask(`git.log(string, string) should be replaced with git.log({ from: string, to: string })`));
	    }
	}
	log.default = default_1;
	
	return log;
}

var merge = {};

var parseMerge = {};

var MergeSummary = {};

var hasRequiredMergeSummary;

function requireMergeSummary () {
	if (hasRequiredMergeSummary) return MergeSummary;
	hasRequiredMergeSummary = 1;
	Object.defineProperty(MergeSummary, "__esModule", { value: true });
	MergeSummary.MergeSummaryDetail = MergeSummary.MergeSummaryConflict = void 0;
	class MergeSummaryConflict {
	    constructor(reason, file = null, meta) {
	        this.reason = reason;
	        this.file = file;
	        this.meta = meta;
	    }
	    toString() {
	        return `${this.file}:${this.reason}`;
	    }
	}
	MergeSummary.MergeSummaryConflict = MergeSummaryConflict;
	class MergeSummaryDetail {
	    constructor() {
	        this.conflicts = [];
	        this.merges = [];
	        this.result = 'success';
	    }
	    get failed() {
	        return this.conflicts.length > 0;
	    }
	    get reason() {
	        return this.result;
	    }
	    toString() {
	        if (this.conflicts.length) {
	            return `CONFLICTS: ${this.conflicts.join(', ')}`;
	        }
	        return 'OK';
	    }
	}
	MergeSummary.MergeSummaryDetail = MergeSummaryDetail;
	
	return MergeSummary;
}

var parsePull = {};

var PullSummary = {};

var hasRequiredPullSummary;

function requirePullSummary () {
	if (hasRequiredPullSummary) return PullSummary;
	hasRequiredPullSummary = 1;
	Object.defineProperty(PullSummary, "__esModule", { value: true });
	PullSummary.PullSummary = void 0;
	let PullSummary$1 = class PullSummary {
	    constructor() {
	        this.remoteMessages = {
	            all: [],
	        };
	        this.created = [];
	        this.deleted = [];
	        this.files = [];
	        this.deletions = {};
	        this.insertions = {};
	        this.summary = {
	            changes: 0,
	            deletions: 0,
	            insertions: 0,
	        };
	    }
	};
	PullSummary.PullSummary = PullSummary$1;
	
	return PullSummary;
}

var parseRemoteMessages = {};

var parseRemoteObjects = {};

var hasRequiredParseRemoteObjects;

function requireParseRemoteObjects () {
	if (hasRequiredParseRemoteObjects) return parseRemoteObjects;
	hasRequiredParseRemoteObjects = 1;
	Object.defineProperty(parseRemoteObjects, "__esModule", { value: true });
	parseRemoteObjects.remoteMessagesObjectParsers = void 0;
	const utils_1 = requireUtils();
	function objectEnumerationResult(remoteMessages) {
	    return (remoteMessages.objects = remoteMessages.objects || {
	        compressing: 0,
	        counting: 0,
	        enumerating: 0,
	        packReused: 0,
	        reused: { count: 0, delta: 0 },
	        total: { count: 0, delta: 0 }
	    });
	}
	function asObjectCount(source) {
	    const count = /^\s*(\d+)/.exec(source);
	    const delta = /delta (\d+)/i.exec(source);
	    return {
	        count: utils_1.asNumber(count && count[1] || '0'),
	        delta: utils_1.asNumber(delta && delta[1] || '0'),
	    };
	}
	parseRemoteObjects.remoteMessagesObjectParsers = [
	    new utils_1.RemoteLineParser(/^remote:\s*(enumerating|counting|compressing) objects: (\d+),/i, (result, [action, count]) => {
	        const key = action.toLowerCase();
	        const enumeration = objectEnumerationResult(result.remoteMessages);
	        Object.assign(enumeration, { [key]: utils_1.asNumber(count) });
	    }),
	    new utils_1.RemoteLineParser(/^remote:\s*(enumerating|counting|compressing) objects: \d+% \(\d+\/(\d+)\),/i, (result, [action, count]) => {
	        const key = action.toLowerCase();
	        const enumeration = objectEnumerationResult(result.remoteMessages);
	        Object.assign(enumeration, { [key]: utils_1.asNumber(count) });
	    }),
	    new utils_1.RemoteLineParser(/total ([^,]+), reused ([^,]+), pack-reused (\d+)/i, (result, [total, reused, packReused]) => {
	        const objects = objectEnumerationResult(result.remoteMessages);
	        objects.total = asObjectCount(total);
	        objects.reused = asObjectCount(reused);
	        objects.packReused = utils_1.asNumber(packReused);
	    }),
	];
	
	return parseRemoteObjects;
}

var hasRequiredParseRemoteMessages;

function requireParseRemoteMessages () {
	if (hasRequiredParseRemoteMessages) return parseRemoteMessages;
	hasRequiredParseRemoteMessages = 1;
	Object.defineProperty(parseRemoteMessages, "__esModule", { value: true });
	parseRemoteMessages.RemoteMessageSummary = parseRemoteMessages.parseRemoteMessages = void 0;
	const utils_1 = requireUtils();
	const parse_remote_objects_1 = requireParseRemoteObjects();
	const parsers = [
	    new utils_1.RemoteLineParser(/^remote:\s*(.+)$/, (result, [text]) => {
	        result.remoteMessages.all.push(text.trim());
	        return false;
	    }),
	    ...parse_remote_objects_1.remoteMessagesObjectParsers,
	    new utils_1.RemoteLineParser([/create a (?:pull|merge) request/i, /\s(https?:\/\/\S+)$/], (result, [pullRequestUrl]) => {
	        result.remoteMessages.pullRequestUrl = pullRequestUrl;
	    }),
	    new utils_1.RemoteLineParser([/found (\d+) vulnerabilities.+\(([^)]+)\)/i, /\s(https?:\/\/\S+)$/], (result, [count, summary, url]) => {
	        result.remoteMessages.vulnerabilities = {
	            count: utils_1.asNumber(count),
	            summary,
	            url,
	        };
	    }),
	];
	function parseRemoteMessages$1(_stdOut, stdErr) {
	    return utils_1.parseStringResponse({ remoteMessages: new RemoteMessageSummary() }, parsers, stdErr);
	}
	parseRemoteMessages.parseRemoteMessages = parseRemoteMessages$1;
	class RemoteMessageSummary {
	    constructor() {
	        this.all = [];
	    }
	}
	parseRemoteMessages.RemoteMessageSummary = RemoteMessageSummary;
	
	return parseRemoteMessages;
}

var hasRequiredParsePull;

function requireParsePull () {
	if (hasRequiredParsePull) return parsePull;
	hasRequiredParsePull = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.parsePullResult = exports.parsePullDetail = void 0;
		const PullSummary_1 = requirePullSummary();
		const utils_1 = requireUtils();
		const parse_remote_messages_1 = requireParseRemoteMessages();
		const FILE_UPDATE_REGEX = /^\s*(.+?)\s+\|\s+\d+\s*(\+*)(-*)/;
		const SUMMARY_REGEX = /(\d+)\D+((\d+)\D+\(\+\))?(\D+(\d+)\D+\(-\))?/;
		const ACTION_REGEX = /^(create|delete) mode \d+ (.+)/;
		const parsers = [
		    new utils_1.LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {
		        result.files.push(file);
		        if (insertions) {
		            result.insertions[file] = insertions.length;
		        }
		        if (deletions) {
		            result.deletions[file] = deletions.length;
		        }
		    }),
		    new utils_1.LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {
		        if (insertions !== undefined || deletions !== undefined) {
		            result.summary.changes = +changes || 0;
		            result.summary.insertions = +insertions || 0;
		            result.summary.deletions = +deletions || 0;
		            return true;
		        }
		        return false;
		    }),
		    new utils_1.LineParser(ACTION_REGEX, (result, [action, file]) => {
		        utils_1.append(result.files, file);
		        utils_1.append((action === 'create') ? result.created : result.deleted, file);
		    }),
		];
		const parsePullDetail = (stdOut, stdErr) => {
		    return utils_1.parseStringResponse(new PullSummary_1.PullSummary(), parsers, stdOut, stdErr);
		};
		exports.parsePullDetail = parsePullDetail;
		const parsePullResult = (stdOut, stdErr) => {
		    return Object.assign(new PullSummary_1.PullSummary(), exports.parsePullDetail(stdOut, stdErr), parse_remote_messages_1.parseRemoteMessages(stdOut, stdErr));
		};
		exports.parsePullResult = parsePullResult;
		
	} (parsePull));
	return parsePull;
}

var hasRequiredParseMerge;

function requireParseMerge () {
	if (hasRequiredParseMerge) return parseMerge;
	hasRequiredParseMerge = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.parseMergeDetail = exports.parseMergeResult = void 0;
		const MergeSummary_1 = requireMergeSummary();
		const utils_1 = requireUtils();
		const parse_pull_1 = requireParsePull();
		const parsers = [
		    new utils_1.LineParser(/^Auto-merging\s+(.+)$/, (summary, [autoMerge]) => {
		        summary.merges.push(autoMerge);
		    }),
		    new utils_1.LineParser(/^CONFLICT\s+\((.+)\): Merge conflict in (.+)$/, (summary, [reason, file]) => {
		        summary.conflicts.push(new MergeSummary_1.MergeSummaryConflict(reason, file));
		    }),
		    new utils_1.LineParser(/^CONFLICT\s+\((.+\/delete)\): (.+) deleted in (.+) and/, (summary, [reason, file, deleteRef]) => {
		        summary.conflicts.push(new MergeSummary_1.MergeSummaryConflict(reason, file, { deleteRef }));
		    }),
		    new utils_1.LineParser(/^CONFLICT\s+\((.+)\):/, (summary, [reason]) => {
		        summary.conflicts.push(new MergeSummary_1.MergeSummaryConflict(reason, null));
		    }),
		    new utils_1.LineParser(/^Automatic merge failed;\s+(.+)$/, (summary, [result]) => {
		        summary.result = result;
		    }),
		];
		/**
		 * Parse the complete response from `git.merge`
		 */
		const parseMergeResult = (stdOut, stdErr) => {
		    return Object.assign(exports.parseMergeDetail(stdOut, stdErr), parse_pull_1.parsePullResult(stdOut, stdErr));
		};
		exports.parseMergeResult = parseMergeResult;
		/**
		 * Parse the merge specific detail (ie: not the content also available in the pull detail) from `git.mnerge`
		 * @param stdOut
		 */
		const parseMergeDetail = (stdOut) => {
		    return utils_1.parseStringResponse(new MergeSummary_1.MergeSummaryDetail(), parsers, stdOut);
		};
		exports.parseMergeDetail = parseMergeDetail;
		
	} (parseMerge));
	return parseMerge;
}

var hasRequiredMerge;

function requireMerge () {
	if (hasRequiredMerge) return merge;
	hasRequiredMerge = 1;
	Object.defineProperty(merge, "__esModule", { value: true });
	merge.mergeTask = void 0;
	const git_response_error_1 = requireGitResponseError();
	const parse_merge_1 = requireParseMerge();
	const task_1 = requireTask();
	function mergeTask(customArgs) {
	    if (!customArgs.length) {
	        return task_1.configurationErrorTask('Git.merge requires at least one option');
	    }
	    return {
	        commands: ['merge', ...customArgs],
	        format: 'utf-8',
	        parser(stdOut, stdErr) {
	            const merge = parse_merge_1.parseMergeResult(stdOut, stdErr);
	            if (merge.failed) {
	                throw new git_response_error_1.GitResponseError(merge);
	            }
	            return merge;
	        }
	    };
	}
	merge.mergeTask = mergeTask;
	
	return merge;
}

var push = {};

var parsePush = {};

var hasRequiredParsePush;

function requireParsePush () {
	if (hasRequiredParsePush) return parsePush;
	hasRequiredParsePush = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.parsePushDetail = exports.parsePushResult = void 0;
		const utils_1 = requireUtils();
		const parse_remote_messages_1 = requireParseRemoteMessages();
		function pushResultPushedItem(local, remote, status) {
		    const deleted = status.includes('deleted');
		    const tag = status.includes('tag') || /^refs\/tags/.test(local);
		    const alreadyUpdated = !status.includes('new');
		    return {
		        deleted,
		        tag,
		        branch: !tag,
		        new: !alreadyUpdated,
		        alreadyUpdated,
		        local,
		        remote,
		    };
		}
		const parsers = [
		    new utils_1.LineParser(/^Pushing to (.+)$/, (result, [repo]) => {
		        result.repo = repo;
		    }),
		    new utils_1.LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {
		        result.ref = Object.assign(Object.assign({}, (result.ref || {})), { local });
		    }),
		    new utils_1.LineParser(/^[*-=]\s+([^:]+):(\S+)\s+\[(.+)]$/, (result, [local, remote, type]) => {
		        result.pushed.push(pushResultPushedItem(local, remote, type));
		    }),
		    new utils_1.LineParser(/^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/, (result, [local, remote, remoteName]) => {
		        result.branch = Object.assign(Object.assign({}, (result.branch || {})), { local,
		            remote,
		            remoteName });
		    }),
		    new utils_1.LineParser(/^([^:]+):(\S+)\s+([a-z0-9]+)\.\.([a-z0-9]+)$/, (result, [local, remote, from, to]) => {
		        result.update = {
		            head: {
		                local,
		                remote,
		            },
		            hash: {
		                from,
		                to,
		            },
		        };
		    }),
		];
		const parsePushResult = (stdOut, stdErr) => {
		    const pushDetail = exports.parsePushDetail(stdOut, stdErr);
		    const responseDetail = parse_remote_messages_1.parseRemoteMessages(stdOut, stdErr);
		    return Object.assign(Object.assign({}, pushDetail), responseDetail);
		};
		exports.parsePushResult = parsePushResult;
		const parsePushDetail = (stdOut, stdErr) => {
		    return utils_1.parseStringResponse({ pushed: [] }, parsers, stdOut, stdErr);
		};
		exports.parsePushDetail = parsePushDetail;
		
	} (parsePush));
	return parsePush;
}

var hasRequiredPush;

function requirePush () {
	if (hasRequiredPush) return push;
	hasRequiredPush = 1;
	Object.defineProperty(push, "__esModule", { value: true });
	push.pushTask = push.pushTagsTask = void 0;
	const parse_push_1 = requireParsePush();
	const utils_1 = requireUtils();
	function pushTagsTask(ref = {}, customArgs) {
	    utils_1.append(customArgs, '--tags');
	    return pushTask(ref, customArgs);
	}
	push.pushTagsTask = pushTagsTask;
	function pushTask(ref = {}, customArgs) {
	    const commands = ['push', ...customArgs];
	    if (ref.branch) {
	        commands.splice(1, 0, ref.branch);
	    }
	    if (ref.remote) {
	        commands.splice(1, 0, ref.remote);
	    }
	    utils_1.remove(commands, '-v');
	    utils_1.append(commands, '--verbose');
	    utils_1.append(commands, '--porcelain');
	    return {
	        commands,
	        format: 'utf-8',
	        parser: parse_push_1.parsePushResult,
	    };
	}
	push.pushTask = pushTask;
	
	return push;
}

var status = {};

var StatusSummary = {};

var FileStatusSummary = {};

var hasRequiredFileStatusSummary;

function requireFileStatusSummary () {
	if (hasRequiredFileStatusSummary) return FileStatusSummary;
	hasRequiredFileStatusSummary = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.FileStatusSummary = exports.fromPathRegex = void 0;
		exports.fromPathRegex = /^(.+) -> (.+)$/;
		class FileStatusSummary {
		    constructor(path, index, working_dir) {
		        this.path = path;
		        this.index = index;
		        this.working_dir = working_dir;
		        if ('R' === (index + working_dir)) {
		            const detail = exports.fromPathRegex.exec(path) || [null, path, path];
		            this.from = detail[1] || '';
		            this.path = detail[2] || '';
		        }
		    }
		}
		exports.FileStatusSummary = FileStatusSummary;
		
	} (FileStatusSummary));
	return FileStatusSummary;
}

var hasRequiredStatusSummary;

function requireStatusSummary () {
	if (hasRequiredStatusSummary) return StatusSummary;
	hasRequiredStatusSummary = 1;
	Object.defineProperty(StatusSummary, "__esModule", { value: true });
	StatusSummary.parseStatusSummary = StatusSummary.StatusSummary = void 0;
	const utils_1 = requireUtils();
	const FileStatusSummary_1 = requireFileStatusSummary();
	let StatusSummary$1 = class StatusSummary {
	    constructor() {
	        this.not_added = [];
	        this.conflicted = [];
	        this.created = [];
	        this.deleted = [];
	        this.modified = [];
	        this.renamed = [];
	        this.files = [];
	        this.staged = [];
	        this.ahead = 0;
	        this.behind = 0;
	        this.current = null;
	        this.tracking = null;
	        this.detached = false;
	    }
	    isClean() {
	        return !this.files.length;
	    }
	};
	StatusSummary.StatusSummary = StatusSummary$1;
	var PorcelainFileStatus;
	(function (PorcelainFileStatus) {
	    PorcelainFileStatus["ADDED"] = "A";
	    PorcelainFileStatus["DELETED"] = "D";
	    PorcelainFileStatus["MODIFIED"] = "M";
	    PorcelainFileStatus["RENAMED"] = "R";
	    PorcelainFileStatus["COPIED"] = "C";
	    PorcelainFileStatus["UNMERGED"] = "U";
	    PorcelainFileStatus["UNTRACKED"] = "?";
	    PorcelainFileStatus["IGNORED"] = "!";
	    PorcelainFileStatus["NONE"] = " ";
	})(PorcelainFileStatus || (PorcelainFileStatus = {}));
	function renamedFile(line) {
	    const detail = /^(.+) -> (.+)$/.exec(line);
	    if (!detail) {
	        return {
	            from: line, to: line
	        };
	    }
	    return {
	        from: String(detail[1]),
	        to: String(detail[2]),
	    };
	}
	function parser(indexX, indexY, handler) {
	    return [`${indexX}${indexY}`, handler];
	}
	function conflicts(indexX, ...indexY) {
	    return indexY.map(y => parser(indexX, y, (result, file) => utils_1.append(result.conflicted, file)));
	}
	const parsers = new Map([
	    parser(PorcelainFileStatus.NONE, PorcelainFileStatus.ADDED, (result, file) => utils_1.append(result.created, file)),
	    parser(PorcelainFileStatus.NONE, PorcelainFileStatus.DELETED, (result, file) => utils_1.append(result.deleted, file)),
	    parser(PorcelainFileStatus.NONE, PorcelainFileStatus.MODIFIED, (result, file) => utils_1.append(result.modified, file)),
	    parser(PorcelainFileStatus.ADDED, PorcelainFileStatus.NONE, (result, file) => utils_1.append(result.created, file) && utils_1.append(result.staged, file)),
	    parser(PorcelainFileStatus.ADDED, PorcelainFileStatus.MODIFIED, (result, file) => utils_1.append(result.created, file) && utils_1.append(result.staged, file) && utils_1.append(result.modified, file)),
	    parser(PorcelainFileStatus.DELETED, PorcelainFileStatus.NONE, (result, file) => utils_1.append(result.deleted, file) && utils_1.append(result.staged, file)),
	    parser(PorcelainFileStatus.MODIFIED, PorcelainFileStatus.NONE, (result, file) => utils_1.append(result.modified, file) && utils_1.append(result.staged, file)),
	    parser(PorcelainFileStatus.MODIFIED, PorcelainFileStatus.MODIFIED, (result, file) => utils_1.append(result.modified, file) && utils_1.append(result.staged, file)),
	    parser(PorcelainFileStatus.RENAMED, PorcelainFileStatus.NONE, (result, file) => {
	        utils_1.append(result.renamed, renamedFile(file));
	    }),
	    parser(PorcelainFileStatus.RENAMED, PorcelainFileStatus.MODIFIED, (result, file) => {
	        const renamed = renamedFile(file);
	        utils_1.append(result.renamed, renamed);
	        utils_1.append(result.modified, renamed.to);
	    }),
	    parser(PorcelainFileStatus.UNTRACKED, PorcelainFileStatus.UNTRACKED, (result, file) => utils_1.append(result.not_added, file)),
	    ...conflicts(PorcelainFileStatus.ADDED, PorcelainFileStatus.ADDED, PorcelainFileStatus.UNMERGED),
	    ...conflicts(PorcelainFileStatus.DELETED, PorcelainFileStatus.DELETED, PorcelainFileStatus.UNMERGED),
	    ...conflicts(PorcelainFileStatus.UNMERGED, PorcelainFileStatus.ADDED, PorcelainFileStatus.DELETED, PorcelainFileStatus.UNMERGED),
	    ['##', (result, line) => {
	            const aheadReg = /ahead (\d+)/;
	            const behindReg = /behind (\d+)/;
	            const currentReg = /^(.+?(?=(?:\.{3}|\s|$)))/;
	            const trackingReg = /\.{3}(\S*)/;
	            const onEmptyBranchReg = /\son\s([\S]+)$/;
	            let regexResult;
	            regexResult = aheadReg.exec(line);
	            result.ahead = regexResult && +regexResult[1] || 0;
	            regexResult = behindReg.exec(line);
	            result.behind = regexResult && +regexResult[1] || 0;
	            regexResult = currentReg.exec(line);
	            result.current = regexResult && regexResult[1];
	            regexResult = trackingReg.exec(line);
	            result.tracking = regexResult && regexResult[1];
	            regexResult = onEmptyBranchReg.exec(line);
	            result.current = regexResult && regexResult[1] || result.current;
	            result.detached = /\(no branch\)/.test(line);
	        }]
	]);
	const parseStatusSummary = function (text) {
	    const lines = text.trim().split('\n');
	    const status = new StatusSummary$1();
	    for (let i = 0, l = lines.length; i < l; i++) {
	        splitLine(status, lines[i]);
	    }
	    return status;
	};
	StatusSummary.parseStatusSummary = parseStatusSummary;
	function splitLine(result, lineStr) {
	    const trimmed = lineStr.trim();
	    switch (' ') {
	        case trimmed.charAt(2):
	            return data(trimmed.charAt(0), trimmed.charAt(1), trimmed.substr(3));
	        case trimmed.charAt(1):
	            return data(PorcelainFileStatus.NONE, trimmed.charAt(0), trimmed.substr(2));
	        default:
	            return;
	    }
	    function data(index, workingDir, path) {
	        const raw = `${index}${workingDir}`;
	        const handler = parsers.get(raw);
	        if (handler) {
	            handler(result, path);
	        }
	        if (raw !== '##') {
	            result.files.push(new FileStatusSummary_1.FileStatusSummary(path, index, workingDir));
	        }
	    }
	}
	
	return StatusSummary;
}

var hasRequiredStatus;

function requireStatus () {
	if (hasRequiredStatus) return status;
	hasRequiredStatus = 1;
	Object.defineProperty(status, "__esModule", { value: true });
	status.statusTask = void 0;
	const StatusSummary_1 = requireStatusSummary();
	function statusTask(customArgs) {
	    return {
	        format: 'utf-8',
	        commands: ['status', '--porcelain', '-b', '-u', ...customArgs],
	        parser(text) {
	            return StatusSummary_1.parseStatusSummary(text);
	        }
	    };
	}
	status.statusTask = statusTask;
	
	return status;
}

var hasRequiredSimpleGitApi;

function requireSimpleGitApi () {
	if (hasRequiredSimpleGitApi) return simpleGitApi;
	hasRequiredSimpleGitApi = 1;
	Object.defineProperty(simpleGitApi, "__esModule", { value: true });
	simpleGitApi.SimpleGitApi = void 0;
	const task_callback_1 = requireTaskCallback();
	const change_working_directory_1 = requireChangeWorkingDirectory();
	const config_1 = requireConfig();
	const grep_1 = requireGrep();
	const hash_object_1 = requireHashObject();
	const init_1 = requireInit();
	const log_1 = requireLog();
	const merge_1 = requireMerge();
	const push_1 = requirePush();
	const status_1 = requireStatus();
	const task_1 = requireTask();
	const utils_1 = requireUtils();
	class SimpleGitApi {
	    constructor(_executor) {
	        this._executor = _executor;
	    }
	    _runTask(task, then) {
	        const chain = this._executor.chain();
	        const promise = chain.push(task);
	        if (then) {
	            task_callback_1.taskCallback(task, promise, then);
	        }
	        return Object.create(this, {
	            then: { value: promise.then.bind(promise) },
	            catch: { value: promise.catch.bind(promise) },
	            _executor: { value: chain },
	        });
	    }
	    add(files) {
	        return this._runTask(task_1.straightThroughStringTask(['add', ...utils_1.asArray(files)]), utils_1.trailingFunctionArgument(arguments));
	    }
	    cwd(directory) {
	        const next = utils_1.trailingFunctionArgument(arguments);
	        if (typeof directory === 'string') {
	            return this._runTask(change_working_directory_1.changeWorkingDirectoryTask(directory, this._executor), next);
	        }
	        if (typeof (directory === null || directory === void 0 ? void 0 : directory.path) === 'string') {
	            return this._runTask(change_working_directory_1.changeWorkingDirectoryTask(directory.path, directory.root && this._executor || undefined), next);
	        }
	        return this._runTask(task_1.configurationErrorTask('Git.cwd: workingDirectory must be supplied as a string'), next);
	    }
	    hashObject(path, write) {
	        return this._runTask(hash_object_1.hashObjectTask(path, write === true), utils_1.trailingFunctionArgument(arguments));
	    }
	    init(bare) {
	        return this._runTask(init_1.initTask(bare === true, this._executor.cwd, utils_1.getTrailingOptions(arguments)), utils_1.trailingFunctionArgument(arguments));
	    }
	    merge() {
	        return this._runTask(merge_1.mergeTask(utils_1.getTrailingOptions(arguments)), utils_1.trailingFunctionArgument(arguments));
	    }
	    mergeFromTo(remote, branch) {
	        if (!(utils_1.filterString(remote) && utils_1.filterString(branch))) {
	            return this._runTask(task_1.configurationErrorTask(`Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`));
	        }
	        return this._runTask(merge_1.mergeTask([remote, branch, ...utils_1.getTrailingOptions(arguments)]), utils_1.trailingFunctionArgument(arguments, false));
	    }
	    outputHandler(handler) {
	        this._executor.outputHandler = handler;
	        return this;
	    }
	    push() {
	        const task = push_1.pushTask({
	            remote: utils_1.filterType(arguments[0], utils_1.filterString),
	            branch: utils_1.filterType(arguments[1], utils_1.filterString),
	        }, utils_1.getTrailingOptions(arguments));
	        return this._runTask(task, utils_1.trailingFunctionArgument(arguments));
	    }
	    stash() {
	        return this._runTask(task_1.straightThroughStringTask(['stash', ...utils_1.getTrailingOptions(arguments)]), utils_1.trailingFunctionArgument(arguments));
	    }
	    status() {
	        return this._runTask(status_1.statusTask(utils_1.getTrailingOptions(arguments)), utils_1.trailingFunctionArgument(arguments));
	    }
	}
	simpleGitApi.SimpleGitApi = SimpleGitApi;
	Object.assign(SimpleGitApi.prototype, config_1.default(), grep_1.default(), log_1.default());
	
	return simpleGitApi;
}

var scheduler = {};

var hasRequiredScheduler;

function requireScheduler () {
	if (hasRequiredScheduler) return scheduler;
	hasRequiredScheduler = 1;
	Object.defineProperty(scheduler, "__esModule", { value: true });
	scheduler.Scheduler = void 0;
	const utils_1 = requireUtils();
	const promise_deferred_1 = requireDist();
	const git_logger_1 = requireGitLogger();
	const createScheduledTask = (() => {
	    let id = 0;
	    return () => {
	        id++;
	        const { promise, done } = promise_deferred_1.createDeferred();
	        return {
	            promise,
	            done,
	            id,
	        };
	    };
	})();
	class Scheduler {
	    constructor(concurrency = 2) {
	        this.concurrency = concurrency;
	        this.logger = git_logger_1.createLogger('', 'scheduler');
	        this.pending = [];
	        this.running = [];
	        this.logger(`Constructed, concurrency=%s`, concurrency);
	    }
	    schedule() {
	        if (!this.pending.length || this.running.length >= this.concurrency) {
	            this.logger(`Schedule attempt ignored, pending=%s running=%s concurrency=%s`, this.pending.length, this.running.length, this.concurrency);
	            return;
	        }
	        const task = utils_1.append(this.running, this.pending.shift());
	        this.logger(`Attempting id=%s`, task.id);
	        task.done(() => {
	            this.logger(`Completing id=`, task.id);
	            utils_1.remove(this.running, task);
	            this.schedule();
	        });
	    }
	    next() {
	        const { promise, id } = utils_1.append(this.pending, createScheduledTask());
	        this.logger(`Scheduling id=%s`, id);
	        this.schedule();
	        return promise;
	    }
	}
	scheduler.Scheduler = Scheduler;
	
	return scheduler;
}

var applyPatch = {};

var hasRequiredApplyPatch;

function requireApplyPatch () {
	if (hasRequiredApplyPatch) return applyPatch;
	hasRequiredApplyPatch = 1;
	Object.defineProperty(applyPatch, "__esModule", { value: true });
	applyPatch.applyPatchTask = void 0;
	const task_1 = requireTask();
	function applyPatchTask(patches, customArgs) {
	    return task_1.straightThroughStringTask(['apply', ...customArgs, ...patches]);
	}
	applyPatch.applyPatchTask = applyPatchTask;
	
	return applyPatch;
}

var branch = {};

var parseBranchDelete = {};

var BranchDeleteSummary = {};

var hasRequiredBranchDeleteSummary;

function requireBranchDeleteSummary () {
	if (hasRequiredBranchDeleteSummary) return BranchDeleteSummary;
	hasRequiredBranchDeleteSummary = 1;
	Object.defineProperty(BranchDeleteSummary, "__esModule", { value: true });
	BranchDeleteSummary.isSingleBranchDeleteFailure = BranchDeleteSummary.branchDeletionFailure = BranchDeleteSummary.branchDeletionSuccess = BranchDeleteSummary.BranchDeletionBatch = void 0;
	class BranchDeletionBatch {
	    constructor() {
	        this.all = [];
	        this.branches = {};
	        this.errors = [];
	    }
	    get success() {
	        return !this.errors.length;
	    }
	}
	BranchDeleteSummary.BranchDeletionBatch = BranchDeletionBatch;
	function branchDeletionSuccess(branch, hash) {
	    return {
	        branch, hash, success: true,
	    };
	}
	BranchDeleteSummary.branchDeletionSuccess = branchDeletionSuccess;
	function branchDeletionFailure(branch) {
	    return {
	        branch, hash: null, success: false,
	    };
	}
	BranchDeleteSummary.branchDeletionFailure = branchDeletionFailure;
	function isSingleBranchDeleteFailure(test) {
	    return test.success;
	}
	BranchDeleteSummary.isSingleBranchDeleteFailure = isSingleBranchDeleteFailure;
	
	return BranchDeleteSummary;
}

var hasRequiredParseBranchDelete;

function requireParseBranchDelete () {
	if (hasRequiredParseBranchDelete) return parseBranchDelete;
	hasRequiredParseBranchDelete = 1;
	Object.defineProperty(parseBranchDelete, "__esModule", { value: true });
	parseBranchDelete.hasBranchDeletionError = parseBranchDelete.parseBranchDeletions = void 0;
	const BranchDeleteSummary_1 = requireBranchDeleteSummary();
	const utils_1 = requireUtils();
	const deleteSuccessRegex = /(\S+)\s+\(\S+\s([^)]+)\)/;
	const deleteErrorRegex = /^error[^']+'([^']+)'/m;
	const parsers = [
	    new utils_1.LineParser(deleteSuccessRegex, (result, [branch, hash]) => {
	        const deletion = BranchDeleteSummary_1.branchDeletionSuccess(branch, hash);
	        result.all.push(deletion);
	        result.branches[branch] = deletion;
	    }),
	    new utils_1.LineParser(deleteErrorRegex, (result, [branch]) => {
	        const deletion = BranchDeleteSummary_1.branchDeletionFailure(branch);
	        result.errors.push(deletion);
	        result.all.push(deletion);
	        result.branches[branch] = deletion;
	    }),
	];
	const parseBranchDeletions = (stdOut, stdErr) => {
	    return utils_1.parseStringResponse(new BranchDeleteSummary_1.BranchDeletionBatch(), parsers, stdOut, stdErr);
	};
	parseBranchDelete.parseBranchDeletions = parseBranchDeletions;
	function hasBranchDeletionError(data, processExitCode) {
	    return processExitCode === utils_1.ExitCodes.ERROR && deleteErrorRegex.test(data);
	}
	parseBranchDelete.hasBranchDeletionError = hasBranchDeletionError;
	
	return parseBranchDelete;
}

var parseBranch = {};

var BranchSummary = {};

var hasRequiredBranchSummary;

function requireBranchSummary () {
	if (hasRequiredBranchSummary) return BranchSummary;
	hasRequiredBranchSummary = 1;
	Object.defineProperty(BranchSummary, "__esModule", { value: true });
	BranchSummary.BranchSummaryResult = void 0;
	class BranchSummaryResult {
	    constructor() {
	        this.all = [];
	        this.branches = {};
	        this.current = '';
	        this.detached = false;
	    }
	    push(current, detached, name, commit, label) {
	        if (current) {
	            this.detached = detached;
	            this.current = name;
	        }
	        this.all.push(name);
	        this.branches[name] = {
	            current: current,
	            name: name,
	            commit: commit,
	            label: label
	        };
	    }
	}
	BranchSummary.BranchSummaryResult = BranchSummaryResult;
	
	return BranchSummary;
}

var hasRequiredParseBranch;

function requireParseBranch () {
	if (hasRequiredParseBranch) return parseBranch;
	hasRequiredParseBranch = 1;
	Object.defineProperty(parseBranch, "__esModule", { value: true });
	parseBranch.parseBranchSummary = void 0;
	const BranchSummary_1 = requireBranchSummary();
	const utils_1 = requireUtils();
	const parsers = [
	    new utils_1.LineParser(/^(\*\s)?\((?:HEAD )?detached (?:from|at) (\S+)\)\s+([a-z0-9]+)\s(.*)$/, (result, [current, name, commit, label]) => {
	        result.push(!!current, true, name, commit, label);
	    }),
	    new utils_1.LineParser(/^(\*\s)?(\S+)\s+([a-z0-9]+)\s(.*)$/s, (result, [current, name, commit, label]) => {
	        result.push(!!current, false, name, commit, label);
	    })
	];
	function parseBranchSummary(stdOut) {
	    return utils_1.parseStringResponse(new BranchSummary_1.BranchSummaryResult(), parsers, stdOut);
	}
	parseBranch.parseBranchSummary = parseBranchSummary;
	
	return parseBranch;
}

var hasRequiredBranch;

function requireBranch () {
	if (hasRequiredBranch) return branch;
	hasRequiredBranch = 1;
	Object.defineProperty(branch, "__esModule", { value: true });
	branch.deleteBranchTask = branch.deleteBranchesTask = branch.branchLocalTask = branch.branchTask = branch.containsDeleteBranchCommand = void 0;
	const git_response_error_1 = requireGitResponseError();
	const parse_branch_delete_1 = requireParseBranchDelete();
	const parse_branch_1 = requireParseBranch();
	const utils_1 = requireUtils();
	function containsDeleteBranchCommand(commands) {
	    const deleteCommands = ['-d', '-D', '--delete'];
	    return commands.some(command => deleteCommands.includes(command));
	}
	branch.containsDeleteBranchCommand = containsDeleteBranchCommand;
	function branchTask(customArgs) {
	    const isDelete = containsDeleteBranchCommand(customArgs);
	    const commands = ['branch', ...customArgs];
	    if (commands.length === 1) {
	        commands.push('-a');
	    }
	    if (!commands.includes('-v')) {
	        commands.splice(1, 0, '-v');
	    }
	    return {
	        format: 'utf-8',
	        commands,
	        parser(stdOut, stdErr) {
	            if (isDelete) {
	                return parse_branch_delete_1.parseBranchDeletions(stdOut, stdErr).all[0];
	            }
	            return parse_branch_1.parseBranchSummary(stdOut);
	        },
	    };
	}
	branch.branchTask = branchTask;
	function branchLocalTask() {
	    const parser = parse_branch_1.parseBranchSummary;
	    return {
	        format: 'utf-8',
	        commands: ['branch', '-v'],
	        parser,
	    };
	}
	branch.branchLocalTask = branchLocalTask;
	function deleteBranchesTask(branches, forceDelete = false) {
	    return {
	        format: 'utf-8',
	        commands: ['branch', '-v', forceDelete ? '-D' : '-d', ...branches],
	        parser(stdOut, stdErr) {
	            return parse_branch_delete_1.parseBranchDeletions(stdOut, stdErr);
	        },
	        onError({ exitCode, stdOut }, error, done, fail) {
	            if (!parse_branch_delete_1.hasBranchDeletionError(String(error), exitCode)) {
	                return fail(error);
	            }
	            done(stdOut);
	        },
	    };
	}
	branch.deleteBranchesTask = deleteBranchesTask;
	function deleteBranchTask(branch, forceDelete = false) {
	    const task = {
	        format: 'utf-8',
	        commands: ['branch', '-v', forceDelete ? '-D' : '-d', branch],
	        parser(stdOut, stdErr) {
	            return parse_branch_delete_1.parseBranchDeletions(stdOut, stdErr).branches[branch];
	        },
	        onError({ exitCode, stdErr, stdOut }, error, _, fail) {
	            if (!parse_branch_delete_1.hasBranchDeletionError(String(error), exitCode)) {
	                return fail(error);
	            }
	            throw new git_response_error_1.GitResponseError(task.parser(utils_1.bufferToString(stdOut), utils_1.bufferToString(stdErr)), String(error));
	        },
	    };
	    return task;
	}
	branch.deleteBranchTask = deleteBranchTask;
	
	return branch;
}

var checkIgnore = {};

var CheckIgnore = {};

var hasRequiredCheckIgnore$1;

function requireCheckIgnore$1 () {
	if (hasRequiredCheckIgnore$1) return CheckIgnore;
	hasRequiredCheckIgnore$1 = 1;
	Object.defineProperty(CheckIgnore, "__esModule", { value: true });
	CheckIgnore.parseCheckIgnore = void 0;
	/**
	 * Parser for the `check-ignore` command - returns each file as a string array
	 */
	const parseCheckIgnore = (text) => {
	    return text.split(/\n/g)
	        .map(line => line.trim())
	        .filter(file => !!file);
	};
	CheckIgnore.parseCheckIgnore = parseCheckIgnore;
	
	return CheckIgnore;
}

var hasRequiredCheckIgnore;

function requireCheckIgnore () {
	if (hasRequiredCheckIgnore) return checkIgnore;
	hasRequiredCheckIgnore = 1;
	Object.defineProperty(checkIgnore, "__esModule", { value: true });
	checkIgnore.checkIgnoreTask = void 0;
	const CheckIgnore_1 = requireCheckIgnore$1();
	function checkIgnoreTask(paths) {
	    return {
	        commands: ['check-ignore', ...paths],
	        format: 'utf-8',
	        parser: CheckIgnore_1.parseCheckIgnore,
	    };
	}
	checkIgnore.checkIgnoreTask = checkIgnoreTask;
	
	return checkIgnore;
}

var clone = {};

var hasRequiredClone;

function requireClone () {
	if (hasRequiredClone) return clone;
	hasRequiredClone = 1;
	Object.defineProperty(clone, "__esModule", { value: true });
	clone.cloneMirrorTask = clone.cloneTask = void 0;
	const task_1 = requireTask();
	const utils_1 = requireUtils();
	function cloneTask(repo, directory, customArgs) {
	    const commands = ['clone', ...customArgs];
	    if (typeof repo === 'string') {
	        commands.push(repo);
	    }
	    if (typeof directory === 'string') {
	        commands.push(directory);
	    }
	    return task_1.straightThroughStringTask(commands);
	}
	clone.cloneTask = cloneTask;
	function cloneMirrorTask(repo, directory, customArgs) {
	    utils_1.append(customArgs, '--mirror');
	    return cloneTask(repo, directory, customArgs);
	}
	clone.cloneMirrorTask = cloneMirrorTask;
	
	return clone;
}

var commit = {};

var parseCommit = {};

var hasRequiredParseCommit;

function requireParseCommit () {
	if (hasRequiredParseCommit) return parseCommit;
	hasRequiredParseCommit = 1;
	Object.defineProperty(parseCommit, "__esModule", { value: true });
	parseCommit.parseCommitResult = void 0;
	const utils_1 = requireUtils();
	const parsers = [
	    new utils_1.LineParser(/^\[([^\s]+)( \([^)]+\))? ([^\]]+)/, (result, [branch, root, commit]) => {
	        result.branch = branch;
	        result.commit = commit;
	        result.root = !!root;
	    }),
	    new utils_1.LineParser(/\s*Author:\s(.+)/i, (result, [author]) => {
	        const parts = author.split('<');
	        const email = parts.pop();
	        if (!email || !email.includes('@')) {
	            return;
	        }
	        result.author = {
	            email: email.substr(0, email.length - 1),
	            name: parts.join('<').trim()
	        };
	    }),
	    new utils_1.LineParser(/(\d+)[^,]*(?:,\s*(\d+)[^,]*)(?:,\s*(\d+))/g, (result, [changes, insertions, deletions]) => {
	        result.summary.changes = parseInt(changes, 10) || 0;
	        result.summary.insertions = parseInt(insertions, 10) || 0;
	        result.summary.deletions = parseInt(deletions, 10) || 0;
	    }),
	    new utils_1.LineParser(/^(\d+)[^,]*(?:,\s*(\d+)[^(]+\(([+-]))?/, (result, [changes, lines, direction]) => {
	        result.summary.changes = parseInt(changes, 10) || 0;
	        const count = parseInt(lines, 10) || 0;
	        if (direction === '-') {
	            result.summary.deletions = count;
	        }
	        else if (direction === '+') {
	            result.summary.insertions = count;
	        }
	    }),
	];
	function parseCommitResult(stdOut) {
	    const result = {
	        author: null,
	        branch: '',
	        commit: '',
	        root: false,
	        summary: {
	            changes: 0,
	            insertions: 0,
	            deletions: 0,
	        },
	    };
	    return utils_1.parseStringResponse(result, parsers, stdOut);
	}
	parseCommit.parseCommitResult = parseCommitResult;
	
	return parseCommit;
}

var hasRequiredCommit;

function requireCommit () {
	if (hasRequiredCommit) return commit;
	hasRequiredCommit = 1;
	Object.defineProperty(commit, "__esModule", { value: true });
	commit.commitTask = void 0;
	const parse_commit_1 = requireParseCommit();
	function commitTask(message, files, customArgs) {
	    const commands = ['commit'];
	    message.forEach((m) => commands.push('-m', m));
	    commands.push(...files, ...customArgs);
	    return {
	        commands,
	        format: 'utf-8',
	        parser: parse_commit_1.parseCommitResult,
	    };
	}
	commit.commitTask = commitTask;
	
	return commit;
}

var diff = {};

var hasRequiredDiff;

function requireDiff () {
	if (hasRequiredDiff) return diff;
	hasRequiredDiff = 1;
	Object.defineProperty(diff, "__esModule", { value: true });
	diff.diffSummaryTask = void 0;
	const parse_diff_summary_1 = requireParseDiffSummary();
	function diffSummaryTask(customArgs) {
	    return {
	        commands: ['diff', '--stat=4096', ...customArgs],
	        format: 'utf-8',
	        parser(stdOut) {
	            return parse_diff_summary_1.parseDiffResult(stdOut);
	        }
	    };
	}
	diff.diffSummaryTask = diffSummaryTask;
	
	return diff;
}

var fetch = {};

var parseFetch = {};

var hasRequiredParseFetch;

function requireParseFetch () {
	if (hasRequiredParseFetch) return parseFetch;
	hasRequiredParseFetch = 1;
	Object.defineProperty(parseFetch, "__esModule", { value: true });
	parseFetch.parseFetchResult = void 0;
	const utils_1 = requireUtils();
	const parsers = [
	    new utils_1.LineParser(/From (.+)$/, (result, [remote]) => {
	        result.remote = remote;
	    }),
	    new utils_1.LineParser(/\* \[new branch]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
	        result.branches.push({
	            name,
	            tracking,
	        });
	    }),
	    new utils_1.LineParser(/\* \[new tag]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
	        result.tags.push({
	            name,
	            tracking,
	        });
	    })
	];
	function parseFetchResult(stdOut, stdErr) {
	    const result = {
	        raw: stdOut,
	        remote: null,
	        branches: [],
	        tags: [],
	    };
	    return utils_1.parseStringResponse(result, parsers, stdOut, stdErr);
	}
	parseFetch.parseFetchResult = parseFetchResult;
	
	return parseFetch;
}

var hasRequiredFetch;

function requireFetch () {
	if (hasRequiredFetch) return fetch;
	hasRequiredFetch = 1;
	Object.defineProperty(fetch, "__esModule", { value: true });
	fetch.fetchTask = void 0;
	const parse_fetch_1 = requireParseFetch();
	function fetchTask(remote, branch, customArgs) {
	    const commands = ['fetch', ...customArgs];
	    if (remote && branch) {
	        commands.push(remote, branch);
	    }
	    return {
	        commands,
	        format: 'utf-8',
	        parser: parse_fetch_1.parseFetchResult,
	    };
	}
	fetch.fetchTask = fetchTask;
	
	return fetch;
}

var move = {};

var parseMove = {};

var hasRequiredParseMove;

function requireParseMove () {
	if (hasRequiredParseMove) return parseMove;
	hasRequiredParseMove = 1;
	Object.defineProperty(parseMove, "__esModule", { value: true });
	parseMove.parseMoveResult = void 0;
	const utils_1 = requireUtils();
	const parsers = [
	    new utils_1.LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {
	        result.moves.push({ from, to });
	    }),
	];
	function parseMoveResult(stdOut) {
	    return utils_1.parseStringResponse({ moves: [] }, parsers, stdOut);
	}
	parseMove.parseMoveResult = parseMoveResult;
	
	return parseMove;
}

var hasRequiredMove;

function requireMove () {
	if (hasRequiredMove) return move;
	hasRequiredMove = 1;
	Object.defineProperty(move, "__esModule", { value: true });
	move.moveTask = void 0;
	const parse_move_1 = requireParseMove();
	const utils_1 = requireUtils();
	function moveTask(from, to) {
	    return {
	        commands: ['mv', '-v', ...utils_1.asArray(from), to],
	        format: 'utf-8',
	        parser: parse_move_1.parseMoveResult,
	    };
	}
	move.moveTask = moveTask;
	
	return move;
}

var pull = {};

var hasRequiredPull;

function requirePull () {
	if (hasRequiredPull) return pull;
	hasRequiredPull = 1;
	Object.defineProperty(pull, "__esModule", { value: true });
	pull.pullTask = void 0;
	const parse_pull_1 = requireParsePull();
	function pullTask(remote, branch, customArgs) {
	    const commands = ['pull', ...customArgs];
	    if (remote && branch) {
	        commands.splice(1, 0, remote, branch);
	    }
	    return {
	        commands,
	        format: 'utf-8',
	        parser(stdOut, stdErr) {
	            return parse_pull_1.parsePullResult(stdOut, stdErr);
	        }
	    };
	}
	pull.pullTask = pullTask;
	
	return pull;
}

var remote = {};

var GetRemoteSummary = {};

var hasRequiredGetRemoteSummary;

function requireGetRemoteSummary () {
	if (hasRequiredGetRemoteSummary) return GetRemoteSummary;
	hasRequiredGetRemoteSummary = 1;
	Object.defineProperty(GetRemoteSummary, "__esModule", { value: true });
	GetRemoteSummary.parseGetRemotesVerbose = GetRemoteSummary.parseGetRemotes = void 0;
	const utils_1 = requireUtils();
	function parseGetRemotes(text) {
	    const remotes = {};
	    forEach(text, ([name]) => remotes[name] = { name });
	    return Object.values(remotes);
	}
	GetRemoteSummary.parseGetRemotes = parseGetRemotes;
	function parseGetRemotesVerbose(text) {
	    const remotes = {};
	    forEach(text, ([name, url, purpose]) => {
	        if (!remotes.hasOwnProperty(name)) {
	            remotes[name] = {
	                name: name,
	                refs: { fetch: '', push: '' },
	            };
	        }
	        if (purpose && url) {
	            remotes[name].refs[purpose.replace(/[^a-z]/g, '')] = url;
	        }
	    });
	    return Object.values(remotes);
	}
	GetRemoteSummary.parseGetRemotesVerbose = parseGetRemotesVerbose;
	function forEach(text, handler) {
	    utils_1.forEachLineWithContent(text, (line) => handler(line.split(/\s+/)));
	}
	
	return GetRemoteSummary;
}

var hasRequiredRemote;

function requireRemote () {
	if (hasRequiredRemote) return remote;
	hasRequiredRemote = 1;
	Object.defineProperty(remote, "__esModule", { value: true });
	remote.removeRemoteTask = remote.remoteTask = remote.listRemotesTask = remote.getRemotesTask = remote.addRemoteTask = void 0;
	const GetRemoteSummary_1 = requireGetRemoteSummary();
	const task_1 = requireTask();
	function addRemoteTask(remoteName, remoteRepo, customArgs = []) {
	    return task_1.straightThroughStringTask(['remote', 'add', ...customArgs, remoteName, remoteRepo]);
	}
	remote.addRemoteTask = addRemoteTask;
	function getRemotesTask(verbose) {
	    const commands = ['remote'];
	    if (verbose) {
	        commands.push('-v');
	    }
	    return {
	        commands,
	        format: 'utf-8',
	        parser: verbose ? GetRemoteSummary_1.parseGetRemotesVerbose : GetRemoteSummary_1.parseGetRemotes,
	    };
	}
	remote.getRemotesTask = getRemotesTask;
	function listRemotesTask(customArgs = []) {
	    const commands = [...customArgs];
	    if (commands[0] !== 'ls-remote') {
	        commands.unshift('ls-remote');
	    }
	    return task_1.straightThroughStringTask(commands);
	}
	remote.listRemotesTask = listRemotesTask;
	function remoteTask(customArgs = []) {
	    const commands = [...customArgs];
	    if (commands[0] !== 'remote') {
	        commands.unshift('remote');
	    }
	    return task_1.straightThroughStringTask(commands);
	}
	remote.remoteTask = remoteTask;
	function removeRemoteTask(remoteName) {
	    return task_1.straightThroughStringTask(['remote', 'remove', remoteName]);
	}
	remote.removeRemoteTask = removeRemoteTask;
	
	return remote;
}

var stashList = {};

var hasRequiredStashList;

function requireStashList () {
	if (hasRequiredStashList) return stashList;
	hasRequiredStashList = 1;
	Object.defineProperty(stashList, "__esModule", { value: true });
	stashList.stashListTask = void 0;
	const parse_list_log_summary_1 = requireParseListLogSummary();
	const log_1 = requireLog();
	function stashListTask(opt = {}, customArgs) {
	    const options = log_1.parseLogOptions(opt);
	    const parser = parse_list_log_summary_1.createListLogSummaryParser(options.splitter, options.fields);
	    return {
	        commands: ['stash', 'list', ...options.commands, ...customArgs],
	        format: 'utf-8',
	        parser,
	    };
	}
	stashList.stashListTask = stashListTask;
	
	return stashList;
}

var subModule = {};

var hasRequiredSubModule;

function requireSubModule () {
	if (hasRequiredSubModule) return subModule;
	hasRequiredSubModule = 1;
	Object.defineProperty(subModule, "__esModule", { value: true });
	subModule.updateSubModuleTask = subModule.subModuleTask = subModule.initSubModuleTask = subModule.addSubModuleTask = void 0;
	const task_1 = requireTask();
	function addSubModuleTask(repo, path) {
	    return subModuleTask(['add', repo, path]);
	}
	subModule.addSubModuleTask = addSubModuleTask;
	function initSubModuleTask(customArgs) {
	    return subModuleTask(['init', ...customArgs]);
	}
	subModule.initSubModuleTask = initSubModuleTask;
	function subModuleTask(customArgs) {
	    const commands = [...customArgs];
	    if (commands[0] !== 'submodule') {
	        commands.unshift('submodule');
	    }
	    return task_1.straightThroughStringTask(commands);
	}
	subModule.subModuleTask = subModuleTask;
	function updateSubModuleTask(customArgs) {
	    return subModuleTask(['update', ...customArgs]);
	}
	subModule.updateSubModuleTask = updateSubModuleTask;
	
	return subModule;
}

var tag = {};

var TagList = {};

var hasRequiredTagList;

function requireTagList () {
	if (hasRequiredTagList) return TagList;
	hasRequiredTagList = 1;
	Object.defineProperty(TagList, "__esModule", { value: true });
	TagList.parseTagList = TagList.TagList = void 0;
	let TagList$1 = class TagList {
	    constructor(all, latest) {
	        this.all = all;
	        this.latest = latest;
	    }
	};
	TagList.TagList = TagList$1;
	const parseTagList = function (data, customSort = false) {
	    const tags = data
	        .split('\n')
	        .map(trimmed)
	        .filter(Boolean);
	    if (!customSort) {
	        tags.sort(function (tagA, tagB) {
	            const partsA = tagA.split('.');
	            const partsB = tagB.split('.');
	            if (partsA.length === 1 || partsB.length === 1) {
	                return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));
	            }
	            for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {
	                const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));
	                if (diff) {
	                    return diff;
	                }
	            }
	            return 0;
	        });
	    }
	    const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf('.') >= 0);
	    return new TagList$1(tags, latest);
	};
	TagList.parseTagList = parseTagList;
	function singleSorted(a, b) {
	    const aIsNum = isNaN(a);
	    const bIsNum = isNaN(b);
	    if (aIsNum !== bIsNum) {
	        return aIsNum ? 1 : -1;
	    }
	    return aIsNum ? sorted(a, b) : 0;
	}
	function sorted(a, b) {
	    return a === b ? 0 : a > b ? 1 : -1;
	}
	function trimmed(input) {
	    return input.trim();
	}
	function toNumber(input) {
	    if (typeof input === 'string') {
	        return parseInt(input.replace(/^\D+/g, ''), 10) || 0;
	    }
	    return 0;
	}
	
	return TagList;
}

var hasRequiredTag;

function requireTag () {
	if (hasRequiredTag) return tag;
	hasRequiredTag = 1;
	Object.defineProperty(tag, "__esModule", { value: true });
	tag.addAnnotatedTagTask = tag.addTagTask = tag.tagListTask = void 0;
	const TagList_1 = requireTagList();
	/**
	 * Task used by `git.tags`
	 */
	function tagListTask(customArgs = []) {
	    const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));
	    return {
	        format: 'utf-8',
	        commands: ['tag', '-l', ...customArgs],
	        parser(text) {
	            return TagList_1.parseTagList(text, hasCustomSort);
	        },
	    };
	}
	tag.tagListTask = tagListTask;
	/**
	 * Task used by `git.addTag`
	 */
	function addTagTask(name) {
	    return {
	        format: 'utf-8',
	        commands: ['tag', name],
	        parser() {
	            return { name };
	        }
	    };
	}
	tag.addTagTask = addTagTask;
	/**
	 * Task used by `git.addTag`
	 */
	function addAnnotatedTagTask(name, tagMessage) {
	    return {
	        format: 'utf-8',
	        commands: ['tag', '-a', '-m', tagMessage, name],
	        parser() {
	            return { name };
	        }
	    };
	}
	tag.addAnnotatedTagTask = addAnnotatedTagTask;
	
	return tag;
}

var git;
var hasRequiredGit;

function requireGit () {
	if (hasRequiredGit) return git;
	hasRequiredGit = 1;
	const {GitExecutor} = requireGitExecutor();
	const {SimpleGitApi} = requireSimpleGitApi();

	const {Scheduler} = requireScheduler();
	const {GitLogger} = requireGitLogger();
	const {configurationErrorTask} = requireTask();
	const {
	   asArray,
	   filterArray,
	   filterPrimitives,
	   filterString,
	   filterStringOrStringArray,
	   filterType,
	   getTrailingOptions,
	   trailingFunctionArgument,
	   trailingOptionsArgument
	} = requireUtils();
	const {applyPatchTask} = requireApplyPatch();
	const {branchTask, branchLocalTask, deleteBranchesTask, deleteBranchTask} = requireBranch();
	const {checkIgnoreTask} = requireCheckIgnore();
	const {checkIsRepoTask} = requireCheckIsRepo();
	const {cloneTask, cloneMirrorTask} = requireClone();
	const {cleanWithOptionsTask, isCleanOptionsArray} = requireClean();
	const {commitTask} = requireCommit();
	const {diffSummaryTask} = requireDiff();
	const {fetchTask} = requireFetch();
	const {moveTask} = requireMove();
	const {pullTask} = requirePull();
	const {pushTagsTask} = requirePush();
	const {addRemoteTask, getRemotesTask, listRemotesTask, remoteTask, removeRemoteTask} = requireRemote();
	const {getResetMode, resetTask} = requireReset();
	const {stashListTask} = requireStashList();
	const {addSubModuleTask, initSubModuleTask, subModuleTask, updateSubModuleTask} = requireSubModule();
	const {addAnnotatedTagTask, addTagTask, tagListTask} = requireTag();
	const {straightThroughBufferTask, straightThroughStringTask} = requireTask();

	function Git (options, plugins) {
	   this._executor = new GitExecutor(
	      options.binary, options.baseDir,
	      new Scheduler(options.maxConcurrentProcesses), plugins,
	   );
	   this._logger = new GitLogger();
	}

	(Git.prototype = Object.create(SimpleGitApi.prototype)).constructor = Git;

	/**
	 * Logging utility for printing out info or error messages to the user
	 * @type {GitLogger}
	 * @private
	 */
	Git.prototype._logger = null;

	/**
	 * Sets the path to a custom git binary, should either be `git` when there is an installation of git available on
	 * the system path, or a fully qualified path to the executable.
	 *
	 * @param {string} command
	 * @returns {Git}
	 */
	Git.prototype.customBinary = function (command) {
	   this._executor.binary = command;
	   return this;
	};

	/**
	 * Sets an environment variable for the spawned child process, either supply both a name and value as strings or
	 * a single object to entirely replace the current environment variables.
	 *
	 * @param {string|Object} name
	 * @param {string} [value]
	 * @returns {Git}
	 */
	Git.prototype.env = function (name, value) {
	   if (arguments.length === 1 && typeof name === 'object') {
	      this._executor.env = name;
	   } else {
	      (this._executor.env = this._executor.env || {})[name] = value;
	   }

	   return this;
	};

	/**
	 * List the stash(s) of the local repo
	 */
	Git.prototype.stashList = function (options) {
	   return this._runTask(
	      stashListTask(
	         trailingOptionsArgument(arguments) || {},
	         filterArray(options) && options || []
	      ),
	      trailingFunctionArgument(arguments),
	   );
	};

	function createCloneTask (api, task, repoPath, localPath) {
	   if (typeof repoPath !== 'string') {
	      return configurationErrorTask(`git.${ api }() requires a string 'repoPath'`);
	   }

	   return task(repoPath, filterType(localPath, filterString), getTrailingOptions(arguments));
	}


	/**
	 * Clone a git repo
	 */
	Git.prototype.clone = function () {
	   return this._runTask(
	      createCloneTask('clone', cloneTask, ...arguments),
	      trailingFunctionArgument(arguments),
	   );
	};

	/**
	 * Mirror a git repo
	 */
	Git.prototype.mirror = function () {
	   return this._runTask(
	      createCloneTask('mirror', cloneMirrorTask, ...arguments),
	      trailingFunctionArgument(arguments),
	   );
	};

	/**
	 * Moves one or more files to a new destination.
	 *
	 * @see https://git-scm.com/docs/git-mv
	 *
	 * @param {string|string[]} from
	 * @param {string} to
	 */
	Git.prototype.mv = function (from, to) {
	   return this._runTask(moveTask(from, to), trailingFunctionArgument(arguments));
	};

	/**
	 * Internally uses pull and tags to get the list of tags then checks out the latest tag.
	 *
	 * @param {Function} [then]
	 */
	Git.prototype.checkoutLatestTag = function (then) {
	   var git = this;
	   return this.pull(function () {
	      git.tags(function (err, tags) {
	         git.checkout(tags.latest, then);
	      });
	   });
	};

	/**
	 * Commits changes in the current working directory - when specific file paths are supplied, only changes on those
	 * files will be committed.
	 *
	 * @param {string|string[]} message
	 * @param {string|string[]} [files]
	 * @param {Object} [options]
	 * @param {Function} [then]
	 */
	Git.prototype.commit = function (message, files, options, then) {
	   const next = trailingFunctionArgument(arguments);
	   const messages = [];

	   if (filterStringOrStringArray(message)) {
	      messages.push(...asArray(message));
	   } else {
	      console.warn('simple-git deprecation notice: git.commit: requires the commit message to be supplied as a string/string[], this will be an error in version 3');
	   }

	   return this._runTask(
	      commitTask(
	         messages,
	         asArray(filterType(files, filterStringOrStringArray, [])),
	         [...filterType(options, filterArray, []), ...getTrailingOptions(arguments, 0, true)]
	      ),
	      next
	   );
	};

	/**
	 * Pull the updated contents of the current repo
	 */
	Git.prototype.pull = function (remote, branch, options, then) {
	   return this._runTask(
	      pullTask(filterType(remote, filterString), filterType(branch, filterString), getTrailingOptions(arguments)),
	      trailingFunctionArgument(arguments),
	   );
	};

	/**
	 * Fetch the updated contents of the current repo.
	 *
	 * @example
	 *   .fetch('upstream', 'master') // fetches from master on remote named upstream
	 *   .fetch(function () {}) // runs fetch against default remote and branch and calls function
	 *
	 * @param {string} [remote]
	 * @param {string} [branch]
	 */
	Git.prototype.fetch = function (remote, branch) {
	   return this._runTask(
	      fetchTask(filterType(remote, filterString), filterType(branch, filterString), getTrailingOptions(arguments)),
	      trailingFunctionArgument(arguments),
	   );
	};

	/**
	 * Disables/enables the use of the console for printing warnings and errors, by default messages are not shown in
	 * a production environment.
	 *
	 * @param {boolean} silence
	 * @returns {Git}
	 */
	Git.prototype.silent = function (silence) {
	   console.warn('simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3');
	   this._logger.silent(!!silence);
	   return this;
	};

	/**
	 * List all tags. When using git 2.7.0 or above, include an options object with `"--sort": "property-name"` to
	 * sort the tags by that property instead of using the default semantic versioning sort.
	 *
	 * Note, supplying this option when it is not supported by your Git version will cause the operation to fail.
	 *
	 * @param {Object} [options]
	 * @param {Function} [then]
	 */
	Git.prototype.tags = function (options, then) {
	   return this._runTask(
	      tagListTask(getTrailingOptions(arguments)),
	      trailingFunctionArgument(arguments),
	   );
	};

	/**
	 * Rebases the current working copy. Options can be supplied either as an array of string parameters
	 * to be sent to the `git rebase` command, or a standard options object.
	 */
	Git.prototype.rebase = function () {
	   return this._runTask(
	      straightThroughStringTask(['rebase', ...getTrailingOptions(arguments)]),
	      trailingFunctionArgument(arguments)
	   );
	};

	/**
	 * Reset a repo
	 */
	Git.prototype.reset = function (mode) {
	   return this._runTask(
	      resetTask(getResetMode(mode), getTrailingOptions(arguments)),
	      trailingFunctionArgument(arguments),
	   );
	};

	/**
	 * Revert one or more commits in the local working copy
	 */
	Git.prototype.revert = function (commit) {
	   const next = trailingFunctionArgument(arguments);

	   if (typeof commit !== 'string') {
	      return this._runTask(
	         configurationErrorTask('Commit must be a string'),
	         next,
	      );
	   }

	   return this._runTask(
	      straightThroughStringTask(['revert', ...getTrailingOptions(arguments, 0, true), commit]),
	      next
	   );
	};

	/**
	 * Add a lightweight tag to the head of the current branch
	 */
	Git.prototype.addTag = function (name) {
	   const task = (typeof name === 'string')
	      ? addTagTask(name)
	      : configurationErrorTask('Git.addTag requires a tag name');

	   return this._runTask(task, trailingFunctionArgument(arguments));
	};

	/**
	 * Add an annotated tag to the head of the current branch
	 */
	Git.prototype.addAnnotatedTag = function (tagName, tagMessage) {
	   return this._runTask(
	      addAnnotatedTagTask(tagName, tagMessage),
	      trailingFunctionArgument(arguments),
	   );
	};

	/**
	 * Check out a tag or revision, any number of additional arguments can be passed to the `git checkout` command
	 * by supplying either a string or array of strings as the first argument.
	 */
	Git.prototype.checkout = function () {
	   const commands = ['checkout', ...getTrailingOptions(arguments, true)];
	   return this._runTask(
	      straightThroughStringTask(commands),
	      trailingFunctionArgument(arguments),
	   );
	};

	/**
	 * Check out a remote branch
	 *
	 * @param {string} branchName name of branch
	 * @param {string} startPoint (e.g origin/development)
	 * @param {Function} [then]
	 */
	Git.prototype.checkoutBranch = function (branchName, startPoint, then) {
	   return this.checkout(['-b', branchName, startPoint], trailingFunctionArgument(arguments));
	};

	/**
	 * Check out a local branch
	 */
	Git.prototype.checkoutLocalBranch = function (branchName, then) {
	   return this.checkout(['-b', branchName], trailingFunctionArgument(arguments));
	};

	/**
	 * Delete a local branch
	 */
	Git.prototype.deleteLocalBranch = function (branchName, forceDelete, then) {
	   return this._runTask(
	      deleteBranchTask(branchName, typeof forceDelete === "boolean" ? forceDelete : false),
	      trailingFunctionArgument(arguments),
	   );
	};

	/**
	 * Delete one or more local branches
	 */
	Git.prototype.deleteLocalBranches = function (branchNames, forceDelete, then) {
	   return this._runTask(
	      deleteBranchesTask(branchNames, typeof forceDelete === "boolean" ? forceDelete : false),
	      trailingFunctionArgument(arguments),
	   );
	};

	/**
	 * List all branches
	 *
	 * @param {Object | string[]} [options]
	 * @param {Function} [then]
	 */
	Git.prototype.branch = function (options, then) {
	   return this._runTask(
	      branchTask(getTrailingOptions(arguments)),
	      trailingFunctionArgument(arguments),
	   );
	};

	/**
	 * Return list of local branches
	 *
	 * @param {Function} [then]
	 */
	Git.prototype.branchLocal = function (then) {
	   return this._runTask(
	      branchLocalTask(),
	      trailingFunctionArgument(arguments),
	   );
	};

	/**
	 * Executes any command against the git binary.
	 */
	Git.prototype.raw = function (commands) {
	   const createRestCommands = !Array.isArray(commands);
	   const command = [].slice.call(createRestCommands ? arguments : commands, 0);

	   for (let i = 0; i < command.length && createRestCommands; i++) {
	      if (!filterPrimitives(command[i])) {
	         command.splice(i, command.length - i);
	         break;
	      }
	   }

	   command.push(
	      ...getTrailingOptions(arguments, 0, true),
	   );

	   var next = trailingFunctionArgument(arguments);

	   if (!command.length) {
	      return this._runTask(
	         configurationErrorTask('Raw: must supply one or more command to execute'),
	         next,
	      );
	   }

	   return this._runTask(straightThroughStringTask(command), next);
	};

	Git.prototype.submoduleAdd = function (repo, path, then) {
	   return this._runTask(
	      addSubModuleTask(repo, path),
	      trailingFunctionArgument(arguments),
	   );
	};

	Git.prototype.submoduleUpdate = function (args, then) {
	   return this._runTask(
	      updateSubModuleTask(getTrailingOptions(arguments, true)),
	      trailingFunctionArgument(arguments),
	   );
	};

	Git.prototype.submoduleInit = function (args, then) {
	   return this._runTask(
	      initSubModuleTask(getTrailingOptions(arguments, true)),
	      trailingFunctionArgument(arguments),
	   );
	};

	Git.prototype.subModule = function (options, then) {
	   return this._runTask(
	      subModuleTask(getTrailingOptions(arguments)),
	      trailingFunctionArgument(arguments),
	   );
	};

	Git.prototype.listRemote = function () {
	   return this._runTask(
	      listRemotesTask(getTrailingOptions(arguments)),
	      trailingFunctionArgument(arguments),
	   );
	};

	/**
	 * Adds a remote to the list of remotes.
	 */
	Git.prototype.addRemote = function (remoteName, remoteRepo, then) {
	   return this._runTask(
	      addRemoteTask(remoteName, remoteRepo, getTrailingOptions(arguments)),
	      trailingFunctionArgument(arguments),
	   );
	};

	/**
	 * Removes an entry by name from the list of remotes.
	 */
	Git.prototype.removeRemote = function (remoteName, then) {
	   return this._runTask(
	      removeRemoteTask(remoteName),
	      trailingFunctionArgument(arguments),
	   );
	};

	/**
	 * Gets the currently available remotes, setting the optional verbose argument to true includes additional
	 * detail on the remotes themselves.
	 */
	Git.prototype.getRemotes = function (verbose, then) {
	   return this._runTask(
	      getRemotesTask(verbose === true),
	      trailingFunctionArgument(arguments),
	   );
	};

	/**
	 * Call any `git remote` function with arguments passed as an array of strings.
	 *
	 * @param {string[]} options
	 * @param {Function} [then]
	 */
	Git.prototype.remote = function (options, then) {
	   return this._runTask(
	      remoteTask(getTrailingOptions(arguments)),
	      trailingFunctionArgument(arguments),
	   );
	};

	/**
	 * Call any `git tag` function with arguments passed as an array of strings.
	 *
	 * @param {string[]} options
	 * @param {Function} [then]
	 */
	Git.prototype.tag = function (options, then) {
	   const command = getTrailingOptions(arguments);

	   if (command[0] !== 'tag') {
	      command.unshift('tag');
	   }

	   return this._runTask(
	      straightThroughStringTask(command),
	      trailingFunctionArgument(arguments)
	   );
	};

	/**
	 * Updates repository server info
	 *
	 * @param {Function} [then]
	 */
	Git.prototype.updateServerInfo = function (then) {
	   return this._runTask(
	      straightThroughStringTask(['update-server-info']),
	      trailingFunctionArgument(arguments),
	   );
	};

	/**
	 * Pushes the current tag changes to a remote which can be either a URL or named remote. When not specified uses the
	 * default configured remote spec.
	 *
	 * @param {string} [remote]
	 * @param {Function} [then]
	 */
	Git.prototype.pushTags = function (remote, then) {
	   const task = pushTagsTask({remote: filterType(remote, filterString)}, getTrailingOptions(arguments));

	   return this._runTask(task, trailingFunctionArgument(arguments));
	};

	/**
	 * Removes the named files from source control.
	 */
	Git.prototype.rm = function (files) {
	   return this._runTask(
	      straightThroughStringTask(['rm', '-f', ...asArray(files)]),
	      trailingFunctionArgument(arguments)
	   );
	};

	/**
	 * Removes the named files from source control but keeps them on disk rather than deleting them entirely. To
	 * completely remove the files, use `rm`.
	 *
	 * @param {string|string[]} files
	 */
	Git.prototype.rmKeepLocal = function (files) {
	   return this._runTask(
	      straightThroughStringTask(['rm', '--cached', ...asArray(files)]),
	      trailingFunctionArgument(arguments)
	   );
	};

	/**
	 * Returns a list of objects in a tree based on commit hash. Passing in an object hash returns the object's content,
	 * size, and type.
	 *
	 * Passing "-p" will instruct cat-file to determine the object type, and display its formatted contents.
	 *
	 * @param {string[]} [options]
	 * @param {Function} [then]
	 */
	Git.prototype.catFile = function (options, then) {
	   return this._catFile('utf-8', arguments);
	};

	Git.prototype.binaryCatFile = function () {
	   return this._catFile('buffer', arguments);
	};

	Git.prototype._catFile = function (format, args) {
	   var handler = trailingFunctionArgument(args);
	   var command = ['cat-file'];
	   var options = args[0];

	   if (typeof options === 'string') {
	      return this._runTask(
	         configurationErrorTask('Git.catFile: options must be supplied as an array of strings'),
	         handler,
	      );
	   }

	   if (Array.isArray(options)) {
	      command.push.apply(command, options);
	   }

	   const task = format === 'buffer'
	      ? straightThroughBufferTask(command)
	      : straightThroughStringTask(command);

	   return this._runTask(task, handler);
	};

	Git.prototype.diff = function (options, then) {
	   const command = ['diff', ...getTrailingOptions(arguments)];

	   if (typeof options === 'string') {
	      command.splice(1, 0, options);
	      this._logger.warn('Git#diff: supplying options as a single string is now deprecated, switch to an array of strings');
	   }

	   return this._runTask(
	      straightThroughStringTask(command),
	      trailingFunctionArgument(arguments),
	   );
	};

	Git.prototype.diffSummary = function () {
	   return this._runTask(
	      diffSummaryTask(getTrailingOptions(arguments, 1)),
	      trailingFunctionArgument(arguments),
	   );
	};

	Git.prototype.applyPatch = function (patches) {
	   const task = !filterStringOrStringArray(patches)
	      ? configurationErrorTask(`git.applyPatch requires one or more string patches as the first argument`)
	      : applyPatchTask(asArray(patches), getTrailingOptions([].slice.call(arguments, 1)));

	   return this._runTask(
	      task,
	      trailingFunctionArgument(arguments),
	   );
	};

	Git.prototype.revparse = function () {
	   const commands = ['rev-parse', ...getTrailingOptions(arguments, true)];
	   return this._runTask(
	      straightThroughStringTask(commands, true),
	      trailingFunctionArgument(arguments),
	   );
	};

	/**
	 * Show various types of objects, for example the file at a certain commit
	 *
	 * @param {string[]} [options]
	 * @param {Function} [then]
	 */
	Git.prototype.show = function (options, then) {
	   return this._runTask(
	      straightThroughStringTask(['show', ...getTrailingOptions(arguments, 1)]),
	      trailingFunctionArgument(arguments)
	   );
	};

	/**
	 */
	Git.prototype.clean = function (mode, options, then) {
	   const usingCleanOptionsArray = isCleanOptionsArray(mode);
	   const cleanMode = usingCleanOptionsArray && mode.join('') || filterType(mode, filterString) || '';
	   const customArgs = getTrailingOptions([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));

	   return this._runTask(
	      cleanWithOptionsTask(cleanMode, customArgs),
	      trailingFunctionArgument(arguments),
	   );
	};

	Git.prototype.exec = function (then) {
	   const task = {
	      commands: [],
	      format: 'utf-8',
	      parser () {
	         if (typeof then === 'function') {
	            then();
	         }
	      }
	   };

	   return this._runTask(task);
	};

	/**
	 * Clears the queue of pending commands and returns the wrapper instance for chaining.
	 *
	 * @returns {Git}
	 */
	Git.prototype.clearQueue = function () {
	   // TODO:
	   // this._executor.clear();
	   return this;
	};

	/**
	 * Check if a pathname or pathnames are excluded by .gitignore
	 *
	 * @param {string|string[]} pathnames
	 * @param {Function} [then]
	 */
	Git.prototype.checkIgnore = function (pathnames, then) {
	   return this._runTask(
	      checkIgnoreTask(asArray((filterType(pathnames, filterStringOrStringArray, [])))),
	      trailingFunctionArgument(arguments),
	   );
	};

	Git.prototype.checkIsRepo = function (checkType, then) {
	   return this._runTask(
	      checkIsRepoTask(filterType(checkType, filterString)),
	      trailingFunctionArgument(arguments),
	   );
	};

	git = Git;
	return git;
}

var hasRequiredGitFactory;

function requireGitFactory () {
	if (hasRequiredGitFactory) return gitFactory;
	hasRequiredGitFactory = 1;
	Object.defineProperty(gitFactory, "__esModule", { value: true });
	gitFactory.gitInstanceFactory = gitFactory.gitExportFactory = gitFactory.esModuleFactory = void 0;
	const api_1 = requireApi();
	const plugins_1 = requirePlugins();
	const utils_1 = requireUtils();
	const Git = requireGit();
	/**
	 * Adds the necessary properties to the supplied object to enable it for use as
	 * the default export of a module.
	 *
	 * Eg: `module.exports = esModuleFactory({ something () {} })`
	 */
	function esModuleFactory(defaultExport) {
	    return Object.defineProperties(defaultExport, {
	        __esModule: { value: true },
	        default: { value: defaultExport },
	    });
	}
	gitFactory.esModuleFactory = esModuleFactory;
	function gitExportFactory(factory, extra) {
	    return Object.assign(function (...args) {
	        return factory.apply(null, args);
	    }, api_1.default, extra || {});
	}
	gitFactory.gitExportFactory = gitExportFactory;
	function gitInstanceFactory(baseDir, options) {
	    const plugins = new plugins_1.PluginStore();
	    const config = utils_1.createInstanceConfig(baseDir && (typeof baseDir === 'string' ? { baseDir } : baseDir) || {}, options);
	    if (!utils_1.folderExists(config.baseDir)) {
	        throw new api_1.default.GitConstructError(config, `Cannot use simple-git on a directory that does not exist`);
	    }
	    if (Array.isArray(config.config)) {
	        plugins.add(plugins_1.commandConfigPrefixingPlugin(config.config));
	    }
	    plugins.add(plugins_1.completionDetectionPlugin(config.completion));
	    config.progress && plugins.add(plugins_1.progressMonitorPlugin(config.progress));
	    config.timeout && plugins.add(plugins_1.timeoutPlugin(config.timeout));
	    config.spawnOptions && plugins.add(plugins_1.spawnOptionsPlugin(config.spawnOptions));
	    plugins.add(plugins_1.errorDetectionPlugin(plugins_1.errorDetectionHandler(true)));
	    config.errors && plugins.add(plugins_1.errorDetectionPlugin(config.errors));
	    return new Git(config, plugins);
	}
	gitFactory.gitInstanceFactory = gitInstanceFactory;
	
	return gitFactory;
}

var promiseWrapped = {};

var hasRequiredPromiseWrapped;

function requirePromiseWrapped () {
	if (hasRequiredPromiseWrapped) return promiseWrapped;
	hasRequiredPromiseWrapped = 1;
	Object.defineProperty(promiseWrapped, "__esModule", { value: true });
	promiseWrapped.gitP = void 0;
	const git_response_error_1 = requireGitResponseError();
	const git_factory_1 = requireGitFactory();
	const functionNamesBuilderApi = [
	    'customBinary', 'env', 'outputHandler', 'silent',
	];
	const functionNamesPromiseApi = [
	    'add',
	    'addAnnotatedTag',
	    'addConfig',
	    'addRemote',
	    'addTag',
	    'applyPatch',
	    'binaryCatFile',
	    'branch',
	    'branchLocal',
	    'catFile',
	    'checkIgnore',
	    'checkIsRepo',
	    'checkout',
	    'checkoutBranch',
	    'checkoutLatestTag',
	    'checkoutLocalBranch',
	    'clean',
	    'clone',
	    'commit',
	    'cwd',
	    'deleteLocalBranch',
	    'deleteLocalBranches',
	    'diff',
	    'diffSummary',
	    'exec',
	    'fetch',
	    'getRemotes',
	    'init',
	    'listConfig',
	    'listRemote',
	    'log',
	    'merge',
	    'mergeFromTo',
	    'mirror',
	    'mv',
	    'pull',
	    'push',
	    'pushTags',
	    'raw',
	    'rebase',
	    'remote',
	    'removeRemote',
	    'reset',
	    'revert',
	    'revparse',
	    'rm',
	    'rmKeepLocal',
	    'show',
	    'stash',
	    'stashList',
	    'status',
	    'subModule',
	    'submoduleAdd',
	    'submoduleInit',
	    'submoduleUpdate',
	    'tag',
	    'tags',
	    'updateServerInfo'
	];
	function gitP(...args) {
	    let git;
	    let chain = Promise.resolve();
	    try {
	        git = git_factory_1.gitInstanceFactory(...args);
	    }
	    catch (e) {
	        chain = Promise.reject(e);
	    }
	    function builderReturn() {
	        return promiseApi;
	    }
	    function chainReturn() {
	        return chain;
	    }
	    const promiseApi = [...functionNamesBuilderApi, ...functionNamesPromiseApi].reduce((api, name) => {
	        const isAsync = functionNamesPromiseApi.includes(name);
	        const valid = isAsync ? asyncWrapper(name, git) : syncWrapper(name, git, api);
	        const alternative = isAsync ? chainReturn : builderReturn;
	        Object.defineProperty(api, name, {
	            enumerable: false,
	            configurable: false,
	            value: git ? valid : alternative,
	        });
	        return api;
	    }, {});
	    return promiseApi;
	    function asyncWrapper(fn, git) {
	        return function (...args) {
	            if (typeof args[args.length] === 'function') {
	                throw new TypeError('Promise interface requires that handlers are not supplied inline, ' +
	                    'trailing function not allowed in call to ' + fn);
	            }
	            return chain.then(function () {
	                return new Promise(function (resolve, reject) {
	                    const callback = (err, result) => {
	                        if (err) {
	                            return reject(toError(err));
	                        }
	                        resolve(result);
	                    };
	                    args.push(callback);
	                    git[fn].apply(git, args);
	                });
	            });
	        };
	    }
	    function syncWrapper(fn, git, api) {
	        return (...args) => {
	            git[fn](...args);
	            return api;
	        };
	    }
	}
	promiseWrapped.gitP = gitP;
	function toError(error) {
	    if (error instanceof Error) {
	        return error;
	    }
	    if (typeof error === 'string') {
	        return new Error(error);
	    }
	    return new git_response_error_1.GitResponseError(error);
	}
	
	return promiseWrapped;
}

var promise;
var hasRequiredPromise;

function requirePromise () {
	if (hasRequiredPromise) return promise;
	hasRequiredPromise = 1;
	const {esModuleFactory, gitExportFactory} = requireGitFactory();
	const {gitP} = requirePromiseWrapped();

	promise = esModuleFactory(
	   gitExportFactory(gitP)
	);
	return promise;
}

var file;
var hasRequiredFile;

function requireFile () {
	if (hasRequiredFile) return file;
	hasRequiredFile = 1;
	const decompress = requireDecompress();
	const path = require$$1$4;
	const simpleGit = requirePromise()();
	const tmp = requireTmp();

	const config = requireConfig$1();
	const http = requireHttp();
	const defaultLogger = requireLogger();

	file = {
	  extract(filePath, targetDir, haveFilter, logger = defaultLogger) {
	    logger.info(`Decompressing the ${filePath} into ${targetDir}.`);
	    return decompress(filePath, targetDir, {
	      filter: (decompressFile) => {
	        if (haveFilter) {
	          const decompressPath = decompressFile.path;
	          return !decompressPath.includes('.git/') && !decompressPath.includes('__MACOSX');
	        }
	        return true;
	      },
	    });
	  },

	  downloadAndExtract(url, targetDir, haveFilter = false, token = null, logger = defaultLogger) {
	    logger.info(`Downloading from ${url}. It may take a few minutes.`);
	    const file = tmp.fileSync();
	    const filePath = file.name;
	    logger.debug(`Download into temporary directory: ${filePath}`);
	    const options = config.isOnPremise && token ? { auth: { bearer: token } } : {};
	    return http
	      .stream(url, filePath, options)
	      .then(() => this.extract(filePath, targetDir, haveFilter, logger));
	  },

	  clone(gitRepository, targetDir, cloneOpts = {}, logger = defaultLogger) {
	    const {
	      repository,
	      branch,
	      username,
	      password,
	    } = gitRepository || {};

	    const repoURL = new URL(repository);
	    repoURL.username = username;
	    repoURL.password = password;
	    const url = repoURL.href;

	    const dirName = url.split('/').pop();
	    const gitTargetDir = path.join(targetDir, dirName);
	    logger.info(`Cloning from ${repository} (${branch}) into ${gitTargetDir}. It may take a few minutes.`);

	    const overrideOpts = Object.entries(cloneOpts).reduce((opts, [k, v]) => {
	      opts.push(k);
	      if (v) {
	        opts.push(v);
	      }
	      return opts;
	    }, []);

	    return simpleGit.clone(url, gitTargetDir, [
	      '--depth',
	      '1',
	      '--branch',
	      branch.split('/').pop(),
	      ...overrideOpts,
	    ]);
	  },
	};
	return file;
}

var hasRequiredRemoteDownloader;

function requireRemoteDownloader () {
	if (hasRequiredRemoteDownloader) return remoteDownloader;
	hasRequiredRemoteDownloader = 1;
	const file = requireFile();

	class KatalonStudioDownloader {
	  constructor(logger, downloadUrl) {
	    this.logger = logger;
	    this.downloadUrl = downloadUrl;
	  }

	  download(targetDir) {
	    return file.downloadAndExtract(this.downloadUrl, targetDir, false, null, this.logger);
	  }
	}

	class KatalonTestProjectDownloader {
	  constructor(logger, downloadUrl, token) {
	    this.logger = logger;
	    this.downloadUrl = downloadUrl;
	    this.token = token;
	  }

	  download(targetDir) {
	    return file.downloadAndExtract(this.downloadUrl, targetDir, true, this.token, this.logger);
	  }
	}

	class GitDownloader {
	  constructor(logger, gitRepository, cloneOpts = {}) {
	    this.logger = logger;
	    this.gitRepository = gitRepository;
	    this.cloneOpts = cloneOpts;
	  }

	  download(targetDir) {
	    return file.clone(this.gitRepository, targetDir, this.cloneOpts, this.logger);
	  }
	}


	remoteDownloader.KatalonStudioDownloader = KatalonStudioDownloader;
	remoteDownloader.KatalonTestProjectDownloader = KatalonTestProjectDownloader;
	remoteDownloader.GitDownloader = GitDownloader;
	return remoteDownloader;
}

var katalonStudio;
var hasRequiredKatalonStudio;

function requireKatalonStudio () {
	if (hasRequiredKatalonStudio) return katalonStudio;
	hasRequiredKatalonStudio = 1;
	const _ = requireLodash();
	const fs = require$$0$8;
	const path = require$$1$4;

	const http = requireHttp();
	const defaultLogger = requireLogger();
	const os = requireOs();
	const { KatalonStudioDownloader } = requireRemoteDownloader();
	const utils = requireUtils$2();

	const releasesList =
	  'https://raw.githubusercontent.com/katalon-studio/katalon-studio/master/releases.json';

	function find(startPath, filter, callback) {
	  if (!fs.existsSync(startPath)) {
	    return;
	  }

	  const files = fs.readdirSync(startPath);
	  for (let i = 0; i < files.length; i += 1) {
	    const filename = path.join(startPath, files[i]);
	    const stat = fs.lstatSync(filename);
	    if (stat.isDirectory()) {
	      const file = find(filename, filter);
	      if (!_.isEmpty(file)) {
	        // eslint-disable-next-line consistent-return
	        return file;
	      }
	    } else if (filter.test(filename)) {
	      // eslint-disable-next-line consistent-return
	      return filename;
	    }
	  }
	}

	function getKsLocation(ksVersionNumber, ksLocation) {
	  if (!ksVersionNumber && !ksLocation) {
	    throw new Error("Please specify 'ksVersionNumber' or 'ksLocation'");
	  }

	  if (ksLocation) {
	    return Promise.resolve({
	      ksLocationParentDir: ksLocation,
	    });
	  }

	  return http.request(releasesList, '', {}, 'GET').then(({ body }) => {
	    const osVersion = os.getVersion();
	    const ksVersion = body.find(
	      (item) => item.version === ksVersionNumber && item.os === osVersion,
	    );

	    const userhome = os.getUserHome();
	    const ksLocationParentDir = path.join(userhome, '.katalon', ksVersionNumber);
	    const katalonDoneFilePath = path.join(ksLocationParentDir, '.katalon.done');

	    if (fs.existsSync(katalonDoneFilePath)) {
	      return { ksLocationParentDir };
	    }

	    defaultLogger.info(`Download Katalon Studio ${ksVersionNumber} to ${ksLocationParentDir}.`);
	    const downloader = new KatalonStudioDownloader(defaultLogger, ksVersion.url);
	    return downloader.download(ksLocationParentDir).then(() => {
	      fs.writeFileSync(katalonDoneFilePath, '');
	      return { ksLocationParentDir };
	    });
	  });
	}

	katalonStudio = {
	  execute(
	    ksVersionNumber,
	    ksLocation,
	    ksProjectPath,
	    ksArgs,
	    x11Display,
	    xvfbConfiguration,
	    logger = defaultLogger,
	  ) {
	    return getKsLocation(ksVersionNumber, ksLocation).then(({ ksLocationParentDir }) => {
	      logger.info(`Katalon Folder: ${ksLocationParentDir}`);

	      let ksExecutable =
	        find(ksLocationParentDir, /katalonc$|katalonc\.exe$/) ||
	        find(ksLocationParentDir, /katalon$|katalon\.exe$/);
	      if (!ksExecutable) {
	        throw new Error(`Unable to find Katalon Studio executable in ${ksLocationParentDir}`);
	      }

	      logger.info(`Katalon Executable File: ${ksExecutable}`);

	      if (!os.getVersion().includes('Windows')) {
	        fs.chmodSync(ksExecutable, '755');
	      }

	      if (ksExecutable.indexOf(' ') >= 0) {
	        ksExecutable = `"${ksExecutable}"`;
	      }

	      let ksCommand = utils.updateCommand(
	        ksExecutable,
	        { flag: '-noSplash' },
	        { flag: '-runMode', value: 'console' },
	        { flag: '-projectPath', value: ksProjectPath },
	      );

	      ksCommand = `${ksCommand} ${ksArgs}`;

	      logger.info(`Execute Katalon Studio: ${ksCommand}`);
	      if (logger !== defaultLogger) {
	        defaultLogger.debug(`Execute Katalon Studio command: ${ksCommand}`);
	      }

	      return os.runCommand(ksCommand, x11Display, xvfbConfiguration, logger);
	    });
	  },

	  getKsLocation,
	};
	return katalonStudio;
}

/**
 * @internal
 * Retrieves the value of an environment variable.
 *
 * @param name - The name of the environment variable.
 * @returns The value of the environment variable.
 * @throws Error if the environment variable is not defined.
 */
function mustGetEnvironment(name) {
    const value = process.env[name];
    if (value === undefined) {
        throw new Error(`the ${name} environment variable must be defined`);
    }
    return value;
}
/**
 * Retrieves the value of a GitHub Actions input.
 *
 * @param name - The name of the GitHub Actions input.
 * @returns The value of the GitHub Actions input, or an empty string if not found.
 */
function getInput(name) {
    const value = process.env[`INPUT_${name.toUpperCase()}`] ?? "";
    return value.trim();
}
/**
 * Sets the value of a GitHub Actions output.
 *
 * @param name - The name of the GitHub Actions output.
 * @param value - The value to set for the GitHub Actions output.
 * @returns A promise that resolves when the value is successfully set.
 */
async function setOutput(name, value) {
    const filePath = mustGetEnvironment("GITHUB_OUTPUT");
    await fsPromises.appendFile(filePath, `${name}=${value}${os.EOL}`);
}
/**
 * Sets the value of a GitHub Actions output synchronously.
 *
 * @param name - The name of the GitHub Actions output.
 * @param value - The value to set for the GitHub Actions output.
 */
function setOutputSync(name, value) {
    const filePath = mustGetEnvironment("GITHUB_OUTPUT");
    fs$2.appendFileSync(filePath, `${name}=${value}${os.EOL}`);
}
/**
 * Retrieves the value of a GitHub Actions state.
 *
 * @param name - The name of the GitHub Actions state.
 * @returns The value of the GitHub Actions state, or an empty string if not found.
 */
function getState(name) {
    const value = process.env[`STATE_${name}`] ?? "";
    return value.trim();
}
/**
 * Sets the value of a GitHub Actions state.
 *
 * @param name - The name of the GitHub Actions state.
 * @param value - The value to set for the GitHub Actions state.
 * @returns A promise that resolves when the value is successfully set.
 */
async function setState(name, value) {
    process.env[`STATE_${name}`] = value;
    const filePath = mustGetEnvironment("GITHUB_STATE");
    await fsPromises.appendFile(filePath, `${name}=${value}${os.EOL}`);
}
/**
 * Sets the value of a GitHub Actions state synchronously.
 *
 * @param name - The name of the GitHub Actions state.
 * @param value - The value to set for the GitHub Actions state.
 */
function setStateSync(name, value) {
    process.env[`STATE_${name}`] = value;
    const filePath = mustGetEnvironment("GITHUB_STATE");
    fs$2.appendFileSync(filePath, `${name}=${value}${os.EOL}`);
}
/**
 * Sets the value of an environment variable in GitHub Actions.
 *
 * @param name - The name of the environment variable.
 * @param value - The value to set for the environment variable.
 * @returns A promise that resolves when the environment variable is
 *          successfully set.
 */
async function setEnv(name, value) {
    process.env[name] = value;
    const filePath = mustGetEnvironment("GITHUB_ENV");
    await fsPromises.appendFile(filePath, `${name}=${value}${os.EOL}`);
}
/**
 * Sets the value of an environment variable in GitHub Actions synchronously.
 *
 * @param name - The name of the environment variable.
 * @param value - The value to set for the environment variable.
 */
function setEnvSync(name, value) {
    process.env[name] = value;
    const filePath = mustGetEnvironment("GITHUB_ENV");
    fs$2.appendFileSync(filePath, `${name}=${value}${os.EOL}`);
}
/**
 * Adds a system path to the environment in GitHub Actions.
 *
 * @param sysPath - The system path to add to the environment.
 * @returns A promise that resolves when the system path is successfully added.
 */
async function addPath(sysPath) {
    process.env.PATH =
        process.env.PATH !== undefined
            ? `${sysPath}${path.delimiter}${process.env.PATH}`
            : sysPath;
    const filePath = mustGetEnvironment("GITHUB_PATH");
    await fsPromises.appendFile(filePath, `${sysPath}${os.EOL}`);
}
/**
 * Adds a system path to the environment in GitHub Actions synchronously.
 *
 * @param sysPath - The system path to add to the environment.
 */
function addPathSync(sysPath) {
    process.env.PATH =
        process.env.PATH !== undefined
            ? `${sysPath}${path.delimiter}${process.env.PATH}`
            : sysPath;
    const filePath = mustGetEnvironment("GITHUB_PATH");
    fs$2.appendFileSync(filePath, `${sysPath}${os.EOL}`);
}

/**
 * Logs an information message in GitHub Actions.
 *
 * @param message - The information message to log.
 */
function logInfo(message) {
    process.stdout.write(`${message}${os.EOL}`);
}
/**
 * Logs a debug message in GitHub Actions.
 *
 * @param message - The debug message to log.
 */
function logDebug(message) {
    process.stdout.write(`::debug::${message}${os.EOL}`);
}
/**
 * Logs a warning message in GitHub Actions.
 *
 * @param message - The warning message to log.
 */
function logWarning(message) {
    process.stdout.write(`::warning::${message}${os.EOL}`);
}
/**
 * Logs an error message in GitHub Actions.
 *
 * @param err - The error, which can be of any type.
 */
function logError(err) {
    const message = err instanceof Error ? err.message : String(err);
    process.stdout.write(`::error::${message}${os.EOL}`);
}
/**
 * Logs a command along with its arguments in GitHub Actions.
 *
 * @param command - The command to log.
 * @param args - The arguments of the command.
 */
function logCommand(command, ...args) {
    const message = [command, ...args].join(" ");
    process.stdout.write(`[command]${message}${os.EOL}`);
}
/**
 * Begins a log group in GitHub Actions.
 *
 * @param name - The name of the log group.
 */
function beginLogGroup(name) {
    process.stdout.write(`::group::${name}${os.EOL}`);
}
/**
 * Ends the current log group in GitHub Actions.
 */
function endLogGroup() {
    process.stdout.write(`::endgroup::${os.EOL}`);
}

var dist = /*#__PURE__*/Object.freeze({
	__proto__: null,
	addPath: addPath,
	addPathSync: addPathSync,
	beginLogGroup: beginLogGroup,
	endLogGroup: endLogGroup,
	getInput: getInput,
	getState: getState,
	logCommand: logCommand,
	logDebug: logDebug,
	logError: logError,
	logInfo: logInfo,
	logWarning: logWarning,
	setEnv: setEnv,
	setEnvSync: setEnvSync,
	setOutput: setOutput,
	setOutputSync: setOutputSync,
	setState: setState,
	setStateSync: setStateSync
});

var require$$1 = /*@__PURE__*/getAugmentedNamespace(dist);

var hasRequiredFreeKatalonStudio;

function requireFreeKatalonStudio () {
	if (hasRequiredFreeKatalonStudio) return freeKatalonStudio;
	hasRequiredFreeKatalonStudio = 1;
	const { execute } = requireKatalonStudio();
	const { getInput, logError } = require$$1;

	const user_version = getInput("version");
	const user_projectPath = getInput("projectPath");
	const user_testSuitePath = getInput("testSuitePath");
	const user_browserType = getInput("browserType");
	const user_executionProfile = getInput("executionProfile");

	const apiKey = '2d04df89-8ae6-4b1d-9f40-ca383c8bc02a';

	let user_args = `-noSplash -retry=0 -testSuitePath="${user_testSuitePath}" -browserType=${user_browserType} -executionProfile=${user_executionProfile} -apiKey=${apiKey} --config -webui.autoUpdateDrivers=true`;

	try {
	  execute(user_version, "", user_projectPath, user_args, "", "", {
	    info: function (message) {
	      console.log(message);
	    },
	    debug: function (message) {
	      console.log(message);
	    },
	    error: function (message) {
	      console.error(message);
	    },
	  })
	    .then((status) => {
	      if (status !== 0) {
	        logError(`Exit code ${status}.`);
	      }
	    })
	    .catch((err) => {
	      console.error(err);
	      logError(err);
	    });
	} catch (error) {
	  console.error(error);
	  logError(error.message);
	}
	return freeKatalonStudio;
}

var freeKatalonStudioExports = requireFreeKatalonStudio();
var index = /*@__PURE__*/getDefaultExportFromCjs(freeKatalonStudioExports);

module.exports = index;
